# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.676102 from ensemble.csv
- Best LB score: 70.676102 (verified - matches CV exactly)
- Target: 68.919154 | Gap to target: 1.756948 points (2.55%)
- Experiments run: 3 (all at same score - STUCK at local optimum)

## CRITICAL SITUATION ANALYSIS

**WE ARE STUCK AT A LOCAL OPTIMUM**

All 3 experiments produced the same score (70.676102):
- exp_000: Baseline with fix_direction → 70.676102
- exp_001: bbox3 + tree_packer + backward propagation → 70.676102
- exp_002: Grid-based construction + small N optimization → 70.676102

**Key findings:**
1. ensemble.csv is already the best for ALL 200 N values across 21 solutions
2. Grid-based construction converges to WORSE local optimum (86.4 vs 70.7)
3. Small N values (1-3) are already optimal - no improvement found
4. Short optimization runs (5-10 min) find no improvement

**THE PROBLEM**: The pre-optimized solution is at a strong local optimum that cannot be escaped with:
- Standard SA/local search
- Different starting points (grid-based)
- Exhaustive search on small N

## Response to Evaluator

The evaluator recommended:
1. ✅ Create ensemble of all pre-optimized solutions → **DONE, no improvement possible**
2. ⏳ Run advanced bbox3 optimizer with longer time budget → **NOT YET DONE**
3. ⏳ Try perturbation strategies → **NOT YET DONE**
4. ⏳ Focus on medium/large N values → **NOT YET DONE**

I agree with the remaining recommendations. The key insight is that we need:
- **LONGER optimization time** (1+ hours, not 5-10 minutes)
- **Advanced techniques** like fractional translation
- **Perturbation-based exploration** instead of random restarts

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Run Long Optimization with Fractional Translation
The jonathanchan kernel shows the state-of-the-art approach:
- Ensemble from many sources (already done in our baseline)
- Run SA with fractional translation (NOT done yet)
- Use 15000+ iterations with 5+ restarts per N
- Key technique: `fractional_translation()` with micro-steps

**Implementation from jonathanchan kernel:**
```python
# Fractional translation - micro-adjustments in 8 directions
frac_steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]
dx = [0, 0, 1, -1, 1, 1, -1, -1]
dy = [1, -1, 0, 0, 1, -1, 1, -1]
```

This is the technique that top solutions use to squeeze out the last bits of improvement.

### 2. **[HIGH PRIORITY]** Run bbox3 with Extended Time Budget (1+ hours)
The bbox3 runner kernel uses a 3-HOUR budget with multiple phases:
- Phase A: 2-min runs to find promising (n,r) parameters
- Phase B: 10-min runs on top candidates
- Phase C: 20-min runs on best few

Our previous runs used only 5-10 minutes. Need to run for 1+ hours.

### 3. **[MEDIUM PRIORITY]** Compile and Run the "Why Not" Kernel's Advanced Optimizer
The jazivxt/why-not kernel has a sophisticated bbox3.cpp with:
- Complex number vector coordination
- Fluid dynamics simulation
- Hinge pivot optimization
- Density gradient flow
- Global boundary tension
- Aggressive overlap repair

This is a fundamentally different optimization approach that may escape local optima.

### 4. **[MEDIUM PRIORITY]** Perturbation-Based Exploration
Instead of random restarts, perturb the current good solution:
- Swap tree positions between similar N configurations
- Rotate groups of trees together
- Translate clusters
- Re-optimize with SA

This explores nearby basins without losing the good starting point.

### 5. **[LOWER PRIORITY]** Genetic Algorithm with Crossover
Combine configurations from different N values:
- Take tree arrangements from N=100 and adapt for N=99
- Crossover between different optimization runs
- Mutation + selection

## What NOT to Try (Proven Ineffective)
- ❌ Ensembling pre-optimized solutions (already done, no improvement)
- ❌ Grid-based construction from scratch (converges to worse local optimum)
- ❌ Small N exhaustive optimization (already optimal)
- ❌ Short optimization runs (<30 min) - need 1+ hours
- ❌ Standard SA without fractional translation

## Technical Details

### Tree Geometry
- 15-vertex polygon
- Width: 0.7 at base, height: 1.0
- Area: 0.245625 square units

### Score Formula
score = Σ(side_n² / n) for n=1 to 200

### Current Score Breakdown (top contributors)
- N=1: 0.661250 (side=0.8132, efficiency=0.371)
- N=2: 0.450779 (side=0.9495, efficiency=0.545)
- N=3: 0.434745 (side=1.1420, efficiency=0.565)
- N=200: 0.337731 (side=8.2187, efficiency=0.727)

### Efficiency Analysis
- Best efficiency: ~0.73 at N=200
- Worst efficiency: ~0.37 at N=1 (but already optimal)
- Room for improvement: Medium N values (50-150) have efficiency ~0.68-0.71

## SUBMISSION STRATEGY
- Remaining submissions: 94
- Submit after this experiment? **YES** - we have abundant submissions
- Even if score doesn't improve, LB feedback confirms our understanding

## Key Files
- Baseline: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/ensemble.csv`
- bbox3 optimizer: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/bbox3`
- Advanced SA kernel: `/home/code/research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation/`
- Why-Not kernel: `/home/code/research/kernels/jazivxt_why-not/`
- Tree packer v18: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/santa-2025-try3/a.cpp`

## Research Insights for Escaping Local Optima
From web search on 2D polygon packing optimization:

1. **Adaptive neighborhoods** - step size adjusted on-the-fly based on acceptance rate
   - Positive feedback when move accepted → larger steps
   - Negative feedback when rejected → smaller steps
   - "Crystallization factor" controls this

2. **Temperature reheating** - when acceptance rate falls below threshold, temporarily raise temperature

3. **Lévy-flight jumps** - occasional long-range moves to escape local minima

4. **Collision-free region (CFR) vertices** - place polygons on CFR vertices for guaranteed feasibility

5. **No-fit polygons (NFPs)** - pre-computed for rapid overlap checks

6. **Minkowski-sum based collision-free region generator** - avoids external penalty functions

The key is that standard SA gets stuck because it can't make large enough moves. We need:
- Longer runs to allow more exploration
- Fractional translation for fine-tuning
- Occasional large perturbations to escape basins