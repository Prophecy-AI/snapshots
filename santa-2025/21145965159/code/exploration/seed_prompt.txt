# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D geometric packing optimization problem. The goal is to pack Christmas tree-shaped polygons into the smallest possible square bounding box for configurations of N=1 to N=200 trees.

**Metric:** score = Σ(side_n² / n) for n=1 to 200 (lower is better)
**Target Score:** 68.919154
**Best Pre-optimized Baseline:** ~70.676 (found in snapshots)

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Tip at (0, 0.8)
- Three tiers of branches
- Trunk at bottom (width 0.15, height 0.2)
- Base width 0.7
- Trees can be rotated by any angle (0-360 degrees)

## Key Techniques from Public Kernels

### 1. C++ Optimizer (bbox3) - CRITICAL
The top kernels use a compiled C++ optimizer called `bbox3` that implements:
- Simulated Annealing (SA) with temperature scheduling
- Local search with multiple move types
- Parallel processing with OpenMP
- Long double precision for accuracy

**Key parameters:**
- `-n`: Number of iterations (e.g., 5000-20000)
- `-r`: Number of restarts/rounds (e.g., 16-256)

**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb` contains the full bbox3.cpp source

### 2. Fix Direction / Rotation Optimization
After packing, rotate the entire configuration to minimize bounding box:
- Use convex hull of all tree vertices
- Optimize rotation angle using scipy.optimize.minimize_scalar
- Bounds: (0.001, 89.999) degrees
- This can reduce score by tightening the bounding box alignment

**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

### 3. Backward Propagation
Improve smaller N configurations by removing trees from larger configurations:
- Start from N=200, work down to N=2
- For each N, try removing boundary-touching trees
- Keep the best configuration for N-1 if it improves the score
- This propagates good arrangements downward

**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

### 4. Squeeze and Compaction
- **Squeeze:** Scale all trees toward center until overlap occurs
- **Compaction:** Move individual trees toward center in small steps
- **Local Search:** Try moving/rotating each tree in 8 directions

### 5. Multi-Phase Optimization Strategy
From `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`:
- Phase A: Short runs (2 min) with many parameter combinations to find promising settings
- Phase B: Medium runs (10 min) on top candidates
- Phase C: Long runs (20 min) on best few candidates
- Always keep best solution, revert on regressions

## Pre-optimized Solutions Available
Located in `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`:
- `best_ensemble.csv` - Score: 70.676
- `bucket-of-chump/submission.csv` - Score: 70.676
- `bbox3` binary - Pre-compiled optimizer

## Recommended Experiment Strategy

### Experiment 1: Baseline with Pre-optimized Solution
1. Copy best pre-optimized solution as baseline
2. Run fix_direction rotation optimization
3. Validate no overlaps
4. Submit to establish baseline score

### Experiment 2: Extended bbox3 Optimization
1. Start from best baseline
2. Run bbox3 with longer iterations: `-n 20000 -r 256`
3. Apply fix_direction after each run
4. Run backward propagation
5. Repeat until no improvement

### Experiment 3: Greedy Construction from Scratch
Instead of optimizing existing solutions, try building new configurations:
1. For each N, use greedy placement with weighted angle distribution
2. Try multiple random seeds
3. Apply squeeze + local search
4. Keep best per-N configuration

### Experiment 4: Per-N Focused Optimization
1. Identify which N values contribute most to score
2. Focus optimization on high-impact N values
3. Use longer runs specifically for those N

### Experiment 5: Ensemble Best-of-N
1. Run multiple independent optimizations with different seeds
2. For each N, keep the best configuration across all runs
3. Combine into final submission

## Implementation Notes

### Collision Detection
Use Shapely library with STRtree for efficient spatial queries:
```python
from shapely.strtree import STRtree
tree_index = STRtree(polygons)
possible_indices = tree_index.query(candidate_poly)
```

### Submission Format
- Values must be prefixed with 's' (e.g., "s0.123456")
- Coordinates constrained to -100 ≤ x, y ≤ 100
- Format: id,x,y,deg

### Validation
Always check for overlaps before submission:
```python
def has_overlap(trees):
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

## Critical Success Factors
1. **Start from best baseline** - Don't build from scratch initially
2. **Use C++ optimizer** - Python is too slow for this problem
3. **Long optimization runs** - More iterations = better results
4. **Rotation optimization** - Can provide easy gains
5. **Backward propagation** - Improves smaller N configurations
6. **Validate overlaps** - Invalid submissions are rejected

## Files to Reference
- `../research/kernels/jazivxt_why-not/why-not.ipynb` - bbox3.cpp source code
- `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb` - backward propagation
- `../research/kernels/saspav_santa-submission/santa-submission.ipynb` - fix_direction
- `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/` - pre-optimized solutions
