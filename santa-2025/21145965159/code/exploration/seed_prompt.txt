# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D geometric packing optimization problem. The goal is to pack Christmas tree-shaped polygons into the smallest possible square bounding box for configurations of N=1 to N=200 trees.

**Metric:** score = Σ(side_n² / n) for n=1 to 200 (lower is better)
**Target Score:** 68.919154
**Best Pre-optimized Baseline:** ~70.676 (found in snapshots)
**Gap to Target:** ~1.76 points improvement needed

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Tip at (0, 0.8)
- Three tiers of branches at y=0.5, 0.25, 0.0
- Trunk at bottom (width 0.15, height 0.2)
- Base width 0.7
- Trees can be rotated by any angle (0-360 degrees)

Tree vertices (TX, TY):
```
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## Key Techniques from Public Kernels

### 1. C++ Optimizer (bbox3) - CRITICAL
The top kernels use a compiled C++ optimizer called `bbox3` that implements:
- Simulated Annealing (SA) with temperature scheduling
- Local search with multiple move types (translate, rotate, swap)
- Parallel processing with OpenMP
- Long double precision for accuracy
- Squeeze and compaction moves

**Key parameters:**
- `-n`: Number of iterations (e.g., 5000-20000)
- `-r`: Number of restarts/rounds (e.g., 16-256)

**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb` contains the full bbox3.cpp source

**Pre-compiled binary:** `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/bbox3`

### 2. Fix Direction / Rotation Optimization
After packing, rotate the entire configuration to minimize bounding box:
- Use convex hull of all tree vertices
- Optimize rotation angle using scipy.optimize.minimize_scalar
- Bounds: (0.001, 89.999) degrees
- This can reduce score by tightening the bounding box alignment

**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

### 3. Backward Propagation
Improve smaller N configurations by removing trees from larger configurations:
- Start from N=200, work down to N=2
- For each N, try removing boundary-touching trees
- Keep the best configuration for N-1 if it improves the score
- This propagates good arrangements downward

**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

### 4. Squeeze and Compaction
- **Squeeze:** Scale all trees toward center until overlap occurs (scale 0.9995 to 0.98)
- **Compaction:** Move individual trees toward center in small steps (0.02, 0.008, 0.003, 0.001)
- **Local Search:** Try moving/rotating each tree in 8 directions with various step sizes

### 5. Multi-Phase Optimization Strategy
From `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`:
- Phase A: Short runs (2 min) with many parameter combinations to find promising settings
- Phase B: Medium runs (10 min) on top candidates
- Phase C: Long runs (20 min) on best few candidates
- Always keep best solution, revert on regressions

## Additional Techniques from Research Literature

### 6. Bottom-Left Placement Strategy
- Place each tree as far down and left as possible
- Use weighted angle distribution to favor diagonal orientations
- This helps fill corners better

### 7. Genetic Algorithm Approach
- Encode solution as permutation of tree placement order
- Crossover: Order crossover (OX) or partially mapped crossover (PMX)
- Mutation: Swap two trees, rotate a tree, small position perturbation
- Selection: Tournament selection

### 8. Extended Local Search with Nonlinear Programming
- Use nonlinear programming to minimize overlap
- Swap two polygons in placement
- Tabu search to avoid local minima

### 9. Jostle Algorithm
- Iteratively "jostle" pieces to compact the packing
- Move pieces toward center while maintaining feasibility
- Repeat until no improvement

## Pre-optimized Solutions Available
Located in `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`:
- `best_ensemble.csv` - Score: 70.676
- `bucket-of-chump/submission.csv` - Score: 70.676
- `bbox3` binary - Pre-compiled optimizer
- `santa25-public/` - Multiple solution versions

**Best candidate found:** `submission_candidates/candidate_001.csv` - Score: 70.67609930809661

## Recommended Experiment Strategy

### Experiment 1: Baseline with Pre-optimized Solution
1. Copy best pre-optimized solution (`best_ensemble.csv`) as baseline
2. Run fix_direction rotation optimization
3. Validate no overlaps
4. Submit to establish baseline score

### Experiment 2: Extended bbox3 Optimization
1. Start from best baseline
2. Compile bbox3.cpp with: `g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp`
3. Run bbox3 with longer iterations: `./bbox3 -n 20000 -r 256`
4. Apply fix_direction after each run
5. Run backward propagation
6. Repeat until no improvement

### Experiment 3: Per-N Focused Optimization
1. Calculate score contribution per N: score_n = side_n² / n
2. Identify which N values contribute most to total score
3. Focus optimization on high-impact N values (likely larger N)
4. Use longer runs specifically for those N

### Experiment 4: Ensemble Best-of-N
1. Run multiple independent optimizations with different seeds
2. For each N, keep the best configuration across all runs
3. Combine into final submission using ensemble script

### Experiment 5: Greedy Construction with Multiple Seeds
Instead of optimizing existing solutions, try building new configurations:
1. For each N, use greedy placement with weighted angle distribution
2. Try 100+ random seeds per N
3. Apply squeeze + local search to each
4. Keep best per-N configuration

### Experiment 6: Hybrid Genetic Algorithm
1. Initialize population with variations of best solution
2. Apply crossover and mutation operators
3. Use local search on offspring
4. Keep best solutions across generations

## Implementation Notes

### Collision Detection
Use Shapely library with STRtree for efficient spatial queries:
```python
from shapely.strtree import STRtree
from shapely.geometry import Polygon
from shapely import affinity

tree_index = STRtree(polygons)
possible_indices = tree_index.query(candidate_poly)
for idx in possible_indices:
    if candidate_poly.intersects(polygons[idx]) and not candidate_poly.touches(polygons[idx]):
        return True  # Overlap detected
```

### Submission Format
- Values must be prefixed with 's' (e.g., "s0.123456")
- Coordinates constrained to -100 ≤ x, y ≤ 100
- Format: id,x,y,deg
- id format: NNN_T where NNN is zero-padded N (001-200) and T is tree index

### Score Calculation
```python
def calculate_score(submission_df):
    total_score = 0
    for n in range(1, 201):
        group = submission_df[submission_df['id'].str.startswith(f'{n:03d}_')]
        trees = [ChristmasTree(row['x'], row['y'], row['deg']) for _, row in group.iterrows()]
        side = get_bounding_box_side(trees)
        total_score += side**2 / n
    return total_score
```

### Validation
Always check for overlaps before submission:
```python
def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

## Critical Success Factors
1. **Start from best baseline** - Don't build from scratch initially
2. **Use C++ optimizer** - Python is too slow for this problem
3. **Long optimization runs** - More iterations = better results
4. **Rotation optimization** - Can provide easy gains
5. **Backward propagation** - Improves smaller N configurations
6. **Validate overlaps** - Invalid submissions are rejected
7. **Ensemble multiple runs** - Combine best per-N from different runs

## Files to Reference
- `../research/kernels/jazivxt_why-not/why-not.ipynb` - bbox3.cpp source code
- `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb` - backward propagation + tree_packer
- `../research/kernels/saspav_santa-submission/santa-submission.ipynb` - fix_direction
- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - multi-phase runner
- `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/` - pre-optimized solutions

## Key Insight: Score Improvement Strategy
The gap from 70.676 to 68.919 is ~1.76 points. This requires:
- Improving average side length by ~1.2% across all N
- OR significant improvements on specific high-impact N values
- Focus on larger N (100-200) as they have more room for optimization
- Small improvements compound: 0.01 reduction in side for N=200 saves 0.0001 in score

## Warning: Local Optimum Trap
Pre-optimized solutions may be at local optima. To escape:
- Use different random seeds for initialization
- Try completely different construction strategies
- Use simulated annealing with high initial temperature
- Consider genetic algorithm for global exploration
