{
  "phase": "executor",
  "loop_count": 1,
  "last_submission": null,
  "competition_id": "santa-2025",
  "seed_prompt": "# Santa 2025 - Christmas Tree Packing Optimization\n\n## Problem Overview\nThis is a 2D geometric packing optimization problem. The goal is to pack Christmas tree-shaped polygons into the smallest possible square bounding box for configurations of N=1 to N=200 trees.\n\n**Metric:** score = \u03a3(side_n\u00b2 / n) for n=1 to 200 (lower is better)\n**Target Score:** 68.919154\n**Best Pre-optimized Baseline:** ~70.676 (found in snapshots)\n**Gap to Target:** ~1.76 points improvement needed\n\n## Tree Geometry\nEach tree is a 15-vertex polygon with:\n- Tip at (0, 0.8)\n- Three tiers of branches at y=0.5, 0.25, 0.0\n- Trunk at bottom (width 0.15, height 0.2)\n- Base width 0.7\n- Trees can be rotated by any angle (0-360 degrees)\n\nTree vertices (TX, TY):\n```\nTX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]\nTY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]\n```\n\n## Key Techniques from Public Kernels\n\n### 1. C++ Optimizer (bbox3) - CRITICAL\nThe top kernels use a compiled C++ optimizer called `bbox3` that implements:\n- Simulated Annealing (SA) with temperature scheduling\n- Local search with multiple move types (translate, rotate, swap)\n- Parallel processing with OpenMP\n- Long double precision for accuracy\n- Squeeze and compaction moves\n\n**Key parameters:**\n- `-n`: Number of iterations (e.g., 5000-20000)\n- `-r`: Number of restarts/rounds (e.g., 16-256)\n\n**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb` contains the full bbox3.cpp source\n\n**Pre-compiled binary:** `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/bbox3`\n\n### 2. Fix Direction / Rotation Optimization\nAfter packing, rotate the entire configuration to minimize bounding box:\n- Use convex hull of all tree vertices\n- Optimize rotation angle using scipy.optimize.minimize_scalar\n- Bounds: (0.001, 89.999) degrees\n- This can reduce score by tightening the bounding box alignment\n\n**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`\n\n### 3. Backward Propagation\nImprove smaller N configurations by removing trees from larger configurations:\n- Start from N=200, work down to N=2\n- For each N, try removing boundary-touching trees\n- Keep the best configuration for N-1 if it improves the score\n- This propagates good arrangements downward\n\n**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n\n### 4. Squeeze and Compaction\n- **Squeeze:** Scale all trees toward center until overlap occurs (scale 0.9995 to 0.98)\n- **Compaction:** Move individual trees toward center in small steps (0.02, 0.008, 0.003, 0.001)\n- **Local Search:** Try moving/rotating each tree in 8 directions with various step sizes\n\n### 5. Multi-Phase Optimization Strategy\nFrom `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`:\n- Phase A: Short runs (2 min) with many parameter combinations to find promising settings\n- Phase B: Medium runs (10 min) on top candidates\n- Phase C: Long runs (20 min) on best few candidates\n- Always keep best solution, revert on regressions\n\n## Additional Techniques from Research Literature\n\n### 6. Bottom-Left Placement Strategy\n- Place each tree as far down and left as possible\n- Use weighted angle distribution to favor diagonal orientations\n- This helps fill corners better\n\n### 7. Genetic Algorithm Approach\n- Encode solution as permutation of tree placement order\n- Crossover: Order crossover (OX) or partially mapped crossover (PMX)\n- Mutation: Swap two trees, rotate a tree, small position perturbation\n- Selection: Tournament selection\n\n### 8. Extended Local Search with Nonlinear Programming\n- Use nonlinear programming to minimize overlap\n- Swap two polygons in placement\n- Tabu search to avoid local minima\n\n### 9. Jostle Algorithm\n- Iteratively \"jostle\" pieces to compact the packing\n- Move pieces toward center while maintaining feasibility\n- Repeat until no improvement\n\n## Pre-optimized Solutions Available\nLocated in `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`:\n- `best_ensemble.csv` - Score: 70.676\n- `bucket-of-chump/submission.csv` - Score: 70.676\n- `bbox3` binary - Pre-compiled optimizer\n- `santa25-public/` - Multiple solution versions\n\n**Best candidate found:** `submission_candidates/candidate_001.csv` - Score: 70.67609930809661\n\n## Recommended Experiment Strategy\n\n### Experiment 1: Baseline with Pre-optimized Solution\n1. Copy best pre-optimized solution (`best_ensemble.csv`) as baseline\n2. Run fix_direction rotation optimization\n3. Validate no overlaps\n4. Submit to establish baseline score\n\n### Experiment 2: Extended bbox3 Optimization\n1. Start from best baseline\n2. Compile bbox3.cpp with: `g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp`\n3. Run bbox3 with longer iterations: `./bbox3 -n 20000 -r 256`\n4. Apply fix_direction after each run\n5. Run backward propagation\n6. Repeat until no improvement\n\n### Experiment 3: Per-N Focused Optimization\n1. Calculate score contribution per N: score_n = side_n\u00b2 / n\n2. Identify which N values contribute most to total score\n3. Focus optimization on high-impact N values (likely larger N)\n4. Use longer runs specifically for those N\n\n### Experiment 4: Ensemble Best-of-N\n1. Run multiple independent optimizations with different seeds\n2. For each N, keep the best configuration across all runs\n3. Combine into final submission using ensemble script\n\n### Experiment 5: Greedy Construction with Multiple Seeds\nInstead of optimizing existing solutions, try building new configurations:\n1. For each N, use greedy placement with weighted angle distribution\n2. Try 100+ random seeds per N\n3. Apply squeeze + local search to each\n4. Keep best per-N configuration\n\n### Experiment 6: Hybrid Genetic Algorithm\n1. Initialize population with variations of best solution\n2. Apply crossover and mutation operators\n3. Use local search on offspring\n4. Keep best solutions across generations\n\n## Implementation Notes\n\n### Collision Detection\nUse Shapely library with STRtree for efficient spatial queries:\n```python\nfrom shapely.strtree import STRtree\nfrom shapely.geometry import Polygon\nfrom shapely import affinity\n\ntree_index = STRtree(polygons)\npossible_indices = tree_index.query(candidate_poly)\nfor idx in possible_indices:\n    if candidate_poly.intersects(polygons[idx]) and not candidate_poly.touches(polygons[idx]):\n        return True  # Overlap detected\n```\n\n### Submission Format\n- Values must be prefixed with 's' (e.g., \"s0.123456\")\n- Coordinates constrained to -100 \u2264 x, y \u2264 100\n- Format: id,x,y,deg\n- id format: NNN_T where NNN is zero-padded N (001-200) and T is tree index\n\n### Score Calculation\n```python\ndef calculate_score(submission_df):\n    total_score = 0\n    for n in range(1, 201):\n        group = submission_df[submission_df['id'].str.startswith(f'{n:03d}_')]\n        trees = [ChristmasTree(row['x'], row['y'], row['deg']) for _, row in group.iterrows()]\n        side = get_bounding_box_side(trees)\n        total_score += side**2 / n\n    return total_score\n```\n\n### Validation\nAlways check for overlaps before submission:\n```python\ndef has_overlap(trees):\n    polygons = [t.polygon for t in trees]\n    tree_index = STRtree(polygons)\n    for i, poly in enumerate(polygons):\n        indices = tree_index.query(poly)\n        for idx in indices:\n            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):\n                return True\n    return False\n```\n\n## Critical Success Factors\n1. **Start from best baseline** - Don't build from scratch initially\n2. **Use C++ optimizer** - Python is too slow for this problem\n3. **Long optimization runs** - More iterations = better results\n4. **Rotation optimization** - Can provide easy gains\n5. **Backward propagation** - Improves smaller N configurations\n6. **Validate overlaps** - Invalid submissions are rejected\n7. **Ensemble multiple runs** - Combine best per-N from different runs\n\n## Files to Reference\n- `../research/kernels/jazivxt_why-not/why-not.ipynb` - bbox3.cpp source code\n- `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb` - backward propagation + tree_packer\n- `../research/kernels/saspav_santa-submission/santa-submission.ipynb` - fix_direction\n- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - multi-phase runner\n- `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/` - pre-optimized solutions\n\n## Key Insight: Score Improvement Strategy\nThe gap from 70.676 to 68.919 is ~1.76 points. This requires:\n- Improving average side length by ~1.2% across all N\n- OR significant improvements on specific high-impact N values\n- Focus on larger N (100-200) as they have more room for optimization\n- Small improvements compound: 0.01 reduction in side for N=200 saves 0.0001 in score\n\n## Warning: Local Optimum Trap\nPre-optimized solutions may be at local optima. To escape:\n- Use different random seeds for initialization\n- Try completely different construction strategies\n- Use simulated annealing with high initial temperature\n- Consider genetic algorithm for global exploration\n",
  "evaluator_feedback": "",
  "latest_experiment": {},
  "competitive_intel": "## Available Competitive Intelligence\n\n- Competition description: `../research/description.md`\n- 5 top kernel notebooks in `../research/kernels/`",
  "target_score": 68.919154316391,
  "manual_instructions": "",
  "messages": [],
  "experiments": [],
  "submissions": [],
  "candidates": [],
  "findings": [],
  "metric_lower_is_better": true,
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D packing optimization problem: pack Christmas tree toys (polygon shapes) into smallest square bounding box for N=1 to 200 trees. Score = sum of (side^2 / N) for all N. Lower is better. Target: 68.919154",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "Best pre-optimized solution found: ~70.676 score. Need to improve by ~1.76 points to beat target of 68.919154",
      "source": "exploration/score_check.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Key optimization techniques from kernels: 1) bbox3 C++ optimizer with SA/local search, 2) fix_direction rotation optimization, 3) backward propagation (removing trees from N+1 to get N), 4) squeeze/compaction moves, 5) overlap repair",
      "source": "../research/kernels/",
      "agent": "explorer"
    },
    {
      "finding": "Key 2D packing optimization techniques from research: 1) Bottom-left placement strategy, 2) Genetic algorithms with local search, 3) Simulated annealing, 4) Tabu search, 5) Extended local search with nonlinear programming, 6) Jostle algorithm for irregular shapes, 7) No-fit polygon (NFP) for collision detection",
      "source": "WebSearch: 2D irregular polygon packing optimization",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization problems?",
      "finding": "Two\u2011dimensional irregular polygon packing is a notoriously hard combinatorial problem, and the most effective solvers today combine problem\u2011specific heuristics with powerful meta\u2011heuristic search.  A common baseline is the **bottom\u2011left placement strategy**, which orders pieces and then inserts each one as far down and to the left as possible while respecting geometry; this simple rule underlies many practical algorithms for general\u2011shape packing\u202f([taylorfrancis.com](https://www.taylorfrancis.com/chapters/edit/10.1201/9781351236423-33/practical-algorithms-two-dimensional-packing-general-shapes-yannan-hu-hideki-hashimoto-shinji-imahori-mutsunori-yagiura)).  Building on that, the **Djang\u2011Finch (DJD) heuristic**\u2014originally for 1\u2011D bin packing\u2014has been adapted to irregular 2\u2011D items and paired with a placement routine, yielding results that outperform conventional selection heuristics on convex\u2011polygon instances\u202f([springer.com](https://link.springer.com/article/10.1007/s10479-013-1341-4)).",
      "agent": "explorer"
    }
  ],
  "remaining_submissions": 95,
  "max_submissions": 100,
  "last_reset_date_utc": "2026-01-19",
  "start_time": "2026-01-19T17:14:01.887902",
  "time_limit_minutes": 2100,
  "_saved_at": "2026-01-19T17:24:39.659705"
}