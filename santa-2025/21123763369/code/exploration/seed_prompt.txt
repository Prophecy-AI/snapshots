# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree toys (15-vertex polygons) into the smallest square bounding box for configurations of 1-200 trees.

**Score Formula:** `score = Σ(s_n² / n)` for n=1 to 200, where s_n is the side length of the bounding square for the n-tree configuration. **Lower is better.**

**Target Score to Beat:** 68.922808

## Tree Geometry
- 15-vertex polygon representing a Christmas tree
- Trunk: 0.15 wide, 0.2 tall (bottom at y=-0.2)
- Base tier: 0.7 wide at y=0
- Middle tier: 0.4 wide at y=0.25
- Top tier: 0.25 wide at y=0.5
- Tip: at y=0.8
- Reference point: center of trunk top (0, 0)
- Trees can be rotated by any angle (0-360 degrees)

## CRITICAL FIRST STEP: Download Pre-optimized Baseline

**DO NOT start from sample_submission.csv!** The sample submission scores ~114, far from the target of ~68.9.

Download the best available pre-optimized submission:
```bash
# Option 1: From GitHub (SmartManoj's scoreboard)
wget -q "https://raw.githubusercontent.com/SmartManoj/Santa-Scoreboard/main/submission.csv" -O submission.csv

# Option 2: From Kaggle datasets (if available)
# kaggle datasets download -d <dataset-name>
```

The pre-optimized baselines typically score around 68-70, which is close to the target.

## Key Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (HIGHEST PRIORITY)
**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`, `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

The bbox3 binary is a C++ optimizer with:
- Complex Number Vector Coordination
- Fluid Dynamics simulation
- Hinge Pivot moves
- Density Gradient Flow
- Global Boundary Tension
- OpenMP parallelization

**Compilation:**
```bash
g++ -O3 -fopenmp -march=native -std=c++17 -o bbox3 bbox3.cpp
```

**Usage:** `./bbox3 -n <iterations> -r <radius>`
- Typical parameters: n=1000-2000, r=30-90 for short runs; n=5000-10000, r=256 for longer runs

### 2. tree_packer C++ Optimizer
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Features:
- Simulated Annealing (SA) with temperature scheduling
- Swap move operator (exchange positions of two trees)
- Multi-angle restarts
- Squeeze operation (scale towards centroid)
- Compaction (move trees towards center)
- Local search with 8-directional moves and rotation adjustments

**Compilation:**
```bash
g++ -O3 -fopenmp -march=native -std=c++17 -o tree_packer tree_packer.cpp
```

**Usage:** `./tree_packer -n <iterations> -r <radius>`

### 3. Backward Propagation (bp.cpp)
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Key insight: For n-tree configuration, try removing boundary-touching trees to potentially improve (n-1)-tree configuration.
- Goes from N=200 down to N=2
- Only considers trees that touch the bounding box boundary
- If removing a tree improves the smaller configuration, save it

**Usage:** `./bp input.csv output.csv`

### 4. fix_direction (Rotation Optimization)
**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

Post-processing step that optimizes the global rotation of each configuration:
- Uses scipy.optimize.minimize_scalar to find optimal rotation angle
- Rotates entire configuration to minimize bounding box
- Can reduce score by tightening the bounding box alignment

### 5. Greedy Initialization (for building from scratch)
**Source:** `../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb`

For building initial configurations:
- Start with n-1 tree configuration
- Add new tree at random angle, far from center
- Move towards center until collision
- Back up until no collision
- Use weighted angle distribution (abs(sin(2*angle))) to favor corners

## Recommended Experiment Strategy

### Experiment 1: Baseline + Validation
1. Download pre-optimized submission from GitHub
2. Score it locally using proper polygon-based scoring
3. Validate no overlaps
4. Submit to establish baseline (should be ~68-70)

### Experiment 2: bbox3 Optimization Loop
1. Extract bbox3.cpp from `../research/kernels/jazivxt_why-not/why-not.ipynb`
2. Compile with OpenMP
3. Run optimization loop:
   ```python
   for iteration in range(max_iterations):
       run_bbox3(n=2000, r=60)
       fix_direction()
       repair_overlaps()
       if score_improved:
           save_best()
   ```
4. Submit best result

### Experiment 3: tree_packer + Backward Propagation
1. Extract tree_packer.cpp and bp.cpp from `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`
2. Compile both
3. Run optimization:
   ```bash
   ./tree_packer -n 5000 -r 128
   ./bp submission.csv submission.csv
   ```
4. Apply fix_direction
5. Submit

### Experiment 4: Multi-phase Optimization (3-hour budget)
Based on `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`:
1. Phase A (2 min each): Many short runs with n=1000-2000, r=30-90
2. Phase B (10 min each): Medium runs on top 3 candidates
3. Phase C (20 min each): Long runs on best 2 candidates
4. Always keep best submission, revert on regressions

### Experiment 5: Configuration Merging
For each n from 1 to 200:
- Compare configurations from multiple optimization runs
- Keep the one with smallest bounding box side length
- Merge into final submission

## Validation & Overlap Repair

**CRITICAL:** Submissions with overlapping trees will be rejected!

```python
from shapely.geometry import Polygon
from shapely.strtree import STRtree

def has_overlap(trees):
    if len(trees) <= 1:
        return False
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

Overlap repair:
- If configuration n has overlap, replace with configuration from donor (baseline) file
- Use `replace_group()` function to swap specific n-configurations

## Key Code Components

### ChristmasTree Class
```python
class ChristmasTree:
    def __init__(self, center_x='0', center_y='0', angle='0'):
        self.center_x = Decimal(center_x)
        self.center_y = Decimal(center_y)
        self.angle = Decimal(angle)
        
        # Tree dimensions
        trunk_w, trunk_h = Decimal('0.15'), Decimal('0.2')
        base_w, mid_w, top_w = Decimal('0.7'), Decimal('0.4'), Decimal('0.25')
        tip_y, tier_1_y, tier_2_y = Decimal('0.8'), Decimal('0.5'), Decimal('0.25')
        
        # 15-vertex polygon
        initial_polygon = Polygon([
            (0, tip_y), (top_w/2, tier_1_y), (top_w/4, tier_1_y),
            (mid_w/2, tier_2_y), (mid_w/4, tier_2_y), (base_w/2, 0),
            (trunk_w/2, 0), (trunk_w/2, -trunk_h),
            (-trunk_w/2, -trunk_h), (-trunk_w/2, 0), (-base_w/2, 0),
            (-mid_w/4, tier_2_y), (-mid_w/2, tier_2_y),
            (-top_w/4, tier_1_y), (-top_w/2, tier_1_y)
        ])
        
        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))
        self.polygon = affinity.translate(rotated, xoff=float(self.center_x), yoff=float(self.center_y))
```

### Scoring Function
```python
def get_total_score(dict_of_side_length):
    score = Decimal('0')
    for k, v in dict_of_side_length.items():
        score += v ** 2 / Decimal(str(k))
    return score
```

## Key Insights from Research

1. **Start from pre-optimized baseline** - Sample submission scores ~114, target is ~68.9
2. **Asymmetric solutions often outperform symmetric ones** for larger N values
3. **Boundary-touching trees** are the key to reducing bounding box size
4. **Rotation optimization** (fix_direction) provides small but consistent improvements
5. **Local search on pre-optimized solutions** has diminishing returns
6. **Backward propagation** can improve smaller N configurations by leveraging larger N solutions
7. **Multi-phase optimization** with increasing timeouts is effective for long runs

## Time Budget Considerations
- bbox3 with n=2000, r=60: ~2 minutes per run
- tree_packer with n=5000, r=128: ~5-10 minutes
- Full 3-hour optimization: Use phased approach with increasing timeouts
- Always save checkpoints and revert on regressions

## Files and Paths
- Sample submission: `/home/data/sample_submission.csv`
- Kernels: `../research/kernels/`
- Key kernel with bbox3 source: `../research/kernels/jazivxt_why-not/why-not.ipynb`
- Key kernel with tree_packer source: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`
- Key kernel with multi-phase runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
