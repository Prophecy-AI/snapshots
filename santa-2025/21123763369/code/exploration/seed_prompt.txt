# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree toys (15-vertex polygons) into the smallest square bounding box for configurations of 1-200 trees.

**Score Formula:** `score = Σ(s_n² / n)` for n=1 to 200, where s_n is the side length of the bounding square for the n-tree configuration. **Lower is better.**

**Target Score to Beat:** 68.922808

## Current Baseline Status
- Sample submission (greedy): ~114 (too far from target)
- Pre-optimized from GitHub: ~70.74 (1.82 points above target)
- **Gap to close: ~2.6% improvement needed**

## Tree Geometry
- 15-vertex polygon representing a Christmas tree
- Trunk: 0.15 wide, 0.2 tall (bottom at y=-0.2)
- Base tier: 0.7 wide at y=0
- Middle tier: 0.4 wide at y=0.25
- Top tier: 0.25 wide at y=0.5
- Tip: at y=0.8
- Reference point: center of trunk top (0, 0)
- Trees can be rotated by any angle (0-360 degrees)

## CRITICAL FIRST STEP: Download Pre-optimized Baseline

**DO NOT start from sample_submission.csv!** The sample submission scores ~114, far from the target of ~68.9.

Download the best available pre-optimized submission:
```bash
# From GitHub (SmartManoj's scoreboard) - scores ~70.74
wget -q "https://raw.githubusercontent.com/SmartManoj/Santa-Scoreboard/main/submission.csv" -O submission.csv
```

## Key Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (HIGHEST PRIORITY)
**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`

The bbox3 binary is a C++ optimizer with:
- Complex Number Vector Coordination
- Fluid Dynamics simulation
- Hinge Pivot moves
- Density Gradient Flow
- Global Boundary Tension
- OpenMP parallelization

**Compilation:**
```bash
g++ -O3 -fopenmp -march=native -std=c++17 -o bbox3 bbox3.cpp
```

**Usage:** `./bbox3 -n <iterations> -r <radius>`
- Short runs: n=1000-2000, r=30-90
- Long runs: n=5000-10000, r=256

### 2. tree_packer C++ Optimizer
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Features:
- Simulated Annealing (SA) with temperature scheduling
- Swap move operator (exchange positions of two trees)
- Multi-angle restarts
- Squeeze operation (scale towards centroid)
- Compaction (move trees towards center)
- Local search with 8-directional moves and rotation adjustments

**Compilation:**
```bash
g++ -O3 -fopenmp -march=native -std=c++17 -o tree_packer tree_packer.cpp
```

**Usage:** `./tree_packer -n <iterations> -r <radius>`

### 3. Backward Propagation (bp.cpp)
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Key insight: For n-tree configuration, try removing boundary-touching trees to potentially improve (n-1)-tree configuration.
- Goes from N=200 down to N=2
- Only considers trees that touch the bounding box boundary
- If removing a tree improves the smaller configuration, save it

**Usage:** `./bp input.csv output.csv`

### 4. fix_direction (Rotation Optimization)
**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

Post-processing step that optimizes the global rotation of each configuration:
- Uses scipy.optimize.minimize_scalar to find optimal rotation angle
- Rotates entire configuration to minimize bounding box
- Can reduce score by tightening the bounding box alignment

```python
from scipy.optimize import minimize_scalar
from scipy.spatial import ConvexHull

def optimize_rotation(trees):
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points_np = np.array(all_points)
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    def bbox_side_at_angle(angle_deg):
        angle_rad = np.radians(angle_deg)
        c, s = np.cos(angle_rad), np.sin(angle_rad)
        rot_matrix_T = np.array([[c, s], [-s, c]])
        rotated = hull_points.dot(rot_matrix_T)
        return max(rotated.max(0) - rotated.min(0))
    
    res = minimize_scalar(bbox_side_at_angle, bounds=(0.001, 89.999), method='bounded')
    return res.x, res.fun
```

## Recommended Experiment Strategy

### Experiment 1: Baseline + Validation
1. Download pre-optimized submission from GitHub
2. Score it locally (~70.74 expected)
3. Validate no overlaps
4. Submit to establish baseline

### Experiment 2: bbox3 Optimization Loop
1. Extract bbox3.cpp from `../research/kernels/jazivxt_why-not/why-not.ipynb`
2. Compile with OpenMP
3. Run multi-phase optimization:
   - Phase A: Short runs (2 min each) with various (n, r) combinations
   - Phase B: Medium runs (10 min each) on top candidates
   - Phase C: Long runs (20 min each) on best few
4. Apply fix_direction post-processing
5. Validate and repair overlaps
6. Submit best result

### Experiment 3: tree_packer + Backward Propagation
1. Extract tree_packer.cpp and bp.cpp from santa-claude kernel
2. Compile both
3. Run optimization:
   ```bash
   ./tree_packer -n 5000 -r 128
   ./bp submission.csv submission.csv
   ```
4. Apply fix_direction
5. Submit

### Experiment 4: Configuration Merging
For each n from 1 to 200:
- Compare configurations from multiple optimization runs
- Keep the one with smallest bounding box side length
- Merge into final submission

### Experiment 5: Targeted Optimization
Focus on configurations with highest score contribution:
- Large N values (150-200) contribute most to total score
- Optimize these specifically with longer runs

## Validation & Overlap Repair

**CRITICAL:** Submissions with overlapping trees will be rejected!

```python
from shapely.geometry import Polygon
from shapely.strtree import STRtree

def has_overlap(trees):
    if len(trees) <= 1:
        return False
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False

def repair_overlaps(submission_path, donor_path, failed_n_list):
    """Replace overlapping configurations with donor configurations."""
    df_new = pd.read_csv(submission_path)
    df_good = pd.read_csv(donor_path)
    failed_prefixes = [f"{n:03d}_" for n in failed_n_list]
    df_to_keep = df_new[~df_new["id"].str.startswith(tuple(failed_prefixes))]
    df_replacement = df_good[df_good["id"].str.startswith(tuple(failed_prefixes))]
    df_repaired = pd.concat([df_to_keep, df_replacement]).sort_values(by="id")
    df_repaired.to_csv(submission_path, index=False)
```

## Key Code Components

### ChristmasTree Class
```python
from decimal import Decimal, getcontext
from shapely import affinity
from shapely.geometry import Polygon

getcontext().prec = 30

class ChristmasTree:
    def __init__(self, center_x='0', center_y='0', angle='0'):
        self.center_x = Decimal(str(center_x))
        self.center_y = Decimal(str(center_y))
        self.angle = Decimal(str(angle))
        
        # Tree dimensions
        trunk_w, trunk_h = Decimal('0.15'), Decimal('0.2')
        base_w, mid_w, top_w = Decimal('0.7'), Decimal('0.4'), Decimal('0.25')
        tip_y, tier_1_y, tier_2_y = Decimal('0.8'), Decimal('0.5'), Decimal('0.25')
        
        # 15-vertex polygon
        initial_polygon = Polygon([
            (0, float(tip_y)), (float(top_w/2), float(tier_1_y)), (float(top_w/4), float(tier_1_y)),
            (float(mid_w/2), float(tier_2_y)), (float(mid_w/4), float(tier_2_y)), (float(base_w/2), 0),
            (float(trunk_w/2), 0), (float(trunk_w/2), float(-trunk_h)),
            (float(-trunk_w/2), float(-trunk_h)), (float(-trunk_w/2), 0), (float(-base_w/2), 0),
            (float(-mid_w/4), float(tier_2_y)), (float(-mid_w/2), float(tier_2_y)),
            (float(-top_w/4), float(tier_1_y)), (float(-top_w/2), float(tier_1_y))
        ])
        
        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))
        self.polygon = affinity.translate(rotated, xoff=float(self.center_x), yoff=float(self.center_y))
```

### Scoring Functions
```python
from shapely.ops import unary_union

def get_tree_list_side_length(tree_list):
    all_polygons = [t.polygon for t in tree_list]
    bounds = unary_union(all_polygons).bounds
    return Decimal(str(max(bounds[2] - bounds[0], bounds[3] - bounds[1])))

def get_total_score(dict_of_side_length):
    score = Decimal('0')
    for k, v in dict_of_side_length.items():
        score += v ** 2 / Decimal(str(k))
    return score
```

## Key Insights from Research

1. **Start from pre-optimized baseline** - Sample submission scores ~114, pre-optimized ~70.74, target is ~68.92
2. **Gap to close is ~2.6%** - Need to improve from 70.74 to below 68.92
3. **Asymmetric solutions often outperform symmetric ones** for larger N values
4. **Boundary-touching trees** are the key to reducing bounding box size
5. **Rotation optimization** (fix_direction) provides small but consistent improvements
6. **Local search on pre-optimized solutions** has diminishing returns - need longer runs or different approaches
7. **Backward propagation** can improve smaller N configurations by leveraging larger N solutions
8. **Multi-phase optimization** with increasing timeouts is effective for long runs

## Time Budget Considerations
- bbox3 with n=2000, r=60: ~2 minutes per run
- tree_packer with n=5000, r=128: ~5-10 minutes
- Full 3-hour optimization: Use phased approach with increasing timeouts
- Always save checkpoints and revert on regressions

## Files and Paths
- Sample submission: `/home/data/sample_submission.csv`
- Kernels: `../research/kernels/`
- Key kernel with bbox3 source: `../research/kernels/jazivxt_why-not/why-not.ipynb`
- Key kernel with tree_packer source: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`
- Key kernel with multi-phase runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- Values must be prefixed with 's' to preserve precision
- Coordinates must be in range [-100, 100]
- No overlapping trees allowed
