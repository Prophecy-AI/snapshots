# Santa 2025 - Evolved Strategy (Loop 1)

## Current Status
- Best CV score: 70.7438 from exp_000 (001_baseline_preoptimized)
- Best LB score: 70.7438 (perfect CV-LB match!)
- Target: 68.922808 | Gap to target: 1.82 points (2.64%)
- Submissions used: 1/100 (99 remaining)

## CV-LB Relationship Analysis
- Perfect match: CV = LB (no calibration issues)
- Local scoring is accurate and trustworthy
- This is an optimization problem, not ML - no distribution shift concerns

## Response to Evaluator
The evaluator correctly identified that:
1. ✅ Baseline is correctly established and validated
2. ✅ No optimization has been run yet - only baseline download
3. ✅ Need to begin actual optimization immediately

**Agreed actions:**
- Extract and compile bbox3.cpp from jazivxt_why-not kernel
- Run optimization loops with various parameters
- Apply fix_direction post-processing
- Submit improved results

## Key Insights from Analysis
1. **Score distribution**: Top 20 N values contribute 11.4% of total score
2. **Small N matters**: n=1 alone contributes 0.66 points (0.94% of total)
3. **Improvement needed**: Average 0.009 per N value, or ~2.6% overall
4. **Perfect CV-LB match**: Our local scoring is accurate

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Run bbox3 C++ Optimizer
**Source:** `/home/code/research/kernels/jazivxt_why-not/why-not.ipynb`

Extract bbox3.cpp and compile:
```bash
# Extract from notebook (look for %%writefile bbox3.cpp cell)
g++ -O3 -fopenmp -march=native -std=c++17 -o bbox3 bbox3.cpp
```

Run optimization:
```bash
# Short test run first
./bbox3 -n 2000 -r 60

# Medium run
./bbox3 -n 5000 -r 128

# Long run (if time permits)
./bbox3 -n 10000 -r 256
```

### 2. **[HIGH PRIORITY]** Apply fix_direction Post-processing
After each optimization run, apply rotation optimization:
```python
from scipy.optimize import minimize_scalar
from scipy.spatial import ConvexHull

def optimize_rotation(trees):
    # Get all polygon points
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points_np = np.array(all_points)
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    def bbox_side_at_angle(angle_deg):
        angle_rad = np.radians(angle_deg)
        c, s = np.cos(angle_rad), np.sin(angle_rad)
        rot_matrix_T = np.array([[c, s], [-s, c]])
        rotated = hull_points.dot(rot_matrix_T)
        return max(rotated.max(0) - rotated.min(0))
    
    res = minimize_scalar(bbox_side_at_angle, bounds=(0.001, 89.999), method='bounded')
    return res.x, res.fun
```

### 3. **[HIGH PRIORITY]** Ensemble Best Configurations
**Source:** `/home/code/research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation/`

For each N from 1 to 200:
- Compare configurations from multiple optimization runs
- Keep the one with smallest bounding box side length
- Merge into final submission

### 4. **[MEDIUM PRIORITY]** Run tree_packer + Backward Propagation
**Source:** `/home/code/research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

```bash
# Compile
g++ -O3 -fopenmp -march=native -std=c++17 -o tree_packer tree_packer.cpp
g++ -O3 -march=native -std=c++17 -o bp bp.cpp

# Run
./tree_packer -n 5000 -r 128
./bp submission.csv submission.csv
```

### 5. **[MEDIUM PRIORITY]** Fractional Translation Fine-tuning
After SA optimization, apply micro-adjustments:
- Move each tree by tiny amounts (0.001, 0.0005, 0.0001, etc.)
- Check 8 directions for each step size
- Accept if bounding box shrinks without overlap

## What NOT to Try
- ❌ Starting from sample_submission.csv (too far from target)
- ❌ Reinforcement learning approaches (proven ineffective for this problem)
- ❌ Pure Python optimization (too slow - use C++ with OpenMP)

## Validation Notes
- Always check for overlaps after optimization
- Use repair_overlaps function to replace invalid configurations with donor
- Score locally before submitting

## SUBMISSION STRATEGY
- Remaining submissions: 99
- **Submit after EVERY experiment** - we have abundant submissions
- LB feedback is free information - USE IT!

## Experiment 2 Plan
1. Extract bbox3.cpp from jazivxt_why-not kernel
2. Compile with OpenMP
3. Run short optimization (2-5 min)
4. Apply fix_direction
5. Validate no overlaps
6. Score and submit
7. If improved, run longer optimization

## Time Budget
- Total time: 2100 minutes
- Used: ~20 minutes
- Remaining: ~2080 minutes
- Recommendation: Allocate 30-60 min for initial optimization runs
