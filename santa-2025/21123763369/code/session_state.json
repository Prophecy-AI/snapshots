{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T03:05:26.889845",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "Key approach: bbox3 binary optimizer is used for local search optimization. The workflow is: 1) Start with a baseline CSV, 2) Run bbox3 with parameters -n (iterations) and -r (radius), 3) Apply fix_direction (rotation optimization using scipy.optimize.minimize_scalar), 4) Repair any overlaps by replacing with donor groups. Score = sum(s\u00b2/n) for n=1 to 200.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "bbox3.cpp is a C++ optimizer with features: Complex Number Vector Coordination, Fluid Dynamics, Hinge Pivot, Density Gradient Flow, Global Boundary Tension. Uses global_squeeze for Dynamic Scaling and Overlap Repair. Key parameters: -n (iterations), -r (radius). Compiled with OpenMP for parallelization.",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Santa-Claude kernel uses tree_packer_v21.cpp with: Simulated Annealing (SA), swap move operator, multi-angle restarts, squeeze, compaction, local search. Also uses backward propagation (bp.cpp) that goes from N=200 down to N=2, removing boundary-touching trees to improve smaller configurations. Key parameters: -n (iterations), -r (radius). Downloads pre-optimized submission from GitHub.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Tree shape: 15-vertex polygon with trunk (0.15 wide, 0.2 tall), base tier (0.7 wide), middle tier (0.4 wide), top tier (0.25 wide), tip at y=0.8. Coordinates defined at trunk center (0,0). Collision detection uses point-in-polygon and segment intersection tests.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best optimization algorithms for 2D irregular polygon packing problems?",
      "finding": "Two\u2011dimensional irregular polygon packing \u2013 often called nesting or irregular strip\u2011packing \u2013 asks how to place a set of arbitrarily shaped polygons inside a rectangular sheet (or a set of sheets) while minimizing waste or the number of sheets used.  The problem appears in sheet\u2011metal cutting, textile, furniture, ship\u2011building and many other industries, and is NP\u2011hard, so exact methods are only practical for very small instances\u202f([frontiersin.org](https://www.frontiersin.org/articles/10.3389/fmech.2022.966691/full)).\n\nA large body of work therefore relies on **heuristic and meta\u2011heuristic algorithms** that balance solution quality with computational speed.  The most widely used constructive heuristics are the **bottom\u2011left (BL) placement** and its variants (BL\u2011F, BL\u2011S), as well as **shelf\u2011 and skyline\u2011based methods** that sort polygons by height or width before packing\u202f([taylorfrancis.com](https://www.taylorfrancis.com/chapters/edit/10.1201/9781351236423-33/practical-algorithms-two-dim",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 100
}