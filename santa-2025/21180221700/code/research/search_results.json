{
  "query": "What is the theoretical lower bound for packing N irregular polygons in a square and how do top competitors approach this in Kaggle Santa competitions?",
  "results": [
    {
      "title": "ANSWER",
      "text": "The only provable universal bound for packing\u202fN arbitrary (irregular) polygons into a single square is the **area bound**: any feasible packing must occupy at least the total area of the pieces, so the side length\u202fL of the smallest enclosing square satisfies  \n\n\\[\nL \\;\\ge\\; \\sqrt{\\sum_{i=1}^{N}\\operatorname{area}(P_i)} .\n\\]  \n\nThis elementary lower bound is the same one used for rectangle\u2011packing problems and is the basis of the \u201cwasted\u2011space\u201d lower bound introduced by Korf for optimal rectangle packing\u202f[\u200bKorf\u202f2004\u200b](https://cdn.aaai.org/ICAPS/2004/ICAPS04-019.pdf). No tighter theoretical guarantee is known for general irregular polygons; improving it to an\u202fO(1)\u2011approximation remains an open question\u202f[\u200bKurpisz\u202f&\u202fSuter\u202f2023\u200b](https://export.arxiv.org/pdf/2308.08523v1.pdf).\n\nTop Kaggle \u201cSanta\u201d contestants treat the problem as a large\u2011scale heuristic search rather than trying to meet the theoretical bound. The most successful pipelines combine three ideas:\n\n1. **Problem decomposition** \u2013 the container is recursively partitioned into smaller sub\u2011regions, turning a huge instance (up to\u202f50\u202f000 pieces) into many tractable sub\u2011problems\u202f[\u200bLuo\u202fet\u202fal.\u202f2024\u200b](https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.86/LIPIcs.SoCG.2024.86.pdf).  \n2. **Strong initial solutions** \u2013 integer\u2011programming or greedy \u201cshelf\u201d constructions are used to obtain a feasible start, often exploiting height\u2011sorting of the polygons\u202f[\u200bShadoks\u202f2024\u200b](https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.84/LIPIcs.SoCG.2024.84.pdf).  \n3. **Meta\u2011heuristic refinement** \u2013 differential\u2011evolution, tabu\u2011search, and local\u2011search moves are applied to iteratively eliminate overlaps and improve the occupied area. The combination of these operators yields the best scores in the CG:SHOP/Kaggle Santa challenges, while pure reinforcement\u2011learning approaches have been shown to under\u2011perform\u202f[\u200bDhiman\u202f2025\u200b](https://hmnshudhmn24.medium.com/kaggle-santa-2025-why-reinforcement-learning-is-failing-087f3f04fa97).\n\nIn practice, competitors accept that the theoretical lower bound is unattainable for irregular shapes and focus on high\u2011quality heuristics that quickly approach it.",
      "url": ""
    },
    {
      "title": "Improved Approximations for Translational Packing of Convex Polygons",
      "text": "Improved Approximations for Translational Packing\nof Convex Polygons\nAdam Kurpisz # \u00d1 \u001a\nBern University of Applied Sciences and Department of Mathematics, ETH Zurich, Switzerland\nSilvan Suter # \u001a\nDepartment of Mathematics, ETH Zurich, Switzerland\nAbstract\nOptimal packing of objects in containers is a critical problem in various real-life and industrial\napplications. This paper investigates the two-dimensional packing of convex polygons without\nrotations, where only translations are allowed. We study different settings depending on the type of\ncontainers used, including minimizing the number of containers or the size of the container based on\nan objective function.\nBuilding on prior research in the field, we develop polynomial-time algorithms with improved\napproximation guarantees upon the best-known results by Alt, de Berg and Knauer, as well as\nAamand, Abrahamsen, Beretta and Kleist, for problems such as Polygon Area Minimization, Polygon\nPerimeter Minimization, Polygon Strip Packing, and Polygon Bin Packing. Our approach utilizes a\nsequence of object transformations that allows sorting by height and orientation, thus enhancing\nthe effectiveness of shelf packing algorithms for polygon packing problems. In addition, we present\nefficient approximation algorithms for special cases of the Polygon Bin Packing problem, progressing\ntoward solving an open question concerning an O(1)-approximation algorithm for arbitrary polygons.\n2012 ACM Subject Classification Theory of computation \u2192 Packing and covering problems\nKeywords and phrases Approximation algorithms, Packing problems, Convex polygons, Bin packing,\nStrip packing, Area minimization\nRelated Version This is the full version of the same-named ESA 2023 paper. A link will be provided\nin a future version of this document.\narXiv:2308.08523v1 [cs.CG] 16 Aug 2023\n2 Improved Approximations for Translational Packing of Convex Polygons\n1 Introduction\nMany real-life situations require us to make decisions about optimally packing a collection\nof objects into a specific container. One particular category of these packing problems is\ntwo-dimensional packing, which is encountered in everyday scenarios like arranging items\non a shelf and in industrial applications such as cutting cookies from rolled-out dough\nor manufacturing sets of tiles from standard-sized panels made of wood, glass, or metal.\nAnother intriguing example involves cutting fabric pieces for clothing production. In this\ncase, the pieces often cannot be rotated freely, as they must adhere to a desired pattern\nin the final product, which is tailored of multiple elements. The widespread applicability\nof two-dimensional packing problems has led to a surge of interest in designing efficient\nalgorithms to address them. In this paper, we follow the line of research and study the\nproblem of packing convex polygons without rotations in various settings depending on the\ntype of containers used.\nPast research focusing on theoretical considerations of two-dimensional packings mainly\nconcentrates on the scenario when all objects are axis-parallel rectangles. In this paper, we\nwill discuss packing without rotations, in which only translations are permitted. There are\ntwo main classes of the problem depending on whether the size of the container is fixed and\nwe want to minimize the number of containers used or whether we want to minimize the\ncontainer\u2019s size with respect to some objective function.\nA seminal example of the first class is the Geometric Bin Packing problem in which\na number of unit size squared bins to pack is to be minimized. The problem is arguably\nthe most natural generalization of the regular (1D) Bin Packing to two dimensions, and\nits absolute approximability has been fully understood. Unless P = N P, the best possible\nefficient constant factor approximation is 2 [15], and such an algorithm is known [10].\nIn the second class, there are several variants to be considered. An example is the\nStrip Packing Problem which is concerned with packing objects into a strip of width\n1 and infinite height in such a way that the maximum of all the heights of the placed\nobjects is minimized. Like Geometric Bin Packing, Strip Packing generalizes (1D)\nBin Packing. The best known efficient constant factor approximation for Strip Packing\nhas approximation factor (5/3 + \u03f5) [9]. It is known that there can not exist a polynomial\ntime algorithm with an approximation ratio of (3/2 \u2212 \u03f5) for any \u03f5 > 0 unless P = N P, which\nfollows directly from the approximation hardness of (1D) Bin Packing. Both classes of\nproblems have been also considered in the asymptotic setting, see e.g. [11, 5, 12].\nIn younger time, there was also an increase of interest in cases where the objects in\nquestion are general convex polygons. Alt, de Berg and Knauer [2, 3] considered the problem\nof packing an instance consisting of a number of convex polygons of the form p \u2282 [0, 1]2into\na minimum area axis-parallel rectangular container. We refer to this problem as Polygon\nArea Minimization throughout this paper. In the special case where the instance consists\nof rectangles only, the problem is known to admit a PTAS [4]. They proved the existence of\nthe following efficient algorithm:\nA 23.78-approximation for Polygon Area Minimization.\nRecently, Aamand, Abrahamsen, Beretta and Kleist [1] showed that the algorithm of Alt,\nde Berg and Knauer can be leveraged to obtain also efficient approximation algorithms of\nfurther problems:\nA 7-approximation for Polygon Perimeter Minimization.\nA 51-approximation for Polygon Strip Packing.\nAn 11-approximation for Polygon Bin Packing for polygons with diameter at most 1\n10 .\nA. Kurpisz and S. Suter 3\n1.1 Our results\nThe results of Alt, de Berg and Knauer [2, 3] and Aamand et al. [1] are heavily based on\nso-called shelf packing algorithms. In shelf packing algorithms, the objects are first placed\non the shelves, possibly ordered by height, which are later stacked on one another to build\na final solution. Compared to axis-parallel rectangles, the main challenge in designing an\napproximation algorithm for polygon packing problems is that objects cannot be sorted by\nheight and orientation simultaneously. As a result, the algorithm and its analysis in [2, 3]\nhave such a large approximation guarantee. In this paper, we provide new insight into how\nshelf packing algorithms should be applied to polygon packing problems. We introduce a\nsequence of transformations of the objects that allow us first to sort them by height and later\nby orientation to build a solution of a much better approximation guarantee. More precisely,\nwe design polynomial-time algorithms with the following factors:\nA 9.45-approximation for Polygon Area Minimization.\nUsing this algorithm as a subroutine, we build upon the methods from Aamand et al. [1] to\nobtain the following efficient approximation algorithms:\nA (3.75 + \u03f5)-approximation for Polygon Perimeter Minimization.\nA 21.89-approximation for Polygon Strip Packing.\nA 5.09-approximation for Polygon Bin Packing for polygons which have their diameter\nbounded by 1\n10 .\nThe results are proved in Sections 4, 5, 6, and 7 respectively. Furthermore, in Section 8\nwe show the following results, which make progress towards solving an open question of a\nO(1)-approximation algorithm for Polygon Bin Packing for arbitrary polygons.\nThere is an efficient O(\n1\n\u03b4\n)-approximation algorithm for Polygon Bin Packing for\ninstances where each polygon has width or height at most 1 \u2212 \u03b4.\nThere is an efficient O(1)-approximation algorithm for Polygon Bin Packing for\ninstances with the property that all polygons share a spine (up to translation) with height\nat least 3\n4\n.\n2 Preliminaries\nWe start out considerations by recalling a classical and well-known problem in theoretical\ncomputer science, the Bin Packing problem: Given a list of numbers s1, . . . , sn \u2208 (0, 1] \u2229 Q,\nrepresenting the sizes of n objects, the goal is to find the minimum number of bins of size 1,\nso that we can pac...",
      "url": "https://export.arxiv.org/pdf/2308.08523v1.pdf"
    },
    {
      "title": "A General Heuristic Approach for Maximum Polygon Packing",
      "text": "A General Heuristic Approach for Maximum\nPolygon Packing\nCanhui Luo #\nHuazhong University of Science and Technology, Wuhan, China\nZhouxing Su1 #\nHuazhong University of Science and Technology, Wuhan, China\nZhipeng L\u00fc #\nHuazhong University of Science and Technology, Wuhan, China\nAbstract\nThis work proposes a general heuristic packing approach to address the Maximum Polygon Packing\nProblem introduced by the CG:SHOP 2024 Challenge. Our solver primarily consists of two steps:\n(1) Partitioning the container and polygons to form a series of small-scale subproblems; (2) For each\nsubproblem, sequentially placing polygons into the container and attempting to eliminate overlaps.\n2012 ACM Subject Classification Theory of computation \u2192 Computational geometry; Computing\nmethodologies \u2192 Search methodologies\nKeywords and phrases packing, polygon, heuristic, differential evolution, local search, tabu search\nDigital Object Identifier 10.4230/LIPIcs.SoCG.2024.86\nCategory CG Challenge\nFunding This work was supported in part by the National Natural Science Foundation of China\n(NSFC) under Grant 72101094 and the Special Project for Knowledge Innovation of Hubei Province\nunder Grant 2022013301015175.\nAcknowledgements We want to thank the organizers of CG:SHOP 2024 and all other participants\nfor creating such an engaging challenge. We also want to thank Dominik Krupke for providing a\nhelpful official validator for solutions.\n1 Introduction\nThe recent CG:SHOP 2024 Challenge introduced a variant of irregular packing problems\nknown as the Maximum Polygon Packing (MPP) problem. The MPP problem involves a\nconvex polygonal container C and a polygon set P = {p1, p2, ..., pN }, where polygon piis\nassociated with a value vi. It seeks for a non-overlapping packing with the maximum total\nvalue. The challenge presents a total of 180 instances whose number of polygons ranges from\n28 to 50,000. The official document [4] gives a detailed description of the challenge.\nOur proposed algorithm employs a general process to solve these instances indiscriminately,\nand the overall framework is presented in Figure 1. We first partition a large-scale problem\ninto multiple small-scale subproblems (Section 2) and then solve each subproblem using\nupper-level polygon ordering (Section 3.1) and lower-level packing optimization techniques\n(Section 3.2). Section 4 presents our experimental results, followed by conclusions.\n1 Corresponding author: Zhouxing Su\n\u00a9 Canhui Luo, Zhouxing Su, and Zhipeng L\u00fc;\nlicensed under Creative Commons License CC-BY 4.0\n40th International Symposium on Computational Geometry (SoCG 2024).\nEditors: Wolfgang Mulzer and Jeff M. Phillips; Article No. 86; pp. 86:1\u201386:9\nLeibniz International Proceedings in Informatics\nSchloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik, Dagstuhl Publishing, Germany\n86:2 A General Heuristic Approach for Maximum Polygon Packing\nInput polygon set P and container C\nUpper-level polygon ordering\nLower-level packing optimization\nFinished?\n \nPacking\nAssemble and return the complete solution\nMPP1 MPP2 MPPm\n( ) 0? Overlap Scurr== ( ) Update Sbest best\nReturn S\nPartitioning\nYes\nNo\nYes\nNo\nSelect next one\nFigure 1 The framework of our proposed algorithm.\n2 Partitioning\nIn this section, we present the decomposition of the original large-scale problem into a series\nof smaller MPP subproblems. It involves two components: partitioning the container C into\nmultiple regions and assigning polygons to each region.\n2.1 Container Partitioning\nThe container partitioning process consists of two steps, as shown in Figure 2. Initially, we\narrange two-dimensional square grids starting from the bottom-left corner of the bounding\nbox until the entire container is covered. The subregions formed by the intersection of the\ncontainer with all the grids constitute its partition C = C1 \u222a C2 \u222a ... \u222a Cm. Subsequently,\nwe merge the small subregions with adjacent grids, which are difficult to be used effectively.\nThe grid is dimensioned to keep the scale of each subproblem at approximately 300 polygons,\nmaking a trade-off between effectiveness and efficiency of lower-level packing optimization.\n2.2 Polygon Assignment\nWe adopt a simple approach of randomly assigning polygons to each subregion. Specifically, for\neach subregion Ci, we randomly select a polygon pj from P until\nP\nj\narea(pj )\narea(Ci) \u2265\nPN\ni=0\narea(pi)\narea(C)\n.\nThe advantage of random assignment lies in ensuring that the overall characteristics of each\nsubproblem align with the original problem.\nC. Luo, Z. Su, and Z. L\u00fc 86:3\nFigure 2 The partitioning process for the instance jigsaw_cf1_4fd4c46e. Step 1 (left): Cover the\ncontainer with squares; Step 2: Intersect and merge small regions (from the middle to the right).\nminimum translation\nminimum translation\nIFP\nContainer\nFigure 3 Examples of NFP between two polygons and IFP between container and polygon.\n3 Packing\n3.1 Upper-Level Polygon Ordering\nWe define a priority for each polygon. We repeatedly select one remaining polygon with the\nhighest priority (ties are broken by value) and try to insert it into the current solution. If the\ninsertion with lower-level packing optimization fails, we skip the current polygon and turn to\nthe next one. For the majority of instances, the priority is defined as the value-to-area ratio\nof a polygon (we also call it unit value). Polygons with higher unit values are prioritized\nfor putting in the container, which is called the Unit Value First (UVF) strategy. For\nsmall-scale instances (N < 100), we employ the \u03b1\u03b2-random strategy. It randomly selects\n\u03b1% and \u03b2% of the polygons and reassigns their UVF-based priority to the highest and the\nlowest, respectively. These instances are run for multiple times to ensure comprehensive\noptimization, with \u03b1 and \u03b2 set to 10 in our implementation.\n3.2 Lower-Level Packing Optimization\nThe position of a polygon can be represented by the coordinates l = (x, y) of a reference point,\nsuch as the bottom-left corner of the boundary. Then, the translation of a polygon can be\nrepresented by a vector pointing from its original position to its new position. Given a feasible\npacking S and a polygon p to be placed, it is impossible to find a non-overlapping position\nfor p without moving other polygons in most cases. This section introduces the algorithm for\neliminating overlaps for an invalid packing, which involves solving an unconstrained nonlinear\nproblem and heuristic polygon movement.\nS o C G 2 0 2 4\n86:4 A General Heuristic Approach for Maximum Polygon Packing\n3.2.1 Overlap Minimization\nTo determine the appropriate translation for the polygons, we utilized the no-fit polygon\n(NFP) and inner-fit polygon (IFP), which are fundamental in algorithmic approaches to\ngeometric design and optimization challenges. For a fixed polygon pi and a movable polygon\npj , NFP(pi, pj ) describes their non-overlapping positions with boundaries in contact precisely,\nwhich can be utilized to determine the minimum translation for pj to avoid overlap. Similarly,\nIFP(pi, pj ) is employed to determine the minimum translation to place pj inside pi. Figure 3\nillustrates the polygon translations determined using NFP (left) and IFP (right). The readers\nmay refer to Burke et al. [2] for a more detailed description.\nFor a packing S, based on NFP and IFP, we define the overlap between polygons pi\nand pj as fij (S), representing the minimum translation to separate them, and f0i(S) as the\nminimum translation for moving pi to fit into the container. Subsequently, we employ the\nseparation algorithm proposed by Imamichi et al. [7] to minimize the overlap, which involves\nsolving an unconstrained nonlinear programming problem as follows:\nmin\nS\nF(S) = X\n0\u2264i<j\u2264N\nf\n2\nij (S) (1)\nThe model relaxes the non-overlapping constraint but introduces repulsion forces between\nany two overlapped polygons. We use the classic L-BFGS (limited memory BFGS) method\nto solve this problem. It makes the packing S converge to a local optimum but strongly\ndepends on the initial layout. ...",
      "url": "https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.86/LIPIcs.SoCG.2024.86.pdf"
    },
    {
      "title": "Kaggle Santa 2025: Why \u201cReinforcement Learning\u201d is Failing",
      "text": "Kaggle Santa 2025: Why \u201cReinforcement Learning\u201d is Failing | by Himanshu Dhiman | Dec, 2025 | Medium\n[Sitemap](https://hmnshudhmn24.medium.com/sitemap/sitemap.xml)\n[Open in app](https://play.google.com/store/apps/details?id=com.medium.reader&amp;referrer=utm_source=mobileNavBar&amp;source=post_page---top_nav_layout_nav-----------------------------------------)\nSign up\n[Sign in](https://medium.com/m/signin?operation=login&amp;redirect=https://hmnshudhmn24.medium.com/kaggle-santa-2025-why-reinforcement-learning-is-failing-087f3f04fa97&amp;source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\n[Medium Logo](https://medium.com/?source=post_page---top_nav_layout_nav-----------------------------------------)\n[\nWrite\n](https://medium.com/m/signin?operation=register&amp;redirect=https://medium.com/new-story&amp;source=---top_nav_layout_nav-----------------------new_post_topnav------------------)\n[\nSearch\n](https://medium.com/search?source=post_page---top_nav_layout_nav-----------------------------------------)\nSign up\n[Sign in](https://medium.com/m/signin?operation=login&amp;redirect=https://hmnshudhmn24.medium.com/kaggle-santa-2025-why-reinforcement-learning-is-failing-087f3f04fa97&amp;source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\n![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)\n# Kaggle Santa 2025: Why \u201cReinforcement Learning\u201d is Failing\n[\n![Himanshu Dhiman](https://miro.medium.com/v2/resize:fill:64:64/1*3jyWFYIYAox5D7cqT7gIRA.jpeg)\n](https://hmnshudhmn24.medium.com/?source=post_page---byline--087f3f04fa97---------------------------------------)\n[Himanshu Dhiman](https://hmnshudhmn24.medium.com/?source=post_page---byline--087f3f04fa97---------------------------------------)\n3 min read\n\u00b7Dec 21, 2025\n[\n](https://medium.com/m/signin?actionUrl=https://medium.com/_/vote/p/087f3f04fa97&amp;operation=register&amp;redirect=https://hmnshudhmn24.medium.com/kaggle-santa-2025-why-reinforcement-learning-is-failing-087f3f04fa97&amp;user=Himanshu+Dhiman&amp;userId=288bb1baa8d2&amp;source=---header_actions--087f3f04fa97---------------------clap_footer------------------)\n--\n[](https://medium.com/m/signin?actionUrl=https://medium.com/_/bookmark/p/087f3f04fa97&amp;operation=register&amp;redirect=https://hmnshudhmn24.medium.com/kaggle-santa-2025-why-reinforcement-learning-is-failing-087f3f04fa97&amp;source=---header_actions--087f3f04fa97---------------------bookmark_footer------------------)\nListen\nShare\nPress enter or click to view image in full size\n![]()\nEvery December, Kaggle drops a \u201cSanta\u201d competition that ruins the holidays for thousands of data scientists. We expect a fun puzzle. We get a nightmare of Combinatorial Optimization.\nThis year\u2019s edition,**\u201cSanta 2025: The Christmas Tree Packing Challenge,\u201d**is no exception. The goal? Pack $N$ irregular \u201cTree Polygons\u201d into the smallest possible square bounding box for $N=1$ to $200$.\nIf you checked the leaderboard today (Dec 21), you noticed a trend:**Reinforcement Learning (RL) is getting crushed.**\nDespite the massive hype around \u201cReasoning Models\u201d and PPO agents this year, the top 100 teams aren\u2019t using neural networks. They are using 1980s physics simulations. Here is why the \u201cOld School\u201d is winning, and how the pros are using LLMs to cheat the system.\n## The Problem: Why RL Hates \u201cPacking\u201d\nOn paper, this looks like a game.*Place a tree, check for overlap, repeat.*Perfect for a DQN agent, right?\nWrong. The geometry kills the gradient.\n1. **Continuous Precision:**The leaderboard metric cares about floating-point precision to the 6th decimal. RL agents (which output discrete actions or probability distributions) struggle to make the \u201cmicro-adjustments\u201d needed to squeeze a tree into a 0.001mm gap.\n2. **The \u201cCollision\u201d Cliff:**In packing, a move is either valid (reward = 1) or it overlaps by a pixel (reward = -100). This sparse, binary feedback loop makes it nearly impossible for an agent to \u201clearn\u201d a gradient. It doesn\u2019t know*how*to fix the overlap, just that it failed.## The Solution: Simulated Annealing (on Steroids)\nThe \u201cSecret Sauce\u201d currently dominating the leaderboard is**Simulated Annealing (SA)**combined with**Lattice Generation**.\nInstead of training a model to*predict*the position, teams are writing physics engines that*shake*the box.\n* **High Temperature:**Randomly spin and throw trees into the box (Explorer Phase).\n* **Low Temperature:**Jiggle the trees by microscopic amounts to resolve collisions (Exploiter Phase).\nThe best solutions right now use a \u201cHybrid\u201d strategy:\n* **N &lt; 58:**Use Simulated Annealing to find unstructured, chaotic packings.\n* **N &gt; 58:**Switch to \u201cCrystalline Packing\u201d (regular geometric lattices) which is mathematically superior for large numbers.## The Twist: How LLMs are Actually Helping\nIf RL is dead, where is the AI?\nTop competitors aren\u2019t using LLMs to*solve*the puzzle; they are using LLMs to**write the solver**.\nPython is too slow for 10 billion annealing steps. The meta this year is to prompt Gemini 3 or Claude to:\n\u201cRewrite this Python overlap-check function in Rust/C++ with AVX2 vectorization.\u201d\nWe are seeing \u201cHybrid\u201d workflows where the**Human**defines the heuristics, the**LLM**writes the highly optimized C++ kernels, and**Simulated Annealing**does the heavy lifting.\n## The Starter Code: A Simple Annealer\nIf you want to jump in before the January deadline, don\u2019t start with PyTorch. Start here.\nHere is a conceptual snippet for a \u201cPerturbation\u201d mover \u2014the heart of any good annealing solution.\n```\nimport numpy as np\nimport math\ndef anneal(layout, max\\_temps=10000):\n# layout: Array of [x, y, rotation] for N trees\ncurrent\\_score = calculate\\_area(layout)\ntemperature = 1.0\ncooling\\_rate = 0.9995\nfor i in range(max\\_temps):\n# 1. Propose a Move (The &quot;Shake&quot;)\n# We only move ONE tree slightly to save compute\nidx = np.random.randint(0, len(layout))\noriginal\\_pos = layout[idx].copy()\n# Perturb: Move x/y by small amount, rotate slightly\nlayout[idx][0] += np.random.normal(0, temperature)\nlayout[idx][1] += np.random.normal(0, temperature)\nlayout[idx][2] += np.random.normal(0, temperature \\* 10) # Rotate\n# 2. Check Constraints (The &quot;Wall&quot;)\nif check\\_overlap(layout):\n# Revert immediately if invalid\nlayout[idx] = original\\_pos\ncontinue\n# 3. Acceptance Criteria (Metropolis-Hastings)\nnew\\_score = calculate\\_area(layout)\ndelta = new\\_score - current\\_score\n# If better, accept. If worse, accept with prob based on Temp.\nif delta &lt; 0 or math.exp(-delta / temperature) &gt; np.random.rand():\ncurrent\\_score = new\\_score\nelse:\nlayout[idx] = original\\_pos # Revert\n# Cool down\ntemperature \\*= cooling\\_rate\nreturn layout, current\\_score\n# Pro Tip: Ask an LLM to convert &#x27;&#x27;check\\_overlap&#x27;&#x27; to Cython for 100x speed.\n```\nThe competition ends**January 30, 2026**. You have 40 days. Put down the Neural Network and pick up a physics textbook.\n*(****Discussion:****Are you using a Lattice approach or pure Annealing for N=200? Let\u2019s discuss strategy in the comments!)*\n[\n![Himanshu Dhiman](https://miro.medium.com/v2/resize:fill:96:96/1*3jyWFYIYAox5D7cqT7gIRA.jpeg)\n](https://hmnshudhmn24.medium.com/?source=post_page---post_author_info--087f3f04fa97---------------------------------------)\n[\n![Himanshu Dhiman](https://miro.medium.com/v2/resize:fill:128:128/1*3jyWFYIYAox5D7cqT7gIRA.jpeg)\n](https://hmnshudhmn24.medium.com/?source=post_page---post_author_info--087f3f04fa97---------------------------------------)\n[## Written byHimanshu Dhiman\n](https://hmnshudhmn24.medium.com/?source=post_page---post_author_info--087f3f04fa97---------------------------------------)\n[20 followers](https://hmnshudhmn24.medium.com/followers?source=post_page---post_author_info--087f3f04fa97---------------------------------------)\n\u00b7[0 following](https://hmnshudhmn24.medium.com/following?source=post_page---post_author_info--087f3f04fa97---------------------------------------)\nJust another human t...",
      "url": "https://hmnshudhmn24.medium.com/kaggle-santa-2025-why-reinforcement-learning-is-failing-087f3f04fa97"
    },
    {
      "title": "",
      "text": "Shadoks Approach to Knapsack Polygonal Packing\nGuilherme D. da Fonseca #\nLIS, Aix-Marseille Universit\u00e9, France\nYan Gerard #\nLIMOS, University Clermont Auvergne, Aubi\u00e8re, France\nAbstract\nWe describe the heuristics used by the Shadoks team in the CG:SHOP 2024 Challenge. Each instance\nconsists of a convex polygon called container and a multiset of items, where each item is a simple\npolygon and has an associated value. The goal is to pack some of the items inside the container\nusing translations, in order to maximize the sum of their values. Our strategy consists of obtaining\ngood initial solutions and improving them with local search. To obtain the initial solutions we used\ninteger programming and a carefully designed greedy approach.\n2012 ACM Subject Classification Theory of computation \u2192 Computational geometry\nKeywords and phrases Packing, polygons, heuristics, integer programming, computational geometry\nDigital Object Identifier 10.4230/LIPIcs.SoCG.2024.84\nCategory CG Challenge\nRelated Version Full Version: https://arxiv.org/abs/2403.20123\nSupplementary Material\nSoftware (Source Code): https://github.com/gfonsecabr/shadoks-CGSHOP2024\narchived at swh:1:dir:96fb9ad50c0c1307c7aef78560655cfcfabb24a6\nFunding Work supported by the French ANR PRC grant ADDS (ANR-19-CE48-0005).\nAcknowledgements We would like to thank the Challenge organizers and other competitors for their\ntime, feedback, and making this whole event possible. We would like to thank H\u00e9l\u00e8ne Toussaint,\nRapha\u00ebl Amato, Boris Lonjon, and William Guyot-L\u00e9nat from LIMOS, as well as the Qarma and\nTALEP teams and Manuel Bertrand from LIS, who continue to make the computational resources of\nthe LIMOS and LIS clusters available to our research. We would also like to thank Aldo Gonzalez\u0002Lorenzo and the undergraduate students Aymeric Beck, Houssam Boufarachan, Marine Izoulet, and\nCarla Scardigli for coding viewers for the solutions.\nFigure 1 Our best solutions to jigsaw_cf2_5db5d75a_34, random_rcf4_6e323d40_100,\natris1240, and satris1786 instances.\n\u00a9 Guilherme D. da Fonseca and Yan Gerard;\nlicensed under Creative Commons License CC-BY 4.0\n40th International Symposium on Computational Geometry (SoCG 2024).\nEditors: Wolfgang Mulzer and Jeff M. Phillips; Article No. 84; pp. 84:1\u201384:9\nLeibniz International Proceedings in Informatics\nSchloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik, Dagstuhl Publishing, Germany\n84:2 Shadoks Approach to Knapsack Polygonal Packing\n1 Introduction\nCG:SHOP Challenge is an annual geometric optimization challenge. The sixth edition in\n2024 considers a 2-dimensional knapsack packing problem. The team Shadoks won first place\nwith the best solution (among the 14 participating teams) to 75 instances out of 180. In this\npaper, we describe the heuristics we used. We start by briefly describing the problem.\nAn input instance consists of a convex polygon called container and a multiset of items.\nEach item is a simple polygon with an associated integer value. The goal is to pack some of\nthe instance items inside the container using integer translations in order to maximize the\nsum of their values. In total, 180 instances have been given, ranging from 28 to 50,000 items.\nThe instances are of several different types according to the shape and values of the items.\nSome instances have mostly convex items, while other instances have many non-convex items\nsuch as polyominoes. In terms of item values, some items have only unit value, some have\nvalues proportional to the area, and other have random values, for example. Some solutions\nare presented in Figure 1 and more details about the challenge are available in the organizers\u2019\nsurvey paper [3].\nOur general strategy consists of finding a good initial solution (using integer programming\nor a greedy heuristic) and subsequently optimizing them with local search. Our strategy\nshares many common elements with the second place [5], but they did not use integer\nprogramming to obtain initial solutions and their optimization phase is more sophisticated\nthan ours. The third place [4] uses an hierarchical grid approach. The fourth place [1] used\na completely different integer programming model and a genetic algorithm.\nWe describe the algorithms in Section 2 and experimentally analyze their performance\nusing different parameters in Section 3. Our solvers were coded in Python and C++ and\nexecuted on several desktop laptop computers, as well as the LIMOS and LIS clusters.\n2 Algorithms\nWe used two different algorithms to compute initial solutions, a preprocessing phase that\ncan be executed beforehand, and a local search phase to improve the solutions.\n2.1 Integer Programming Approach\nA simple idea to solve the challenge problem is to produce a set V of random translations of\neach item inside the container and then reduce the problem to a kind of maximum weight\nindependent set problem in a graph G = (V, E). Each translated item is a vertex and there\nare two types of edges: (1) an edge between two translations that overlap and (2) translations\nof the same item i form a clique Ci. If all item have quantity one, then this is a traditional\nmaximum weight independent set problem. However, if items have non-unit quantities, then\neach clique Ciis associated with the quantity qi of item i and at most qi vertices of the\nclique are allowed in the solution.\nThis combinatorial problem can easily be modeled as integer programming with one\nbinary variable per vertex. A type-1 edge uv is modeled as u + v \u2264 1 and each clique Ci\nis modeled as P\nv\u2208Ci\nv \u2264 qi. The CPLEX solver [2] can optimally solve graphs with a few\nthousand vertices obtained from the challenge instances, which is not enough to obtain good\nsolutions using uniformly random placements.\nTo obtain better solutions, we start from a solutions S obtained with the aforementioned\nmethod and build a new graph G = (V, E) as follows. Let \u03c3 > 0 be a parameter and N be a\nset of the zero vector and random vectors where each random vector has x and y coordinates\nG. D. da Fonseca and Y. Gerard 84:3\nas Gaussian random variables of average 0 and standard deviation \u03c3. We create a translation\nin V for each item that is placed in S and for each translation vector in N if the translation\nis inside the container. We also create vertices in V using uniform random translations for\nall items. Edges and cliques are created as before, and the new combinatorial problem is\nsolved with CPLEX. We repeat this procedure multiple times using the previous solution S\nand reducing the value of \u03c3 at each step.\nThis method works well for instances with up to 200 items. To handle larger instances,\nwe partition the container using a square grid and partition the items equally among the\ncells. The partition is such that items are grouped by the slope of the longest edge, breaking\nties by the slope of the diameter. Each cell is then solved independently. The intuition to\ngroup items of similar slope together is that they can often be placed in a way that minimizes\nthe wasted space. Since the values of the items do not seem to be related to the slopes, this\napproach works well for the challenge instances.\n2.2 Greedy Heuristic\nThe greedy heuristic starts by creating an initial list L of n grid points inside the container\n(typically n = 1000). The list L is shuffled and we compute its centroid c rounded to integer\ncoordinates. The point c is inserted in the beginning of L. The input items are placed into a\nlist I ordered by decreasing utility, where the utility function is described next. Different\nutility functions may be used (more details in Section 3). The goal is that items of small\narea and high value have high utility while large items with small value have low utility.\nWe then build the packing by considering the items of the list I one by one in order. At\neach step, we have a current packing and a new item i to pack. We first try to pack i at\nthe first grid position g \u2208 L and at a number of random positions around g. If one of these\npositions is availa...",
      "url": "https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.84/LIPIcs.SoCG.2024.84.pdf"
    },
    {
      "title": "",
      "text": "Optimal Rectangle Packing: New Results\nRichard E. Korf\nComputer Science Department\nUniversity of California, Los Angeles\nLos Angeles, CA 90095\nkorf@cs.ucla.edu\nAbstract\nWe present new results on the problem of finding an enclos\u0002ing rectangle of minimum area that will contain a given a set\nof rectangles. Many simple scheduling tasks can be mod\u0002elled by this NP-complete problem. We present a new lower\nbound on the amount of wasted space in a partial solution, a\nnew dominance condition that prunes many partial solutions,\nand extend our algorithms to packing unoriented rectangles.\nFor our experiments, we consider the set of squares of size\n1x1, 2x2,...,NxN, and find the smallest rectangle that can con\u0002tain them for a given value of N. While previously we solved\nthis problem up to N=22, we extend this to N=25. Overall,\nour new program is over an order of magnitude faster than\nour previous program running on the same machine. We also\nshow that for the larger problems, our optimal algorithm is\nfaster than one that finds the best slicing solution, a popular\napproximation algorithm. In addition, we solve an open prob\u0002lem dating to 1966, concerning packing the set of consecutive\nsquares up to 24x24 in a square of size 70x70.\nIntroduction\nAn Open Square-Packing Problem\nIf we take a 1x1 square, a 2x2 square, etc. up to a 24x24\nsquare, the sum of the areas of these squares is 4900, which\nis 702. This is the only nontrivial sum of consecutive\nsquares starting with one which is a perfect square(Wat\u0002son 1918). (Bitner & Reingold 1975) showed by a com\u0002puter search that these 24 squares cannot all be packed into\na 70x70 square with no overlap. In his Sept. 1966 Scien\u0002tific American Mathematical Games column (Gardner 1966;\n1975), Martin Gardner asked his readers what is the largest\narea of the 70x70 square that can be covered by these\nsquares, a problem he attributes to Richard B. Britton.\nTwenty-seven readers sent in very similar solutions that left\n49 square units uncovered, leaving out the 7x7 square. We\nshow here for the first time that this is the best one can do.\nRectangle Packing\nConsider the following simple scheduling problem: We have\na set of independent and indivisible jobs, each requiring a\ncertain number of workers for a certain time. All workers\nCopyright \rc 2004, American Association for Artificial Intelli\u0002gence (www.aaai.org). All rights reserved.\nwork the same hours, and are paid for the total time, whether\nthey are busy or idle. We can adjust the number of workers,\nand the total time, to minimize the total labor cost, which\nis proportional to the product of the number of workers and\nthe total time. Alternatively, we may want to complete all\njobs as quickly as possible, using as many workers as nec\u0002essary, or minimize the number of workers, taking as much\ntime as needed. A closely-related problem is scheduling a\nset of tasks that require a certain resource, such as electric\npower on a spacecraft, for a given amount of time, so that all\ntasks are completed as soon as possible without exceeding\nthe maximum resource capacity.\nWe can model these problems as rectangle-packing prob\u0002lems. Each job is represented by a rectangle, whose height is\nthe amount of resource needed, and whose width is the time\nrequired. The total amount of resource is the height of an en\u0002closing rectangle, and the total time is the width. All the job\nrectangles must be packed into the enclosing rectangle, with\nno overlap. To minimize the total cost, we want an enclosing\nrectangle of minimum area. To minimize the amount of re\u0002source, we want an enclosing rectangle of minimum width,\nwhose height is the maximum amount of resource needed\nfor any job. Similarly, to minimize the time, we want an\nenclosing rectangle of minimum height, whose width is the\ntime needed for the longest job.\nIn practice there may be other considerations, such as\nprecedence constraints between jobs. These can be added to\nour solution algorithm, pruning partial solutions that don\u2019t\nsatisfy the constraints. This will make it easier to determine\nthat a particular enclosing rectangle can\u2019t contain all the job\nrectangles, but more difficult to find a feasible solution with\na particular enclosing rectangle. For simplicity, we consider\nthe unconstrained case here.\nRectangle packing has other applications as well. One\nis loading a set of rectangular objects onto a cargo pallet,\nwithout stacking objects. In the design of VLSI chips, cir\u0002cuit blocks must be assigned to physical regions of the chip.\nAnother application is cutting a set of rectangles out of a\nrectangular piece of stock material.\nIn scheduling, the orientation of job rectangles is fixed,\nsince resources and time are rarely interchangeable. In VLSI\ndesign, however, we can usually rotate the rectangles ninety\ndegrees. Cargo-loading also involves unoriented rectangles,\nwhile in cutting-stock problems the rectangles may be ori\u0002142 ICAPS 2004 \nFrom: ICAPS-04 Proceedings. Copyright \u00a9 2004, AAAI (www.aaai.org). All rights reserved. \nented or unoriented. We consider both cases here.\nRelated Work\nMost work on rectangle packing deals with approximate\nrather than optimal solutions. Our previous paper on this\nsubject (Korf 2003) represents the current state of the art,\nand contains comparisons to prior work. We showed that\noptimal rectangle-packing is NP-complete. We also intro\u0002duced the benchmark of finding the enclosing rectangle of\nsmallest area that will contain the 1x1, 2x2,...,NxN square,\nand solved the problem for N up to 22.\nOverview\nWe first consider packing a set of rectangles into a fixed en\u0002closing rectangle, and then describe how to search the space\nof enclosing rectangles for one of minimum area. We then\nconsider slicing solutions, a popular approximation method.\nWe describe our experimental results, and present further\nwork and conclusions. This paper repeats some of the mate\u0002rial from (Korf 2003), in order to make it self-contained.\nThe three main contributions of this paper are a new lower\nbound on the space wasted in any partial solution, an ad\u0002ditional dominance condition that allows us to prune more\npartial solutions, and the extension to unoriented rectangles.\nWe extend the set of problems we can solve optimally from\nN=22 to N=25, and solve the open problem proposed by\nGardner. Our new program is over an order of magnitude\nfaster than our previous program. It is also faster than our\nprogram for finding slicing solutions, which is only an ap\u0002proximation algorithm.\nAll our experiments involve packing squares, which pro\u0002vides an infinite number of increasingly difficult problem in\u0002stances, each characterized by a single parameter. However,\nour techniques are applicable to the more general rectangle\u0002packing problem as well. Where we take advantage of the\nsymmetry of squares, we also explain the generalization to\nrectangles. We also explain some additional details omitted\nfrom our previous paper, and correct several errors.\nRectangle Packing as a Binary CSP\nFirst we consider the problem of given a fixed enclosing\nrectangle, can we pack a given set of oriented rectangles into\nit? The enclosing rectangle must be at least as wide as the\nmaximum width of any rectangle, and at least as tall as the\nmaximum height of any rectangle. Furthermore, the area of\nthe enclosing rectangle must equal or exceed the sum of the\nareas of the given rectangles.\nThis can be modelled as a binary constraint-satisfaction\nproblem. There is a variable for each rectangle, whose legal\nvalues are the positions it could occupy without exceeding\nthe boundaries of the enclosing rectangle. There is a binary\nconstraint between each pair of rectangles that they cannot\noverlap. This suggests a backtracking algorithm.\nWe place the rectangles in decreasing order of size, in\norder to avoid rearranging smaller rectangles if there is no\nlegal position for the largest unplaced rectangle. We can\ndefine the size of a rectangle by its area, or its maximum di\u0002mension. The latter definition may be better...",
      "url": "https://cdn.aaai.org/ICAPS/2004/ICAPS04-019.pdf"
    },
    {
      "title": "Search code, repositories, users, issues, pull requests...",
      "text": "GitHub - adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-: In this re-defined optimization problem, help Santa fit Christmas tree toys into the smallest (2-dimension) parcel size possible so that he can efficiently mail these stocking stuffers around the globe. Santa needs the dimensions of the smallest possible square box that fits shipments of between 1-200 trees.\n[Skip to content](#start-of-content)\n## Navigation Menu\nToggle navigation\n[](https://github.com/)\n[Sign in](https://github.com/login?return_to=https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\nAppearance settings\nSearch or jump to...\n# Search code, repositories, users, issues, pull requests...\n</option></form>\nSearch\nClear\n[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)\n# Provide feedback\n</option></form>\nWe read every piece of feedback, and take your input very seriously.\nInclude my email address so I can be contacted\nCancelSubmit feedback\n# Saved searches\n## Use saved searches to filter your results more quickly\n</option></form>\nName\nQuery\nTo see all available qualifiers, see our[documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).\nCancelCreate saved search\n[Sign in](https://github.com/login?return_to=https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\n[Sign up](https://github.com/signup?ref_cta=Sign+up&amp;ref_loc=header+logged+out&amp;ref_page=/%3Cuser-name%3E/%3Crepo-name%3E&amp;source=header-repo&amp;source_repo=adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\nAppearance settings\nResetting focus\nYou signed in with another tab or window.[Reload]()to refresh your session.You signed out in another tab or window.[Reload]()to refresh your session.You switched accounts on another tab or window.[Reload]()to refresh your session.Dismiss alert\n{{ message }}\n[adityapawar327](https://github.com/adityapawar327)/**[Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)**Public\n* [Notifications](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)You must be signed in to change notification settings\n* [Fork1](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\n* [Star2](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\nIn this re-defined optimization problem, help Santa fit Christmas tree toys into the smallest (2-dimension) parcel size possible so that he can efficiently mail these stocking stuffers around the globe. Santa needs the dimensions of the smallest possible square box that fits shipments of between 1-200 trees.\n[www.kaggle.com/code/adityapawar327/santa-2025-christmas-tree-packing-challenge-v1](https://www.kaggle.com/code/adityapawar327/santa-2025-christmas-tree-packing-challenge-v1)\n[2stars](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/stargazers)[1fork](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/forks)[Branches](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/branches)[Tags](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/tags)[Activity](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/activity)\n[Star](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\n[Notifications](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)You must be signed in to change notification settings\n# adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-\nmain\n[Branches](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/branches)[Tags](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/tags)\n[](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/branches)[](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/tags)\nGo to file\nCode\nOpen more actions menu\n## Folders and files\n|Name|Name|\nLast commit message\n|\nLast commit date\n|\n## Latest commit\n## History\n[2 Commits](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/commits/main/)\n[](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/commits/main/)\n|\n[README.md](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/blob/main/README.md)\n|\n[README.md](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/blob/main/README.md)\n|\n|\n|\n[santa-2025-christmas-tree-packing-challenge-v1.ipynb](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/blob/main/santa-2025-christmas-tree-packing-challenge-v1.ipynb)\n|\n[santa-2025-christmas-tree-packing-challenge-v1.ipynb](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/blob/main/santa-2025-christmas-tree-packing-challenge-v1.ipynb)\n|\n|\n|\nView all files\n|\n## Repository files navigation\n# Santa 2025 - Christmas Tree Packing Challenge V1\n[](#santa-2025---christmas-tree-packing-challenge-v1)\nThis repository contains my approach for the[Santa 2025 - Christmas Tree Packing Challenge](https://www.kaggle.com/competitions/santa-2025)on Kaggle.\n## Overview\n[](#overview)\nThe objective of this challenge is to optimally pack rotatable Christmas trees (polygonal shapes) into the smallest possible square, minimizing the bounding box area for each value of N (number of trees from 1 to 200). The final solution is evaluated by an ensemble score that combines all cases.\n**Notebook Link**:[Santa 2025 - Christmas Tree Packing Challenge V1](https://www.kaggle.com/code/adityapawar327/santa-2025-christmas-tree-packing-challenge-v1)\n**Public Score**: 85.92\n## Table of Contents\n[](#table-of-contents)\n* Library Imports and Environment Setup\n* Global Configuration and Precision Settings\n* ChristmasTree Class Definition\n* Utility Functions (Scoring/Collision)\n* Simulated Annealing Algorithm (N &lt; 20)\n* Grid Search Algorithm (N &gt;= 20)\n* Hybrid &amp; Ensemble Solvers\n* Main Computation Loop (N = 1 to 200)\n* Submission Formatting and Export\n## Methodology\n[](#methodology)\n* **Small N (&lt; 20):**Uses Simulated Annealing for efficient search in small configuration spaces.\n* **Large N (&gt;= 20):**Uses a tailored Grid Search for tractable solution space exploration.\n* **Hybrid/Ensemble:**Runs multiple seeds and chooses the best solution for each N.\n* **Collision Detection:**Employs Shapely geometry operations to prevent tree overlap.\n* **Performance:**Code leverages parallelization (`ProcessPoolExecutor`) and high-precision (Decimal) arithmetic.\n## Usage\n[](#usage)\n1. Install dependencies:\n* `shapely`,`numpy`,`pandas`,`matplotlib`,`tqdm`\n* Run the notebook or script sequentially to output results and save a`submission.csv`.\n* Check the score on important N cases (e.g., 1, 10, 25, 50, 100, 150, 200).\n## Output\n[](#output)\n* The notebook prints key logs during computation.\n* A`submission.csv`is generated with columns:`id`,`x`,`y`,`deg`(example row:`001\\_0, s-9.146226, s-0.12832, s-224.999647`).\n## License\n[](#license)\nThis project is released under the[Apache 2.0 License](http://www.apache.org/licenses/LICENSE-2.0).\n## Author\n[](#author)\nAditya Pawar ([Kaggle Profile](https://www.kaggle.com/adityapawar327))\nFor questions or collaboration, feel free to reach out via Kaggle discussions or connect on[LinkedIn](https://www.linkedin.com/in/adityapawar327).\n## About\nIn this re-defined optimization problem, help Santa fit Christmas tree toys into the smallest (2-dimension) parcel size possible so that ...",
      "url": "https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-"
    },
    {
      "title": "Search code, repositories, users, issues, pull requests...",
      "text": "Kaggle/Packing\\_Santas\\_Sleigh/Resources/Not useful/An Efficient Algorithm for 3D Rectangular Box Packing.pdf at master \u00b7charlesjlee/Kaggle \u00b7GitHub\n[Skip to content](#start-of-content)\n## Navigation Menu\nToggle navigation\n[](https://github.com/)\n[Sign in](https://github.com/login?return_to=https://github.com/charlesjlee/Kaggle/blob/master/Packing_Santas_Sleigh/Resources/Not%20useful/An%20Efficient%20Algorithm%20for%203D%20Rectangular%20Box%20Packing.pdf)\nAppearance settings\nSearch or jump to...\n# Search code, repositories, users, issues, pull requests...\n</option></form>\nSearch\nClear\n[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)\n# Provide feedback\n</option></form>\nWe read every piece of feedback, and take your input very seriously.\nInclude my email address so I can be contacted\nCancelSubmit feedback\n# Saved searches\n## Use saved searches to filter your results more quickly\n</option></form>\nName\nQuery\nTo see all available qualifiers, see our[documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).\nCancelCreate saved search\n[Sign in](https://github.com/login?return_to=https://github.com/charlesjlee/Kaggle/blob/master/Packing_Santas_Sleigh/Resources/Not%20useful/An%20Efficient%20Algorithm%20for%203D%20Rectangular%20Box%20Packing.pdf)\n[Sign up](https://github.com/signup?ref_cta=Sign+up&amp;ref_loc=header+logged+out&amp;ref_page=/%3Cuser-name%3E/%3Crepo-name%3E/blob/show&amp;source=header-repo&amp;source_repo=charlesjlee/Kaggle)\nAppearance settings\nResetting focus\nYou signed in with another tab or window.[Reload]()to refresh your session.You signed out in another tab or window.[Reload]()to refresh your session.You switched accounts on another tab or window.[Reload]()to refresh your session.Dismiss alert\n{{ message }}\nThis repository was archived by the owner on May 2, 2020. It is now read-only.\n[charlesjlee](https://github.com/charlesjlee)/**[Kaggle](https://github.com/charlesjlee/Kaggle)**Public archive\n* [Notifications](https://github.com/login?return_to=/charlesjlee/Kaggle)You must be signed in to change notification settings\n* [Fork0](https://github.com/login?return_to=/charlesjlee/Kaggle)\n* [Star8](https://github.com/login?return_to=/charlesjlee/Kaggle)\n</turbo-frame></main>\nYou can\u2019t perform that action at this time.\n</div>",
      "url": "https://github.com/charlesjlee/Kaggle/blob/master/Packing_Santas_Sleigh/Resources/Not%20useful/An%20Efficient%20Algorithm%20for%203D%20Rectangular%20Box%20Packing.pdf"
    },
    {
      "title": "Circle packing",
      "text": "Circle packing - Wikipedia\n[Jump to content](#bodyContent)\n[![](https://en.wikipedia.org/static/images/icons/wikipedia.png)![Wikipedia](https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg)![The Free Encyclopedia](https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg)](https://en.wikipedia.org/wiki/Main_Page)\n[Search](https://en.wikipedia.org/wiki/Special:Search)\nSearch\n# Circle packing\n8 languages\n* [Deutsch](https://de.wikipedia.org/wiki/Kreispackung)\n* [Espa\u00f1ol](https://es.wikipedia.org/wiki/Empaquetamiento_de_c\u00edrculos)\n* [Fran\u00e7ais](https://fr.wikipedia.org/wiki/Empilement_de_cercles)\n* [\ud55c\uad6d\uc5b4](https://ko.wikipedia.org/wiki/\uc6d0_\ucc44\uc6b0\uae30)\n* [Norsk bokm\u00e5l](https://no.wikipedia.org/wiki/Sirkelpakking)\n* [Portugu\u00eas](https://pt.wikipedia.org/wiki/Empacotamento_de_c\u00edrculos)\n* [Rom\u00e2n\u0103](https://ro.wikipedia.org/wiki/\u00cempachetarea_cercurilor)\n* [\u0420\u0443\u0441\u0441\u043a\u0438\u0439](https://ru.wikipedia.org/wiki/\u0423\u043f\u0430\u043a\u043e\u0432\u043a\u0430_\u043a\u0440\u0443\u0433\u043e\u0432)\n[Edit links](https://www.wikidata.org/wiki/Special:EntityPage/Q5121501#sitelinks-wikipedia)\nFrom Wikipedia, the free encyclopedia\nField of geometry closely arranging circles on a plane\nThis article is about the packing of circles on surfaces. For circle packing with a prescribed[intersection graph](https://en.wikipedia.org/wiki/Intersection_graph), see[Circle packing theorem](https://en.wikipedia.org/wiki/Circle_packing_theorem).\n[![](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Citrus_fruits.jpg/250px-Citrus_fruits.jpg)](https://en.wikipedia.org/wiki/File:Citrus_fruits.jpg)The most efficient way to pack different-sized circles together is not obvious.\nIn[geometry](https://en.wikipedia.org/wiki/Geometry),**circle packing**is the study of the arrangement of circles (of equal or varying sizes) on a given surface such that no overlapping occurs and so that no circle can be enlarged without creating an overlap. The associated*[packing density](https://en.wikipedia.org/wiki/Packing_density)*,\u03b7, of an arrangement is the proportion of the surface covered by the circles. Generalisations can be made to higher dimensions &#8211; this is called*[sphere packing](https://en.wikipedia.org/wiki/Sphere_packing)*, which usually deals only with identical spheres.\nThe branch of mathematics generally known as \"circle packing\" is concerned with the geometry and combinatorics of packings of arbitrarily-sized circles: these give rise to discrete analogs of[conformal mapping](https://en.wikipedia.org/wiki/Conformal_mapping),[Riemann surfaces](https://en.wikipedia.org/wiki/Riemann_surfaces)and the like.\n## Densest packing\n[[edit](https://en.wikipedia.org/w/index.php?title=Circle_packing&amp;action=edit&amp;section=1)]\n[![](https://upload.wikimedia.org/wikipedia/commons/thumb/6/69/Circle_packing_%28hexagonal%29.svg/250px-Circle_packing_%28hexagonal%29.svg.png)](https://en.wikipedia.org/wiki/File:Circle_packing_(hexagonal).svg)Identical circles in a*hexagonal packing*arrangement, the densest packing possible[![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fc/Order_and_Chaos.tif/lossy-page1-250px-Order_and_Chaos.tif.jpg)](https://en.wikipedia.org/wiki/File:Order_and_Chaos.tif)Hexagonal packing through natural arrangement of equal circles with transitions to an irregular arrangement of unequal circles\nIn the two-dimensional[Euclidean plane](https://en.wikipedia.org/wiki/Euclidean_plane),[Joseph Louis Lagrange](https://en.wikipedia.org/wiki/Joseph_Louis_Lagrange)proved in 1773 that the highest-density lattice packing of circles is the[hexagonal](https://en.wikipedia.org/wiki/Hexagon)packing arrangement,[&#91;1&#93;](#cite_note-ChangWang-1)in which the centres of the circles are arranged in a[hexagonal lattice](https://en.wikipedia.org/wiki/Hexagonal_lattice)(staggered rows, like a[honeycomb](https://en.wikipedia.org/wiki/Honeycomb)), and each circle is surrounded by six other circles. For circles of diameterDand hexagons of side lengthD, the hexagon area and the circle area are, respectively:\nAH=332D2AC=&#x03C0;4D2{\\\\displaystyle {\\\\begin{aligned}A\\_{\\\\mathrm {H} }&amp;&amp;={\\\\frac {3{\\\\sqrt {3}}}{2}}D^{2}\\\\\\\\[4pt]A\\_{\\\\mathrm {C} }&amp;&amp;={\\\\frac {\\\\pi }{4}}D^{2}\\\\end{aligned}}}![{\\displaystyle {\\begin{aligned}A_{\\mathrm {H} }&amp;={\\frac {3{\\sqrt {3}}}{2}}D^{2}\\\\[4pt]A_{\\mathrm {C} }&amp;={\\frac {\\pi }{4}}D^{2}\\end{aligned}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/28cb2f36b873aa2e71ce641d35b0f85647bb2cf4)\nThe area covered within each hexagon by circles is:\nAHC=3AC=3&#x03C0;4D2{\\\\displaystyle A\\_{\\\\mathrm {HC} }=3A\\_{\\\\mathrm {C} }={\\\\frac {3\\\\pi }{4}}D^{2}}![{\\displaystyle A_{\\mathrm {HC} }=3A_{\\mathrm {C} }={\\frac {3\\pi }{4}}D^{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/4eca3b23624f001abe7d43bd66928bb983c73566)\nFinally, the packing density is:\n&#x03B7;=AHCAH=3&#x03C0;4D2332D2=&#x03C0;23&#x2248;0.9069{\\\\displaystyle {\\\\begin{aligned}\\\\eta ={\\\\frac {A\\_{\\\\mathrm {HC} }}{A\\_{\\\\mathrm {H} }}}&amp;&amp;={\\\\frac {{\\\\frac {3\\\\pi }{4}}D^{2}}{{\\\\frac {3{\\\\sqrt {3}}}{2}}D^{2}}}\\\\\\\\[4pt]&amp;&amp;={\\\\frac {\\\\pi }{2{\\\\sqrt {3}}}}\\\\approx 0.9069\\\\end{aligned}}}![{\\displaystyle {\\begin{aligned}\\eta ={\\frac {A_{\\mathrm {HC} }}{A_{\\mathrm {H} }}}&amp;={\\frac {{\\frac {3\\pi }{4}}D^{2}}{{\\frac {3{\\sqrt {3}}}{2}}D^{2}}}\\\\[4pt]&amp;={\\frac {\\pi }{2{\\sqrt {3}}}}\\approx 0.9069\\end{aligned}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0ce7969e21bb1fa83cd9c7f81fa9eca8fa096e38)\nIn 1890,[Axel Thue](https://en.wikipedia.org/wiki/Axel_Thue)published a proof that this same density is optimal among all packings, not just lattice packings, but his proof was considered by some to be incomplete. The first rigorous proof is attributed to[L\u00e1szl\u00f3 Fejes T\u00f3th](https://en.wikipedia.org/wiki/L%C3%A1szl%C3%B3_Fejes_T%C3%B3th)in 1942.[&#91;1&#93;](#cite_note-ChangWang-1)[&#91;2&#93;](#cite_note-Toth-2)\nWhile the circle has a relatively low maximum packing density, it does not have the lowest possible, even among[centrally-symmetric](https://en.wikipedia.org/wiki/Centrally_symmetric)[convex shapes](https://en.wikipedia.org/wiki/Convex_shape): the[smoothed octagon](https://en.wikipedia.org/wiki/Smoothed_octagon)has a packing density of about 0.902414, the smallest known for centrally-symmetric convex shapes and conjectured to be the smallest possible.[&#91;3&#93;](#cite_note-3)(Packing densities of concave shapes such as[star polygons](https://en.wikipedia.org/wiki/Star_polygon)can be arbitrarily small.)[&#91;4&#93;](#cite_note-4)\n## Other packings\n[[edit](https://en.wikipedia.org/w/index.php?title=Circle_packing&amp;action=edit&amp;section=2)]\nAt the other extreme, B\u00f6r\u00f6czky demonstrated that arbitrarily low density arrangements of rigidly packed circles exist.[&#91;5&#93;](#cite_note-5)[&#91;6&#93;](#cite_note-6)\nThere are eleven circle packings based on the eleven[uniform tilings](https://en.wikipedia.org/wiki/Uniform_tiling#Uniform_tilings_of_the_Euclidean_plane)of the plane.[&#91;7&#93;](#cite_note-7)In these packings, every circle can be mapped to every other circle by reflections and rotations. The[hexagonal](https://en.wikipedia.org/wiki/Hexagon)gaps can be filled by one circle and the[dodecagonal](https://en.wikipedia.org/wiki/Dodecagon)gaps can be filled with seven circles, creating 3-uniform packings. The[truncated trihexagonal tiling](https://en.wikipedia.org/wiki/Truncated_trihexagonal_tiling)with both types of gaps can be filled as a 4-uniform packing. The[snub hexagonal tiling](https://en.wikipedia.org/wiki/Snub_hexagonal_tiling)has two mirror-image forms.\n[![](https://upload.wikimedia.org/wikipedia/commons/7/77/Fundamental_Circle_Packings_%28Better%29.png)](https://en.wikipedia.org/wiki/File:Fundamental_Circle_Packings_(Better).png)\n## On the sphere\n[[edit](https://en.wikipedia.org/w/index.php?title=Circle_packing&amp;action=edit&amp;section=3)]\nA related problem is to determine the lowest-energy arrangement of identically interacting points that are constrained to lie within a given surface....",
      "url": "https://en.wikipedia.org/wiki/Circle_packing"
    }
  ]
}