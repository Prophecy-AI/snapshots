## Current Status
- Best CV score: 70.630478 from exp_009/exp_010 (saspav_best ensemble)
- Best LB score: 70.630478 (verified - CV = LB exactly)
- Target: 68.919154 | Gap to target: 1.711 points (2.42%)
- Submissions used: 6/100 (84 remaining)

## CV-LB Relationship Analysis
- CV = LB exactly (perfect calibration)
- This is a combinatorial optimization problem, not ML
- No distribution shift concerns

## Response to Evaluator
The evaluator correctly identified the KEY INSIGHT: we've been running the C++ optimizer with insufficient parameters:
- Our runs: n=30000, r=5 restarts, 4 generations
- jonathanchan kernel: n=20000-30000, r=80 restarts, 10+ generations
- **We need 16x more restarts!**

The evaluator also correctly noted that simple lattice approaches (hexagonal, square, interlocking) are fundamentally worse because current solutions use sophisticated multi-angle optimization (N=72 uses angles 149-158°, N=100 uses 65-68°), not simple 0/180 tessellation.

## What Has Been Tried (12 experiments)
1. ✅ Baseline from jazivxt/bucket-of-chump: 70.647327
2. ✅ Ensemble from 9 sources: 70.647306 (negligible improvement)
3. ✅ bbox3 optimization: 70.647326 (no improvement)
4. ✅ sa_v1_parallel with n=30000, r=5: NO improvement
5. ✅ Zaburo grid approach: 88.33 (MUCH worse)
6. ✅ Repair + ensemble: No improvement
7. ✅ Fractional translation: No improvement
8. ✅ Expanded ensemble (24 sources): 70.630478 (best so far)
9. ✅ Random restart SA for small N: No improvement
10. ✅ Deletion cascade: No improvement
11. ✅ Crystalline/lattice packing: WORSE than current

## What Has NOT Been Tried
1. **CRITICAL: Running sa_v1_parallel with r=80 restarts (not r=5)**
2. **CRITICAL: Running for 10+ generations (not 4)**
3. **Per-N parameter scaling** (N≤20: 1.5x iterations, N≤50: 1.3x, N>150: 0.8x)
4. **Perturbing current best and re-optimizing** (add noise to positions/angles)
5. **Genetic algorithm with population-based search**
6. **Constraint programming approach**

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Run C++ optimizer with CORRECT parameters
The jonathanchan kernel shows the winning strategy:
```bash
# Compile with optimizations
g++ -O3 -march=native -std=c++17 -fopenmp -o sa_v1_parallel sa_v1_parallel.cpp

# Run with MUCH higher restarts
./sa_v1_parallel -i current_best.csv -o output.csv -n 30000 -r 80

# Let it run for 10+ generations (may take 2-4 hours)
```

Key parameters:
- N ≤ 20: r = 80, iterations = 30000 (1.5x)
- N ≤ 50: r = 80, iterations = 26000 (1.3x)
- N > 150: r = 80, iterations = 16000 (0.8x)

### 2. **[HIGH PRIORITY]** Perturb and re-optimize
If the optimizer finds no improvement, the solution may be at a local optimum.
Try perturbing the current best:
- Add random noise to positions (0.1-0.15)
- Add random noise to angles (10-20 degrees)
- Re-optimize from perturbed state

### 3. **[MEDIUM PRIORITY]** Focus on worst N values
The worst N values (highest scores) have most improvement potential:
- N=1: 0.661250
- N=2: 0.450779
- N=3: 0.434745
- N=5: 0.416850
- N=4: 0.416545

Try exhaustive search or specialized optimization for these small N values.

## What NOT to Try
- ❌ Simple lattice approaches (hexagonal, square, interlocking) - proven WORSE
- ❌ Short optimization runs (< 10 generations)
- ❌ Low restart counts (< 80)
- ❌ Tessellation with 0/180 angles only - current solutions use multi-angle

## SUBMISSION STRATEGY
- Remaining submissions: 84
- **SUBMIT after this experiment** - we have abundant submissions
- LB feedback is FREE information - use it!

## Validation Notes
- Use Shapely for overlap detection (matches Kaggle's checker)
- CV = LB exactly (perfect calibration)
- Score = sum of (side^2 / N) for N=1 to 200

## Key Files
- Current best: /home/code/exploration/datasets/saspav_best.csv (score: 70.630478)
- C++ optimizer: /home/code/exploration/datasets/sa_v1_parallel.cpp
- Submission: /home/submission/submission.csv
