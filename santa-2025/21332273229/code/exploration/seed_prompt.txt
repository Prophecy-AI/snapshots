# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.676102 from exp_000 (baseline)
- Best LB score: 70.6761 (verified - matches CV exactly)
- Target: 68.889699 | Gap to target: 1.786 points (2.5%)

## ⚠️ CRITICAL INSIGHT FROM LOOP 1 ⚠️

**The baseline is ALREADY an ensemble of 30 CSV files taking best per-N.**
- Simple ensembling provides ZERO improvement
- All pre-optimized solutions converge to the SAME local optimum
- We MUST implement novel algorithms from scratch

## CV-LB Relationship
- CV = LB (perfect match, no gap)
- This is expected for deterministic optimization problems
- Focus on improving CV - it will directly improve LB

## Response to Evaluator
The evaluator correctly identified:
1. N=1 is already optimal at 45° rotation - CONFIRMED
2. Small N (1-10) contributes only 6.1% of total score
3. Large N (51-200) contributes 73.1% - THIS IS WHERE IMPROVEMENTS MATTER

**Key insight**: The evaluator suggested optimizing N=1-5, but analysis shows:
- N=1 is already optimal (no improvement possible)
- Large N values contribute 73% of score
- We should focus on LARGE N, not small N

## Score Breakdown (CRITICAL)
```
Small N (1-10):   4.33 points (6.1%)   - Already near-optimal
Medium N (11-50): 14.71 points (20.8%) - Some room for improvement
Large N (51-200): 51.63 points (73.1%) - MOST POTENTIAL FOR IMPROVEMENT
```

To close the 1.786 point gap, we need ~3.5% improvement on large N values.

## ⛔ BLOCKED APPROACHES (DO NOT USE)
- bbox3, sa_fast_v2, eazy_optimizer - FORBIDDEN after baseline
- Any pre-compiled C++ binary - FORBIDDEN
- "More iterations" on existing optimizer - FORBIDDEN
- Simple ensembling of existing CSVs - ALREADY DONE, NO IMPROVEMENT

## ✅ REQUIRED: IMPLEMENT FROM SCRATCH

### PRIORITY 1: Lattice/Tessellation for Large N (N >= 50)
For large N, regular lattice patterns can achieve better packing than random optimization.

**Implementation approach:**
```python
def generate_lattice_packing(n, base_angle=45):
    """Generate lattice packing for n trees.
    
    Key insight: Trees at 45° rotation have square bounding boxes.
    Arrange them in a grid pattern with optimal spacing.
    """
    tree_side = 0.813173  # Side of single tree at 45°
    
    # Calculate grid dimensions
    rows = int(np.ceil(np.sqrt(n)))
    cols = int(np.ceil(n / rows))
    
    # Optimal spacing (slightly less than tree_side due to interlocking)
    dx = tree_side * 0.95  # Horizontal spacing
    dy = tree_side * 0.95  # Vertical spacing
    
    trees = []
    for i in range(rows):
        for j in range(cols):
            if len(trees) >= n:
                break
            x = j * dx
            y = i * dy
            trees.append((x, y, base_angle))
    
    return trees[:n]
```

### PRIORITY 2: Fractional Translation Refinement
After generating initial placement, refine with tiny translations:
```python
def fractional_translation(trees, max_iter=200):
    """Refine tree positions with fractional steps."""
    steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005]
    directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (1,-1), (-1,1), (-1,-1)]
    
    for _ in range(max_iter):
        improved = False
        for i, tree in enumerate(trees):
            for step in steps:
                for dx, dy in directions:
                    new_x = tree[0] + dx * step
                    new_y = tree[1] + dy * step
                    if no_overlap(trees, i, new_x, new_y) and better_score(trees, i, new_x, new_y):
                        trees[i] = (new_x, new_y, tree[2])
                        improved = True
        if not improved:
            break
    return trees
```

### PRIORITY 3: Genetic Algorithm with Custom Operators
```python
def genetic_algorithm(n, population_size=50, generations=100):
    """Evolve population of solutions."""
    population = [random_placement(n) for _ in range(population_size)]
    
    for gen in range(generations):
        # Evaluate fitness
        fitness = [1.0 / score(p) for p in population]
        
        # Selection
        parents = tournament_selection(population, fitness)
        
        # Crossover: swap clusters between parents
        offspring = []
        for p1, p2 in pairs(parents):
            child = crossover(p1, p2)  # Swap half the trees
            offspring.append(child)
        
        # Mutation: rotate/translate random trees
        for child in offspring:
            if random() < 0.1:
                mutate(child)  # Small rotation/translation
        
        population = select_best(population + offspring, population_size)
    
    return min(population, key=score)
```

## Experiment Plan

### Experiment 001: Lattice Packing for Large N
1. Create `experiments/001_lattice_packing/`
2. Implement lattice generation for N=50 to N=200
3. Test different base angles (0°, 15°, 30°, 45°, 60°)
4. Test different spacing factors (0.90, 0.92, 0.95, 0.98)
5. Compare against baseline for each N
6. If better, create hybrid submission (baseline for small N, lattice for large N)

### Experiment 002: Fractional Translation from Scratch
1. Create `experiments/002_fractional_translation/`
2. Implement fractional translation in Python
3. Apply to baseline submission
4. Test step sizes from 0.01 down to 0.00001
5. Measure improvement per N

### Experiment 003: Genetic Algorithm
1. Create `experiments/003_genetic_algorithm/`
2. Implement GA with custom crossover/mutation
3. Focus on N=50-100 where lattice might not be optimal
4. Run for multiple generations

## Validation Requirements
```python
from decimal import Decimal, getcontext
getcontext().prec = 30
SCALE = 10**18

def validate_no_overlap(trees):
    """Validate no overlaps using integer arithmetic."""
    from shapely import Polygon
    polygons = []
    for tree in trees:
        coords = [(int(Decimal(str(x)) * SCALE), 
                   int(Decimal(str(y)) * SCALE)) 
                  for x, y in tree.vertices]
        polygons.append(Polygon(coords))
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                return False, f"Trees {i} and {j} overlap"
    return True, "OK"
```

## Submission Strategy
- Remaining submissions: 92/100
- **SUBMIT AFTER EVERY EXPERIMENT** - LB feedback is free!
- Even if score is worse, we learn what doesn't work

## Key Files
- Baseline submission: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/santa-2025.csv`
- Pre-optimized folder: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`
- Tree geometry: TX, TY arrays (15 vertices)

## Tree Geometry Reference
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
# Tip at (0, 0.8), trunk from y=0 to y=-0.2
# Base width 0.7, total height 1.0
# At 45° rotation: bounding box is 0.813 x 0.813
```

## What NOT to Try
- Running bbox3 or any pre-compiled binary
- Simple ensembling (already done, no improvement)
- Optimizing N=1 (already optimal)
- "More iterations" on existing approaches
