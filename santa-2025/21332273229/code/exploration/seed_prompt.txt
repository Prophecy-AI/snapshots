# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D polygon packing optimization problem where we need to pack Christmas tree toys (15-vertex polygons) into the smallest square bounding box for N=1 to 200 trees.

**Scoring Formula:** score = Σ(s_n²/n) for n=1 to 200, where s_n is the side length of the bounding box for n trees.
**Lower is better.**
**Target Score:** 68.889699 (must beat this)

## Tree Geometry (CRITICAL)
The Christmas tree is a 15-vertex polygon:
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```
- Tip at (0, 0.8), trunk from y=0 to y=-0.2
- Base width 0.7, mid width 0.4, top width 0.25
- Total height: 1.0 (from -0.2 to 0.8)

## Pre-Optimized Resources Available
**CRITICAL: Use these as starting points!**
- Pre-optimized submission: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/santa-2025.csv` (score ~70.676)
- bbox3 binary optimizer: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/bbox3`
- Multiple CSV files: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`
- Best ensemble score achieved: 70.676102

## ⛔ BLOCKED AFTER BASELINE (exp_000)
After getting baseline score, the following are PERMANENTLY FORBIDDEN:
- Running bbox3, tree_packer_v21, or ANY pre-compiled binary with just different parameters
- "More iterations" or "different parameters" on existing optimizers
- Ensembling outputs from the same optimizer

## ✅ REQUIRED: IMPLEMENT FROM SCRATCH
All experiments after baseline MUST implement a novel algorithm:
1. **Lattice/Tessellation Packing** - Generate grid-based placements for large N
2. **Branch-and-bound** - Exhaustive search for small N (N=1 to N=10)
3. **Genetic algorithm** - Evolve population with custom crossover/mutation operators
4. **No-Fit Polygon (NFP)** - Precompute collision-free regions
5. **Bottom-left heuristic** - Construct placements deterministically
6. **Simulated Annealing from scratch** - Implement your own SA with novel moves

DO NOT USE PRE-COMPILED BINARIES. IMPLEMENT THE ALGORITHM.

## Top Approaches from Public Kernels

### 1. bbox3.cpp Optimizer (jazivxt "Why Not" kernel)
Path: `../research/kernels/jazivxt_why-not/why-not.ipynb`
**Key Features:**
- Complex Number Vector Coordination
- Fluid Dynamics simulation
- Hinge Pivot mechanism
- Density Gradient Flow
- Global Boundary Tension
- Aggressive overlap repair using separation vectors

**Usage:** `./bbox3 -n <iterations> -r <rounds> input.csv output.csv`

### 2. tree_packer_v21.cpp (smartmanoj "Santa Claude" kernel)
Path: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`
**Key Features:**
- Swap moves between trees
- Multi-angle restarts
- Higher temperature simulated annealing
- Squeeze, compaction, and local search
- Backward propagation (bp.cpp)

**Usage:** `./tree_packer_v21.exe -n <iterations> -r <rounds>`

### 3. Backward Propagation (bp.cpp)
For each N from 200 down to 2:
- Try removing each boundary-touching tree
- If resulting (N-1) config is better than stored, save it

## Score Breakdown by N (Highest Contributors)
```
N=1:  side=0.813, score=0.661 (HIGHEST - optimize this!)
N=2:  side=0.950, score=0.451
N=3:  side=1.142, score=0.435
N=5:  side=1.444, score=0.417
N=4:  side=1.291, score=0.417
```
**Small N values (1-15) contribute disproportionately to the total score!**

## CRITICAL INSIGHTS FROM PREVIOUS EXPERIMENTS

### What Has Been Tried (and didn't work):
1. **Short optimization runs** - Local optimum is too tight
2. **Simple ensemble** - santa-2025.csv dominates all N values
3. **Backward propagation on pre-optimized** - Found no improvements
4. **Standard SA parameters** - Cannot escape local optimum

### What MUST Be Tried:

#### 1. **LATTICE/TESSELLATION APPROACH FOR LARGE N (N >= 58)** [HIGHEST PRIORITY]
- Start with 2 trees in a specific configuration
- Translate them in x and y directions to create a grid pattern
- Use simulated annealing to optimize the base configuration
- Parameters: `nt = [nx, ny]` where nx*ny >= N
- This generates crystalline/lattice packings that can be tighter than random optimization

```python
# Lattice approach pseudocode
def generate_lattice(n, base_config, dx, dy):
    """Generate n trees by translating base_config"""
    trees = []
    rows = int(np.ceil(np.sqrt(n)))
    cols = int(np.ceil(n / rows))
    for i in range(rows):
        for j in range(cols):
            if len(trees) >= n:
                break
            for tree in base_config:
                new_tree = translate(tree, i*dx, j*dy)
                trees.append(new_tree)
    return trees[:n]
```

#### 2. **FOCUS ON SMALL N VALUES (1-10)** [HIGH PRIORITY]
These have the highest score contribution:
- N=1: side=0.813, contributes 0.66 to score (HIGHEST!)
- For N=1, optimal angle is 45 degrees (minimizes bounding box)
- Try exhaustive search for optimal rotation angles
- For N=2, N=3: Try systematic angle combinations

```python
# Exhaustive search for N=1
def optimize_n1():
    best_side = float('inf')
    best_angle = 0
    for angle in np.arange(0, 360, 0.1):
        tree = ChristmasTree(0, 0, angle)
        side = get_bounding_box_side(tree)
        if side < best_side:
            best_side = side
            best_angle = angle
    return best_angle
```

#### 3. **ASYMMETRIC SOLUTIONS** [MEDIUM PRIORITY]
- Symmetric solutions may be optimal for small N
- Asymmetric solutions outperform for larger N
- Try breaking symmetry in optimization

#### 4. **IMPLEMENT NOVEL OPTIMIZATION FROM SCRATCH** [REQUIRED]
Instead of using pre-compiled binaries:
- Implement your own simulated annealing with novel move operators
- Try genetic algorithms with custom crossover
- Implement constraint programming approach

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- id: `{n:03d}_{tree_index}` (e.g., 001_0, 002_0, 002_1)
- x, y, deg: prefixed with 's' to preserve precision
- Total rows: 20100 (1+2+3+...+200)
- Coordinates must be within [-100, 100]

## Overlap Detection (CRITICAL)
```python
from shapely.geometry import Polygon
from shapely import affinity
from shapely.strtree import STRtree

class ChristmasTree:
    def __init__(self, center_x='0', center_y='0', angle='0'):
        self.center_x = Decimal(str(center_x))
        self.center_y = Decimal(str(center_y))
        self.angle = Decimal(str(angle))
        
        TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
        TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
        
        initial_polygon = Polygon(zip(TX, TY))
        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))
        self.polygon = affinity.translate(rotated, xoff=float(self.center_x), yoff=float(self.center_y))

def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

## Scoring Function
```python
def get_total_score(submission_df):
    total = 0
    for n in range(1, 201):
        trees = load_trees_for_n(submission_df, n)
        xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])
        side = max(xys.max(axis=0) - xys.min(axis=0))
        total += side**2 / n
    return total
```

## Recommended Experiment Strategy

### Experiment 0: Establish Baseline
1. Copy best pre-optimized submission (score: 70.676102)
2. Verify score calculation matches
3. Submit to confirm LB score

### Experiment 1: Small N Optimization (HIGH PRIORITY)
1. Focus on N=1 to N=10 specifically
2. For N=1: Try all angles from 0 to 360 in 0.01 degree increments
3. For N=2, N=3: Try systematic angle combinations
4. These contribute ~4.5 points to total score!

### Experiment 2: Implement Lattice Approach for Large N
1. Implement tessellation/lattice packing for N >= 58
2. Start with 2 base trees, translate to create grid
3. Optimize base configuration and translation vectors
4. This is a fundamentally different approach that can beat local optima

### Experiment 3: Implement Novel SA from Scratch
1. Write your own simulated annealing in Python
2. Use novel move operators:
   - Swap two trees
   - Rotate single tree
   - Translate single tree toward center
   - Perturb all trees slightly
3. Use adaptive temperature schedule

### Experiment 4: Genetic Algorithm
1. Implement GA with population of configurations
2. Custom crossover: combine good sub-configurations
3. Mutation: random perturbations
4. Selection: tournament selection based on score

## What NOT to Try
- Simple ensemble (already tried - one source dominates)
- Short optimization runs (local optimum is too tight)
- fix_direction post-processing (causes precision loss and overlaps)
- Micro-optimizations on pre-optimized submission
- Running pre-compiled binaries with different parameters

## Technical Notes
- Use high-precision Decimal arithmetic to avoid floating-point errors
- Validate for overlaps before submitting (Kaggle rejects overlapping trees)
- C++ optimizers use OpenMP for parallelization (check available threads with `nproc`)
- Pre-optimized files available in `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`

## Key Insight
The gap of ~1.8 points requires fundamentally different approaches, not micro-optimization. The pre-optimized submission is already at a very tight local optimum. To beat the target, we need:
1. **Lattice/tessellation approach** for large N (fundamentally different algorithm)
2. **Focus on high-contribution small N values** (N=1 alone contributes 0.66!)
3. **Implement novel algorithms from scratch** (not just run binaries)
4. **Fresh starting configurations** to escape local optima

## Mathematical Lower Bound Consideration
For a single tree (N=1), the minimum bounding box is achieved when the tree is rotated to minimize the diagonal. The current N=1 side of 0.813 may already be near optimal, but verify this.

For large N, the theoretical packing density approaches a limit based on the tree's area. The tree area is approximately 0.35 square units, so for N trees, the minimum possible bounding box area is roughly N * 0.35 / packing_efficiency.

## Validation Checklist
1. No overlapping trees (use has_overlap function)
2. All coordinates within [-100, 100]
3. All 200 configurations present (20100 rows)
4. Values prefixed with 's' in submission
