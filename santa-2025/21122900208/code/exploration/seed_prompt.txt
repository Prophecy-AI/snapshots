## Goal
Beat the target score of 68.922808.
The problem is 2D packing of N Christmas trees (polygons) into the smallest square box for N=1..200.
Score = sum(side_length^2 / n) for n=1..200.

## Phase 1: Match Best Kernel (Priority 1)
The best public approach uses a pre-compiled C++ optimizer `bbox3` and a Python-based rotation optimizer `fix_direction`.
You MUST replicate this workflow first.

### Step 1: Setup & Data
1. Download the required dataset containing the `bbox3` binary and baseline submission:
   ```bash
   kaggle datasets download -d saspav/santa-2025-csv -p ../research/datasets/ --unzip
   ```
2. Copy `bbox3` to your working directory and make it executable:
   ```bash
   cp ../research/datasets/bbox3 .
   chmod +x bbox3
   ```
3. Copy the baseline `submission.csv` to `submission.csv`.

### Step 2: Implement Optimization Loop
Create a Python script (e.g., `main.py`) that implements the logic from `santa-2025-best-keeping-bbox3-runner`:
1. **Rotation Optimization (`fix_direction`)**:
   - Implement the `fix_direction` function (uses `scipy.optimize.minimize_scalar` and `shapely`).
   - Run this on the baseline `submission.csv` first.
2. **`bbox3` Optimization**:
   - Run the `bbox3` binary using `subprocess`.
   - Usage: `./bbox3 -n <N> -r <R>` (where N is tree count, R is likely run duration or restarts).
   - Parse the output to get the score.
   - Strategy:
     - Iterate through N=1..200 (or a subset of promising Ns).
     - Run `bbox3` for a short duration.
     - If score improves, update `submission.csv`.
3. **Overlap Check**:
   - Implement `has_overlap` using `shapely.strtree.STRtree` to ensure validity.
   - Discard invalid solutions.

**Reference Kernel:** `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb`
**Reference Kernel:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

## Phase 2: Innovation (Beat the Kernel)
**WARNING:** Local search (SA) on a pre-optimized CSV often gets stuck in local optima.
You must use **CONSTRUCTIVE** approaches to break out.

### Strategy 1: Greedy Backtracking with Beam Search
Instead of tweaking existing positions, build solutions from scratch or partial states.
- **Algorithm:**
  1. Start with an empty box.
  2. Place trees one by one.
  3. For each tree, generate K candidate positions/rotations (using a grid or random sampling).
  4. Keep the top B (Beam Width) partial configurations that minimize the current bounding box.
  5. Backtrack if no valid placement is found.
- **Parameters:** Beam=10, Depth=N, Candidates=100.
- **Implementation:** Python + Shapely (or optimized C++ if you can compile it).

### Strategy 2: Random Initialization + Optimization
- Do NOT start from `submission.csv`.
- Generate a **random** valid configuration for a specific N.
- THEN apply `bbox3` or `fix_direction` to this random start.
- Repeat multiple times and keep the best. This explores different basins of attraction.

### Strategy 3: Lattice/Crystalline Packing (for N > 50)
- Research suggests structured packings work better for large N.
- Try arranging trees in a grid/hexagonal pattern.
- Optimize the lattice parameters (spacing, angle).

## Technical Details
- **Tree Shape:** Defined in `ChristmasTree` class (see kernels). Use `shapely` for polygons.
- **Precision:** Use `decimal.Decimal` for coordinates to avoid floating point errors, as the metric is sensitive.
- **Validation:** ALWAYS check for overlaps before accepting a solution.

## Resources
- `../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb` (Tree definition)
- `../research/datasets/bbox3` (Binary optimizer)
