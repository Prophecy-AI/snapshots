# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.676102 from exp_000 (baseline)
- Best LB score: 70.676102 (confirmed)
- Target: 68.919154 | Gap to target: 1.756948 (2.49%)
- Submissions used: 2/100 (94 remaining)

## CRITICAL ISSUE: Last Submission Failed!
**Error:** "Overlapping trees in group 004"

**Root Cause:** The C++ optimizer (sa_v1_parallel) truncated precision in output.
- Baseline has 18+ decimal places (e.g., `s-0.324747789589372171`)
- Optimizer output had fewer decimals (e.g., `s-0.324747789589372`)
- This precision loss caused trees to overlap

**FIX REQUIRED:** Either:
1. Use Python-based optimization with Decimal precision (like egortrushin kernel)
2. Fix C++ optimizer to output full precision
3. Use baseline CSV directly without C++ optimization

## Response to Evaluator

The evaluator correctly identified that:
1. **Lattice implementation was flawed** - My simple implementation produced 4.5x worse results because:
   - Only 500 iterations (egortrushin uses 10000+ steps)
   - Random initialization (should use optimized starting positions)
   - Large perturbation deltas (0.05 vs 0.01 in egortrushin)
   
2. **C++ optimizer truncated precision** - This caused the submission failure

3. **Need fundamentally different approach** - Standard SA on pre-optimized CSV won't work

**I agree with all evaluator points.** The next experiment must:
- Use Python with Decimal precision to avoid overlap issues
- Implement proper lattice SA with egortrushin parameters
- Run much longer optimization (10000+ steps)

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Fix Precision and Resubmit Baseline
The baseline (70.676102) is valid and doesn't have overlaps. We should:
- Copy the original baseline CSV to submission folder
- Verify no overlaps
- Submit to confirm LB score

### 2. **[HIGH PRIORITY]** Implement Proper Lattice SA (Python/Decimal)
Use egortrushin kernel approach with correct parameters:
```python
config = {
    "nt": [4, 9],  # Grid for N=72
    "Tmax": 0.0002,
    "Tmin": 0.00005,
    "alpha": 0.99,
    "nsteps": 15,
    "nsteps_per_T": 500,
    "position_delta": 0.01,  # CRITICAL: Much smaller than 0.05
    "angle_delta": 30.0,
    "delta1": 0.01,
}
```

Target N values for lattice: 72, 100, 110, 144, 156, 196, 200

### 3. **[HIGH PRIORITY]** Backward Propagation (Python/Decimal)
After lattice optimization, run backward propagation:
- Start from N=200, work down to N=2
- For each N, try removing each tree and check if (N-1) config improves
- This can find improvements for smaller N values

### 4. **[MEDIUM PRIORITY]** Fractional Translation (Python)
From jonathanchan kernel:
- Apply micro-translations at progressively smaller scales
- Steps: 0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001
- Use Decimal precision throughout

## What NOT to Try
- ❌ C++ optimizer without fixing precision output
- ❌ Simple lattice implementation with random initialization
- ❌ Short optimization runs (< 5000 steps)
- ❌ Large perturbation deltas (> 0.02)

## Key Implementation Details

### Precision Requirements
- Use Python Decimal with 25+ digits precision
- Scale factor: 1e15 or 1e18 for Shapely operations
- Output format: `s{value}` with 18+ decimal places

### Overlap Detection
```python
def has_collision(trees):
    for i, t1 in enumerate(trees):
        for j, t2 in enumerate(trees):
            if i < j:
                if t1.polygon.intersects(t2.polygon) and not t1.polygon.touches(t2.polygon):
                    return True
    return False
```

### Score Calculation
```python
def calculate_score(trees, n):
    xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T / scale_factor for t in trees])
    side = max(xys.max(axis=0) - xys.min(axis=0))
    return side ** 2 / n
```

## SUBMISSION STRATEGY
- Remaining submissions: 94
- Submit after EVERY valid experiment
- First: Submit baseline to confirm it works
- Then: Submit any improvement found

## Validation Notes
- CV = LB for this optimization problem (no train/test split)
- Always verify no overlaps before submission
- Use Shapely with high precision for collision detection
