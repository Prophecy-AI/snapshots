# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.676102 from exp_000 (001_baseline)
- Best LB score: 70.676102 (confirmed - CV = LB for optimization problems)
- Target: 68.919154 | Gap to target: 1.756948 (2.55%)

## CV-LB Relationship Analysis
- CV = LB exactly (this is an optimization problem, not ML)
- No distribution shift concerns - improving CV directly improves LB
- The challenge is escaping the local optimum, not generalization

## Response to Evaluator
The evaluator correctly identified:
1. **N=1 is already optimal** at 45-degree angle (confirmed by exhaustive search)
2. **Small N values (1-10) have highest score contribution** but N=1 cannot be improved
3. **Standard optimizers found NO improvements** on the pre-optimized CSV
4. **Need fundamentally different approaches**: lattice packing, fractional translation, longer runs

I agree with the evaluator's assessment. The key insight from the jonathanchan kernel is:
- **Fractional translation** with micro-steps (0.001 down to 0.00001)
- **Population-based optimization** keeping top 3 candidates
- **Perturbation** to escape local optima
- **Multiple generations** of optimization

## CRITICAL: What Previous Experiments Found
From the snapshot analysis:
- sa_v1_parallel.cpp optimizer → NO improvements
- tree_packer_v18.cpp optimizer → NO improvements
- tree_packer_v21.cpp optimizer → NO improvements
- Backward propagation → NO improvements
- Ensemble of 30 CSV files → santa-2025.csv dominates ALL N values

**The pre-optimized santa-2025.csv is at a VERY TIGHT LOCAL OPTIMUM.**

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Implement sa_v1_parallel.cpp with MUCH LONGER RUNS
The jonathanchan kernel's C++ optimizer with:
- `-n 20000` iterations (vs. short runs tried before)
- `-r 80` rounds
- Multiple generations with perturbation
- Fractional translation post-processing

**Key code from jonathanchan kernel:**
```cpp
// Fractional translation with micro-steps
double frac_steps[] = {0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001};

// Population-based optimization (keep top 3)
vector<pair<double, Cfg>> pop;
if (pop.size() > 3) pop.resize(3);

// Perturbation to escape local optima
Cfg perturb(Cfg c, double strength, int seed);
```

### 2. **[HIGH PRIORITY]** Lattice-Based Packing for Large N
From egortrushin kernel - for N >= 58 (especially 72, 100, 110, 144, 156, 196, 200):
- Start with two base trees in optimal configuration
- Translate in x and y to create grid pattern
- Parameters: `nt = [nx, ny]` where `nx * ny >= N`
- This generates crystalline packings that can escape local optima

**Grid configurations:**
- N=72: nt = [4, 9] (4*9=36, need 72 trees, so 2 base trees)
- N=100: nt = [5, 10]
- N=110: nt = [5, 11]
- N=144: nt = [6, 12]
- N=156: nt = [6, 13]
- N=196: nt = [7, 14]
- N=200: nt = [7, 15] (take first 200 from 210)

### 3. **[MEDIUM PRIORITY]** Ensemble from Multiple Sources
The jonathanchan kernel ensembles from 19+ sources:
- bucket-of-chump
- santa-2025-csv
- telegram submissions
- Various kernel outputs

For each N, keep the best configuration from all sources.

### 4. **[MEDIUM PRIORITY]** Random Initialization + Optimization
- Generate completely NEW starting configurations
- Don't start from pre-optimized CSV
- Then apply optimization to the random starting point
- This explores different basins of attraction

## What NOT to Try
- Simple SA on pre-optimized CSV (already tried, no improvements)
- Short optimization runs (need hours, not minutes)
- Improving N=1 (already optimal at 45 degrees)
- Backward propagation alone (already tried, no improvements)

## Pre-optimized Files Available
- Best: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/santa-2025-csv/santa-2025.csv` (70.676102)
- bbox3 binary: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/bbox3`
- Multiple ensemble sources in `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`

## C++ Optimizer Source
The sa_v1_parallel.cpp from jonathanchan kernel is in:
`/home/code/research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation/`

Extract the C++ code from the notebook and compile:
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o sa_v1_parallel sa_v1_parallel.cpp
./sa_v1_parallel -i submission.csv -o submission.csv -n 20000 -r 80
```

## SUBMISSION STRATEGY
- Remaining submissions: 94
- Submit after EVERY experiment - we have abundant submissions
- LB feedback is free information - USE IT!

## Next Experiment Plan
1. Extract sa_v1_parallel.cpp from jonathanchan kernel notebook
2. Compile with OpenMP for parallel execution
3. Run with high iterations: `-n 20000 -r 80`
4. Apply fractional translation post-processing
5. Validate no overlaps
6. Submit to get LB feedback

## Validation Checklist
1. No overlapping trees (use Shapely STRtree for fast overlap detection)
2. All coordinates within [-100, 100]
3. All 200 configurations present (20100 rows)
4. Values prefixed with 's' in submission format