# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.676102 from exp_000 (baseline)
- Best LB score: 70.676102 (confirmed via submission)
- Target: 68.919154 | Gap to target: 1.756948 (2.49%)

## CV-LB Relationship
- CV = LB for this problem (no train/test split, pure optimization)
- No distribution shift - what works locally works on LB

## Response to Evaluator

The evaluator correctly identified that:
1. **Backward propagation found ZERO improvements** - baseline is optimal for this technique
2. **bbox3 long run found ZERO improvements** - even with -n 50000 -r 64
3. **The baseline is at an EXTREMELY tight local optimum**

The evaluator's recommendation to try **perturbation + population-based approach** is spot-on. This is the key technique we haven't tried yet.

**Key insight from my analysis:**
- fix_direction (rotation optimization) also found ZERO improvements - baseline is already optimally rotated
- The baseline has been optimized by multiple techniques already
- The only way to escape is through PERTURBATION - randomly disturbing the solution and re-optimizing

## What Has Been Tried (ALL FAILED)
1. ✅ sa_v1_parallel C++ optimizer - NO improvement
2. ✅ Fractional translation - NO improvement  
3. ✅ Backward propagation - NO improvement
4. ✅ bbox3 with high iterations (-n 50000 -r 64) - NO improvement
5. ✅ Lattice from scratch - MUCH WORSE results
6. ✅ fix_direction rotation - NO improvement (tested in loop 4)
7. ✅ Ensemble of 30 CSVs - baseline dominates ALL N values

## What Has NOT Been Tried (CRITICAL!)

### 1. **[HIGHEST PRIORITY] Perturbation + Re-optimization**
The jonathanchan kernel uses this technique:
```cpp
Cfg perturb(Cfg c, double strength, uint64_t seed) {
    int numPerturb = max(1, (int)(c.n * 0.15));  // Perturb 15% of trees
    for (int k = 0; k < numPerturb; k++) {
        int i = ri(c.n);
        c.x[i] += (rf() - 0.5) * strength;  // Random position shift
        c.y[i] += (rf() - 0.5) * strength;
        c.a[i] = fmod(c.a[i] + (rf() - 0.5) * 60 + 360, 360.0);  // Random angle
    }
    return c;
}
```

**Implementation strategy:**
1. Load baseline configuration
2. Perturb 10-15% of trees (random position shift 0.1-0.5, angle shift 10-30°)
3. Run SA optimization to find new local optimum
4. If better, keep; if not, try different perturbation
5. Repeat with population of 3 solutions

### 2. **[HIGH PRIORITY] Population-Based Approach**
Keep top 3 solutions, perturb each, re-optimize, keep best 3:
```python
population = [baseline]
for generation in range(10):
    for solution in population:
        perturbed = perturb(solution, strength=0.1)
        optimized = run_sa(perturbed)
        population.append(optimized)
    population = sorted(population, key=score)[:3]  # Keep top 3
```

### 3. **[HIGH PRIORITY] sa_v3 Optimizer**
The jonathanchan kernel has sa_v3 with 8 move types:
- translate, rotate, swap, squeeze, compaction, local search, fractional translation
- More sophisticated than sa_v1

**Extract and compile sa_v3 from jonathanchan kernel, run with perturbation.**

### 4. **[MEDIUM PRIORITY] Much Longer Optimization**
Top solutions run for HOURS, not minutes:
- `-n 20000 -r 80` with multiple generations
- Endless mode with periodic saves
- Different random seeds

## Recommended Approaches (Priority Order)

1. **[HIGHEST PRIORITY]** Implement Python-based perturbation + SA optimization
   - Perturb 15% of trees with position_delta=0.1, angle_delta=30
   - Run SA with 10000 iterations
   - Keep population of 3 solutions
   - Run for 10+ generations

2. **[HIGH PRIORITY]** Extract and compile sa_v3 from jonathanchan kernel
   - Has more sophisticated move types
   - Use with perturbation mechanism
   - Run with `-n 20000 -r 80`

3. **[MEDIUM PRIORITY]** Try different perturbation strengths
   - Weak: position_delta=0.05, angle_delta=15
   - Medium: position_delta=0.1, angle_delta=30
   - Strong: position_delta=0.2, angle_delta=60

## What NOT to Try
- ❌ More bbox3 runs without perturbation (already at local optimum)
- ❌ More backward propagation (already tried, no improvement)
- ❌ fix_direction rotation (already optimal)
- ❌ Lattice from scratch (much worse than baseline)
- ❌ Simple SA without perturbation (will return to same local optimum)

## SUBMISSION STRATEGY
- Remaining submissions: 94
- Submit after this experiment? **YES** - we have abundant submissions
- Even if no improvement, LB feedback is valuable

## Validation Notes
- CV = LB for this problem (pure optimization)
- Use Python Decimal precision for final submission
- Verify no overlaps before submission

## CRITICAL: The Key to Escaping Local Optima

The baseline is at a LOCAL optimum, not GLOBAL. All standard optimization techniques converge to the same local optimum.

**The ONLY way to escape is PERTURBATION:**
1. Randomly disturb the solution (shift positions, rotate angles)
2. Re-optimize from the perturbed state
3. The optimizer may find a DIFFERENT local optimum
4. If better, keep it; if not, try again with different perturbation

This is the technique used by top competitors. We must implement it.
