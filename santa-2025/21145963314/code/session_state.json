{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T17:14:10.415883",
  "time_limit_minutes": 2100,
  "experiments": [
    {
      "id": "exp_000",
      "name": "001_baseline",
      "model_type": "preoptimized",
      "score": 70.676102,
      "cv_score": 70.676102,
      "lb_score": null,
      "notes": "Established baseline using pre-optimized santa-2025.csv from snapshot. Score: 70.676102. Target: 68.919154. Gap: 1.756948 (2.55%). No overlaps detected in sample configurations. Top contributors to score are small N values (N=1 contributes 0.66, N=2 contributes 0.45). The pre-optimized solution is at a tight local optimum - previous experiments showed standard optimization approaches (SA, backward propagation, C++ optimizers) found NO improvements.",
      "experiment_folder": "/home/code/experiments/001_baseline",
      "timestamp": "2026-01-19T17:23:30.765126"
    }
  ],
  "candidates": [
    {
      "file_path": "/home/code/submission_candidates/candidate_000.csv",
      "score": 70.676102,
      "cv_score": 70.676102,
      "model_name": "001_baseline",
      "experiment_id": "exp_000",
      "timestamp": "2026-01-19T17:23:30.766676"
    }
  ],
  "submissions": [],
  "strategy_history": [
    {
      "strategy": "# Santa 2025 - Christmas Tree Packing Optimization\n\n## Problem Overview\nThis is a 2D polygon packing optimization problem. The goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding box for each configuration of N trees (N=1 to 200).\n\n**Scoring:** score = \u03a3(s_n\u00b2 / n) for n=1 to 200, where s_n is the side length of the bounding square for n trees. Lower is better.\n\n**Target Score:** Beat 68.919154\n**Current Best:** 70.676102 (from pre-optimized santa-2025.csv)\n**Gap to Target:** 1.75 points (2.54%)\n\n## CRITICAL INSIGHT FROM PREVIOUS EXPERIMENTS\n\n**The pre-optimized santa-2025.csv is at a VERY TIGHT LOCAL OPTIMUM.**\n\nPrevious experiments tried:\n- sa_v1_parallel.cpp optimizer \u2192 NO improvements\n- tree_packer_v18.cpp optimizer \u2192 NO improvements  \n- tree_packer_v21.cpp optimizer \u2192 NO improvements\n- Backward propagation \u2192 NO improvements\n- Ensemble of 30 CSV files \u2192 santa-2025.csv dominates ALL N values\n\n**Standard optimization approaches CANNOT escape this local optimum.**\n\n## Tree Geometry\nEach Christmas tree is a 15-vertex polygon with:\n- Trunk: width 0.15, height 0.2\n- Base tier: width 0.7\n- Middle tier: width 0.4\n- Top tier: width 0.25\n- Tip at y=0.8\n- Total height: 1.0 (from trunk bottom at -0.2 to tip at 0.8)\n\n## TECHNIQUES TO ESCAPE LOCAL OPTIMA (From Research)\n\n### 1. Four-Corners (FC) Heuristic\nRepeatedly re-position items at the four extreme corners of the bounding box to generate diverse configurations and break out of stagnation.\n\n### 2. Iterated Local Search (ILS) / Monotonic Basin Hopping\nAfter each local optimum, apply a perturbation step (both combinatorial and continuous moves) to jump to a new basin before re-optimizing.\n\n### 3. Guided Local Search (GLS) Meta-heuristic\nPenalize features that appear in local optima to guide search away from previously visited regions.\n\n### 4. Adaptive Temperature Simulated Annealing\nAdjust perturbation size based on acceptance rate - large jumps when search stalls, finer moves near promising regions.\n\n### 5. Fast Neighborhood Search\nDefine rich set of elementary moves (swap, rotate, slide) and apply in steep-descent-plus-random-restart fashion.\n\n### 6. Hybrid GA with Jostle Algorithm\nGlobal recombination operators generate diverse populations, intensive local refinement converges quickly, occasional re-initialization keeps search from settling.\n\n## APPROACHES THAT MIGHT WORK (Priority Order)\n\n### 1. **[HIGHEST PRIORITY]** Lattice/Grid-Based Approach for Large N\nFor large N (72, 100, 110, 144, 156, 196, 200), use fundamentally different approach:\n- Start with two base trees in a specific configuration\n- Translate them in x and y directions to create a grid pattern\n- Parameters: nt = [nx, ny] where nx*ny >= N\n- Use simulated annealing to optimize the base configuration\n- This generates crystalline/lattice packings that can be tighter than random optimization\n\n### 2. **[HIGH PRIORITY]** Focus on Small N Values (1-10)\nThese have the LOWEST efficiency and HIGHEST score contribution:\n- N=1: side=0.813, contributes 0.66 to score (highest single contribution!)\n- N=2: side=0.950, contributes 0.45 to score\n- For N=1, optimal angle is 45 degrees (minimizes bounding box)\n- Try exhaustive search for optimal rotation angles\n- The tree has 15 vertices - try all 360 degrees in 0.001 increments\n\n### 3. **[HIGH PRIORITY]** Much Longer Optimization Runs with Perturbation\nTop solutions run for HOURS, not minutes:\n- `-n 15000+` iterations (vs. short runs tried)\n- `-r 80+` rounds\n- Multiple generations with perturbation to escape local optima\n- Different random seeds\n- Use ILS/Basin Hopping approach\n\n### 4. **[MEDIUM PRIORITY]** Greedy Backtracking with Beam Search\nBuild solutions tree-by-tree from scratch (NOT from pre-optimized CSV):\n- Use beam search to explore multiple paths\n- Parameters: BEAM=10, DEPTH=10, MAX_STATES=4000\n- This is fundamentally different from optimizing existing solutions\n\n### 5. **[MEDIUM PRIORITY]** Random Initialization + Optimization\n- Generate completely NEW starting configurations\n- Don't start from pre-optimized CSV\n- Then apply optimization to the random starting point\n\n## Top Approaches from Public Kernels\n\n### bbox3 C++ Optimizer (Primary Approach)\n**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`\n\nKey features:\n- Complex Number Vector Coordination for position calculations\n- Fluid Dynamics simulation for tree movement\n- Hinge Pivot mechanism for rotation optimization\n- Density Gradient Flow for compaction\n- Global Boundary Tension for edge optimization\n- OpenMP parallelization for speed\n\n**Usage:**\n```bash\ng++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp\n./bbox3 -n 10000 -r 64\n```\n\n### tree_packer_v21 (Alternative Optimizer)\n**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n\nFeatures:\n- Swap moves between trees\n- Multi-angle restarts\n- Higher temperature simulated annealing\n- Squeeze, compaction, and local search phases\n- Uses long double precision for accuracy\n\n### fix_direction Post-Processing\n**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`\n\nAfter optimization, rotate entire configuration to minimize bounding box:\n```python\ndef optimize_rotation(trees):\n    all_points = []\n    for tree in trees:\n        all_points.extend(list(tree.polygon.exterior.coords))\n    hull_points = points_np[ConvexHull(points_np).vertices]\n    \n    res = minimize_scalar(\n        lambda a: calculate_bbox_side_at_angle(a, hull_points),\n        bounds=(0.001, 89.999), method='bounded'\n    )\n    return res.x, res.fun\n```\n\n### Backward Propagation (bp.cpp)\nImproves smaller N configurations by removing trees from larger ones:\n- Start from N=200, work down to N=2\n- For each config, try removing boundary-touching trees\n- If resulting (N-1) config is better than stored, save it\n\n## Key Implementation Details\n\n### ChristmasTree Class\n```python\nclass ChristmasTree:\n    def __init__(self, center_x='0', center_y='0', angle='0'):\n        self.center_x = Decimal(center_x)\n        self.center_y = Decimal(center_y)\n        self.angle = Decimal(angle)\n        \n        initial_polygon = Polygon([\n            (0.0, 0.8),      # Tip\n            (0.125, 0.5),    # Right top tier\n            (0.0625, 0.5),\n            (0.2, 0.25),     # Right mid tier\n            (0.1, 0.25),\n            (0.35, 0.0),     # Right base\n            (0.075, 0.0),    # Right trunk\n            (0.075, -0.2),\n            (-0.075, -0.2),  # Left trunk\n            (-0.075, 0.0),\n            (-0.35, 0.0),    # Left base\n            (-0.1, 0.25),    # Left mid tier\n            (-0.2, 0.25),\n            (-0.0625, 0.5),  # Left top tier\n            (-0.125, 0.5),\n        ])\n        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))\n        self.polygon = affinity.translate(rotated, xoff=float(self.center_x), yoff=float(self.center_y))\n```\n\n### Overlap Detection\n```python\nfrom shapely.strtree import STRtree\n\ndef has_overlap(trees):\n    polygons = [t.polygon for t in trees]\n    tree_index = STRtree(polygons)\n    \n    for i, poly in enumerate(polygons):\n        indices = tree_index.query(poly)\n        for idx in indices:\n            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):\n                return True\n    return False\n```\n\n### Scoring Function\n```python\ndef get_total_score(submission_df):\n    total = 0\n    for n in range(1, 201):\n        trees = load_trees_for_n(submission_df, n)\n        xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])\n        side = max(xys.max(axis=0) - xys.min(axis=0))\n        total += side**2 / n\n    return total\n```\n\n## Submission Format\n```csv\nid,x,y,deg\n001_0,s0.0,s0.0,s90.0\n002_0,s0.0,s0.0,s90.0\n002_1,s0.202736,s-0.511271,s90.0\n...\n```\n- id: `{n:03d}_{tree_index}` (e.g., 001_0, 002_0, 002_1)\n- x, y, deg: prefixed with 's' to preserve precision\n- Total rows: 20100 (1+2+3+...+200)\n\n## Validation Checklist\n1. No overlapping trees (use has_overlap function)\n2. All coordinates within [-100, 100]\n3. All 200 configurations present (20100 rows)\n4. Values prefixed with 's' in submission\n\n## External Datasets\nTop kernels use pre-optimized submissions as starting points:\n- \"santa-2025-csv\" - contains bbox3 binary and optimized CSV\n- \"bucket-of-chump\" - another optimized starting point\n\n## WHAT NOT TO TRY (Already Failed)\n- Simple ensemble (santa-2025.csv dominates all N values)\n- Short optimization runs (no improvements found)\n- Standard backward propagation (no improvements found)\n- Running optimizers on pre-optimized submission without perturbation (local optimum is too tight)\n\n## RECOMMENDED EXPERIMENT PIPELINE\n\n### Experiment 1: Establish Baseline\n1. Download pre-optimized submission (santa-2025.csv or bucket-of-chump)\n2. Run fix_direction on it\n3. Validate no overlaps\n4. Submit to verify baseline score (~70.67)\n\n### Experiment 2: Lattice Approach for Large N\n1. Implement lattice-based packing for N >= 58\n2. Start with 2 base trees, translate to create grid\n3. Optimize base configuration and translation vectors\n4. Compare with pre-optimized for each N, keep better\n\n### Experiment 3: Focus on Small N (1-10)\n1. For N=1, try all angles 0-360 in 0.001 increments\n2. For N=2-10, exhaustive search for optimal configurations\n3. These have highest score contribution per tree\n\n### Experiment 4: Extended Optimization with ILS/Perturbation\n1. Run bbox3 with -n 20000 -r 256 (hours, not minutes)\n2. Use different random seeds\n3. Apply perturbation after each local optimum (ILS approach)\n4. Use Guided Local Search to avoid revisiting same regions\n\n### Experiment 5: Greedy Construction from Scratch\n1. Build solutions tree-by-tree (not from pre-optimized)\n2. Use beam search with BEAM=10\n3. For each N, try multiple construction strategies\n\n### Experiment 6: Four-Corners Heuristic\n1. For each configuration, try repositioning trees at four corners\n2. Re-optimize after each repositioning\n3. Keep best result\n\n## Key Insights\n1. Symmetric solutions may be optimal for small N but asymmetric for large N\n2. Trees tend to interlock with alternating orientations (0\u00b0, 90\u00b0, 180\u00b0, 270\u00b0)\n3. Lattice-like patterns emerge in well-optimized configurations\n4. The gap of 1.75 points requires reducing average side by ~0.053 units across all N\n5. CV = LB for this optimization problem (no distribution shift)\n6. Small N values (1-10) have highest score contribution - focus here first\n\n## Reference Notebooks\n- Getting started: `../research/kernels/inversion_santa-2025-getting-started/`\n- bbox3 optimizer: `../research/kernels/jazivxt_why-not/`\n- fix_direction: `../research/kernels/saspav_santa-submission/`\n- tree_packer_v21 + bp: `../research/kernels/smartmanoj_santa-claude/`\n- Best-keeping runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`\n",
      "agent": "explorer",
      "timestamp": "2026-01-19T17:21:07.734008"
    }
  ],
  "feedback_history": [
    {
      "feedback": "## What I Understood\n\nThe junior researcher established a baseline by loading the pre-optimized santa-2025.csv submission and verifying its score. This is a 2D polygon packing optimization problem where the goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest square bounding box for N=1 to 200 trees. The baseline score is 70.676102, with a target of 68.919154 (gap of 1.76 points, 2.55%). The researcher correctly verified no overlaps exist and analyzed per-N contributions to the score.\n\n## Technical Execution Assessment\n\n**Validation**: Sound. The scoring function correctly implements the competition metric: score = \u03a3(s_n\u00b2/n) for n=1 to 200. The bounding box computation and overlap detection are properly implemented using Shapely.\n\n**Leakage Risk**: None - this is a pure optimization problem, not a prediction task. CV = LB by definition.\n\n**Score Integrity**: Verified. The score of 70.676102 is correctly computed and matches the expected value from the pre-optimized submission.\n\n**Code Quality**: Good. The notebook is clean, uses proper coordinate parsing (handling 's' prefix), and includes validation checks for overlaps.\n\nVerdict: **TRUSTWORTHY** - The baseline is correctly established.\n\n## Strategic Assessment\n\n**Approach Fit**: \u2705 Appropriate first step. Establishing a verified baseline before optimization is the right approach.\n\n**Effort Allocation**: \u26a0\ufe0f **CRITICAL CONTEXT FROM PREVIOUS SESSION** - The snapshot reveals that previous experiments already tried:\n- sa_v1_parallel.cpp optimizer \u2192 NO improvements\n- tree_packer_v18.cpp optimizer \u2192 NO improvements\n- tree_packer_v21.cpp optimizer \u2192 NO improvements\n- Backward propagation \u2192 NO improvements\n- Ensemble of 30 CSV files \u2192 santa-2025.csv dominates ALL N values\n\n**The pre-optimized santa-2025.csv is at a VERY TIGHT LOCAL OPTIMUM.** Standard optimization approaches cannot escape it.\n\n**Assumptions Being Challenged**:\n1. \u274c \"Short optimization runs can find improvements\" - The local optimum is too tight\n2. \u274c \"Backward propagation will help\" - Larger N configs don't have better sub-configurations\n3. \u274c \"More ensemble sources will help\" - All 30 available sources are dominated by santa-2025.csv\n\n**Blind Spots - CRITICAL APPROACHES NOT YET TRIED**:\n\n### 1. **[HIGHEST PRIORITY] Lattice/Grid-Based Approach for Large N**\nFor large N values (72, 100, 110, 144, 156, 196, 200), use a fundamentally different approach:\n- Start with two base trees in a specific configuration\n- Translate them in x and y directions to create a grid pattern\n- Parameters: nt = [nx, ny] where nx*ny >= N\n- Use simulated annealing to optimize the base configuration\n- This generates crystalline/lattice packings that can be tighter than random optimization\n\nThis is NOT being tried at all and is used by top solutions!\n\n### 2. **[HIGH PRIORITY] Focus on Small N Values (1-10)**\nThese have the LOWEST efficiency and HIGHEST score contribution:\n- N=1: side=0.813, contributes 0.66 to score (highest single contribution!)\n- N=2: side=0.950, contributes 0.45 to score\n- For N=1, optimal angle is 45 degrees (minimizes bounding box)\n- Try exhaustive search for optimal rotation angles\n- The tree has 15 vertices - try all 360 degrees in 0.001 increments\n\n### 3. **[HIGH PRIORITY] Much Longer Optimization Runs with Perturbation**\nTop solutions run for HOURS, not minutes:\n- `-n 15000+` iterations (vs. short runs tried)\n- `-r 80+` rounds\n- Multiple generations with perturbation to escape local optima\n- Different random seeds\n- Use ILS/Basin Hopping approach\n\n### 4. **[MEDIUM PRIORITY] Greedy Backtracking with Beam Search**\nBuild solutions tree-by-tree from scratch (NOT from pre-optimized CSV):\n- Use beam search to explore multiple paths\n- Parameters: BEAM=10, DEPTH=10, MAX_STATES=4000\n- This is fundamentally different from optimizing existing solutions\n\n**Trajectory**: The baseline is established correctly. The key insight from previous work is that the pre-optimized submission is at a very tight local optimum. The next experiments MUST use fundamentally different approaches, not just run the same optimizers again.\n\n## What's Working\n\n1. **Baseline correctly established** - Score of 70.676102 verified, no overlaps\n2. **Per-N analysis is insightful** - Identified that small N values (1-10) have highest score contribution\n3. **Infrastructure is ready** - bbox3 binary is compiled, pre-optimized files are available\n4. **Problem understanding is solid** - Tree geometry, scoring, and validation are all correct\n\n## Key Concerns\n\n### 1. **Don't Repeat Failed Approaches**\n- **Observation**: Previous session tried standard optimizers (sa_v1_parallel, tree_packer_v18, tree_packer_v21, backward propagation) and found NO improvements\n- **Why it matters**: Running the same approaches again will waste time\n- **Suggestion**: Focus on fundamentally different approaches: lattice packing, exhaustive search for small N, or much longer runs with perturbation\n\n### 2. **Small N Values Are Low-Hanging Fruit**\n- **Observation**: N=1 contributes 0.66 to score (highest single contribution), but has lowest efficiency (1.51 trees/unit area)\n- **Why it matters**: Improving small N values could have outsized impact on total score\n- **Suggestion**: For N=1, try exhaustive angle search (0-360 in 0.001 increments). The optimal angle should minimize the bounding box of the rotated tree.\n\n### 3. **Lattice Approach for Large N is Untried**\n- **Observation**: Top kernels use grid-based placement for large N, but this hasn't been implemented\n- **Why it matters**: This is a fundamentally different approach that can escape local optima\n- **Suggestion**: Implement lattice packing for N >= 58 (where grid patterns become efficient)\n\n## Top Priority for Next Experiment\n\n**Implement exhaustive angle search for N=1 (and possibly N=2-5).**\n\nRationale:\n1. N=1 contributes 0.66 to score - the highest single contribution\n2. For a single tree, the optimal angle is deterministic - just find the rotation that minimizes the bounding box\n3. This is a quick win that doesn't require complex optimization\n4. The tree has 15 vertices - try all angles from 0 to 360 in 0.001 degree increments\n5. The current N=1 uses angle 45.0 degrees with side 0.813 - can we do better?\n\n**Implementation approach:**\n```python\n# For N=1, find optimal rotation angle\nbest_side = float('inf')\nbest_angle = 0\nfor angle in np.arange(0, 360, 0.001):\n    tree = ChristmasTree('0', '0', str(angle))\n    coords = np.array(tree.polygon.exterior.coords)\n    side = max(coords.max(axis=0) - coords.min(axis=0))\n    if side < best_side:\n        best_side = side\n        best_angle = angle\n```\n\nIf N=1 can be improved, the same approach can be applied to N=2-5 with exhaustive search over all angle combinations.\n\n**Secondary priority**: If N=1 cannot be improved, implement lattice-based packing for large N values (N >= 58) as this is the approach used by top solutions but hasn't been tried yet.\n",
      "experiment_id": "exp_000",
      "agent": "evaluator",
      "timestamp": "2026-01-19T17:25:40.021495"
    }
  ],
  "data_findings": [
    {
      "finding": "This is a 2D polygon packing optimization problem. Goal: pack Christmas tree shapes (15-vertex polygons) into smallest square bounding box for N=1 to 200 trees. Score = \u03a3(s_n\u00b2/n) where s_n is side length. Lower is better. Target: beat 68.919154.",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "bbox3.cpp is the core optimizer used by top solutions. Features: Complex Number Vector Coordination, Fluid Dynamics simulation, Hinge Pivot mechanism, Density Gradient Flow, Global Boundary Tension, OpenMP parallelization. Key params: -n iterations (5000-20000), -r rounds (16-256).",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "fix_direction post-processing: After optimization, rotate entire configuration to minimize bounding box. Uses ConvexHull of all tree vertices, then minimize_scalar to find optimal rotation angle between 0-90 degrees. Can improve score by reducing bounding box side.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "tree_packer_v21.cpp: Alternative optimizer with swap moves, multi-angle restarts, higher temperature SA. Uses long double precision. Includes squeeze, compaction, and local search phases. Also has backward propagation (bp.cpp) to improve smaller N configs by removing trees from larger ones.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Top kernels use pre-optimized submissions as starting points: 'bucket-of-chump/submission.csv' and 'santa-2025-csv/santa-2025.csv'. These contain already-optimized configurations that can be further improved.",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Christmas tree geometry: 15-vertex polygon with trunk (w=0.15, h=0.2), base tier (w=0.7), middle tier (w=0.4), top tier (w=0.25), tip at y=0.8. Total height 1.0. Can be positioned (x,y) and rotated by angle (deg).",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Previous experiments achieved 70.676102 score. Target is 68.919154 (gap of 1.75 points, 2.54%). Pre-optimized santa-2025.csv is at a very tight local optimum - standard optimization (sa_v1_parallel, tree_packer_v18, backward propagation) found NO improvements. Need fundamentally different approaches.",
      "source": "/home/nonroot/snapshots/santa-2025/21116303805/code/state.json",
      "agent": "explorer"
    },
    {
      "finding": "Key insight: Small N values (1-10) have lowest efficiency (1.5-2.6 trees/unit area). N=1 contributes 0.66 to score (highest single contribution). For N=1, optimal angle is 45 degrees to minimize bounding box.",
      "source": "/home/nonroot/snapshots/santa-2025/21116303805/code/state.json",
      "agent": "explorer"
    },
    {
      "finding": "Lattice-based approach for large N (72, 100, 110, 144, 156, 196, 200): Start with two base trees, translate them in x and y directions to create grid pattern. Parameters: nt = [nx, ny] where nx*ny >= N. This generates crystalline packings that can be tighter than random optimization.",
      "source": "/home/nonroot/snapshots/santa-2025/21116303805/code/state.json",
      "agent": "explorer"
    },
    {
      "finding": "Techniques to escape local optima in 2D polygon packing: 1) Four-corners (FC) heuristic - repositions items at four extreme corners to generate diverse offspring. 2) Fast neighborhood search with swap/rotate/slide moves + random restarts. 3) Adaptive temperature SA - adjusts perturbation size based on acceptance rate. 4) Iterated Local Search (ILS) / Monotonic Basin Hopping - perturbation step after each local optimum. 5) Guided Local Search (GLS) meta-heuristic. 6) Hybrid GA with Jostle algorithm.",
      "source": "WebSearch: escaping local optima in 2D polygon packing",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best techniques for escaping local optima in 2D polygon packing optimization problems?",
      "finding": "Two\u2011dimensional polygon\u2011packing problems are notoriously multimodal; a na\u00efve local search quickly becomes trapped in sub\u2011optimal layouts.  Modern approaches therefore combine a strong constructive heuristic with diversification mechanisms that deliberately \u201cshake\u201d the current solution and allow the algorithm to explore distant regions of the search space.  A widely used example is the **four\u2011corners (FC) heuristic** embedded in a self\u2011adaptive evolutionary algorithm, which repeatedly re\u2011positions items at the four extreme corners of the bin to generate diverse offspring and to break out of stagnation\u202f([ScienceDirect](https://www.sciencedirect.com/science/article/abs/pii/S0377221706003018)).  Similar diversification is achieved by **fast neighbourhood search**, which defines a rich set of elementary moves (swap, rotate, slide) and applies them in a steep\u2011descent\u2011plus\u2011random\u2011restart fashion, enabling rapid escape from shallow basins\u202f([ScienceDirect](https://www.sciencedirect.com/science/",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 95
}