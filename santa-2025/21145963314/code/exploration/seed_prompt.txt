# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D polygon packing optimization problem. The goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding box for each configuration of N trees (N=1 to 200).

**Scoring:** score = Σ(s_n² / n) for n=1 to 200, where s_n is the side length of the bounding square for n trees. Lower is better.

**Target Score:** Beat 68.919154
**Current Best:** 70.676102 (from pre-optimized santa-2025.csv)
**Gap to Target:** 1.75 points (2.54%)

## CRITICAL INSIGHT FROM PREVIOUS EXPERIMENTS

**The pre-optimized santa-2025.csv is at a VERY TIGHT LOCAL OPTIMUM.**

Previous experiments tried:
- sa_v1_parallel.cpp optimizer → NO improvements
- tree_packer_v18.cpp optimizer → NO improvements  
- tree_packer_v21.cpp optimizer → NO improvements
- Backward propagation → NO improvements
- Ensemble of 30 CSV files → santa-2025.csv dominates ALL N values

**Standard optimization approaches CANNOT escape this local optimum.**

## Tree Geometry
Each Christmas tree is a 15-vertex polygon with:
- Trunk: width 0.15, height 0.2
- Base tier: width 0.7
- Middle tier: width 0.4
- Top tier: width 0.25
- Tip at y=0.8
- Total height: 1.0 (from trunk bottom at -0.2 to tip at 0.8)

The tree can be positioned (x, y) and rotated by angle (deg).

## APPROACHES THAT MIGHT WORK (Priority Order)

### 1. **[HIGHEST PRIORITY]** Lattice/Grid-Based Approach for Large N
For large N (72, 100, 110, 144, 156, 196, 200), use fundamentally different approach:
- Start with two base trees in a specific configuration
- Translate them in x and y directions to create a grid pattern
- Parameters: nt = [nx, ny] where nx*ny >= N
- Use simulated annealing to optimize the base configuration
- This generates crystalline/lattice packings that can be tighter than random optimization

```python
# For N >= 58, try crystalline packing
# Start with 2 base trees, translate to create grid
# nt = [rows, cols] such that rows * cols >= N
# Optimize the base configuration and translation vectors
```

### 2. **[HIGH PRIORITY]** Focus on Small N Values (1-10)
These have the LOWEST efficiency and HIGHEST score contribution:
- N=1: side=0.813, contributes 0.66 to score (highest single contribution!)
- N=2: side=0.950, contributes 0.45 to score
- For N=1, optimal angle is 45 degrees (minimizes bounding box)
- Try exhaustive search for optimal rotation angles
- The tree has 15 vertices - try all 360 degrees in 0.001 increments

### 3. **[HIGH PRIORITY]** Much Longer Optimization Runs
Top solutions run for HOURS, not minutes:
- `-n 15000+` iterations (vs. short runs tried)
- `-r 80+` rounds
- Multiple generations with perturbation to escape local optima
- Different random seeds

### 4. **[MEDIUM PRIORITY]** Greedy Backtracking with Beam Search
Build solutions tree-by-tree from scratch (NOT from pre-optimized CSV):
- Use beam search to explore multiple paths
- Parameters: BEAM=10, DEPTH=10, MAX_STATES=4000
- This is fundamentally different from optimizing existing solutions

### 5. **[MEDIUM PRIORITY]** Random Initialization
- Generate completely NEW starting configurations
- Don't start from pre-optimized CSV
- Then apply optimization to the random starting point

## Top Approaches from Public Kernels

### bbox3 C++ Optimizer (Primary Approach)
**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`

Key features:
- Complex Number Vector Coordination for position calculations
- Fluid Dynamics simulation for tree movement
- Hinge Pivot mechanism for rotation optimization
- Density Gradient Flow for compaction
- Global Boundary Tension for edge optimization
- OpenMP parallelization for speed

**Usage:**
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp
./bbox3 -n 10000 -r 64
```

### tree_packer_v21 (Alternative Optimizer)
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Features:
- Swap moves between trees
- Multi-angle restarts
- Higher temperature simulated annealing
- Squeeze, compaction, and local search phases
- Uses long double precision for accuracy

### fix_direction Post-Processing
**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

After optimization, rotate entire configuration to minimize bounding box:
```python
def optimize_rotation(trees):
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    res = minimize_scalar(
        lambda a: calculate_bbox_side_at_angle(a, hull_points),
        bounds=(0.001, 89.999), method='bounded'
    )
    return res.x, res.fun
```

### Backward Propagation (bp.cpp)
Improves smaller N configurations by removing trees from larger ones:
- Start from N=200, work down to N=2
- For each config, try removing boundary-touching trees
- If resulting (N-1) config is better than stored, save it

## Key Implementation Details

### ChristmasTree Class
```python
class ChristmasTree:
    def __init__(self, center_x='0', center_y='0', angle='0'):
        self.center_x = Decimal(center_x)
        self.center_y = Decimal(center_y)
        self.angle = Decimal(angle)
        
        initial_polygon = Polygon([
            (0.0, 0.8),      # Tip
            (0.125, 0.5),    # Right top tier
            (0.0625, 0.5),
            (0.2, 0.25),     # Right mid tier
            (0.1, 0.25),
            (0.35, 0.0),     # Right base
            (0.075, 0.0),    # Right trunk
            (0.075, -0.2),
            (-0.075, -0.2),  # Left trunk
            (-0.075, 0.0),
            (-0.35, 0.0),    # Left base
            (-0.1, 0.25),    # Left mid tier
            (-0.2, 0.25),
            (-0.0625, 0.5),  # Left top tier
            (-0.125, 0.5),
        ])
        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))
        self.polygon = affinity.translate(rotated, xoff=float(self.center_x), yoff=float(self.center_y))
```

### Overlap Detection
```python
from shapely.strtree import STRtree

def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

### Scoring Function
```python
def get_total_score(submission_df):
    total = 0
    for n in range(1, 201):
        trees = load_trees_for_n(submission_df, n)
        xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])
        side = max(xys.max(axis=0) - xys.min(axis=0))
        total += side**2 / n
    return total
```

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- id: `{n:03d}_{tree_index}` (e.g., 001_0, 002_0, 002_1)
- x, y, deg: prefixed with 's' to preserve precision
- Total rows: 20100 (1+2+3+...+200)

## Validation Checklist
1. No overlapping trees (use has_overlap function)
2. All coordinates within [-100, 100]
3. All 200 configurations present (20100 rows)
4. Values prefixed with 's' in submission

## External Datasets
Top kernels use pre-optimized submissions as starting points:
- "santa-2025-csv" - contains bbox3 binary and optimized CSV
- "bucket-of-chump" - another optimized starting point

## WHAT NOT TO TRY (Already Failed)
- Simple ensemble (santa-2025.csv dominates all N values)
- Short optimization runs (no improvements found)
- Standard backward propagation (no improvements found)
- Running optimizers on pre-optimized submission (local optimum is too tight)

## RECOMMENDED EXPERIMENT PIPELINE

### Experiment 1: Establish Baseline
1. Download pre-optimized submission (santa-2025.csv or bucket-of-chump)
2. Run fix_direction on it
3. Validate no overlaps
4. Submit to verify baseline score (~70.67)

### Experiment 2: Lattice Approach for Large N
1. Implement lattice-based packing for N >= 58
2. Start with 2 base trees, translate to create grid
3. Optimize base configuration and translation vectors
4. Compare with pre-optimized for each N, keep better

### Experiment 3: Focus on Small N (1-10)
1. For N=1, try all angles 0-360 in 0.001 increments
2. For N=2-10, exhaustive search for optimal configurations
3. These have highest score contribution per tree

### Experiment 4: Extended Optimization
1. Run bbox3 with -n 20000 -r 256 (hours, not minutes)
2. Use different random seeds
3. Apply perturbation to escape local optima

### Experiment 5: Greedy Construction from Scratch
1. Build solutions tree-by-tree (not from pre-optimized)
2. Use beam search with BEAM=10
3. For each N, try multiple construction strategies

## Key Insights
1. Symmetric solutions may be optimal for small N but asymmetric for large N
2. Trees tend to interlock with alternating orientations (0°, 90°, 180°, 270°)
3. Lattice-like patterns emerge in well-optimized configurations
4. The gap of 1.75 points requires reducing average side by ~0.053 units across all N
5. CV = LB for this optimization problem (no distribution shift)

## Reference Notebooks
- Getting started: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 optimizer: `../research/kernels/jazivxt_why-not/`
- fix_direction: `../research/kernels/saspav_santa-submission/`
- tree_packer_v21 + bp: `../research/kernels/smartmanoj_santa-claude/`
- Best-keeping runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
