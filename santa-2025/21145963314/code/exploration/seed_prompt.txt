# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D polygon packing optimization problem. The goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding box for each configuration of N trees (N=1 to 200).

**Scoring:** score = Σ(s_n² / n) for n=1 to 200, where s_n is the side length of the bounding square for n trees. Lower is better.

**Target Score:** Beat 68.919154

## Tree Geometry
Each Christmas tree is a 15-vertex polygon with:
- Trunk: width 0.15, height 0.2
- Base tier: width 0.7
- Middle tier: width 0.4
- Top tier: width 0.25
- Tip at y=0.8
- Total height: 1.0 (from trunk bottom at -0.2 to tip at 0.8)

The tree can be positioned (x, y) and rotated by angle (deg).

## Top Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (Primary Approach)
**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`

The bbox3.cpp optimizer is the core engine used by top solutions. Key features:
- Complex Number Vector Coordination for position calculations
- Fluid Dynamics simulation for tree movement
- Hinge Pivot mechanism for rotation optimization
- Density Gradient Flow for compaction
- Global Boundary Tension for edge optimization
- OpenMP parallelization for speed
- Aggressive overlap repair with separation vectors

**Key Parameters:**
- `-n <iterations>`: Number of optimization iterations (try 5000-20000)
- `-r <rounds>`: Number of rounds (try 16-256)

**Usage:**
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp
./bbox3 -n 10000 -r 64
```

### 2. tree_packer_v21 (Alternative Optimizer)
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Features:
- Swap moves between trees
- Multi-angle restarts
- Higher temperature simulated annealing
- Squeeze, compaction, and local search phases
- Uses long double precision for accuracy

### 3. fix_direction Post-Processing (CRITICAL)
**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

After optimization, apply rotation to the entire configuration to minimize bounding box:
```python
def optimize_rotation(trees):
    # Get convex hull of all tree vertices
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    # Find optimal rotation angle
    res = minimize_scalar(
        lambda a: calculate_bbox_side_at_angle(a, hull_points),
        bounds=(0.001, 89.999), method='bounded'
    )
    return res.x, res.fun
```

### 4. Backward Propagation (bp.cpp)
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Improves smaller N configurations by removing trees from larger ones:
- Start from N=200, work down to N=2
- For each config, try removing boundary-touching trees
- If resulting (N-1) config is better than stored, save it

## Recommended Experiment Pipeline

### Phase 1: Reproduce Best Kernel Score (~70-71)
1. Download pre-optimized submission from top kernel datasets
2. Run fix_direction on it
3. Validate no overlaps
4. Submit to verify baseline score

### Phase 2: Extended Optimization
1. Compile bbox3.cpp with OpenMP
2. Run with higher iterations: `./bbox3 -n 20000 -r 128`
3. Apply fix_direction post-processing (multiple passes)
4. Run backward propagation
5. Validate and submit

### Phase 3: Beat Target Score (< 68.919154)

**Per-N Optimization:**
- Calculate score contribution for each N: s_n² / n
- Identify N values with worst efficiency
- Focus optimization time on those specific configurations
- Small improvements on bad N values help more than good ones

**Multi-Start Strategy:**
- Run optimizer multiple times with different random seeds
- Keep best result for each N
- Combine best configurations from different runs

**Ensemble Approach:**
- Run both bbox3 and tree_packer_v21
- For each N, keep whichever gives smaller bounding box
- Apply fix_direction to final combined result

**Fine-Grained Position Adjustment:**
- After main optimization, try micro-adjustments (0.0001 units)
- Focus on boundary-touching trees
- Use gradient descent for final polish

**Per-Tree Rotation Optimization:**
- For each tree in a configuration, try small angle adjustments
- Keep changes that reduce bounding box without causing overlap

## Key Implementation Details

### ChristmasTree Class
```python
class ChristmasTree:
    def __init__(self, center_x='0', center_y='0', angle='0'):
        self.center_x = Decimal(center_x)
        self.center_y = Decimal(center_y)
        self.angle = Decimal(angle)
        
        # 15-vertex polygon definition
        initial_polygon = Polygon([
            (0.0, 0.8),      # Tip
            (0.125, 0.5),    # Right top tier
            (0.0625, 0.5),
            (0.2, 0.25),     # Right mid tier
            (0.1, 0.25),
            (0.35, 0.0),     # Right base
            (0.075, 0.0),    # Right trunk
            (0.075, -0.2),
            (-0.075, -0.2),  # Left trunk
            (-0.075, 0.0),
            (-0.35, 0.0),    # Left base
            (-0.1, 0.25),    # Left mid tier
            (-0.2, 0.25),
            (-0.0625, 0.5),  # Left top tier
            (-0.125, 0.5),
        ])
        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))
        self.polygon = affinity.translate(rotated, xoff=float(self.center_x), yoff=float(self.center_y))
```

### Overlap Detection
```python
from shapely.strtree import STRtree

def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

### Scoring Function
```python
def get_total_score(submission_df):
    total = 0
    for n in range(1, 201):
        trees = load_trees_for_n(submission_df, n)
        xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])
        side = max(xys.max(axis=0) - xys.min(axis=0))
        total += side**2 / n
    return total
```

### Overlap Repair
```python
def replace_group(target_file, donor_file, group_id, output_file):
    # Replace overlapping configuration with known-good one from donor
    header_t, groups_t = load_groups(target_file)
    header_d, groups_d = load_groups(donor_file)
    groups_t[group_id] = groups_d[group_id]
    save_groups(output_file, header_t, groups_t)
```

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- id: `{n:03d}_{tree_index}` (e.g., 001_0, 002_0, 002_1)
- x, y, deg: prefixed with 's' to preserve precision
- Total rows: 20100 (1+2+3+...+200)

## Validation Checklist
1. No overlapping trees (use has_overlap function)
2. All coordinates within [-100, 100]
3. All 200 configurations present (20100 rows)
4. Values prefixed with 's' in submission

## External Datasets
Top kernels use pre-optimized submissions as starting points:
- "santa-2025-csv" - contains bbox3 binary and optimized CSV
- "bucket-of-chump" - another optimized starting point
- Download these to use as baseline

## Optimization Time Budget
- Kaggle notebooks have ~12 hour limit
- bbox3 with -n 10000 -r 64 takes ~1-2 hours
- fix_direction takes ~10-15 minutes
- backward_propagation takes ~5-10 minutes
- Plan for multiple optimization passes

## Key Insights from Discussions
1. Symmetric solutions may be optimal for small N but asymmetric for large N
2. Focus optimization effort on N values with worst efficiency
3. The winning solutions likely use extensive compute time and multiple optimization passes
4. Lattice-like patterns emerge in well-optimized configurations
5. Trees tend to interlock with alternating orientations (0°, 90°, 180°, 270°)

## CRITICAL: Constructive Approaches for Breaking Local Optima

### 1. Greedy Backtracking with Beam Search
Pre-optimized solutions are at local optima. To escape:
- Build solutions tree-by-tree from scratch
- Use beam search to explore multiple paths
- Parameters: BEAM=10, DEPTH=10, MAX_STATES=4000

### 2. Random Initialization
- Generate completely new starting configurations
- Don't start from pre-optimized CSV
- Then apply optimization to the random starting point

### 3. Lattice-Based Approach for Large N
For large N (72, 100, 110, 144, 156, 196, 200):
- Use grid-based placement
- Start with two base trees and translate them in x and y directions
- Parameters: nt = [nx, ny] where nx*ny >= N
- This generates crystalline/lattice packings that can be tighter than random optimization

## Strategy to Beat Target
1. Start with best available pre-optimized submission
2. Run extended bbox3 optimization (-n 20000 -r 256)
3. Apply fix_direction multiple times
4. Run backward propagation
5. Identify worst N values and re-optimize them specifically
6. Ensemble results from multiple runs
7. Fine-tune boundary trees with micro-adjustments
8. Validate thoroughly before each submission

## Reference Notebooks
- Getting started: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 optimizer: `../research/kernels/jazivxt_why-not/`
- fix_direction: `../research/kernels/saspav_santa-submission/`
- tree_packer_v21 + bp: `../research/kernels/smartmanoj_santa-claude/`
- Best-keeping runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
