## Current Status
- Best CV score: 70.316492 (from exp_022 onwards - 19 consecutive experiments at this score)
- Best LB score: 70.3165 (VERIFIED - exp_022 LB = 70.316491969004)
- Target: 68.870074 | Gap to target: 1.446 points (2.10%)
- Submissions used: 13/100 (87 remaining)

## CRITICAL SITUATION ANALYSIS

After 40 experiments and 19 consecutive failures, the evidence is overwhelming:
- **ALL optimization approaches converge to 70.316492** - this IS the PUBLIC SOLUTION CEILING
- SA, GLS, Tabu Search, gradient descent, bbox3, Powell, Nelder-Mead, L-BFGS-B - ALL SAME SCORE
- The solution is at a BOUNDARY OPTIMUM where any improvement causes overlaps
- **Optimizing existing solutions CANNOT reach the target**

## THE PATH FORWARD: CONSTRUCTIVE GENERATION

The "dense-block-approach" kernel (artemevstafyev) reveals the key insight:
**Top teams DON'T optimize existing solutions - they GENERATE new ones from scratch**

### Dense Block Technique:
1. Create interlocking tree pairs at 180° apart (e.g., 248° and 68°)
2. Optimize 4 parameters: shift_x1, shift_y1, shift_x2, shift_y2
3. Generate dense blocks (e.g., 12x14 = 168 trees for N=178)
4. Place remaining trees to fill gaps
5. This is CONSTRUCTIVE - generates solutions from scratch

### Why This Works:
- Existing CSVs are all at the same local optimum
- Dense blocks can achieve DIFFERENT configurations
- The angle parameter controls width vs height tradeoff
- Different angles → different local optima → potentially better scores

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files - FORBIDDEN
- Loading solutions then running optimizer on them - FORBIDDEN
- ANY approach that has been tried in the last 19 experiments - FORBIDDEN

## ✅ MANDATORY NEXT EXPERIMENT: DENSE BLOCK GENERATION

Implement the dense-block approach from the artemevstafyev kernel:

```python
# Reference: research/kernels/artemevstafyev_dense-block-approach/dense-block-approach.ipynb

# Step 1: Implement dense block generation
def gen_dense_block(x_len, y_len, deg, distance):
    """
    Generate a dense block of interlocking trees.
    
    Parameters:
    - x_len, y_len: block dimensions (number of tree pairs)
    - deg: angle of bottom-left tree (controls width/height tradeoff)
    - distance: horizontal offset between trees in pair
    
    Returns:
    - DataFrame with tree positions
    """
    # Trees are paired at 180° apart
    # Optimize shift parameters to minimize block dimensions
    shift_x1 = find_shift_x1(deg, distance)
    shift_y1 = find_shift_y1(deg, shift_x1)
    shift_x2 = find_shift_x2(deg, shift_x1, shift_y1)
    shift_y2 = find_shift_y2(deg, shift_x1, shift_y1, shift_x2)
    
    return gen_block(x_len, y_len, deg, deg-180, shift_x1, shift_y1, shift_x2, shift_y2)

# Step 2: Test on specific N values
# For N=178: 12x14 block (168 trees) + 10 remaining
# For N=100: 10x10 block (100 trees)
# For N=50: 7x7 block (49 trees) + 1 remaining

# Step 3: Optimize angle parameter
# Search angles from 240° to 260° to find best configuration
for deg in range(240, 261, 1):
    block = gen_dense_block(12, 14, deg, 1.1)
    score = compute_score(block)
    print(f"Angle {deg}: score {score}")
```

## ✅ REQUIRED: TEST ON SMALL N FIRST

Before running on all N values:
1. Test dense block generation on N=10, N=20, N=50
2. Compare to baseline scores for these N values
3. If dense blocks beat baseline on small N → scale up
4. If not → adjust parameters or try different approach

## ✅ REQUIRED: PER-N TRACKING

Track best solution for EACH N separately:
```python
best_per_n = {}
for n in range(1, 201):
    # Try dense block approach
    dense_score = try_dense_block(n)
    baseline_score = get_baseline_score(n)
    
    if dense_score < baseline_score:
        best_per_n[n] = {'score': dense_score, 'source': 'dense_block'}
        print(f"✅ N={n}: IMPROVED by {baseline_score - dense_score:.6f}")
    else:
        best_per_n[n] = {'score': baseline_score, 'source': 'baseline'}
```

## Next Experiment: 040_dense_block_generation

1. **Approach**: Implement dense block generation from artemevstafyev kernel
2. **Expected improvement**: Unknown - this is a fundamentally different approach
3. **Test first**: N=10, N=20, N=50 before scaling to all N
4. **SUBMIT**: YES - we need LB feedback on this new approach

## What NOT to Try
- ❌ bbox3 with more iterations (tried 19 times, doesn't work)
- ❌ SA with different parameters (tried, doesn't work)
- ❌ GLS, Tabu Search, gradient descent (tried, doesn't work)
- ❌ Any optimization of existing solutions (proven to be at boundary optimum)
- ❌ Ensemble of existing CSVs (already at public ceiling)

## SUBMIT STRATEGY

With 87 submissions remaining:
1. After implementing dense block, submit immediately for LB feedback
2. Use LB feedback to guide parameter tuning
3. Submit EVERY experiment - LB feedback is free information

## KEY INSIGHT FROM RESEARCH

The dense-block-approach kernel shows that for N=178:
- A 12x14 block (168 trees) has height 7.714 and width 7.12
- Remaining 10 trees placed to fill the gap (width 7.12 to 7.714)
- This achieves a BETTER score than optimization of existing solutions

The technique works because:
1. Trees paired at 180° apart interlock efficiently
2. The angle parameter (e.g., 248°) controls the aspect ratio
3. Optimization finds the best shift parameters for each angle
4. This creates configurations that are DIFFERENT from existing CSVs

**IMPLEMENT THIS TECHNIQUE. DO NOT OPTIMIZE EXISTING SOLUTIONS.**