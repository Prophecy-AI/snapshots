{
  "query": "How to minimize square bounding box for 2D polygon packing with rotation?",
  "results": [
    {
      "title": "ANSWER",
      "text": "To obtain the smallest\u2011area **square** that can contain a set of 2\u2011D polygons (allowing each polygon to be rotated), follow these core steps\u202f\u2014\u202fall of which are supported by the cited sources:\n\n1. **Compute the convex hull of each polygon**  \n   The hull reduces the problem to the outermost vertices only; any interior points never affect the bounding box.  \n   *Use any standard hull algorithm (e.g., Graham scan or QuickHull).*  \n   ([Computing oriented minimum bounding boxes in 2D](https://geidav.wordpress.com/2014/01/23/computing-oriented-minimum-bounding-boxes-in-2d))\n\n2. **Apply the Rotating Calipers method to the hull**  \n   Rotate a pair of calipers around the hull, aligning one caliper with each hull edge in turn. For each orientation you obtain the axis\u2011aligned width\u202f\\(w\\) and height\u202f\\(h\\) of the minimal enclosing rectangle.  \n   This yields all candidate orientations in\u202f\\(O(n)\\) time.  \n   ([Computing oriented minimum bounding boxes in 2D](https://geidav.wordpress.com/2014/01/23/computing-oriented-minimum-bounding-boxes-in-2d))\n\n3. **Convert each candidate rectangle to a square**  \n   For the current orientation, set the square side length to  \n   \\[\n   s = \\max(w,\\,h)\n   \\]  \n   The square\u2019s area is \\(s^{2}\\). Record the orientation and side length.\n\n4. **Select the orientation with the minimal square area**  \n   Scan the list of squares produced in step\u202f3 and keep the one with the smallest \\(s^{2}\\). This orientation gives the optimal rotation for the polygon that yields the minimal\u2011area enclosing square.  \n   (The same \u201crotate\u2011and\u2011measure\u201d idea is described in the GIS\u2011StackExchange answer that iterates over angles and keeps the minimum area.)  \n   ([Finding minimum\u2011area\u2011rectangle for given points?](https://gis.stackexchange.com/questions/22895/finding-minimum-area-rectangle-for-given-points))\n\n5. **Place the polygon inside the optimal square**  \n   * Translate the polygon so that its centroid (or any chosen reference point) coincides with the square\u2019s centre.  \n   * Apply the optimal rotation found in step\u202f4.  \n   The polygon now fits inside the smallest possible square for the given set.\n\n**Summary** \u2013 Compute convex hull \u2192 rotate calipers to enumerate edge\u2011aligned orientations \u2192 for each orientation build the smallest square (side\u202f=\u202fmax(width, height)) \u2192 pick the orientation with the lowest square area \u2192 rotate and translate the polygon accordingly. This procedure yields the minimal square bounding box for 2\u2011D polygon packing with rotation.",
      "url": ""
    },
    {
      "title": "Computing oriented minimum bounding boxes in 2D",
      "text": "# Introduction\n\n_Oriented bounding boxes_ are an important tool for visibility testing and collision detection in computer graphics. In this post I want to talk about how to compute the oriented _minimum_ bounding box (OMBB) of an arbitrary polygon in two dimensions. As a polygon just enforces an ordering on a set of points (vertices), everything described in the following equally applies to simple point sets. _Minimum_ in this context refers to the area of the bounding box. A minimum oriented bounding box is also known as _smallest-area enclosing rectangle_. However, I will stick to the former term throughout this article as it is more frequently used in the computer graphics world.\n\nThe easiest way of computing a bounding box for a polygon is to determine the minimum and maximum ![x](https://s0.wp.com/latex.php?latex=x&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5)\u2013 and ![y](https://s0.wp.com/latex.php?latex=y&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5)\u2013 coordinates of its vertices. Such an _axis aligned bounding box_ (AABB) can be computed trivially but it\u2019s in most cases significantly bigger than the polygon\u2019s OMBB. Finding the OMBB requires some more work as the bounding box\u2019 area must be minimized, constrained by the location of the polygon\u2019s vertices. Look at the following figure for an illustration (AABB in blue, OMBB in red).\n\n![AABB vs OMBB](https://geidav.wordpress.com/wp-content/uploads/2014/01/aabb_vs_ombb.png?w=820)\n\nThe technique for computing OMBBs presented in the following consists of two detached steps. In the first step the _convex hull_ of the input polygon is computed. If the polygon is convex this step can be omitted because a convex polygon is equal to its convex hull. In the second step the _Rotating Calipers_ method is employed on the convex hull to compute the resulting OMBB. I will focus on the Rotating Calipers method because it\u2019s not very widely known in comparison to the numerous ways of computing convex hulls.\n\n# Convex hulls\n\nIn less mathematical but more illustrative terms the _convex hull_ of a set of ![n](https://s0.wp.com/latex.php?latex=n&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) points can be described as the closed polygonal chain of all outer points of the set, which entirely encloses all set elements. You can picture it as the shape of a rubber band stretched around all set elements. The convex hull of a set of two-dimensional points can be efficiently computed in ![O(n\\log n)](https://s0.wp.com/latex.php?latex=O%28n%5Clog+n%29&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5). In the figure below the convex hull of the vertices of a concave polygon is depicted.\n\n![Convex hull of vertices of concave polygon](https://geidav.wordpress.com/wp-content/uploads/2014/01/convex_hull2.png?w=820)\n\nThere are numerous algorithms for computing convex hulls: _Quick Hull_, _Gift Wrapping_ (also known as _Jarvis March_), _Graham\u2019s Algorithm_ and some more. I\u2019ve chosen the Gift Wrapping algorithm for my implementation because it\u2019s easy to implement and provides good performance in case ![n](https://s0.wp.com/latex.php?latex=n&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) is small or the polygon\u2019s convex hull contains only a few vertices. The runtime complexity is ![O(nh)](https://s0.wp.com/latex.php?latex=O%28nh%29&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5), where ![h](https://s0.wp.com/latex.php?latex=h&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) is the number of vertices in the convex hull. In the general case Gift Wrapping is outperformed by other algorithms. Especially, when all points are part of the convex hull. In that case the complexity degrades to ![O(n^2)](https://s0.wp.com/latex.php?latex=O%28n%5E2%29&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5).\n\nAs there are many good articles on the Gift Wrapping algorithm available online, I won\u2019t describe it another time here. Instead I want to focus on the lesser-known Rotating Calipers method for computing OMBBs. However, take care that your convex hull algorithm correctly handles collinear points. If multiple points lie on a convex hull edge, only the spanning points should end up in the convex hull.\n\n# Rotating Calipers\n\n_Rotating Calipers_ is a versatile method for solving a number of problems from the field of computational geometry. It resembles the idea of rotating a dynamically adjustable caliper around the outside of a polygon\u2019s convex hull. Originally, this method was invented to compute the diameter of convex polygons. Beyond that, it can be used to compute OMBBs, the minimum and maximum distance between two convex polygons, the intersection of convex polygons and many things more.\n\nThe idea of using the Rotating Calipers method for computing OMBBs is based on the following theorem, establishing a connection between the input polygon\u2019s convex hull and the orientation of the resulting OMBB. The theorem was proven in 1975 by Freeman and Shapira[1](https://geidav.wordpress.com/2014/01/23/computing-oriented-minimum-bounding-boxes-in-2d/#fn-1057-FreemanShapira1975):\n\n> The smallest-area enclosing rectangle of a polygon has a side collinear with one of the edges of its convex hull.\n\nThanks to this theorem the number of OMBB candidates is dramatically reduced to the number of convex hull edges. Thus, the complexity of the Rotating Calipers method is _linear_ if the convex hull is already available. If it isn\u2019t available the overall complexity is bound by the cost of computing the convex hull. An example of a set of OMBB candidates (red) for a convex hull (green) is depicted in the figure below. Note, that there are as many OMBB candidates as convex hull edges and each OMBB candidate has one side flush with one edge of the convex hull.\n\n![OMBB candidates](https://geidav.wordpress.com/wp-content/uploads/2014/01/ombb_candidates.png?w=820)\n\nTo determine the OMBB of a polygon, first, two orthogonally aligned pairs of parallel _supporting lines_ through the convex hull\u2019s _extreme points_ are created. The intersection of the four lines forms a rectangle. Next, the lines are simultaneously rotated about their supporting points until one line coincides with an edge of the convex hull. Each time an edge coincides, the four lines form another rectangle / OMBB candidate. This process is repeated until each convex hull edge once coincided with one of the four caliper lines. The resulting OMBB is the OMBB candidate with the smallest area. The entire algorithm is outlined step by step below.\n\n1. Compute the convex hull of the input polygon.\n2. Find the the extreme points ![p_\\text{min}=(x_\\text{min},y_\\text{min})^T](https://s0.wp.com/latex.php?latex=p_%5Ctext%7Bmin%7D%3D%28x_%5Ctext%7Bmin%7D%2Cy_%5Ctext%7Bmin%7D%29%5ET&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) and ![p_\\text{max}=(x_\\text{max},y_\\text{max})^T](https://s0.wp.com/latex.php?latex=p_%5Ctext%7Bmax%7D%3D%28x_%5Ctext%7Bmax%7D%2Cy_%5Ctext%7Bmax%7D%29%5ET&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) of the convex hull.\n3. Construct two vertical supporting lines at ![x_\\text{min}](https://s0.wp.com/latex.php?latex=x_%5Ctext%7Bmin%7D&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) and ![x_\\text{max}](https://s0.wp.com/latex.php?latex=x_%5Ctext%7Bmax%7D&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) and two horizontal ones at ![y_\\text{min}](https://s0.wp.com/latex.php?latex=y_%5Ctext%7Bmin%7D&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) and ![y_\\text{max}](https://s0.wp.com/latex.php?latex=y_%5Ctext%7Bmax%7D&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5).\n4. Initialize the current minimum rectangle area ![A_\\text{min}=\\infty](https://s0.wp.com/latex.php?latex=A_%5Ctext%7Bmin%7D%3D%5Cinfty&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5).\n5. Rotate the supporting lines until one coincides with an edge of the convex hull.\n1. Compute the area ![A](https://s0.wp.com/latex.php?latex=A&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) of the current rectangle.\n2. Update the minimum area and store the current rectangle if ![A<A_\\text{min}](https://s...",
      "url": "https://geidav.wordpress.com/2014/01/23/computing-oriented-minimum-bounding-boxes-in-2d"
    },
    {
      "title": "Finding minimum-area-rectangle for given points?",
      "text": "**Teams**\n\nQ&A for work\n\nConnect and share knowledge within a single location that is structured and easy to search.\n\n[Learn more about Teams](https://stackoverflow.co/teams/)\n\n# [Finding minimum-area-rectangle for given points?](https://gis.stackexchange.com/questions/22895/finding-minimum-area-rectangle-for-given-points)\n\n[Ask Question](https://gis.stackexchange.com/questions/ask)\n\nAsked13 years, 4 months ago\n\nModified [2 years, 1 month ago](https://gis.stackexchange.com/gis.stackexchange.com?lastactivity)\n\nViewed\n130k times\n\n98\n\nAs you see in the figure, the question is:\n\n**How to find the minimum-area-rectangle (MAR) fitted on the given points?**\n\nand a supporting question is:\n\n**Is there any analytical solution for the problem?**\n\n_(A development of the question will be to fit a box (3D) to a cluster of points in a 3D point cloud.)_\n\nAs a first stage I propose to find the convex-hull for the points which reforms the problem (by removing those points are not involved in the solution) to:\n**fitting a MAR to a polygon.**\nThe required method will provide X ( _center of rectangle_), D ( _two dimensions_) and A ( _angle_).\n\nMy proposal for solution:\n\n- Find the centroid of the polygon (see [Finding center of geometry of object?](https://gis.stackexchange.com/questions/22739/how-to-find-the-center-of-geometry-of-an-object))\n- **\\[S\\]** Fit a simple fitted rectangle i.e., parallel to the axes X and Y\n  - you may use `minmax` function for X and Y of the given points (e.g., polygon's vertices)\n- Store the area of the fitted rectangle\n- Rotate the polygon about the centroid by e.g., 1 degree\n- Repeat from **\\[S\\]** until a full rotation done\n- Report the angle of the minimum area as the result\n\nIt looks to me promising, however the following problems exist:\n\n- choose of a good resolution for the angle change could be challenging,\n- the computation cost is high,\n- the solution is not analytical but experimental.\n\n- [geometry](https://gis.stackexchange.com/questions/tagged/geometry)\n- [3d](https://gis.stackexchange.com/questions/tagged/3d)\n- [algorithm](https://gis.stackexchange.com/questions/tagged/algorithm)\n- [extents](https://gis.stackexchange.com/questions/tagged/extents)\n- [convex-hull](https://gis.stackexchange.com/questions/tagged/convex-hull)\n\n[Share](https://gis.stackexchange.com/q/22895)\n\n[Improve this question](https://gis.stackexchange.com/posts/22895/edit)\n\nFollow\n\n[edited Apr 13, 2017 at 12:34](https://gis.stackexchange.com/posts/22895/revisions)\n\n[Community](https://gis.stackexchange.com/users/-1/community) Bot\n\n1\n\nasked Apr 5, 2012 at 8:03\n\n[Developer](https://gis.stackexchange.com/users/4537/developer) Developer\n\n3,42744 gold badges3131 silver badges3434 bronze badges\n\n0\n\n[Add a comment](https://gis.stackexchange.com/gis.stackexchange.com)\u00a0\\|\n\n## 8 Answers 8\n\nSorted by:\n[Reset to default](https://gis.stackexchange.com/questions/22895/finding-minimum-area-rectangle-for-given-points?answertab=scoredesc#tab-top)\n\nHighest score (default)Date modified (newest first)Date created (oldest first)\n\n62\n\nYes, there is an analytical solution for this problem. The algorithm you are looking for is known in [polygon generalisation](https://gis.stackexchange.com/questions/3739/generalisation-strategies-for-building-outlines/3756#3756) as \"smallest surrounding rectangle\".\n\nThe algorithm you describe is fine but in order to solve the problems you have listed, you can use the fact that **the orientation of the MAR is the same as the one of the edges of the point cloud convex hull**. So you just need to test the orientations of the convex hull edges. You should:\n\n- Compute the convex hull of the cloud.\n- For each edge of the convex hull:\n- compute the edge orientation (with arctan),\n- rotate the convex hull using this orientation in order to compute easily the bounding rectangle area with min/max of x/y of the rotated convex hull,\n- Store the orientation corresponding to the minimum area found,\n- Return the rectangle corresponding to the minimum area found.\n\nAn example of implementation in java is available [there](http://sourceforge.net/p/opencarto/code/HEAD/tree/trunk/server/src/main/java/org/opencarto/algo/base/SmallestSurroundingRectangle.java).\n\nIn 3D, the same applies, except:\n\n- The convex hull will be a volume,\n- The orientations tested will be the orientations (in 3D) of the convex hull faces.\n\nGood luck!\n\n[Share](https://gis.stackexchange.com/a/22904)\n\n[Improve this answer](https://gis.stackexchange.com/posts/22904/edit)\n\nFollow\n\n[edited Dec 20, 2022 at 12:25](https://gis.stackexchange.com/posts/22904/revisions)\n\n[Kadir \u015eahbaz](https://gis.stackexchange.com/users/29431/kadir-%c5%9eahbaz)\n\n78.5k5757 gold badges260260 silver badges407407 bronze badges\n\nanswered Apr 5, 2012 at 10:18\n\n[julien](https://gis.stackexchange.com/users/162/julien) julien\n\n10.3k66 gold badges5757 silver badges9595 bronze badges\n\n10\n\n- 13\n\n+1 Very nice answer! I would like to point out that actual rotation of the cloud is unnecessary. First--you probably meant this--only the vertices of the hull have to be considered. Second, instead of rotating, represent the current side as a pair of orthogonal unit vectors. Taking their dot products with the hull vertex coordinates (which could be done as a single matrix operation) gives the rotated coordinates: no trigonometry necessary, fast, and perfectly accurate.\n\n\u2013\u00a0[whuber](https://gis.stackexchange.com/users/664/whuber)\n\nCommentedApr 5, 2012 at 15:01\n\n- 4\n\nThanks for the links. Indeed, rotating only for # of edges makes the proposed method very efficient. I could find the paper proves that. Although I marked this as the answer for loyalty to the first good answer (cannot choose two/more great answers :( ) I would like to recommend strongly considering **whuber's** complete answer below. The efficiency of the given method there (avoiding rotations!) is incredible, and the whole procedure is only a few lines of code. To me it is readily translatable to Python :)\n\n\u2013\u00a0[Developer](https://gis.stackexchange.com/users/4537/developer)\n\nCommentedApr 6, 2012 at 0:56\n\n- 2\n\nNote that the extension into 3D is a bit more complicated than that. Each face of the 3D convex hull defines a possible orientation of _one face_ of the bounding box, but not the orientation of faces perpendicular to it. The problem of how to rotate the box in that plane becomes the 2D minimum-bounding-rectangle problem in the plane of that face. For each edge of the convex hull of the cloud projected onto a given plane you can draw a bounding box which will give you a different volume in 3D.\n\n\u2013\u00a0[Will](https://gis.stackexchange.com/users/110535/will)\n\nCommentedDec 5, 2017 at 11:12\n\n- 1\n\n@julien Do you know of a way to solve the \"minimum bounding _square_\" problem? In that case it seems the \"the orientation of the MAR is the same as the one of one of the edges\" assumption no longer holds.\n\n\u2013\u00a0[Thomas Ahle](https://gis.stackexchange.com/users/24502/thomas-ahle)\n\nCommentedJul 12, 2022 at 19:58\n\n- 1\n\n@ThomasAhle Indeed ! Already for a triangle, the problem does not seem obvious. Maybe something to think about this summer !\n\n\u2013\u00a0[julien](https://gis.stackexchange.com/users/162/julien)\n\nCommentedJul 14, 2022 at 7:17\n\n\n\\|\u00a0[Show **5** more comments](https://gis.stackexchange.com/gis.stackexchange.com)\n\n55\n\n**To supplement @julien's great solution,** here is a working implementation in `R`, which could serve as pseudocode to guide any GIS-specific implementation (or be applied directly in `R`, of course). Input is an array of point coordinates. Output (the value of `mbr`) is an array of the vertices of the minimum bounding rectangle (with the first one repeated to close it). Note the complete absence of any trigonometric calculations.\n\n```\nMBR <- function(p) {\n  # Analyze the convex hull edges\n  a <- chull(p)                                   # Indexes of extremal points\n  a <- c(a, a[1])                                 # Close the loop\n  e <- p[a[-1],] - p[a[-length(a)], ]             # Ed...",
      "url": "https://gis.stackexchange.com/questions/22895/finding-minimum-area-rectangle-for-given-points"
    },
    {
      "title": "Calculating the Bounding Rectangle at an Angle of a Polygon",
      "text": "##### Collectives\u2122 on Stack Overflow\n\nFind centralized, trusted content and collaborate around the technologies you use most.\n\n[Learn more about Collectives](https://stackoverflow.com/collectives)\n\n**Teams**\n\nQ&A for work\n\nConnect and share knowledge within a single location that is structured and easy to search.\n\n[Learn more about Teams](https://stackoverflow.co/teams/)\n\nGet early access and see previews of new features.\n\n[Learn more about Labs](https://stackoverflow.co/labs/)\n\n# [Calculating the Bounding Rectangle at an Angle of a Polygon](https://stackoverflow.com/questions/889596/calculating-the-bounding-rectangle-at-an-angle-of-a-polygon)\n\n[Ask Question](https://stackoverflow.com/questions/ask)\n\nAsked15 years, 1 month ago\n\nModified [3 years, 11 months ago](https://stackoverflow.com/questions/889596/calculating-the-bounding-rectangle-at-an-angle-of-a-polygon?lastactivity)\n\nViewed\n6k times\n\n7\n\nI have the need to determine the bounding rectangle for a polygon at an arbitrary angle. This picture illustrates what I need to do:\n\n[alt text http://kevlar.net/RotatedBoundingRectangle.png](http://kevlar.net/RotatedBoundingRectangle.png)\n\nThe pink rectangle is what I need to determine at various angles for simple 2d polygons.\n\nAny solutions are much appreciated!\n\n**Edit:**\n\nThanks for the answers, I got it working once I got the center points correct. You guys are awesome!\n\n- [algorithm](https://stackoverflow.com/questions/tagged/algorithm)\n- [graphics](https://stackoverflow.com/questions/tagged/graphics)\n- [geometry](https://stackoverflow.com/questions/tagged/geometry)\n\n[Share](https://stackoverflow.com/q/889596)\n\n[Improve this question](https://stackoverflow.com/posts/889596/edit)\n\nFollow\n\n[edited May 20, 2009 at 19:44](https://stackoverflow.com/posts/889596/revisions)\n\nkevin42\n\nasked May 20, 2009 at 18:53\n\n[![kevin42's user avatar](https://www.gravatar.com/avatar/e2e15ff996a485e7c68d53fdc0d64478?s=64&d=identicon&r=PG)](https://stackoverflow.com/users/10705/kevin42)\n\n[kevin42](https://stackoverflow.com/users/10705/kevin42) kevin42\n\n2,10833 gold badges2222 silver badges2121 bronze badges\n\n4\n\n- By \"various angles\" do you mean the bounding rectangle has to be at a certain angle, or the shape inside has to be at a certain angle?\n\n\u2013\u00a0[Welbog](https://stackoverflow.com/users/52443/welbog)\n\nCommentedMay 20, 2009 at 18:55\n\n- You'll have to fix some angles here else there are multiple solutions.\n\n\u2013\u00a0[Glenn](https://stackoverflow.com/users/29771/glenn)\n\nCommentedMay 20, 2009 at 18:58\n\n- The angle of the bounding rectangle is what varies. I've thought about rotating the polygon in the reverse direction, then fitting a rectangle around it, and rotating the points of the rectangle back, but I think I'm getting messed up by identifying the center points correctly.\n\n\u2013\u00a0[kevin42](https://stackoverflow.com/users/10705/kevin42)\n\nCommentedMay 20, 2009 at 19:01\n\n- Just rotate both about 0,0. You don't need the center point\n\n\u2013\u00a0[Matthias Wandel](https://stackoverflow.com/users/20073/matthias-wandel)\n\nCommentedMay 20, 2009 at 19:15\n\n\n[Add a comment](https://stackoverflow.com/questions/889596/calculating-the-bounding-rectangle-at-an-angle-of-a-polygon)\u00a0\\|\n\n## 5 Answers 5\n\nSorted by:\n[Reset to default](https://stackoverflow.com/questions/889596/calculating-the-bounding-rectangle-at-an-angle-of-a-polygon?answertab=scoredesc#tab-top)\n\nHighest score (default)Trending (recent votes count more)Date modified (newest first)Date created (oldest first)\n\n8\n\nTo get a bounding box with a certain angle, rotate the polygon the other way round by that angle. Then you can use the min/max x/y coordinates to get a simple bounding box and rotate that by the angle to get your final result.\n\nFrom your comment it seems you have problems with getting the center point of the polygon. The center of a polygon should be the average of the coordinate sums of each point. So for points P1,...,PN, calculate:\n\n```\nxsum = p1.x + ... + pn.x;\nysum = p1.y + ... + pn.y;\nxcenter = xsum / n;\nycenter = ysum / n;\n\n```\n\nTo make this complete, I also add some formulas for the rotation involved. To rotate a point (x,y) around a center point (cx, cy), do the following:\n\n```\n// Translate center to (0,0)\nxt = x - cx;\nyt = y - cy;\n// Rotate by angle alpha (make sure to convert alpha to radians if needed)\nxr = xt * cos(alpha) - yt * sin(alpha);\nyr = xt * sin(alpha) + yt * cos(alpha);\n// Translate back to (cx, cy)\nresult.x = xr + cx;\nresult.y = yr + cx;\n\n```\n\n[Share](https://stackoverflow.com/a/889626)\n\n[Improve this answer](https://stackoverflow.com/posts/889626/edit)\n\nFollow\n\n[edited May 20, 2009 at 20:15](https://stackoverflow.com/posts/889626/revisions)\n\nanswered May 20, 2009 at 18:59\n\n[![schnaader's user avatar](https://www.gravatar.com/avatar/d21d33ac8f67242d2c1dd61c8696d358?s=64&d=identicon&r=PG)](https://stackoverflow.com/users/34065/schnaader)\n\n[schnaader](https://stackoverflow.com/users/34065/schnaader) schnaader\n\n49.5k1010 gold badges106106 silver badges139139 bronze badges\n\n7\n\n- Beat me to the centre-point calculation. +1 for having the right answer.\n\n\u2013\u00a0[Welbog](https://stackoverflow.com/users/52443/welbog)\n\nCommentedMay 20, 2009 at 19:08\n\n- For this algorithm, does it matter what point you rotate about?\n\n\u2013\u00a0[Emmett](https://stackoverflow.com/users/2749/emmett)\n\nCommentedMay 20, 2009 at 19:14\n\n- No, it doesn't matter if you just want to know the size of the bounding box, but it will help with the placement of the bounding box around the polygon.\n\n\u2013\u00a0[schnaader](https://stackoverflow.com/users/34065/schnaader)\n\nCommentedMay 20, 2009 at 19:18\n\n- 3\n\n\n\n\n\nEven for bounding box placement, it seems like as long as you rotate the box & shape back around the same point once you've placed it, it'll work.\n\n\u2013\u00a0[Emmett](https://stackoverflow.com/users/2749/emmett)\n\nCommentedMay 20, 2009 at 19:21\n\n- I think your yr = yt \\* sin(alpha) + yt \\* cos(alpha); is wrong, don't you want it to be: yr = xt \\* sin(alpha) + yt \\* cos(alpha); ?\n\n\u2013\u00a0[kevin42](https://stackoverflow.com/users/10705/kevin42)\n\nCommentedMay 20, 2009 at 19:41\n\n\n\\|\u00a0[Show **2** more comments](https://stackoverflow.com/questions/889596/calculating-the-bounding-rectangle-at-an-angle-of-a-polygon)\n\n3\n\nTo get the smallest rectangle you should get the right angle. This can acomplished by an algorithm used in collision detection: oriented bounding boxes.\nThe basic steps:\n\nGet all vertices cordinates\n\nBuild a covariance matrix\n\nFind the eigenvalues\n\nProject all the vertices in the eigenvalue space\n\nFind max and min in every eigenvalue space.\n\nFor more information just google OBB \"colision detection\"\n\nPs: If you just project all vertices and find maximum and minimum you're making AABB (axis aligned bounding box). Its easier and requires less computational effort, but doesn't guarantee the minimum box.\n\n[Share](https://stackoverflow.com/a/889692)\n\n[Improve this answer](https://stackoverflow.com/posts/889692/edit)\n\nFollow\n\n[edited May 20, 2009 at 19:14](https://stackoverflow.com/posts/889692/revisions)\n\n[![ChrisF's user avatar](https://i.sstatic.net/gIt1g.png?s=64)](https://stackoverflow.com/users/59303/chrisf)\n\n[ChrisF](https://stackoverflow.com/users/59303/chrisf) \u2666\n\n136k3131 gold badges261261 silver badges332332 bronze badges\n\nanswered May 20, 2009 at 19:12\n\n[![RMAAlmeida's user avatar](https://www.gravatar.com/avatar/2364d2eda12be1d1e5618d3c1371e326?s=64&d=identicon&r=PG)](https://stackoverflow.com/users/96003/rmaalmeida)\n\n[RMAAlmeida](https://stackoverflow.com/users/96003/rmaalmeida) RMAAlmeida\n\n30433 silver badges1313 bronze badges\n\n[Add a comment](https://stackoverflow.com/questions/889596/calculating-the-bounding-rectangle-at-an-angle-of-a-polygon)\u00a0\\|\n\n2\n\nI'm interpreting your question to mean \"For a given 2D polygon, how do you calculate the position of a bounding rectangle for which the angle of orientation is predetermined?\"\n\nAnd I would do it by rotating the polygon against the angle of orientation, then use a simple search for its maximum and minimum points in the two ca...",
      "url": "https://stackoverflow.com/questions/889596/calculating-the-bounding-rectangle-at-an-angle-of-a-polygon"
    },
    {
      "title": "Mastering Minimum Bounding Box",
      "text": "# Mastering Minimum Bounding Box\n\nA Comprehensive Guide to Computational Geometry's Essential Concept\n\nSarah Lee\nAI generatedLlama-4-Maverick-17B-128E-Instruct-FP8 8 min read\u00b7 June 14, 2025\n\n28 views\n\nPhoto by [Steve Johnson](https://unsplash.com/@steve_j?utm_source=numberanalytics&utm_medium=referral) on\n[Unsplash](https://unsplash.com?utm_source=numberanalytics&utm_medium=referral)\n\n## Introduction to Minimum Bounding Box\n\nThe Minimum Bounding Box (MBB) is a fundamental concept in Computational Geometry, playing a crucial role in various applications across multiple disciplines. In this guide, we'll explore the definition, importance, and applications of MBB, as well as delve into the algorithms and implementation details.\n\n### Definition and Importance of Minimum Bounding Box\n\nThe Minimum Bounding Box of a set of 2D or 3D objects is the smallest rectangle or cuboid that completely encloses all the objects. It is a compact representation that captures the spatial extent of the objects, making it an essential tool in various geometric computations.\n\nMathematically, given a set of points ${p\\_i}$ in $\\\\mathbb{R}^d$, the MBB is the box with the minimum volume that contains all the points. For a 2D set of points, the MBB can be represented as a rectangle with the minimum area.\n\nThe MBB is important because it provides a simple and efficient way to:\n\n- Approximate the shape and size of complex objects\n- Perform collision detection and proximity queries\n- Index and query large datasets in spatial databases\n- Optimize rendering and visibility culling in computer graphics\n\n### Applications in Various Fields\n\nThe Minimum Bounding Box has numerous applications across various fields, including:\n\n- **Computer-Aided Design (CAD)**: MBB is used to compute the bounding box of complex CAD models, facilitating tasks like collision detection and model optimization.\n- **Geographic Information Systems (GIS)**: MBB is used to index and query large spatial datasets, such as maps and satellite imagery.\n- **Robotics and Computer Vision**: MBB is used to detect and track objects, as well as to perform scene understanding and reconstruction.\n- **Game Development**: MBB is used to optimize rendering and collision detection in games.\n\n### Overview of the Guide\n\nIn this comprehensive guide, we'll cover the following topics:\n\n1. Algorithms for computing the Minimum Bounding Box\n2. Implementing MBB in various programming languages\n3. Optimizations and special cases to consider\n4. Common pitfalls and debugging techniques\n\n## Algorithms for Computing Minimum Bounding Box\n\nSeveral algorithms exist for computing the Minimum Bounding Box, each with its strengths and weaknesses. We'll explore the Rotating Calipers algorithm and the Convex Hull algorithm, two popular methods for computing MBB.\n\n### Rotating Calipers Algorithm\n\nThe Rotating Calipers algorithm is a popular method for computing the MBB of a 2D convex polygon. The algorithm works by maintaining a pair of parallel lines (calipers) that are rotated around the polygon, keeping track of the minimum and maximum projections of the polygon vertices onto the lines.\n\nThe algorithm can be broken down into the following steps:\n\n1. Compute the convex hull of the input polygon\n2. Initialize the calipers to be parallel to the x-axis\n3. Rotate the calipers around the polygon, updating the minimum and maximum projections\n4. Keep track of the minimum area rectangle encountered during the rotation\n\nThe Rotating Calipers algorithm has a time complexity of $O(n)$, where $n$ is the number of vertices in the convex hull.\n\n### Convex Hull Algorithm\n\nThe Convex Hull algorithm is another popular method for computing the MBB. The algorithm works by computing the convex hull of the input points and then finding the minimum area rectangle that encloses the hull.\n\nThe algorithm can be broken down into the following steps:\n\n1. Compute the convex hull of the input points using an algorithm like Graham's Scan or Chan's Algorithm\n2. Iterate over the edges of the convex hull to find the minimum area rectangle\n\nThe Convex Hull algorithm has a time complexity of $O(n \\\\log n)$, where $n$ is the number of input points.\n\n### Comparison of Different Algorithms\n\n| Algorithm | Time Complexity | Applicability |\n| --- | --- | --- |\n| Rotating Calipers | $O(n)$ | 2D convex polygons |\n| Convex Hull | $O(n \\\\log n)$ | 2D and 3D point sets |\n\nThe choice of algorithm depends on the specific use case and the characteristics of the input data. For 2D convex polygons, the Rotating Calipers algorithm is generally faster and more efficient. For 3D point sets or non-convex polygons, the Convex Hull algorithm is a better choice.\n\n## Implementing Minimum Bounding Box\n\nImplementing the Minimum Bounding Box algorithm requires careful consideration of several factors, including the choice of programming language, data structures, and optimizations.\n\n### Code Examples in Various Programming Languages\n\nHere are some code examples in different programming languages:\n\n#### Python\n\n````\nimport numpy as np\n\ndef rotating_calipers(points):\n    # Compute convex hull\n    hull = convex_hull(points)\n\n    # Initialize calipers\n    min_area = float('inf')\n    min_box = None\n\n    for i in range(len(hull)):\n        # Rotate calipers\n        p1, p2 = hull[i], hull[(i+1) % len(hull)]\n        area, box = compute_box(p1, p2, hull)\n        if area < min_area:\n            min_area = area\n            min_box = box\n\n    return min_box\n\n#### C++\n```cpp\n#include <vector>\n#include <algorithm>\n\nstruct Point {\n    double x, y;\n};\n\nstd::vector<Point> convexHull(std::vector<Point>& points) {\n    // Implement convex hull algorithm\n}\n\nstd::vector<Point> rotatingCalipers(std::vector<Point>& points) {\n    // Compute convex hull\n    std::vector<Point> hull = convexHull(points);\n\n    // Initialize calipers\n    double minArea = std::numeric_limits<double>::max();\n    std::vector<Point> minBox;\n\n    for (size_t i = 0; i < hull.size(); ++i) {\n        // Rotate calipers\n        Point p1 = hull[i], p2 = hull[(i+1) % hull.size()];\n        double area;\n        std::vector<Point> box = computeBox(p1, p2, hull, area);\n        if (area < minArea) {\n            minArea = area;\n            minBox = box;\n        }\n    }\n\n    return minBox;\n}\n\n### Optimizations and Special Cases\nSeveral optimizations and special cases can be considered when implementing the MBB algorithm:\n* **Early termination**: If the input polygon is already a rectangle, the algorithm can terminate early.\n* **Simplification**: Simplifying the input polygon or point set can reduce the computational complexity.\n* **Caching**: Caching the results of expensive computations can improve performance.\n\n### Common Pitfalls and Debugging Techniques\nSome common pitfalls to watch out for when implementing the MBB algorithm include:\n* **Numerical instability**: Care should be taken to avoid numerical instability when computing the convex hull or rotating calipers.\n* **Edge cases**: The algorithm should be tested on edge cases, such as degenerate polygons or point sets.\n* **Input validation**: The input data should be validated to ensure it is correct and consistent.\n\nTo debug the algorithm, techniques like visualization and logging can be employed to identify issues and understand the algorithm's behavior.\n\n### Visualizing the Algorithm\nThe following Mermaid diagram illustrates the Rotating Calipers algorithm:\n\n````\n\n```\ngraph LR;\n    A[\"Compute Convex Hull\"] --> B[\"Initialize Calipers\"];\n    B --> C[\"Rotate Calipers\"];\n    C --> D[\"Update Minimum Area Rectangle\"];\n    D --> C;\n    C --> E[\"Return Minimum Bounding Box\"];\n\n```\n\n## Conclusion\n\nThe Minimum Bounding Box is a fundamental concept in Computational Geometry with numerous applications across various fields. By understanding the algorithms and implementation details, developers can effectively utilize MBB in their applications. This guide has provided a comprehensive overview of the MBB algorithm, including its def...",
      "url": "https://www.numberanalytics.com/blog/ultimate-guide-minimum-bounding-box-computational-geometry"
    },
    {
      "title": "A lower bound for the non-oriented two-dimensional bin packing problem",
      "text": "[Skip to main content](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#screen-reader-main-content) [Skip to article](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#screen-reader-main-title)\n\n- [View\u00a0**PDF**](https://www.sciencedirect.com/science/article/pii/S0166218X01002530/pdfft?md5=55b7c0ad8f7598120fab50a56874169d&pid=1-s2.0-S0166218X01002530-main.pdf)\n- Download full issue\n\nSearch ScienceDirect\n\n## Outline\n\n1. [Abstract](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#aep-abstract-id6)\n2. [Keywords](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#aep-keywords-id8)\n3. [1\\. Introduction](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#aep-section-id9)\n4. [2\\. Lower bounds](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#aep-section-id10)\n5. [3\\. A branch-and-bound algorithm](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#SEC3)\n6. [4\\. Computational experiments](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#SEC4)\n7. [Acknowledgements](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#aep-acknowledgment-id20)\n8. [References](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#aep-bibliography-id21)\n\n## [Cited by (55)](https://www.sciencedirect.com/science/article/pii/S0166218X01002530\\#section-cited-by)\n\n## Figures (2)\n\n1. [![Fig. 1. (a) cutting produced by CUTSQ; (b) cutting with minimum number of squares](https://ars.els-cdn.com/content/image/1-s2.0-S0166218X01002530-gr1.sml)](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#FIG1)\n2. [![Fig. 2. The item subsets of Definition 1](https://ars.els-cdn.com/content/image/1-s2.0-S0166218X01002530-gr2.sml)](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#FIG2)\n\n## Tables (4)\n\n1. [Table](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#aep-table-id11)\n2. [Table 1](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#TBL1)\n3. [Table 2](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#TBL2)\n4. [Table 3](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#TBL3)\n\n[![Elsevier](https://sdfestaticassets-us-east-1.sciencedirectassets.com/prod/558f6b3505d331efa27a89a25731aa712b0662a4/image/elsevier-non-solus.png)](https://www.sciencedirect.com/journal/discrete-applied-mathematics)\n\n## [Discrete Applied Mathematics](https://www.sciencedirect.com/journal/discrete-applied-mathematics)\n\n[Volume 118, Issues 1\u20132](https://www.sciencedirect.com/journal/discrete-applied-mathematics/vol/118/issue/1), 15 April 2002, Pages 13-24\n\n[![Discrete Applied Mathematics](https://ars.els-cdn.com/content/image/S0166218X.gif)](https://www.sciencedirect.com/journal/discrete-applied-mathematics/vol/118/issue/1)\n\n# A lower bound for the non-oriented two-dimensional bin packing problem\n\nAuthor links open overlay panelMauroDell'Amicoa, SilvanoMartellob, DanieleVigob\n\nShow more\n\nOutline\n\nAdd to Mendeley\n\nShare\n\nCite\n\n[https://doi.org/10.1016/S0166-218X(01)00253-0](https://doi.org/10.1016/S0166-218X(01)00253-0) [Get rights and content](https://s100.copyright.com/AppDispatchServlet?publisherName=ELS&contentID=S0166218X01002530&orderBeanReset=true)\n\nUnder an Elsevier [user license](http://www.elsevier.com/open-access/userlicense/1.0/)\n\nopen archive\n\n## Abstract\n\nGiven a set of rectangular items, and an unlimited number of identical rectangular bins, we consider the problem of allocating, without overlapping, all the items to the minimum number of bins. We assume that the items may be rotated by 90\u00b0. The problem is strongly NP-hard, and has several industrial applications. No specific lower bound is known for it. We present a lower bound which explicitly takes into account the possible item rotation. The bound is embedded into an exact branch-and-bound algorithm. The average performance is evaluated through computational experiments.\n\n- [Previous article in issue](https://www.sciencedirect.com/science/article/pii/S0166218X01002529)\n- [Next article in issue](https://www.sciencedirect.com/science/article/pii/S0166218X01002542)\n\n## Keywords\n\nCutting and packing\n\nLower bound\n\nBranch-and-bound\n\n## 1\\. Introduction\n\nGiven a set of _n_ rectangular _items_, each characterized by width _w_ _j_ and height _h_ _j_ ( _j_ =1,\u2026, _n_), and an unlimited number of identical rectangular _bins_, having width _W_ and height _H_, the general two-dimensional bin packing problem is to allocate, without overlapping, all the _n_ items to the minimum number of bins. Variants arise in practical contexts, according to specific technological requirements. In this paper, we consider the case where rotation of the items by 90\u00b0 is allowed, known as _Non-Oriented Two-Dimensional Bin Packing Problem_ and denoted as 2BP\\|R\\|F in the typology introduced by Lodi et al. [\\[9\\]](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#BIB9). The problem arises in several practical contexts: cutting of wood, metal or glass from standardized stock pieces when the items to be cut have no texture or decoration, packing of box bases on shelves or truck beds, and so on.\n\nThe problem is NP-hard in the strong sense, as it generalizes the well-known one-dimensional bin packing problem. Heuristic algorithms for 2BP\\|R\\|F have been presented by Bengtsson [\\[2\\]](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#BIB2), El-Bouri et al. [\\[6\\]](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#BIB6) and Lodi et al. [\\[9\\]](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#BIB9). Surveys on cutting and packing problems have been given by Dyckhoff and Finke [\\[4\\]](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#BIB4) and Dowsland and Dowsland [\\[3\\]](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#BIB3), and an annotated bibliography by Dyckhoff et al. [\\[5\\]](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#BIB5).\n\nApart from the trivial continuous lower bound, which does not take into account the possibility of rotating the items, to our knowledge no specific lower bound is known for 2BP\\|R\\|F (while lower bounds for the case where rotation is not allowed have been given by Martello and Vigo [\\[11\\]](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#BIB11) and by Fekete and Schepers [\\[7\\]](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#BIB7)). The main results that we present here are a specifically tailored relaxation and a new lower bound on the corresponding solution value. Since our relaxation is based on decomposition of the items into squares, these results are also useful in the special cases where the problem is to pack squares (see, e.g., [\\[1\\]](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#BIB1), [\\[8\\]](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#BIB8)). In the next section, we describe the relaxation, discuss some implementation details and introduce the lower bound. In [Section 3](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#SEC3), we show how a branch-and-bound algorithm from the literature can be adapted to our problem. The performances of the bound and of the exact algorithm are evaluated in [Section 4](https://www.sciencedirect.com/science/article/pii/S0166218X01002530#SEC4) through computational experiments.\n\nIn the following, we will assume, without loss of generality, that all input data are positive integers and that bins and items are given in \u201chorizontal\u201d orientation, i.e., that _W_ \u2a7e _H_ and _w_ _j_\u2a7e _h_ _j_ for _j_ =1,\u2026, _n_. We further assume, in order to ensure feasibility, that _w_ _j_\u2a7d _W_ and _h_ _j_\u2a7d _H_ for _j_ =1,\u2026, _n_.\n\n## 2\\. Lower bounds\n\nThe only known lower bound for 2BP\\|R\\|F is the obvious _continuous lower bound_:(1)LBC=\u2211j=1nwj...",
      "url": "https://www.sciencedirect.com/science/article/pii/S0166218X01002530"
    },
    {
      "title": "Rotational polygon containment and minimum enclosure using only robust 2D constructions",
      "text": "[Skip to main content](https://www.sciencedirect.com/science/article/pii/S0925772199000061#screen-reader-main-content) [Skip to article](https://www.sciencedirect.com/science/article/pii/S0925772199000061#screen-reader-main-title)\n\n- [View\u00a0**PDF**](https://www.sciencedirect.com/science/article/pii/S0925772199000061/pdf?md5=6df4c26ebfcb25ac3d4ad469c82e58f4&pid=1-s2.0-S0925772199000061-main.pdf)\n- Download full issue\n\nSearch ScienceDirect\n\n## Outline\n\n1. [Abstract](https://www.sciencedirect.com/science/article/pii/S0925772199000061#aep-abstract-id4)\n2. [Keywords](https://www.sciencedirect.com/science/article/pii/S0925772199000061#aep-keywords-id6)\n\n## [Cited by (56)](https://www.sciencedirect.com/science/article/pii/S0925772199000061\\#section-cited-by)\n\n[![Elsevier](https://sdfestaticassets-us-east-1.sciencedirectassets.com/prod/0252b05f1c89f902c3409111ceb5a6d9843d1f5b/image/elsevier-non-solus.png)](https://www.sciencedirect.com/journal/computational-geometry)\n\n## [Computational Geometry](https://www.sciencedirect.com/journal/computational-geometry)\n\n[Volume 13, Issue 1](https://www.sciencedirect.com/journal/computational-geometry/vol/13/issue/1), May 1999, Pages 3-19\n\n[![Computational Geometry](https://ars.els-cdn.com/content/image/1-s2.0-S0925772124X00048-cov150h.gif)](https://www.sciencedirect.com/journal/computational-geometry/vol/13/issue/1)\n\n# Rotational polygon containment and minimum enclosure using only robust 2D constructions [\u2606](https://www.sciencedirect.com/science/article/pii/S0925772199000061\\#aep-article-footnote-id1)\n\nAuthor links open overlay panelVictor J.Milenkovic1\n\nShow more\n\nOutline\n\nAdd to Mendeley\n\nShare\n\nCite\n\n[https://doi.org/10.1016/S0925-7721(99)00006-1](https://doi.org/10.1016/S0925-7721(99)00006-1) [Get rights and content](https://s100.copyright.com/AppDispatchServlet?publisherName=ELS&contentID=S0925772199000061&orderBeanReset=true)\n\nUnder a Creative Commons [license](http://creativecommons.org/licenses/by-nc-nd/4.0/)\n\nopen archive\n\n## Abstract\n\nAn algorithm and a robust floating point implementation is given for _rotational polygon containment_: given polygons _P_ 1, _P_ 2, _P_ 3,\u2026, _P_ _k_ and a container polygon C, find rotations and translations for the k polygons that place them into the container without overlapping. A version of the algorithm and implementation also solves _rotational minimum enclosure_: given a class C of container polygons, find a container C\u2208C of minimum area for which containment has a solution. The minimum enclosure is approximate: it bounds the minimum area between (1\u2212 _\u03b5_) _A_ and A. Experiments indicate that finding the minimum enclosure is practical for _k_ =2,3 but not larger unless optimality is sacrificed or angles ranges are limited (although these solutions can still be useful). Important applications for these algorithm to industrial problems are discussed. The paper also gives practical algorithms and numerical techniques for robustly calculating polygon set intersection, Minkowski sum, and _range intersection_: the intersection of a polygon with itself as it rotates through a range of angles. In particular, it introduces _nearest pair rounding_, which allows all these calculations to be carried out in rounded floating point arithmetic.\n\n- [Previous article in issue](https://www.sciencedirect.com/science/article/pii/S0925772199000139)\n- [Next article in issue](https://www.sciencedirect.com/science/article/pii/S092577219900005X)\n\n## Keywords\n\nLayout\n\nPacking or nesting of irregular polygons\n\nContainment\n\nMinimum enclosure\n\nRobust geometry\n\nGeometric rounding\n\nRecommended articles\n\n- ### [3D mesh cutting for high quality atlas packing](https://www.sciencedirect.com/science/article/pii/S0167839622000851)\n\n\n\n2022, Computer Aided Geometric Design\n\n\n\n\n\n\n\nCitation Excerpt :\n\n\n\nScaffold mesh structures (Jiang et al., 2017; Zhang et al., 2005) are also proposed to compute globally bijective parameterization. Atlas packing The problem of maximizing the packing efficiency for a given set of charts is NP-hard Garey (1979); Milenkovic (1999). Early attempts (L\u00e9vy et al., 2002; N\u00f6ll and Strieker, 2011; Sander et al., 2003) design schemes to balance packing efficiency against computational cost while leaving the chart geometry unchanged.\n\n\n\n\n\n\n\nShow abstract\n\n\n\n\n\n\n\nAn efficiently packed, low-distortion parameterization with a short boundary can save a great amount of memory and improve both quality and efficiency of rendering. Existing packing methods begin with an input atlas (or parameterization), but the cuts in the input atlas may be not suitable for a high quality result. We propose a simple yet effective approach to cut an input surface and generate an atlas that comprehensively considers the packing efficiency, the mapping distortion and the boundary length. Viewing the desired cuts on the input mesh as the pullback of a low-distortion mapping from a polysquare boundary, we notice that the above three objectives actually imply a small number of cone singularities with angle deficit of \u03c02k,k\u2208Z, and orthogonally intersected short cuts passing through all singularities. Therefore, we first leverage a cross frame-field to identify a set of singularities and cancel some of them to balance their amount and atlas distortion. Then, the singularities remained are heuristically connected by short cuts which intersect with each other nearly orthogonally. Results show that our method produces a low-distortion and polysquare-like atlas with controllable number of singularities. Comparing with other atlas generation methods only focusing on distortion, taking our atlas as the input for the subsequent packing algorithm ( [Liu et al., 2019](https://www.sciencedirect.com/science/article/pii/S0925772199000061#br0010)) is better than using previous cutting strategies on a benchmark containing 5519 cases, because the conflicts among those desired objectives for packing are alleviated at an early stage.\n\n- ### [Robust atlas generation via angle-based segmentation](https://www.sciencedirect.com/science/article/pii/S0167839620300418)\n\n\n\n2020, Computer Aided Geometric Design\n\n\n\n\n\n\n\nCitation Excerpt :\n\n\n\nWe use Jiang et al. (2017) to generate the initial bijective parameterizations. Since the parameterized charts contain complex boundaries, maximizing their packing efficiency is an NP-hard problem (Garey and Johnson, 1979; Milenkovic, 1999). To seek a desired tradeoff between computational cost and packing efficiency, some heuristic algorithms are proposed (N\u00f6ll and Strieker, 2011; Sander et al., 2003; L\u00e9vy et al., 2002).\n\n\n\n\n\n\n\nShow abstract\n\n\n\n\n\n\n\nWe present a robust method to generate atlases with low isometric distortion and high packing efficiency. Given a surface that has been cut to disk topology, the algorithm contains four steps: (1) computing a bijective parameterization with low isometric distortion; (2) partitioning the input parameterized charts into a set of rectangle-like patches; (3) mapping rectangle-like patches onto rectangles that are packed into a rectangular domain; and (4) reducing parameterization distortion while maintaining high packing efficiency and bijection. Since there have been elegant and robust solutions for the first, third, and fourth steps, we focus on the second step. Central to the second step is a novel and robust segmentation technique. To improve the robustness of the segmentation, we first deform the parameterized charts to straighten their boundaries while aligning with the axes as much as possible, bounding the deformation distortion, and not introducing intersecting boundaries. Since rectangle-like patches are preferred for the third and fourth steps, we segment the deformed charts by decomposing concave interior angles into several interior angles close to \u03c02 or _\u03c0_. To this end, we develop four types of operations: (i) bridging operation, (ii) extension operation, (iii) vertical line operation, and (iv) bisector operation. The pre-deformation process makes our heuri...",
      "url": "https://www.sciencedirect.com/science/article/pii/S0925772199000061"
    },
    {
      "title": "",
      "text": "New Improvements in Optimal Rectangle Packing\nEric Huang and Richard E. Korf\nComputer Science Department\nUniversity of California, Los Angeles\nLos Angeles, CA 90095\nehuang@cs.ucla.edu, korf@cs.ucla.edu\nAbstract\nThe rectangle packing problem consists of find\u0002ing an enclosing rectangle of smallest area that can\ncontain a given set of rectangles without overlap.\nOur algorithm picks the x-coordinates of all the\nrectangles before picking any of the y-coordinates.\nFor the x-coordinates, we present a dynamic vari\u0002able ordering heuristic and an adaptation of a prun\u0002ing algorithm used in previous solvers. We then\ntransform the rectangle packing problem into a per\u0002fect packing problem that has no empty space, and\npresent inference rules to reduce the instance size.\nFor the y-coordinates we search a space that models\nempty positions as variables and rectangles as val\u0002ues. Our solver is over 19 times faster than the pre\u0002vious state-of-the-art on the largest problem solved\nto date, allowing us to extend the known solutions\nfor a consecutive-square packing benchmark from\nN=27 to N=32.\n1 Introduction\nGiven a set of rectangles, our problem is to find all enclosing\nrectangles of minimum area that will contain them without\noverlap. We refer to an enclosing rectangle as a bounding\nbox. The optimization problem is NP-hard, while the prob\u0002lem of deciding whether a set of rectangles can be packed in\na given bounding box is NP-complete, via a reduction from\nbin-packing [Korf, 2003]. The consecutive-square packing\nbenchmark is a simple set of increasingly difficult bench\u0002marks for this problem, where the task is to find the bounding\nboxes of minimum area that contain a set of squares of sizes\n1x1, 2x2, ..., up to NxN [Korf, 2003]. For example, Figure 1\nis an optimal solution for N=32. We use this benchmark here\nbut none of the techniques introduced in this paper are spe\u0002cific to packing squares as opposed to rectangles.\nRectangle packing has many practical applications. It ap\u0002pears when loading a set of rectangular objects on a pallet\nwithout stacking them, and also in VLSI design where rect\u0002angular circuit components must be packed onto a rectangu\u0002lar chip. Various other cutting stock and layout problems also\nhave rectangle packing at their core.\nFigure 1: An optimal solution for N=32 with a bounding box\nof 85x135.\n511\n(a) Compulsory part of a 5x2 at\nx=[0,2]\n(b) Assigning a 4x2 to [0,2].\nFigure 2: Examples of compulsory parts and intervals.\n2 Previous Work\nKorf [2003] divided the rectangle packing problem into two\nsubproblems: the minimal bounding box problem and the\ncontainment problem. The former finds a bounding box of\nleast area that can contain a given set of rectangles, while the\nlatter tries to pack the given rectangles in a given bounding\nbox. The algorithm that solves the minimal bounding box\nproblem calls the algorithm that solves the containment prob\u0002lem as a subroutine.\n2.1 Minimal Bounding Box Problem\nA simple way to solve the minimal bounding box problem\nis to find the minimum and maximum areas that describe\nthe set of feasible and potentially optimal bounding boxes.\nBounding boxes of all dimensions can be generated with ar\u0002eas within this range, and then tested in non-decreasing order\nof area until all feasible solutions of smallest area are found.\nThe minimum area is the sum of the areas of the given rectan\u0002gles. The maximum area is determined by the bounding box\nof a greedy solution found by setting the bounding box height\nto that of the tallest rectangle, and then placing the rectangles\nin the first available position when scanning from left to right,\nand for each column scanning from bottom to top.\n2.2 Containment Problem\nKorf\u2019s [2003] absolute placement approach modeled rectan\u0002gles as variables and empty locations in the bounding box\nas values. Moffitt and Pollack\u2019s [2006] relative placement ap\u0002proach used a variable for every pair of rectangles to represent\nthe relations above, below, left, and right. Absolute place\u0002ment was faster than relative placement [Korf et al., 2009],\nwhich in turn was faster than the methods of Clautiaux et al.\n[2007] and Beldiceanu et al. [2008].\nSimonis and O\u2019Sullivan [2008] used Clautiaux et al.\u2019s\n[2007] variable order with additional constraints from\nBeldiceanu et al. [2008] to greatly outperform Korf et al.\u2019s\nsolver [2009]. They used Prolog\u2019s backtracking engine to\nsolve a set of constraints which they specified prior to the\nsearch effort. They first assigned the x-coordinates of all\nthe rectangles before any of the y-coordinates. Since we use\nsome of these ideas, we review them here.\nSimonis and O\u2019Sullivan [2008] used two sets of redundant\nvariables for the x-coordinates. The first set of N variables\ncorrespond to \u201cintervals\u201d where a rectangle is assigned an\ninterval of x-coordinates. Interval sizes are hand-picked for\neach rectangle prior to search, and they induce a smaller rect\u0002angle representing the common intersecting area of placing\nthe rectangle in any location in the interval [Beldiceanu et\nal., 2008]. Larger intervals result in weaker constraint prop\u0002agation (less pruning) but a smaller branching factor, while\nsmaller intervals result in stronger constraint propagation but\na larger branching factor.\nAs shown in Figure 2b, a 4x2 rectangle assigned an x\u0002interval of [0,2] consumes 2 units of area at each x-coordinate\nin [2,3], represented by the doubly-hatched area. This \u201ccom\u0002pulsory profile\u201d [Beldiceanu et al., 2008] is a constraint com\u0002mon to all positions x \u2208 [0, 2] of the original 4x2 rectan\u0002gle. If there were no feasible set of interval assignments, then\nthe constraint would save us from having to try individual x\u0002values. However, if we do find a set of interval assignments,\nthen we must search for a set of single x-coordinate val\u0002ues. Simonis and O\u2019Sullivan [2008] used a total of 4N vari\u0002ables, assigning (in order) x-intervals, single x-coordinates,\ny-intervals, and finally single y-coordinates.\n3 Overall Search Strategy\nWe separate the containment problem from the minimal\nbounding box problem, and use Korf et al.\u2019s [2009] al\u0002gorithm to solve the latter problem. Like Simonis and\nO\u2019Sullivan [2008], we assign all x-coordinates prior to any y\u0002coordinates, and use interval variables for the x-coordinates.\nWe set a rectangle\u2019s interval size to 0.35 times its width,\nwhich gave us the best performance. Finally, we do not use\ninterval variables for the y-coordinates. All of the remaining\nideas presented in this paper are our contributions.\nAlthough we use some ideas used by Simonis and\nO\u2019Sullivan [2008], we do not take a constraint programming\napproach in which all constraints are specified to a general\npurpose solver like Prolog, prior to the search effort. Instead,\nwe have implemented our program from scratch in C++, al\u0002lowing us to easily choose which constraints and inferences to\nuse at what time, and giving us more flexibility during search.\nFor example, as we will explain later, we make different in\u0002ferences depending on the partial solution.\nWe implemented a chronological backtracking algorithm\nwith dynamic variable ordering and forward checking. Our\nalgorithm works in three stages as it goes from the root of the\nsearch tree down to the leaves:\n1. It first works on the x-coordinates in a model where\nvariables are rectangles and values are x-coordinate lo\u0002cations, using dynamic variable ordering by area and a\nconstraint that detects infeasible subtrees.\n2. For each x-coordinate solution found, it conducts a per\u0002fect packing transformation, applies inference rules to\nreduce the transformed problem size, and derives conti\u0002guity constraints between rectangles.\n3. It then searches for a set of y-coordinates in a model\nwhere variables are empty corners and values are rect\u0002angles.\n4 Assigning X-Coordinates\nFor the x-coordinates, we propose a dynamic variable order\nand a constraint adapted from Korf\u2019s [2003] wasted-space\npruning heuristic. For a bounding box of size WxH we use\n512\nan array of size W representing the...",
      "url": "https://ijcai.org/Proceedings/09/Papers/092.pdf"
    },
    {
      "title": "PLOS One",
      "text": "An efficient constructive heuristic for the rectangular packing problem with rotations | PLOS One\n[Skip to main content](#main-content)\nAdvertisement\nBrowse Subject Areas\n?\nClick through the PLOS taxonomy to find articles in your field.\nFor more information about PLOS Subject Areas, click[here](https://github.com/PLOS/plos-thesaurus/blob/master/README.md).\n[](#)[](#)\n* Loading metrics\nOpen Access\nPeer-reviewed\nResearch Article\n# An efficient constructive heuristic for the rectangular packing problem with rotations\n* Xusheng Zhao,\nRolesMethodology,\nSoftware,\nWriting \u2013original draft\nAffiliationsSchool of Mechanical Science & Engineering, Huazhong University of Science and Technology, Wuhan, Hubei, China, State Key Laboratory of Intelligent Manufacturing Equipment and Technology, Huazhong University of Science and Technology, Wuhan, Hubei, China\n&#x02A2F;\n* Yunqing Rao,\nRolesFunding acquisition,\nWriting \u2013review & editing\n\\* E-mail:[ryq@hust.edu.cn](mailto:ryq@hust.edu.cn)\nAffiliationsSchool of Mechanical Science & Engineering, Huazhong University of Science and Technology, Wuhan, Hubei, China, State Key Laboratory of Intelligent Manufacturing Equipment and Technology, Huazhong University of Science and Technology, Wuhan, Hubei, China\n[![ORCID logo](https://journals.plos.org/resource/img/orcid_16x16.png)https://orcid.org/0000-0001-7752-3502](https://orcid.org/0000-0001-7752-3502)\n&#x02A2F;\n* Peng Qi,\nRolesInvestigation\nAffiliationsSchool of Mechanical Science & Engineering, Huazhong University of Science and Technology, Wuhan, Hubei, China, State Key Laboratory of Intelligent Manufacturing Equipment and Technology, Huazhong University of Science and Technology, Wuhan, Hubei, China\n&#x02A2F;\n* Qianhang Lyu,\nRolesMethodology\nAffiliationsSchool of Mechanical Science & Engineering, Huazhong University of Science and Technology, Wuhan, Hubei, China, State Key Laboratory of Intelligent Manufacturing Equipment and Technology, Huazhong University of Science and Technology, Wuhan, Hubei, China\n&#x02A2F;\n* Piaoruo Yang,\nRolesSoftware\nAffiliationsSchool of Mechanical Science & Engineering, Huazhong University of Science and Technology, Wuhan, Hubei, China, State Key Laboratory of Intelligent Manufacturing Equipment and Technology, Huazhong University of Science and Technology, Wuhan, Hubei, China\n&#x02A2F;\n* Shoubo Yu\nRolesValidation\nAffiliationsSchool of Mechanical Science & Engineering, Huazhong University of Science and Technology, Wuhan, Hubei, China, State Key Laboratory of Intelligent Manufacturing Equipment and Technology, Huazhong University of Science and Technology, Wuhan, Hubei, China\n&#x02A2F;\n# An efficient constructive heuristic for the rectangular packing problem with rotations\n* Xusheng Zhao,\n* Yunqing Rao,\n* Peng Qi,\n* Qianhang Lyu,\n* Piaoruo Yang,\n* Shoubo Yu\n![PLOS](https://journals.plos.org/resource/img/logo-plos-full-color.svg)\nx\n* Published: December 28, 2023\n* [https://doi.org/10.1371/journal.pone.0295206](https://doi.org/10.1371/journal.pone.0295206)\n* * [Article](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0295206)\n* [Authors](https://journals.plos.org/plosone/article/authors?id=10.1371/journal.pone.0295206)\n* [Metrics](https://journals.plos.org/plosone/article/metrics?id=10.1371/journal.pone.0295206)\n* [Comments](https://journals.plos.org/plosone/article/comments?id=10.1371/journal.pone.0295206)\n* [Media Coverage](http://plos.altmetric.com/details/doi/10.1371/journal.pone.0295206)\n* [Reader Comments](article/comments?id=10.1371/journal.pone.0295206)\n* [Figures](#)\n## Figures\n![Fig 1](https://journals.plos.org/plosone/article/figure/image?size=inline&amp;id=10.1371/journal.pone.0295206.g001)\n![Table 1](https://journals.plos.org/plosone/article/figure/image?size=inline&amp;id=10.1371/journal.pone.0295206.t001)\n![Fig 2](https://journals.plos.org/plosone/article/figure/image?size=inline&amp;id=10.1371/journal.pone.0295206.g002)\n![Fig 3](https://journals.plos.org/plosone/article/figure/image?size=inline&amp;id=10.1371/journal.pone.0295206.g003)\n![Fig 4](https://journals.plos.org/plosone/article/figure/image?size=inline&amp;id=10.1371/journal.pone.0295206.g004)\n![Fig 5](https://journals.plos.org/plosone/article/figure/image?size=inline&amp;id=10.1371/journal.pone.0295206.g005)\n![Fig 6](https://journals.plos.org/plosone/article/figure/image?size=inline&amp;id=10.1371/journal.pone.0295206.g006)\n![Table 2](https://journals.plos.org/plosone/article/figure/image?size=inline&amp;id=10.1371/journal.pone.0295206.t002)\n![Fig 7](https://journals.plos.org/plosone/article/figure/image?size=inline&amp;id=10.1371/journal.pone.0295206.g007)\n![Table 3](https://journals.plos.org/plosone/article/figure/image?size=inline&amp;id=10.1371/journal.pone.0295206.t003)\n![Table 4](https://journals.plos.org/plosone/article/figure/image?size=inline&amp;id=10.1371/journal.pone.0295206.t004)\n![Table 5](https://journals.plos.org/plosone/article/figure/image?size=inline&amp;id=10.1371/journal.pone.0295206.t005)\n![Table 6](https://journals.plos.org/plosone/article/figure/image?size=inline&amp;id=10.1371/journal.pone.0295206.t006)\n## Abstract\nThe rectangular packing problem has been extensively studied over the years due to its wide application in industry. However, most of the research efforts are devoted to positioning techniques of the rectangles for various problem variants, the efficient implementation of the packing procedure is relatively less studied. In this paper, we propose an efficient constructive algorithm for the rectangular packing problem with rotations. We design a preprocess procedure with four data structures to store the information used for item selection. The gaps on the skyline are categorized into three types according to their associated edges for the placement procedure, during which the item is searched and packed in a descending order of the fitness value. The entire constructive phase takes a time complexity of O(*n*log*n*). For the packing improvement phase, we optimize the packing through random perturbation on the sequence and orientation of the item. Three classes of stochastic problems are generated ranging from small-scale to extra-large-scale, the recorded running time confirms the efficiency of the proposed algorithm. We also test the proposed algorithm on the benchmark problem C21, N13, NT, Babu and CX, the computational results show that it delivers a good performance.\n**Citation:**Zhao X, Rao Y, Qi P, Lyu Q, Yang P, Yu S (2023) An efficient constructive heuristic for the rectangular packing problem with rotations. PLoS ONE 18(12):\ne0295206.\nhttps://doi.org/10.1371/journal.pone.0295206\n**Editor:**Lalit Chandra Saikia, National Institute of Technology Silchar, India, INDIA\n**Received:**August 26, 2023;**Accepted:**November 16, 2023;**Published:**December 28, 2023\n**Copyright:**\u00a9 2023 Zhao et al. This is an open access article distributed under the terms of the[Creative Commons Attribution License](http://creativecommons.org/licenses/by/4.0/), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.\n**Data Availability:**All relevant data are within the paper.\n**Funding:**This work was supported by the National Natural Science Foundation of China (Grant No. 51975231). The funder participated in the editing of the manuscript.\n**Competing interests:**The authors have declared that no competing interests exist.\n## 1. Introduction\nGiven a group of large objects with regular shape and homogeneous material, designing an assortment of the small items accommodated by the large objects to minimize the waste is the classic cutting and packing problem [[1](#pone.0295206.ref001)]. Additional constraints in industrial applications may add properties to the cutting and packing problem, which defines a wide range of problem variants. For example, the small items can be rectangles, circles, polygons or even contour shapes with curved edges, and the large object...",
      "url": "https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0295206"
    }
  ]
}