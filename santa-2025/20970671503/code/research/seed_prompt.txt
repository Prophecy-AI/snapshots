# Christmas Tree Packing Optimization - Strategy Guide (Loop 1)

## Current Status
- Best CV score: 164.82 from exp_000 (001_baseline_greedy)
- Best LB score: 164.82 (CV-LB gap: 0.0 - expected for deterministic optimization)
- Target to beat: 68.95 (2.4x improvement needed)
- Submissions used: 1/100

## Response to Evaluator
- Technical verdict: TRUSTWORTHY - baseline correctly implemented
- Evaluator's top priority: Implement squeeze and compaction operations
- **I AGREE** - the greedy baseline is fundamentally limited. We need local search operators.
- Key concern: 2.4x gap requires fundamental approach change. **AGREED** - incremental Python improvements won't close this gap.
- Alternative suggestion: Use bbox3 or compile C++ optimizer. **THIS IS THE PATH FORWARD.**

## Data Understanding
- Reference notebooks: `exploration/evolver_loop1_lb_feedback.ipynb` for score analysis
- Key insight: Score = sum(sideÂ²/n) for n=1 to 200
  - Small n (1-10) contributes 8.44 to total score
  - Medium n (11-50) contributes 33.35
  - Large n (51-200) contributes 121.17
- **Optimizing large n has highest absolute impact, but small n has highest per-tree leverage**

## Critical Infrastructure Finding
- **g++ compiler available with 26 CPU cores**
- Can compile and run C++ optimizers with OpenMP parallelization
- This is the key to competitive scores - Python is too slow

## Recommended Approaches (Priority Order)

### 1. COMPILE AND RUN C++ TREE PACKER (HIGHEST PRIORITY)
The tree_packer_v21 C++ code from smartmanoj kernel is available in:
`/home/code/research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

**Action:**
1. Extract the C++ code from the notebook
2. Compile with: `g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer.cpp`
3. Run with parameters like: `./tree_packer -n 5000 -r 16`
4. This implements: simulated annealing, squeeze, compaction, local search, swap moves

**Why:** Top kernels achieve ~68-69 scores using this approach. Our Python baseline can't compete.

### 2. IMPLEMENT BACKWARD PROPAGATION (AFTER C++ OPTIMIZER)
The backward propagation code is also in the smartmanoj kernel (bp.cpp).

**Action:**
1. Extract and compile bp.cpp
2. Run after tree_packer: `./bp submission.csv submission.csv`
3. This uses larger configs to improve smaller ones

**Why:** Provides additional score improvement by propagating good solutions downward.

### 3. APPLY FIX_DIRECTION ROTATION OPTIMIZATION
Our baseline already has this, but it should be applied after C++ optimization.

**Action:**
1. After C++ optimizer produces submission, apply fix_direction in Python
2. Use scipy.optimize.minimize_scalar on convex hull of all vertices
3. Search angles 0-90 degrees for minimum bounding box

**Why:** Provides consistent small improvements (~0.1-0.5 score reduction).

### 4. FALLBACK: PYTHON SQUEEZE + COMPACTION (IF C++ FAILS)
If C++ compilation fails, implement in Python with Numba acceleration:

**Squeeze operation:**
```python
def squeeze(trees, scale=0.9995):
    cx, cy = centroid(trees)
    for tree in trees:
        tree.x = cx + (tree.x - cx) * scale
        tree.y = cy + (tree.y - cy) * scale
    # Check collisions, back off if needed
```

**Compaction operation:**
```python
def compaction(trees, steps=[0.02, 0.008, 0.003, 0.001]):
    cx, cy = centroid(trees)
    for tree in trees:
        for step in steps:
            # Move toward centroid by step
            # Accept if reduces bounding box and no collision
```

## What NOT to Try
- More greedy placement variations - the approach is fundamentally limited
- Hyperparameter tuning of greedy (num_attempts, step sizes) - won't close 2.4x gap
- Pure Python local search without acceleration - too slow

## Validation Notes
- CV = LB for this problem (deterministic scoring)
- No need for cross-validation - just compute score locally
- Verify no overlapping trees before submission (use Shapely intersection check)

## Implementation Order
1. **First:** Try to compile and run tree_packer_v21 C++ code
2. **Then:** Apply backward propagation
3. **Then:** Apply fix_direction rotation optimization
4. **Finally:** Validate for overlaps and submit

## Expected Outcome
- C++ optimizer should achieve score ~68-70 within 1-2 hours of runtime
- This would beat the target of 68.95
- If C++ approach works, we can iterate with longer runs and different parameters