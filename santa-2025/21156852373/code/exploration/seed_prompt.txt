# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.676102 from exp_000 (001_baseline)
- Best LB score: N/A (not yet submitted)
- Target: 68.919154 | Gap to target: 1.756948

## Public Kernel Status (CRITICAL!)
- Have we implemented the best kernel yet? **NO** - we only loaded a pre-optimized CSV
- Top kernels identified:
  1. jonathanchan/santa25-ensemble-sa-fractional-translation - Ensemble + SA + Fractional Translation
  2. yongsukprasertsuk/santa-2025-best-keeping-bbox3-runner - 3-Phase optimization
  3. saspav/santa-submission - fix_direction post-processing
  4. jazivxt/why-not - bbox3 optimizer
  5. smartmanoj/santa-claude - tree_packer_v21 + backward propagation
- Kernels we've implemented: NONE (only loaded pre-optimized CSV)
- Kernels still to implement: ALL OF THE ABOVE

## Response to Evaluator
The evaluator correctly identified that:
1. **Optimization time is the key bottleneck** - We need to run optimizers for HOURS, not minutes
2. **Multiple parallel strategies needed** - bbox3, tree_packer, lattice, fix_direction
3. **Submit early to verify LB score** - We have 100 submissions, should use them

I fully agree with these priorities. The next experiment should:
1. Start long optimization runs immediately
2. Submit the baseline to verify LB matches local score
3. Implement fix_direction post-processing

## Key Insights from Research

### From Web Search:
- **Simulated Annealing dominates** - Top solutions use SA with high iterations (15000+)
- **Lattice/Crystalline packing for large N** - For N > 58, crystalline packings are mathematically superior
- **Fractional translation** - Fine-grained micro-adjustments (0.001, 0.0005, 0.0001 steps) for final polish
- **RL doesn't work** - Reinforcement learning fails due to sparse binary feedback

### From Kernels:
1. **Ensemble approach** (jonathanchan): Collect best solution for each N from multiple sources
2. **3-Phase optimization** (yongsukprasertsuk): Short → Medium → Long runs with fix_direction after each
3. **Fractional translation** (jonathanchan): 8-directional micro-moves with decreasing step sizes
4. **fix_direction** (saspav): Rotate entire configuration to minimize bounding box using convex hull

### Available Pre-optimized CSVs:
- `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/santa-2025.csv` (score: 70.676102)
- `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/best_ensemble.csv`
- `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/telegram/71.97.csv` (score: ~71.97)
- `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/telegram/72.49.csv` (score: ~72.49)
- Multiple CSVs in santa25-public/ directory

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY] Submit Baseline + Start Long Optimization**
- Submit the baseline (70.676102) to verify LB score matches
- Start bbox3 running in background with high iterations:
  ```bash
  cp /home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/bbox3 /home/code/
  cp /home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/santa-2025.csv /home/code/current.csv
  cd /home/code && ./bbox3 -n 20000 -r 128 < current.csv > optimized.csv
  ```
  This should run for 2+ hours.

### 2. **[HIGH PRIORITY] Implement Ensemble from Multiple Sources**
- Collect all available CSVs from snapshots
- For each N (1-200), find the best solution across all sources
- This can immediately improve score without optimization

### 3. **[HIGH PRIORITY] Implement fix_direction Post-Processing**
From saspav kernel:
```python
from scipy.spatial import ConvexHull
from scipy.optimize import minimize_scalar

def optimize_rotation(trees):
    # Get convex hull of all tree vertices
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points_np = np.array(all_points)
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    # Find optimal rotation angle
    res = minimize_scalar(
        lambda a: calculate_bbox_side_at_angle(a, hull_points),
        bounds=(0.001, 89.999), method='bounded'
    )
    return res.x, res.fun
```

### 4. **[MEDIUM PRIORITY] Implement Fractional Translation**
From jonathanchan kernel - micro-adjustments for final polish:
```cpp
double frac_steps[] = {0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001};
double dx[] = {0, 0, 1, -1, 1, 1, -1, -1};
double dy[] = {1, -1, 0, 0, 1, -1, 1, -1};
// For each tree, try all 8 directions at each step size
```

### 5. **[MEDIUM PRIORITY] Focus on Small N Values**
- N=1 contributes 0.661 to score (highest single contribution)
- N=1 is already at optimal 45° rotation
- Small N values (1-15) have worst efficiency - focus optimization here

## What NOT to Try
- Short optimization runs (minutes) - they find NO improvements
- Simple ensemble without per-N selection - one file dominates
- Backward propagation alone - doesn't help on tight local optima
- Reinforcement learning - doesn't work for this problem

## SUBMISSION STRATEGY
- Remaining submissions: 100
- Submit after this experiment? **YES** - we have abundant submissions
- Submit baseline first to verify LB score, then submit after each improvement

## Validation Notes
- Score formula: Σ(s_n² / n) for n=1 to 200
- Lower is better
- No overlaps allowed (use Shapely for validation)
- Coordinates prefixed with 's' in CSV format

## Next Experiment Plan (002_extended_optimization)
1. Submit baseline to get LB feedback
2. Start bbox3 optimization in background (2+ hours)
3. Implement ensemble from all available CSVs
4. Apply fix_direction post-processing to ensemble
5. Calculate new score and submit if improved
