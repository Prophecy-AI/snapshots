# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D polygon packing optimization problem. The goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding box for each configuration of N trees (N=1 to 200).

**Scoring:** score = Σ(s_n² / n) for n=1 to 200, where s_n is the side length of the bounding square for n trees. **Lower is better.**

**Target Score:** Beat 68.919154
**Current Best from Snapshots:** 70.676102 (gap of ~1.75 points)

## Tree Geometry
Each Christmas tree is a 15-vertex polygon with:
- Trunk: width 0.15, height 0.2
- Base tier: width 0.7
- Middle tier: width 0.4
- Top tier: width 0.25
- Tip at y=0.8
- Total height: 1.0 (from trunk bottom at -0.2 to tip at 0.8)

The tree can be positioned (x, y) and rotated by angle (deg).

## CRITICAL INSIGHT FROM PREVIOUS EXPERIMENTS

**The pre-optimized santa-2025.csv is at a VERY TIGHT LOCAL OPTIMUM.**

Previous experiments found:
- Running bbox3 and tree_packer_v21 for short periods (minutes) found NO improvements
- Backward propagation found NO improvements
- Ensemble of 30 CSV files didn't help - santa-2025.csv dominates all N values
- The gap of 1.75 points requires fundamentally different approaches

**What DOESN'T work:**
- Short optimization runs (minutes instead of hours)
- Simple ensemble (all sources dominated by one file)
- Backward propagation alone

**What MIGHT work:**
1. **MUCH LONGER optimization runs** (hours, not minutes) - top solutions run 15000+ iterations, 80+ rounds
2. **Lattice-based approach for large N** - grid-based placement fundamentally different from random optimization
3. **Focus on small N values** - N=1 contributes 0.66 to score (highest single contribution)
4. **Perturbation to escape local optima** - random restarts with perturbation
5. **3-Phase optimization strategy** - short runs to find promising params, then longer runs on best candidates

## Top Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (Primary Approach)
**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`

The bbox3.cpp optimizer is the core engine used by top solutions. Key features:
- Complex Number Vector Coordination for position calculations
- Fluid Dynamics simulation for tree movement
- Hinge Pivot mechanism for rotation optimization
- Density Gradient Flow for compaction
- Global Boundary Tension for edge optimization
- OpenMP parallelization for speed
- Aggressive overlap repair with separation vectors

**Compilation:**
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp
```

**Usage (MUST RUN FOR HOURS, NOT MINUTES):**
```bash
./bbox3 -n 20000 -r 128  # High iterations and rounds
```

### 2. tree_packer_v21 (Alternative Optimizer)
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Features:
- Swap moves between trees
- Multi-angle restarts
- Higher temperature simulated annealing
- Squeeze, compaction, and local search phases
- Uses long double precision for accuracy

**Usage:**
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer_v21 tree_packer_v21.cpp
./tree_packer_v21 -n 10000 -r 256
```

### 3. 3-Phase Optimization Strategy (Best-Keeping Runner)
**Source:** `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`

Sophisticated multi-phase approach:
- **Phase A (short runs):** 2 min each, n=1000-2000, r=30-90, find promising settings
- **Phase B (medium runs):** 10 min each on top candidates
- **Phase C (long runs):** 20 min each on best few
- Uses fix_direction + overlap repair after each phase
- Keeps best submission, reverts on regressions

### 4. fix_direction Post-Processing (CRITICAL)
**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

After optimization, apply rotation to the entire configuration to minimize bounding box:
```python
from scipy.spatial import ConvexHull
from scipy.optimize import minimize_scalar

def optimize_rotation(trees):
    # Get convex hull of all tree vertices
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points_np = np.array(all_points)
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    # Find optimal rotation angle
    res = minimize_scalar(
        lambda a: calculate_bbox_side_at_angle(a, hull_points),
        bounds=(0.001, 89.999), method='bounded'
    )
    return res.x, res.fun
```

### 5. Backward Propagation (bp.cpp)
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Improves smaller N configurations by removing trees from larger ones:
- Start from N=200, work down to N=2
- For each config, try removing boundary-touching trees
- If resulting (N-1) config is better than stored, save it

## Recommended Experiment Pipeline

### Phase 1: Establish Baseline (~70.68)
1. Copy pre-optimized submission from snapshots:
   ```bash
   cp /home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/santa-2025.csv submission.csv
   ```
2. Validate no overlaps
3. Submit to verify baseline score

### Phase 2: Extended Optimization (HOURS, NOT MINUTES)
1. Compile bbox3.cpp with OpenMP
2. **Run for 2+ hours with high iterations:**
   ```bash
   ./bbox3 -n 20000 -r 128
   ```
3. Apply fix_direction post-processing (multiple passes)
4. Run backward propagation
5. Validate and submit

### Phase 3: Alternative Approaches to Beat Target (< 68.919154)

**Lattice-Based Approach for Large N (CRITICAL - NOT YET TRIED):**
For large N (72, 100, 110, 144, 156, 196, 200), use grid-based placement:
- Start with two base trees and translate them in x and y directions
- Parameters: `nt = [nx, ny]` where nx*ny >= N
- This generates crystalline/lattice packings that can be tighter than random optimization

**Focus on Small N Values:**
- N=1 contributes 0.66 to score (highest single contribution)
- N=1 optimal angle is 45 degrees (minimizes bounding box)
- Small N values (1-10) have lowest efficiency (1.5-2.6 trees/unit area)
- Improving these could have outsized impact

**Multi-Start Strategy:**
- Run optimizer multiple times with different random seeds
- Keep best result for each N
- Combine best configurations from different runs

**Per-N Optimization:**
- Calculate score contribution for each N: s_n² / n
- Identify N values with worst efficiency
- Focus optimization time on those specific configurations

## Key Implementation Details

### ChristmasTree Class
```python
from decimal import Decimal, getcontext
from shapely import affinity
from shapely.geometry import Polygon

getcontext().prec = 30

class ChristmasTree:
    def __init__(self, center_x='0', center_y='0', angle='0'):
        self.center_x = Decimal(center_x)
        self.center_y = Decimal(center_y)
        self.angle = Decimal(angle)
        
        # 15-vertex polygon definition
        initial_polygon = Polygon([
            (0.0, 0.8),      # Tip
            (0.125, 0.5),    # Right top tier
            (0.0625, 0.5),
            (0.2, 0.25),     # Right mid tier
            (0.1, 0.25),
            (0.35, 0.0),     # Right base
            (0.075, 0.0),    # Right trunk
            (0.075, -0.2),
            (-0.075, -0.2),  # Left trunk
            (-0.075, 0.0),
            (-0.35, 0.0),    # Left base
            (-0.1, 0.25),    # Left mid tier
            (-0.2, 0.25),
            (-0.0625, 0.5),  # Left top tier
            (-0.125, 0.5),
        ])
        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))
        self.polygon = affinity.translate(rotated, xoff=float(self.center_x), yoff=float(self.center_y))
```

### Overlap Detection
```python
from shapely.strtree import STRtree

def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

### Scoring Function
```python
import numpy as np

def get_total_score(submission_df):
    total = 0
    for n in range(1, 201):
        trees = load_trees_for_n(submission_df, n)
        xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])
        side = max(xys.max(axis=0) - xys.min(axis=0))
        total += side**2 / n
    return total
```

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- id: `{n:03d}_{tree_index}` (e.g., 001_0, 002_0, 002_1)
- x, y, deg: prefixed with 's' to preserve precision
- Total rows: 20100 (1+2+3+...+200)

## Validation Checklist
1. No overlapping trees (use has_overlap function)
2. All coordinates within [-100, 100]
3. All 200 configurations present (20100 rows)
4. Values prefixed with 's' in submission

## Pre-Optimized Files Available
- `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/santa-2025.csv` - Best known baseline (score ~70.68)
- `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/bucket-of-chump/submission.csv` - Alternative baseline
- `/home/nonroot/snapshots/santa-2025/21116303805/code/bbox3` - Pre-compiled bbox3 binary

## Strategy to Beat Target (68.919154)

**Priority 1: MUCH LONGER OPTIMIZATION (CRITICAL)**
The current best is stuck at a local optimum. Run bbox3 for 2+ hours:
```bash
./bbox3 -n 20000 -r 128
```
Let it run overnight if needed. Top solutions use hours of compute time.

**Priority 2: LATTICE APPROACH FOR LARGE N (NOT YET TRIED)**
Implement grid-based placement for N=144, 156, 196, 200:
- For N=144, use nt=[6, 12] (6 trees in x, 12 in y)
- For N=196, use nt=[7, 14]
- For N=200, use nt=[7, 15] then take first 200 trees

**Priority 3: VERIFY N=1 IS OPTIMAL**
Check if N=1 is at 45-degree rotation (optimal for minimizing bounding box).
If not, fix it - this alone could save 0.16 points (9% of the gap!).

**Priority 4: MULTI-SEED OPTIMIZATION**
Run optimizer multiple times with different random seeds.
Keep best result for each N value.

**Priority 5: 3-PHASE OPTIMIZATION**
Use the best-keeping runner approach:
1. Phase A: Short runs (2min) to find promising n,r parameters
2. Phase B: Medium runs (10min) on top candidates
3. Phase C: Long runs (20min) on best few
4. Apply fix_direction + overlap repair after each phase

## Key Insights from Discussions
1. Asymmetric solutions may outperform symmetric for large N
2. Trees tend to interlock with alternating orientations (0°, 90°, 180°, 270°)
3. Lattice-like patterns emerge in well-optimized configurations
4. Focus optimization effort on N values with worst efficiency
5. The winning solutions likely use extensive compute time and multiple optimization passes

## Time Budget
- bbox3 with -n 10000 -r 64 takes ~1-2 hours
- fix_direction takes ~10-15 minutes
- backward_propagation takes ~5-10 minutes
- Plan for multiple optimization passes
- **Run optimization overnight for best results**

## Overlap Repair
If optimization creates overlaps, repair by replacing with known-good configurations:
```python
def replace_group(target_file, donor_file, group_id, output_file):
    # Replace overlapping configuration with known-good one from donor
    header_t, groups_t = load_groups(target_file)
    header_d, groups_d = load_groups(donor_file)
    groups_t[group_id] = groups_d[group_id]
    save_groups(output_file, header_t, groups_t)
```

## Summary of Approaches to Try
1. **Long optimization runs** (2+ hours with bbox3 -n 20000 -r 128)
2. **Lattice-based packing** for large N values
3. **Verify N=1 is at 45 degrees** (optimal rotation)
4. **Multi-seed optimization** with best-per-N selection
5. **3-phase optimization** (short→medium→long runs)
6. **fix_direction post-processing** (multiple passes)
7. **Backward propagation** after optimization
8. **Per-N focused optimization** on worst-efficiency configurations
