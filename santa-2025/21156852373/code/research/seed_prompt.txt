# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.676102 from exp_000 (baseline)
- Best LB score: 70.676102398091 (verified, no overlaps)
- Target: 68.919154 | Gap to target: 1.756948 (2.49%)
- Submissions used: 2/100 (98 remaining)

## Critical Situation Assessment

### What's Been Exhaustively Tried (ALL FAILED)
1. **bbox3 optimizer** - 80 rounds, 0 improvement
2. **tree_packer_v21** - 0 improvement  
3. **Fractional translation** - 0.000000003 improvement on N=128 only
4. **sa_v1_parallel** - 4 generations, 0 improvement
5. **Ensemble from 731 CSV files** - best 51.42 but 168/200 overlapping groups (invalid)
6. **Rebuild from corners** - 0 improvements found
7. **Perturbed restarts** - converged to worse optima (73.x vs 70.67)

### Key Insight: BASELINE IS AT EXTREMELY TIGHT LOCAL OPTIMUM
The baseline cannot be improved by ANY standard optimization technique. This is confirmed by:
- bbox3 ran 80 rounds with ZERO improvement
- Fractional translation found only 0.000000003 improvement
- All 731 CSV files in snapshots either have same/worse scores OR have overlaps

## Response to Evaluator

The evaluator correctly identified that:
1. Standard optimization has been exhausted - AGREED, proven by experiments
2. The target may require non-public techniques - AGREED, gap is 1.76 points beyond best public kernel
3. Symmetric solutions not fully explored - AGREED, this is a key direction
4. Ensemble repair could unlock gains - PARTIALLY AGREE, but 168/200 overlapping groups makes this very difficult

**My assessment:** We need to try FUNDAMENTALLY DIFFERENT approaches, not variations of SA/local search.

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY] Grid-Based SA with Deletion Cascade (jiweiliu kernel)**
The "super-fast-simulated-annealing-with-translations" kernel uses a fundamentally different approach:
- Creates grid-based unit cell configurations
- Uses Numba-accelerated SA optimization
- Applies deletion cascade to propagate good large configs to smaller sizes
- Achieved 0.15 improvement in under 2 minutes on their baseline

**Implementation:**
```python
# Key insight: Start from grid configurations, not random
# For each grid size (ncols, nrows), create unit cell with 2 trees
# Optimize with SA, then cascade down by removing trees
```

### 2. **[HIGH PRIORITY] Iterated Local Search (ILS) with Strong Perturbation**
Research shows ILS/Monotonic Basin Hopping is effective for escaping local optima:
- Apply strong perturbation moves (not small tweaks)
- Re-optimize after each perturbation
- Accept if new local optimum is better

**Implementation:**
- Perturb by randomly relocating 10-20% of trees to new positions
- Run full SA optimization after perturbation
- Repeat 100+ times with different seeds

### 3. **[MEDIUM PRIORITY] Guided Local Search (GLS) Meta-heuristic**
GLS penalizes features of local optima to escape them:
- Track which tree positions appear in local optima
- Add penalty to objective function for these positions
- Forces search to explore different regions

### 4. **[MEDIUM PRIORITY] Symmetric Solution Search for Small N**
For N=2-20, try exhaustive symmetric configurations:
- Mirror symmetry (horizontal, vertical, diagonal)
- Rotational symmetry (180°, 120°, 90°)
- Fine-grained grid search (1000+ positions, 360 angles)

### 5. **[LOWER PRIORITY] Very Long Random Restarts**
Generate completely random starting configurations and optimize for hours:
- Not perturbations of baseline - truly random
- Run bbox3 for 50000+ iterations, 100+ rounds
- Repeat 10-20 times with different seeds

## What NOT to Try
- ❌ More bbox3/tree_packer_v21 on baseline (proven ineffective)
- ❌ More fractional translation (0 improvement)
- ❌ Ensemble from existing CSVs (all have overlaps or same scores)
- ❌ Small perturbations (converge back to same optimum)

## Technical Notes

### Overlap Validation (CRITICAL)
Use scale_factor=1e15 to match Kaggle's strict validation:
```python
def has_overlap(trees):
    for i in range(len(trees)):
        for j in range(i+1, len(trees)):
            if trees[i].polygon.intersects(trees[j].polygon):
                intersection = trees[i].polygon.intersection(trees[j].polygon)
                if intersection.area > 0:  # NOT > 1e-10
                    return True
    return False
```

### Score Calculation
```python
score = sum((side_length[n] ** 2) / n for n in range(1, 201))
```

### Key Files
- Baseline: `/home/code/submission_candidates/candidate_000.csv` (score: 70.676102)
- Grid SA kernel: `/home/code/research/kernels/jiweiliu_super-fast-simulated-annealing-with-translations/`
- Rebuild from corners: `/home/code/research/kernels/chistyakov_new-simple-fix-rebuild-large-layout-from-corners/`

## SUBMISSION STRATEGY
- Remaining submissions: 98
- Submit after EVERY experiment that produces a valid submission
- LB feedback is free information - USE IT!

## Success Criteria
- Beat 68.919154 with verified LB submission
- Current gap: 1.756948 points (2.49% improvement needed)
- This requires finding a fundamentally different local optimum basin
