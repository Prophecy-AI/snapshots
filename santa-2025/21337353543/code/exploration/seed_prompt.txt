# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt

## Problem Overview

This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (15 vertices each) into the smallest possible square bounding box for N=1 to 200 trees.

**Scoring Formula:** score = Σ(side_n² / n) for n=1 to 200
- Lower is better
- Small N values contribute MORE to score (N=1 contributes ~0.66, N=200 contributes ~0.35)
- Target score: **68.888293** (must beat this)

**Tree Shape (15 vertices):**
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```
- Tree has tip at (0, 0.8), trunk bottom at y=-0.2
- Width: 0.7 at base, 0.4 at middle tier, 0.25 at top tier
- Trunk: 0.15 wide, 0.2 tall

## ⛔ ABSOLUTELY FORBIDDEN (EXPERIMENT WILL BE REJECTED)

The following are PERMANENTLY FORBIDDEN after baseline:
- bbox3 - FORBIDDEN
- sa_fast_v2 - FORBIDDEN  
- eazy_optimizer - FORBIDDEN
- tree_packer - FORBIDDEN
- shake_public - FORBIDDEN
- subprocess.run() - FORBIDDEN
- os.system() - FORBIDDEN
- ANY pre-compiled binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any tool - FORBIDDEN
- Running "more iterations" on any optimizer - FORBIDDEN

If your experiment runs ANY binary, it will produce ~70.6.
The target is 68.89. BINARIES CANNOT GET THERE.

## ✅ MANDATORY FIRST TASK: SOLVE N=1-10 OPTIMALLY

BEFORE any other work, implement exhaustive search for small N:

**For N=1 (contributes ~0.66 to score - HIGHEST!):**
- Test EVERY rotation angle from 0° to 360° in 0.01° increments
- Find the angle that minimizes bounding box
- This alone can improve score by 0.05-0.1 points

**For N=2-10:**
- Implement branch-and-bound or exhaustive placement search
- These contribute ~2.5 points total - worth optimizing!

## ✅ MANDATORY: PER-N SOLUTION TRACKING

Track best solution for EACH N value separately:
1. Load baseline per-N scores from existing submission
2. After your algorithm runs, compare per-N scores
3. SAVE any N where you improved (even if total is worse)
4. Accumulate improvements across experiments

## ✅ REQUIRED: IMPLEMENT ALGORITHM IN PYTHON

Write YOUR OWN code. Choose ONE:
1. Bottom-left constructive heuristic (easiest)
2. Genetic algorithm with crossover (medium)
3. Custom local search written from scratch (medium)
4. Branch-and-bound for exact solutions (hardest)

NO BINARIES. NO SUBPROCESS. NO OS.SYSTEM.
WRITE THE ALGORITHM YOURSELF IN PYTHON.

## Insights from Discussions (MANDATORY)

- Discussion "Why the winning solutions will be Asymmetric" (39 votes): Asymmetric solutions outperform symmetric ones for this packing problem. Don't assume rotational symmetry in optimal solutions.
- Discussion "Expected Leaderboard Progression" (20 votes): Staff-provided guidance on expected score progression
- Discussion "Interactive Editor" (58 votes): Tool for manually adjusting tree positions - suggests manual fine-tuning is valuable
- Discussion "IMPORTANT: Santa Etiquette" (78 votes): Competition rules and guidelines

## What Discussions Say DOESN'T Work
- Short optimization runs on pre-optimized submissions (local optimum is too tight)
- Simple ensemble of existing CSVs (one source dominates all N values)
- Running binaries with default parameters (produces ~70.6, not competitive)

## Unexplored Ideas from Discussions
- Lattice-based approach for large N (grid patterns for N >= 58)
- Backward propagation (remove trees from N to improve N-1)
- Focus on small N values which have highest score contribution

## Key Insights from Research

### Academic Approaches (from web search):
1. **No-Fit Polygon (NFP)**: Precompute collision-free regions for O(1) overlap checks
2. **Collision-Free Region (CFR)**: Place items ONLY on CFR vertices for optimal compaction
3. **Two-Level Algorithm**: Inner level solves fixed-container placement, outer level adjusts container size
4. **Extended Local Search**: Combine with nonlinear programming for overlap minimization
5. **Simulated Annealing**: Controls both sequence and placement of items

### Key Techniques from Kernels:
1. **Rotation Optimization (fix_direction)**: After packing, rotate entire configuration to minimize bounding box
2. **Squeeze/Compaction**: Scale configuration toward center until overlap, then back off
3. **Local Search**: Move trees toward center in small steps, keeping best non-overlapping position
4. **Boundary Focus**: Trees on bounding box boundary are most important to optimize

### Collision Detection (Shapely-based):
```python
from shapely.geometry import Polygon
from shapely import affinity
from shapely.strtree import STRtree

def has_overlap(polygons):
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

## Algorithm Recommendations

### Priority 1: Exhaustive Search for Small N (N=1-10)
```python
def optimize_single_tree():
    """For N=1, find optimal rotation angle"""
    best_side = float('inf')
    best_angle = 0
    for angle in np.arange(0, 360, 0.01):  # Fine-grained search
        tree = create_tree(0, 0, angle)
        bounds = tree.bounds
        side = max(bounds[2]-bounds[0], bounds[3]-bounds[1])
        if side < best_side:
            best_side = side
            best_angle = angle
    return best_angle, best_side
```

### Priority 2: Bottom-Left Heuristic with Rotation
```python
def bottom_left_place(existing_trees, new_tree_angle):
    """Place new tree at bottom-left feasible position"""
    # Start from far away, move toward center
    # Find first non-overlapping position
    # Try multiple angles for new tree
```

### Priority 3: Local Search Improvement
```python
def local_search(trees, max_iter=1000):
    """Improve existing configuration"""
    for _ in range(max_iter):
        # Pick random tree
        # Try small moves (dx, dy, dangle)
        # Keep if improves bounding box without overlap
```

### Priority 4: Rotation Optimization (Post-Processing)
```python
def optimize_rotation(trees):
    """Rotate entire configuration to minimize bounding box"""
    from scipy.optimize import minimize_scalar
    from scipy.spatial import ConvexHull
    
    # Get convex hull of all tree vertices
    # Find rotation angle that minimizes bounding box
    # Apply rotation to all trees
```

## Complete ChristmasTree Implementation

```python
from decimal import Decimal, getcontext
from shapely import affinity
from shapely.geometry import Polygon
from shapely.ops import unary_union

getcontext().prec = 25

class ChristmasTree:
    def __init__(self, center_x='0', center_y='0', angle='0'):
        self.center_x = Decimal(str(center_x))
        self.center_y = Decimal(str(center_y))
        self.angle = Decimal(str(angle))

        # Tree dimensions
        trunk_w = Decimal('0.15')
        trunk_h = Decimal('0.2')
        base_w = Decimal('0.7')
        mid_w = Decimal('0.4')
        top_w = Decimal('0.25')
        tip_y = Decimal('0.8')
        tier_1_y = Decimal('0.5')
        tier_2_y = Decimal('0.25')
        base_y = Decimal('0.0')
        trunk_bottom_y = -trunk_h

        # 15-vertex polygon
        initial_polygon = Polygon([
            (float(Decimal('0.0')), float(tip_y)),
            (float(top_w / 2), float(tier_1_y)),
            (float(top_w / 4), float(tier_1_y)),
            (float(mid_w / 2), float(tier_2_y)),
            (float(mid_w / 4), float(tier_2_y)),
            (float(base_w / 2), float(base_y)),
            (float(trunk_w / 2), float(base_y)),
            (float(trunk_w / 2), float(trunk_bottom_y)),
            (float(-trunk_w / 2), float(trunk_bottom_y)),
            (float(-trunk_w / 2), float(base_y)),
            (float(-base_w / 2), float(base_y)),
            (float(-mid_w / 4), float(tier_2_y)),
            (float(-mid_w / 2), float(tier_2_y)),
            (float(-top_w / 4), float(tier_1_y)),
            (float(-top_w / 2), float(tier_1_y)),
        ])
        
        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))
        self.polygon = affinity.translate(rotated, 
                                          xoff=float(self.center_x), 
                                          yoff=float(self.center_y))
```

## Submission Format

```csv
id,x,y,deg
001_0,s0.0,s0.0,s20.411299
002_0,s0.0,s0.0,s20.411299
002_1,s-0.541068,s0.259317,s51.66348
```
- Values prefixed with 's' to preserve precision
- Coordinates: -100 ≤ x, y ≤ 100
- No overlapping trees allowed
- Total rows: 20100 (1+2+3+...+200)

## Validation Code

```python
def calculate_score(submission_df):
    """Calculate total score from submission"""
    total_score = 0
    for n in range(1, 201):
        group = submission_df[submission_df['id'].str.startswith(f'{n:03d}_')]
        trees = [ChristmasTree(
            row['x'].lstrip('s'), 
            row['y'].lstrip('s'), 
            row['deg'].lstrip('s')
        ) for _, row in group.iterrows()]
        
        # Check for overlaps
        polygons = [t.polygon for t in trees]
        if has_overlap(polygons):
            print(f"WARNING: Overlap in N={n}")
            
        # Calculate bounding box
        bounds = unary_union(polygons).bounds
        side = max(bounds[2] - bounds[0], bounds[3] - bounds[1])
        
        total_score += (side ** 2) / n
    
    return total_score
```

## Strategy for Beating Target

1. **Start with best available baseline** - load from snapshots if available
2. **Focus on small N first** - N=1-20 contribute ~5 points, easier to optimize
3. **Implement pure Python algorithms** - no binaries
4. **Track per-N improvements** - accumulate wins across experiments
5. **Use rotation optimization** - often gives 0.01-0.1 improvement
6. **Consider asymmetric solutions** - discussions suggest these outperform symmetric
7. **Lattice patterns for large N** - grid-based placement for N >= 58

## Files and Paths

- Data: `/home/data/sample_submission.csv`
- Snapshots: `/home/nonroot/snapshots/santa-2025/`
- Research kernels: `../research/kernels/`

## Expected Workflow

1. Load best baseline from snapshots or sample_submission.csv
2. Calculate per-N scores for baseline
3. Implement exhaustive search for N=1-10
4. Apply improvements to baseline
5. Validate no overlaps
6. Submit and track improvements

## Score Contribution by N (Approximate)

| N Range | Contribution | Priority |
|---------|-------------|----------|
| N=1 | ~0.66 | HIGHEST |
| N=2-5 | ~1.5 | HIGH |
| N=6-10 | ~1.0 | HIGH |
| N=11-50 | ~10.0 | MEDIUM |
| N=51-100 | ~12.0 | MEDIUM |
| N=101-200 | ~44.0 | LOW (many trees, hard to optimize) |

Focus optimization effort on small N values where improvements have outsized impact!
