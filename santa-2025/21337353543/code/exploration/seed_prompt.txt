# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt

## Problem Overview

This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (15 vertices each) into the smallest possible square bounding box for N=1 to 200 trees.

**Scoring Formula:** score = Σ(side_n² / n) for n=1 to 200
- Lower is better
- Small N values contribute MORE to score (N=1 contributes ~0.66, N=200 contributes ~0.35)
- Target score: **68.888293** (must beat this)

**Tree Shape (15 vertices):**
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```
- Tree has tip at (0, 0.8), trunk bottom at y=-0.2
- Width: 0.7 at base, 0.4 at middle tier, 0.25 at top tier
- Trunk: 0.15 wide, 0.2 tall

## ⛔ ABSOLUTELY FORBIDDEN (EXPERIMENT WILL BE REJECTED)

The following are PERMANENTLY FORBIDDEN after baseline:
- bbox3 - FORBIDDEN
- sa_fast_v2 - FORBIDDEN  
- eazy_optimizer - FORBIDDEN
- tree_packer - FORBIDDEN
- shake_public - FORBIDDEN
- subprocess.run() - FORBIDDEN
- os.system() - FORBIDDEN
- ANY pre-compiled binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any tool - FORBIDDEN
- Running "more iterations" on any optimizer - FORBIDDEN

If your experiment runs ANY binary, it will produce ~70.6.
The target is 68.89. BINARIES CANNOT GET THERE.

## ✅ MANDATORY FIRST TASK: SOLVE N=1-10 OPTIMALLY

BEFORE any other work, implement exhaustive search for small N:

**For N=1 (contributes ~0.66 to score - HIGHEST!):**
- Test EVERY rotation angle from 0° to 360° in 0.01° increments
- Find the angle that minimizes bounding box
- This alone can improve score by 0.05-0.1 points

**For N=2-10:**
- Implement branch-and-bound or exhaustive placement search
- These contribute ~2.5 points total - worth optimizing!

## ✅ MANDATORY: PER-N SOLUTION TRACKING

Track best solution for EACH N value separately:
1. Load baseline per-N scores from existing submission
2. After your algorithm runs, compare per-N scores
3. SAVE any N where you improved (even if total is worse)
4. Accumulate improvements across experiments

## ✅ REQUIRED: IMPLEMENT ALGORITHM IN PYTHON

Write YOUR OWN code. Choose ONE:
1. Bottom-left constructive heuristic (easiest)
2. Genetic algorithm with crossover (medium)
3. Custom local search written from scratch (medium)
4. Branch-and-bound for exact solutions (hardest)

NO BINARIES. NO SUBPROCESS. NO OS.SYSTEM.
WRITE THE ALGORITHM YOURSELF IN PYTHON.

## Key Insights from Research

### Academic Approaches (from web search):
1. **No-Fit Polygon (NFP)**: Precompute collision-free regions for O(1) overlap checks
2. **Collision-Free Region (CFR)**: Place items ONLY on CFR vertices for optimal compaction
3. **Two-Level Algorithm**: Inner level solves fixed-container placement, outer level adjusts container size
4. **Extended Local Search**: Combine with nonlinear programming for overlap minimization
5. **Simulated Annealing**: Controls both sequence and placement of items

### Key Techniques from Kernels:
1. **Rotation Optimization (fix_direction)**: After packing, rotate entire configuration to minimize bounding box
2. **Squeeze/Compaction**: Scale configuration toward center until overlap, then back off
3. **Local Search**: Move trees toward center in small steps, keeping best non-overlapping position
4. **Boundary Focus**: Trees on bounding box boundary are most important to optimize

### Collision Detection (Shapely-based):
```python
from shapely.geometry import Polygon
from shapely import affinity
from shapely.strtree import STRtree

def has_overlap(polygons):
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

## Algorithm Recommendations

### Priority 1: Exhaustive Search for Small N (N=1-10)
```python
def optimize_single_tree():
    """For N=1, find optimal rotation angle"""
    best_side = float('inf')
    best_angle = 0
    for angle in np.arange(0, 360, 0.01):  # Fine-grained search
        tree = create_tree(0, 0, angle)
        bounds = tree.bounds
        side = max(bounds[2]-bounds[0], bounds[3]-bounds[1])
        if side < best_side:
            best_side = side
            best_angle = angle
    return best_angle, best_side
```

### Priority 2: Bottom-Left Heuristic with Rotation
```python
def bottom_left_place(existing_trees, new_tree_angle):
    """Place new tree at bottom-left feasible position"""
    # Start from far away, move toward center
    # Find first non-overlapping position
    # Try multiple angles for new tree
```

### Priority 3: Local Search Improvement
```python
def local_search(trees, max_iter=1000):
    """Improve existing configuration"""
    for _ in range(max_iter):
        # Pick random tree
        # Try small moves (dx, dy, dangle)
        # Keep if improves bounding box without overlap
```

### Priority 4: Rotation Optimization (Post-Processing)
```python
def optimize_rotation(trees):
    """Rotate entire configuration to minimize bounding box"""
    from scipy.optimize import minimize_scalar
    from scipy.spatial import ConvexHull
    
    # Get convex hull of all tree vertices
    # Find rotation angle that minimizes bounding box
    # Apply rotation to all trees
```

## Submission Format

```csv
id,x,y,deg
001_0,s0.0,s0.0,s20.411299
002_0,s0.0,s0.0,s20.411299
002_1,s-0.541068,s0.259317,s51.66348
```
- Values prefixed with 's' to preserve precision
- Coordinates: -100 ≤ x, y ≤ 100
- No overlapping trees allowed

## Validation Code

```python
def calculate_score(submission_df):
    """Calculate total score from submission"""
    total_score = 0
    for n in range(1, 201):
        group = submission_df[submission_df['id'].str.startswith(f'{n:03d}_')]
        trees = [create_tree(row) for _, row in group.iterrows()]
        
        # Check for overlaps
        if has_overlap(trees):
            print(f"WARNING: Overlap in N={n}")
            
        # Calculate bounding box
        all_bounds = [t.bounds for t in trees]
        minx = min(b[0] for b in all_bounds)
        maxx = max(b[2] for b in all_bounds)
        miny = min(b[1] for b in all_bounds)
        maxy = max(b[3] for b in all_bounds)
        side = max(maxx - minx, maxy - miny)
        
        total_score += (side ** 2) / n
    
    return total_score
```

## Strategy for Beating Target

1. **Start with best available baseline** - load from snapshots if available
2. **Focus on small N first** - N=1-20 contribute ~5 points, easier to optimize
3. **Implement pure Python algorithms** - no binaries
4. **Track per-N improvements** - accumulate wins across experiments
5. **Use rotation optimization** - often gives 0.01-0.1 improvement
6. **Consider asymmetric solutions** - discussions suggest these outperform symmetric

## Files and Paths

- Data: `/home/data/sample_submission.csv`
- Snapshots: `/home/nonroot/snapshots/santa-2025/`
- Research kernels: `../research/kernels/`

## Expected Workflow

1. Load best baseline from snapshots or sample_submission.csv
2. Calculate per-N scores for baseline
3. Implement exhaustive search for N=1-10
4. Apply improvements to baseline
5. Validate no overlaps
6. Submit and track improvements
