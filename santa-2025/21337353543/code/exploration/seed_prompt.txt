# Santa 2025 - Christmas Tree Packing Challenge - Loop 1 Seed Prompt

## Current Status
- **Best CV score:** 70.615791 from exp_000 (baseline)
- **Best LB score:** N/A (no submissions yet)
- **Target:** 68.888293 | **Gap to target:** 1.727498 points (2.4%)
- **Submissions remaining:** 94/100

## Response to Evaluator

The evaluator correctly identified that:
1. ✅ Baseline validation is thorough and correct
2. ✅ Per-N score tracking is implemented
3. ✅ N=1 contributes 0.661 to score - highest single contribution
4. ✅ The code directory is empty - no optimization code written yet

**Evaluator's top priority:** Implement exhaustive search for N=1-10. I AGREE - this is the highest-leverage work.

## ⛔ ABSOLUTELY FORBIDDEN

- bbox3, sa_fast_v2, eazy_optimizer, tree_packer, shake_public - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY pre-compiled binary - FORBIDDEN
- These produce ~70.6 and CANNOT reach target of 68.89

## ✅ MANDATORY EXPERIMENT 001: SOLVE N=1-10 OPTIMALLY

This is the HIGHEST PRIORITY task. Implement in pure Python:

### N=1 Exhaustive Search (CRITICAL - contributes 0.661 to score!)

```python
import numpy as np
from shapely.geometry import Polygon
from shapely import affinity

# Tree vertices
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def get_bbox_side(angle):
    """Get bounding box side for single tree at given angle."""
    poly = Polygon(zip(TX, TY))
    rotated = affinity.rotate(poly, angle, origin=(0, 0))
    bounds = rotated.bounds  # (minx, miny, maxx, maxy)
    return max(bounds[2] - bounds[0], bounds[3] - bounds[1])

# Exhaustive search: 0° to 360° in 0.01° increments
best_angle, best_side = 0, float('inf')
for angle_int in range(36000):  # 0.01° resolution
    angle = angle_int / 100.0
    side = get_bbox_side(angle)
    if side < best_side:
        best_side, best_angle = side, angle

print(f"Optimal N=1: angle={best_angle}°, side={best_side}")
# Current baseline: side=0.813, score=0.661
# If we can get side=0.78, score=0.608 → saves 0.053 points!
```

### N=2-10 Systematic Search

For N=2-10, implement placement search:
1. For each N, try multiple rotation combinations
2. Use bottom-left heuristic for placement
3. Apply rotation optimization (fix_direction) as post-processing

### Rotation Optimization (fix_direction) - ALLOWED, Pure Python

From the saspav kernel, this technique rotates the ENTIRE configuration to minimize bounding box:

```python
from scipy.spatial import ConvexHull
from scipy.optimize import minimize_scalar

def optimize_rotation(trees):
    """Find optimal rotation angle for entire configuration."""
    # Get all vertices
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points_np = np.array(all_points)
    
    # Use convex hull for efficiency
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    def bbox_at_angle(angle_deg):
        angle_rad = np.radians(angle_deg)
        c, s = np.cos(angle_rad), np.sin(angle_rad)
        rot_matrix = np.array([[c, s], [-s, c]])
        rotated = hull_points.dot(rot_matrix)
        min_xy = np.min(rotated, axis=0)
        max_xy = np.max(rotated, axis=0)
        return max(max_xy[0] - min_xy[0], max_xy[1] - min_xy[1])
    
    # Optimize in [0, 90] range (symmetry)
    res = minimize_scalar(bbox_at_angle, bounds=(0, 90), method='bounded')
    return res.x, res.fun
```

## Per-N Score Tracking (MANDATORY)

After optimization, compare per-N scores to baseline:

```python
import json

# Load baseline per-N scores
with open('/home/code/experiments/000_baseline/per_n_scores.json') as f:
    baseline = json.load(f)

# Compare and track improvements
improvements = []
for n in range(1, 201):
    my_score = my_per_n_scores[n]
    base_score = baseline['scores'][str(n)]
    diff = base_score - my_score  # positive = improvement
    if diff > 0.0001:
        improvements.append((n, diff))
        print(f"✅ N={n}: IMPROVED by {diff:.6f}")

print(f"\nTotal improvements: {len(improvements)} N values")
print(f"Total score gain: {sum(d for _, d in improvements):.6f}")
```

## Baseline Per-N Analysis (Key Targets)

From the baseline, these N values have highest potential for improvement:

| N | Current Side | Current Score | Contribution |
|---|-------------|---------------|--------------|
| 1 | 0.813 | 0.661 | HIGHEST - optimize first! |
| 2 | 0.950 | 0.451 | High impact |
| 3 | 1.142 | 0.435 | High impact |
| 4 | 1.291 | 0.417 | High impact |
| 5 | 1.444 | 0.417 | High impact |
| 6-10 | 1.55-1.94 | 0.38-0.40 each | Medium impact |

**Total N=1-10 contribution: ~4.3 points (6% of total score)**

## Algorithm Implementation Order

1. **FIRST:** N=1 exhaustive rotation search (30 minutes)
2. **SECOND:** Apply fix_direction to all N values (1 hour)
3. **THIRD:** N=2-5 placement optimization (2 hours)
4. **FOURTH:** N=6-10 placement optimization (2 hours)

## Submission Strategy

**SUBMIT AFTER THIS EXPERIMENT!** We have 94 submissions remaining.
- Even if score is worse, LB feedback is valuable
- We need to calibrate CV-LB relationship
- Submissions are FREE information

## What NOT to Try

- ❌ Running bbox3, shake_public, or any binary
- ❌ "Optimizing" existing CSV with external tools
- ❌ Copying kernel approaches that use binaries
- ❌ Skipping small N optimization

## Expected Outcome

If we optimize N=1-10 properly:
- N=1: 0.661 → ~0.61 (save 0.05)
- N=2-5: 1.72 → ~1.65 (save 0.07)
- N=6-10: 1.95 → ~1.88 (save 0.07)
- **Total expected improvement: 0.15-0.25 points**

This would bring score from 70.62 to ~70.40, still far from target but a solid start.

## Key Insight from Discussions

Discussion "Why the winning solutions will be Asymmetric" (39 votes):
- Asymmetric solutions outperform symmetric ones
- Don't assume rotational symmetry in optimal solutions
- This suggests we need to explore non-standard placements

## Validation Requirements

Before submission, validate:
1. No overlaps (use Shapely intersection check)
2. Correct submission format (s-prefixed values)
3. All 200 N values present
4. Per-N scores calculated correctly
