# Santa 2025 - Christmas Tree Packing Challenge - Loop 1 Seed Prompt

## Current Status
- Best CV score: 70.615791 from exp_000 (baseline)
- Best LB score: **FAILED** - "Overlapping trees in group 040"
- Target: 68.887744 | Gap to target: 1.727 points

## ⚠️ CRITICAL ISSUE: BASELINE SUBMISSION FAILED ⚠️

The baseline submission was REJECTED by Kaggle with error: **"Overlapping trees in group 040"**

**Root Cause:** Our local validation using Shapely passed, but Kaggle's validation is STRICTER.

**Why This Happened:**
1. The official kernel uses `scale_factor = Decimal('1e15')` to scale all coordinates
2. This converts floating-point to integer-like precision for collision detection
3. Our local validation used standard Shapely without this scaling
4. Trees that appear to "touch" locally may actually overlap at Kaggle's precision

## Response to Evaluator

The evaluator correctly identified that:
1. ✅ Baseline validation was thorough - but it used WRONG precision
2. ✅ Per-N tracking is implemented - this is good
3. ✅ Small N optimization has highest ROI - agreed
4. ⚠️ N=1 is NOT optimally solved - this is a key opportunity

**However, the evaluator missed the critical issue:** The baseline submission FAILED due to overlap detection precision mismatch. We MUST fix this before any optimization work.

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any tool - FORBIDDEN

## ✅ MANDATORY FIRST TASK: FIX OVERLAP VALIDATION

Before ANY optimization, you MUST implement proper overlap detection:

```python
from decimal import Decimal, getcontext
from shapely.geometry import Polygon
from shapely import affinity
from shapely.strtree import STRtree

getcontext().prec = 25
SCALE_FACTOR = Decimal('1e15')

# Tree shape vertices
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def create_scaled_tree_polygon(x, y, angle):
    """Create tree polygon with 1e15 scaling for precision."""
    x = Decimal(str(x))
    y = Decimal(str(y))
    angle = Decimal(str(angle))
    
    # Create polygon with scaled coordinates
    coords = [(Decimal(str(tx)) * SCALE_FACTOR, Decimal(str(ty)) * SCALE_FACTOR) 
              for tx, ty in zip(TX, TY)]
    poly = Polygon(coords)
    
    # Rotate and translate with scaling
    poly = affinity.rotate(poly, float(angle), origin=(0, 0))
    poly = affinity.translate(poly, 
                              xoff=float(x * SCALE_FACTOR), 
                              yoff=float(y * SCALE_FACTOR))
    return poly

def has_overlap_strict(polygons):
    """Check for overlaps using strict precision."""
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i:
                if poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                    return True, i, idx
    return False, -1, -1
```

## ✅ TASK 1: VALIDATE AND FIX BASELINE (REQUIRED FIRST)

1. Load the baseline submission from `/home/code/experiments/000_baseline/submission.csv`
2. Re-validate ALL N values using the STRICT overlap detection above
3. Identify which N values have overlaps (we know N=40 does)
4. For each N with overlaps, apply a small "separation" to fix:
   - Move overlapping trees apart by tiny amounts (0.001 units)
   - Re-check until no overlaps
5. Save the FIXED submission

**Expected outcome:** A valid submission that passes Kaggle's validation.

## ✅ TASK 2: SOLVE N=1 OPTIMALLY (HIGHEST IMPACT)

After fixing overlaps, optimize N=1:

```python
def optimize_n1():
    """Find optimal rotation for single tree."""
    best_side = float('inf')
    best_angle = 0
    
    for angle_int in range(0, 36000):  # 0.01° increments
        angle = angle_int / 100.0
        tree = create_scaled_tree_polygon(0, 0, angle)
        bounds = tree.bounds
        width = (Decimal(str(bounds[2])) - Decimal(str(bounds[0]))) / SCALE_FACTOR
        height = (Decimal(str(bounds[3])) - Decimal(str(bounds[1]))) / SCALE_FACTOR
        side = float(max(width, height))
        
        if side < best_side:
            best_side = side
            best_angle = angle
    
    return best_angle, best_side
```

N=1 contributes ~0.66 to total score. Even a 0.01 improvement in side = 0.016 points saved!

## ✅ TASK 3: EXTEND TO N=2-10

For N=2-10, implement exhaustive or branch-and-bound search:
- N=2: Try all rotation combinations (0-360° in 1° steps for both trees)
- N=3-5: Use greedy placement with multiple rotation attempts
- N=6-10: Use bottom-left heuristic with rotation optimization

## Per-N Score Tracking (MANDATORY)

After each improvement:
1. Compare per-N scores to baseline
2. Save improvements to `/home/code/experiments/001_fix_overlaps/per_n_improvements.json`
3. Only keep N values where you improved

## Validation Before Submission (MANDATORY)

Before creating ANY submission:
```python
# Validate ALL N values with strict precision
for n in range(1, 201):
    trees = get_trees_for_n(n)
    polygons = [create_scaled_tree_polygon(t.x, t.y, t.angle) for t in trees]
    has_overlap, i, j = has_overlap_strict(polygons)
    if has_overlap:
        print(f"⚠️ N={n}: Trees {i} and {j} overlap - FIX REQUIRED")
```

## Expected Experiment Flow

1. **exp_001_fix_overlaps**: Fix the baseline to pass Kaggle validation
   - Expected CV: ~70.62 (same as baseline, just fixed)
   - Expected LB: Should pass validation

2. **exp_002_optimize_n1**: Optimize N=1 rotation
   - Expected improvement: 0.02-0.05 points

3. **exp_003_optimize_small_n**: Optimize N=2-10
   - Expected improvement: 0.1-0.3 points

## Key Insights from Research

1. **Precision is critical**: Use `scale_factor = 1e15` for all collision detection
2. **Asymmetric solutions win**: Don't assume rotational symmetry
3. **Small N has highest impact**: N=1-10 contribute ~4.3 points (6% of total)
4. **Binaries produce ~70.6**: We need novel approaches to reach 68.89

## Submission Strategy

- Remaining submissions: 94
- **SUBMIT AFTER FIXING OVERLAPS** - we need to verify the fix works
- Then submit after each meaningful improvement
- LB feedback is free information - use it!
