{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-25T18:27:02.857805",
  "time_limit_minutes": 2100,
  "experiments": [
    {
      "id": "exp_000",
      "name": "000_baseline",
      "model_type": "optimization",
      "score": 70.615791,
      "cv_score": 70.615791,
      "lb_score": null,
      "notes": "Baseline from best available snapshot (21337107511). Score: 70.615791, Target: 68.888293, Gap: 1.727498. No overlaps detected. Score breakdown: N=1: 0.6612, N=2-5: 1.7189, N=6-10: 1.9490, N=11-50: 14.7036, N=51-100: 17.6063, N=101-200: 33.9768. Small N values have highest impact - N=1 alone contributes 0.66 to score.",
      "experiment_folder": "experiments/000_baseline",
      "timestamp": "2026-01-25T18:34:37.636267"
    }
  ],
  "candidates": [
    {
      "file_path": "/home/code/submission_candidates/candidate_000.csv",
      "score": 70.615791,
      "cv_score": 70.615791,
      "model_name": "000_baseline",
      "experiment_id": "exp_000",
      "timestamp": "2026-01-25T18:34:37.637763"
    }
  ],
  "submissions": [],
  "strategy_history": [
    {
      "strategy": "# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt\n\n## Problem Overview\n\nThis is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (15 vertices each) into the smallest possible square bounding box for N=1 to 200 trees.\n\n**Scoring Formula:** score = \u03a3(side_n\u00b2 / n) for n=1 to 200\n- Lower is better\n- Small N values contribute MORE to score (N=1 contributes ~0.66, N=200 contributes ~0.35)\n- Target score: **68.888293** (must beat this)\n\n**Tree Shape (15 vertices):**\n```python\nTX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]\nTY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]\n```\n- Tree has tip at (0, 0.8), trunk bottom at y=-0.2\n- Width: 0.7 at base, 0.4 at middle tier, 0.25 at top tier\n- Trunk: 0.15 wide, 0.2 tall\n\n## \u26d4 ABSOLUTELY FORBIDDEN (EXPERIMENT WILL BE REJECTED)\n\nThe following are PERMANENTLY FORBIDDEN after baseline:\n- bbox3 - FORBIDDEN\n- sa_fast_v2 - FORBIDDEN  \n- eazy_optimizer - FORBIDDEN\n- tree_packer - FORBIDDEN\n- shake_public - FORBIDDEN\n- subprocess.run() - FORBIDDEN\n- os.system() - FORBIDDEN\n- ANY pre-compiled binary or executable - FORBIDDEN\n- \"Optimizing\" existing CSV files with any tool - FORBIDDEN\n- Running \"more iterations\" on any optimizer - FORBIDDEN\n\nIf your experiment runs ANY binary, it will produce ~70.6.\nThe target is 68.89. BINARIES CANNOT GET THERE.\n\n## \u2705 MANDATORY FIRST TASK: SOLVE N=1-10 OPTIMALLY\n\nBEFORE any other work, implement exhaustive search for small N:\n\n**For N=1 (contributes ~0.66 to score - HIGHEST!):**\n- Test EVERY rotation angle from 0\u00b0 to 360\u00b0 in 0.01\u00b0 increments\n- Find the angle that minimizes bounding box\n- This alone can improve score by 0.05-0.1 points\n\n**For N=2-10:**\n- Implement branch-and-bound or exhaustive placement search\n- These contribute ~2.5 points total - worth optimizing!\n\n## \u2705 MANDATORY: PER-N SOLUTION TRACKING\n\nTrack best solution for EACH N value separately:\n1. Load baseline per-N scores from existing submission\n2. After your algorithm runs, compare per-N scores\n3. SAVE any N where you improved (even if total is worse)\n4. Accumulate improvements across experiments\n\n## \u2705 REQUIRED: IMPLEMENT ALGORITHM IN PYTHON\n\nWrite YOUR OWN code. Choose ONE:\n1. Bottom-left constructive heuristic (easiest)\n2. Genetic algorithm with crossover (medium)\n3. Custom local search written from scratch (medium)\n4. Branch-and-bound for exact solutions (hardest)\n\nNO BINARIES. NO SUBPROCESS. NO OS.SYSTEM.\nWRITE THE ALGORITHM YOURSELF IN PYTHON.\n\n## Insights from Discussions (MANDATORY)\n\n- Discussion \"Why the winning solutions will be Asymmetric\" (39 votes): Asymmetric solutions outperform symmetric ones for this packing problem. Don't assume rotational symmetry in optimal solutions.\n- Discussion \"Expected Leaderboard Progression\" (20 votes): Staff-provided guidance on expected score progression\n- Discussion \"Interactive Editor\" (58 votes): Tool for manually adjusting tree positions - suggests manual fine-tuning is valuable\n- Discussion \"IMPORTANT: Santa Etiquette\" (78 votes): Competition rules and guidelines\n\n## What Discussions Say DOESN'T Work\n- Short optimization runs on pre-optimized submissions (local optimum is too tight)\n- Simple ensemble of existing CSVs (one source dominates all N values)\n- Running binaries with default parameters (produces ~70.6, not competitive)\n\n## Unexplored Ideas from Discussions\n- Lattice-based approach for large N (grid patterns for N >= 58)\n- Backward propagation (remove trees from N to improve N-1)\n- Focus on small N values which have highest score contribution\n\n## Key Insights from Research\n\n### Academic Approaches (from web search):\n1. **No-Fit Polygon (NFP)**: Precompute collision-free regions for O(1) overlap checks\n2. **Collision-Free Region (CFR)**: Place items ONLY on CFR vertices for optimal compaction\n3. **Two-Level Algorithm**: Inner level solves fixed-container placement, outer level adjusts container size\n4. **Extended Local Search**: Combine with nonlinear programming for overlap minimization\n5. **Simulated Annealing**: Controls both sequence and placement of items\n\n### Key Techniques from Kernels:\n1. **Rotation Optimization (fix_direction)**: After packing, rotate entire configuration to minimize bounding box\n2. **Squeeze/Compaction**: Scale configuration toward center until overlap, then back off\n3. **Local Search**: Move trees toward center in small steps, keeping best non-overlapping position\n4. **Boundary Focus**: Trees on bounding box boundary are most important to optimize\n\n### Collision Detection (Shapely-based):\n```python\nfrom shapely.geometry import Polygon\nfrom shapely import affinity\nfrom shapely.strtree import STRtree\n\ndef has_overlap(polygons):\n    tree_index = STRtree(polygons)\n    for i, poly in enumerate(polygons):\n        indices = tree_index.query(poly)\n        for idx in indices:\n            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):\n                return True\n    return False\n```\n\n## Algorithm Recommendations\n\n### Priority 1: Exhaustive Search for Small N (N=1-10)\n```python\ndef optimize_single_tree():\n    \"\"\"For N=1, find optimal rotation angle\"\"\"\n    best_side = float('inf')\n    best_angle = 0\n    for angle in np.arange(0, 360, 0.01):  # Fine-grained search\n        tree = create_tree(0, 0, angle)\n        bounds = tree.bounds\n        side = max(bounds[2]-bounds[0], bounds[3]-bounds[1])\n        if side < best_side:\n            best_side = side\n            best_angle = angle\n    return best_angle, best_side\n```\n\n### Priority 2: Bottom-Left Heuristic with Rotation\n```python\ndef bottom_left_place(existing_trees, new_tree_angle):\n    \"\"\"Place new tree at bottom-left feasible position\"\"\"\n    # Start from far away, move toward center\n    # Find first non-overlapping position\n    # Try multiple angles for new tree\n```\n\n### Priority 3: Local Search Improvement\n```python\ndef local_search(trees, max_iter=1000):\n    \"\"\"Improve existing configuration\"\"\"\n    for _ in range(max_iter):\n        # Pick random tree\n        # Try small moves (dx, dy, dangle)\n        # Keep if improves bounding box without overlap\n```\n\n### Priority 4: Rotation Optimization (Post-Processing)\n```python\ndef optimize_rotation(trees):\n    \"\"\"Rotate entire configuration to minimize bounding box\"\"\"\n    from scipy.optimize import minimize_scalar\n    from scipy.spatial import ConvexHull\n    \n    # Get convex hull of all tree vertices\n    # Find rotation angle that minimizes bounding box\n    # Apply rotation to all trees\n```\n\n## Complete ChristmasTree Implementation\n\n```python\nfrom decimal import Decimal, getcontext\nfrom shapely import affinity\nfrom shapely.geometry import Polygon\nfrom shapely.ops import unary_union\n\ngetcontext().prec = 25\n\nclass ChristmasTree:\n    def __init__(self, center_x='0', center_y='0', angle='0'):\n        self.center_x = Decimal(str(center_x))\n        self.center_y = Decimal(str(center_y))\n        self.angle = Decimal(str(angle))\n\n        # Tree dimensions\n        trunk_w = Decimal('0.15')\n        trunk_h = Decimal('0.2')\n        base_w = Decimal('0.7')\n        mid_w = Decimal('0.4')\n        top_w = Decimal('0.25')\n        tip_y = Decimal('0.8')\n        tier_1_y = Decimal('0.5')\n        tier_2_y = Decimal('0.25')\n        base_y = Decimal('0.0')\n        trunk_bottom_y = -trunk_h\n\n        # 15-vertex polygon\n        initial_polygon = Polygon([\n            (float(Decimal('0.0')), float(tip_y)),\n            (float(top_w / 2), float(tier_1_y)),\n            (float(top_w / 4), float(tier_1_y)),\n            (float(mid_w / 2), float(tier_2_y)),\n            (float(mid_w / 4), float(tier_2_y)),\n            (float(base_w / 2), float(base_y)),\n            (float(trunk_w / 2), float(base_y)),\n            (float(trunk_w / 2), float(trunk_bottom_y)),\n            (float(-trunk_w / 2), float(trunk_bottom_y)),\n            (float(-trunk_w / 2), float(base_y)),\n            (float(-base_w / 2), float(base_y)),\n            (float(-mid_w / 4), float(tier_2_y)),\n            (float(-mid_w / 2), float(tier_2_y)),\n            (float(-top_w / 4), float(tier_1_y)),\n            (float(-top_w / 2), float(tier_1_y)),\n        ])\n        \n        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))\n        self.polygon = affinity.translate(rotated, \n                                          xoff=float(self.center_x), \n                                          yoff=float(self.center_y))\n```\n\n## Submission Format\n\n```csv\nid,x,y,deg\n001_0,s0.0,s0.0,s20.411299\n002_0,s0.0,s0.0,s20.411299\n002_1,s-0.541068,s0.259317,s51.66348\n```\n- Values prefixed with 's' to preserve precision\n- Coordinates: -100 \u2264 x, y \u2264 100\n- No overlapping trees allowed\n- Total rows: 20100 (1+2+3+...+200)\n\n## Validation Code\n\n```python\ndef calculate_score(submission_df):\n    \"\"\"Calculate total score from submission\"\"\"\n    total_score = 0\n    for n in range(1, 201):\n        group = submission_df[submission_df['id'].str.startswith(f'{n:03d}_')]\n        trees = [ChristmasTree(\n            row['x'].lstrip('s'), \n            row['y'].lstrip('s'), \n            row['deg'].lstrip('s')\n        ) for _, row in group.iterrows()]\n        \n        # Check for overlaps\n        polygons = [t.polygon for t in trees]\n        if has_overlap(polygons):\n            print(f\"WARNING: Overlap in N={n}\")\n            \n        # Calculate bounding box\n        bounds = unary_union(polygons).bounds\n        side = max(bounds[2] - bounds[0], bounds[3] - bounds[1])\n        \n        total_score += (side ** 2) / n\n    \n    return total_score\n```\n\n## Strategy for Beating Target\n\n1. **Start with best available baseline** - load from snapshots if available\n2. **Focus on small N first** - N=1-20 contribute ~5 points, easier to optimize\n3. **Implement pure Python algorithms** - no binaries\n4. **Track per-N improvements** - accumulate wins across experiments\n5. **Use rotation optimization** - often gives 0.01-0.1 improvement\n6. **Consider asymmetric solutions** - discussions suggest these outperform symmetric\n7. **Lattice patterns for large N** - grid-based placement for N >= 58\n\n## Files and Paths\n\n- Data: `/home/data/sample_submission.csv`\n- Snapshots: `/home/nonroot/snapshots/santa-2025/`\n- Research kernels: `../research/kernels/`\n\n## Expected Workflow\n\n1. Load best baseline from snapshots or sample_submission.csv\n2. Calculate per-N scores for baseline\n3. Implement exhaustive search for N=1-10\n4. Apply improvements to baseline\n5. Validate no overlaps\n6. Submit and track improvements\n\n## Score Contribution by N (Approximate)\n\n| N Range | Contribution | Priority |\n|---------|-------------|----------|\n| N=1 | ~0.66 | HIGHEST |\n| N=2-5 | ~1.5 | HIGH |\n| N=6-10 | ~1.0 | HIGH |\n| N=11-50 | ~10.0 | MEDIUM |\n| N=51-100 | ~12.0 | MEDIUM |\n| N=101-200 | ~44.0 | LOW (many trees, hard to optimize) |\n\nFocus optimization effort on small N values where improvements have outsized impact!\n",
      "agent": "explorer",
      "timestamp": "2026-01-25T18:32:02.360939"
    }
  ],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D irregular polygon packing problem - pack Christmas tree shapes into smallest square bounding box for N=1 to 200. Score = sum(side^2/n). Tree shape is a 15-vertex polygon with trunk and 3 tiers. Key approaches: 1) Simulated annealing with local search, 2) Genetic algorithms, 3) Bottom-left heuristics, 4) No-fit polygon (NFP) for collision detection, 5) Compaction/squeeze operations. Top kernels use C++ compiled binaries (bbox3, tree_packer) for speed.",
      "source": "../research/description.md and ../research/kernels/",
      "agent": "explorer"
    },
    {
      "finding": "Academic research shows: 1) Extended local search with nonlinear programming, 2) Collision-free region (CFR) placement, 3) Simulated annealing controls sequence and placement, 4) Two-level algorithms (inner: fixed container, outer: adjust container size), 5) Tabu search to avoid local minima. Key insight: place items on CFR vertices for optimal compaction.",
      "source": "web_search_irregular_polygon_packing",
      "agent": "explorer"
    },
    {
      "finding": "Key kernels use pre-compiled binaries: bbox3 (main optimizer), shake_public (shaking/perturbation), tree_packer (SA-based). The workflow is: 1) Start with good baseline CSV, 2) Run bbox3 with parameters -n (iterations) -r (restarts), 3) Apply fix_direction (rotation optimization), 4) Run shake_public for perturbation, 5) Validate and repair overlaps. Score ~70.6 achievable with binaries, target 68.89 requires novel approaches.",
      "source": "../research/kernels/saspav_santa-submission/",
      "agent": "explorer"
    },
    {
      "finding": "Discussion 'Why the winning solutions will be Asymmetric' (39 votes) suggests asymmetric solutions outperform symmetric ones for this packing problem. This is a key insight for algorithm design - don't assume rotational symmetry in optimal solutions.",
      "source": "discussion_666880",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for irregular polygon packing optimization in 2D?",
      "finding": "Gli algoritmi pi\u00f9 efficaci per l'ottimizzazione del packing di poligoni irregolari in 2D sono spesso basati su approcci euristici, metaeuristici e metodi esatti, a seconda della complessit\u00e0 e delle specifiche del problema. Tra le tecniche pi\u00f9 note vi sono gli algoritmi genetici combinati con metodi lineari, come descritto in uno studio che propone un approccio ibrido di genetico e programmazione lineare per ottimizzare il packing irregolare ([MDPI](https://www.mdpi.com/2076-3417/13/22/12474)). Inoltre, i metodi di ricerca locale estesa, come quelli basati sulla programmazione non lineare e sul simulated annealing, sono stati efficaci nel trovare soluzioni competitive e migliorare risultati noti, anche minimizzando il materiale di scarto ([ScienceDirect](https://www.sciencedirect.com/science/article/abs/pii/S0305054811001596), [Springer](https://link.springer.com/article/10.1007/s10479-013-1341-4)). \n\nAltri approcci includono heuristici come l'algoritmo di Djang e Finch adattato per il ",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 94
}