{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-25T18:27:02.857805",
  "time_limit_minutes": 2100,
  "experiments": [
    {
      "id": "exp_000",
      "name": "000_baseline",
      "model_type": "optimization",
      "score": 70.615791,
      "cv_score": 70.615791,
      "lb_score": null,
      "notes": "Baseline from best available snapshot (21337107511). Score: 70.615791, Target: 68.888293, Gap: 1.727498. No overlaps detected. Score breakdown: N=1: 0.6612, N=2-5: 1.7189, N=6-10: 1.9490, N=11-50: 14.7036, N=51-100: 17.6063, N=101-200: 33.9768. Small N values have highest impact - N=1 alone contributes 0.66 to score.",
      "experiment_folder": "experiments/000_baseline",
      "timestamp": "2026-01-25T18:34:37.636267"
    }
  ],
  "candidates": [
    {
      "file_path": "/home/code/submission_candidates/candidate_000.csv",
      "score": 70.615791,
      "cv_score": 70.615791,
      "model_name": "000_baseline",
      "experiment_id": "exp_000",
      "timestamp": "2026-01-25T18:34:37.637763"
    }
  ],
  "submissions": [
    {
      "candidate_id": "exp_000",
      "experiment_id": "exp_000",
      "timestamp": "2026-01-25T18:38:00.084492+00:00",
      "model_name": "000_baseline",
      "cv_score": 70.615791,
      "lb_score": "",
      "error": "Overlapping trees in group 040"
    }
  ],
  "strategy_history": [
    {
      "strategy": "# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt\n\n## Problem Overview\n\nThis is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (15 vertices each) into the smallest possible square bounding box for N=1 to 200 trees.\n\n**Scoring Formula:** score = \u03a3(side_n\u00b2 / n) for n=1 to 200\n- Lower is better\n- Small N values contribute MORE to score (N=1 contributes ~0.66, N=200 contributes ~0.35)\n- Target score: **68.888293** (must beat this)\n\n**Tree Shape (15 vertices):**\n```python\nTX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]\nTY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]\n```\n- Tree has tip at (0, 0.8), trunk bottom at y=-0.2\n- Width: 0.7 at base, 0.4 at middle tier, 0.25 at top tier\n- Trunk: 0.15 wide, 0.2 tall\n\n## \u26d4 ABSOLUTELY FORBIDDEN (EXPERIMENT WILL BE REJECTED)\n\nThe following are PERMANENTLY FORBIDDEN after baseline:\n- bbox3 - FORBIDDEN\n- sa_fast_v2 - FORBIDDEN  \n- eazy_optimizer - FORBIDDEN\n- tree_packer - FORBIDDEN\n- shake_public - FORBIDDEN\n- subprocess.run() - FORBIDDEN\n- os.system() - FORBIDDEN\n- ANY pre-compiled binary or executable - FORBIDDEN\n- \"Optimizing\" existing CSV files with any tool - FORBIDDEN\n- Running \"more iterations\" on any optimizer - FORBIDDEN\n\nIf your experiment runs ANY binary, it will produce ~70.6.\nThe target is 68.89. BINARIES CANNOT GET THERE.\n\n## \u2705 MANDATORY FIRST TASK: SOLVE N=1-10 OPTIMALLY\n\nBEFORE any other work, implement exhaustive search for small N:\n\n**For N=1 (contributes ~0.66 to score - HIGHEST!):**\n- Test EVERY rotation angle from 0\u00b0 to 360\u00b0 in 0.01\u00b0 increments\n- Find the angle that minimizes bounding box\n- This alone can improve score by 0.05-0.1 points\n\n**For N=2-10:**\n- Implement branch-and-bound or exhaustive placement search\n- These contribute ~2.5 points total - worth optimizing!\n\n## \u2705 MANDATORY: PER-N SOLUTION TRACKING\n\nTrack best solution for EACH N value separately:\n1. Load baseline per-N scores from existing submission\n2. After your algorithm runs, compare per-N scores\n3. SAVE any N where you improved (even if total is worse)\n4. Accumulate improvements across experiments\n\n## \u2705 REQUIRED: IMPLEMENT ALGORITHM IN PYTHON\n\nWrite YOUR OWN code. Choose ONE:\n1. Bottom-left constructive heuristic (easiest)\n2. Genetic algorithm with crossover (medium)\n3. Custom local search written from scratch (medium)\n4. Branch-and-bound for exact solutions (hardest)\n\nNO BINARIES. NO SUBPROCESS. NO OS.SYSTEM.\nWRITE THE ALGORITHM YOURSELF IN PYTHON.\n\n## Insights from Discussions (MANDATORY)\n\n- Discussion \"Why the winning solutions will be Asymmetric\" (39 votes): Asymmetric solutions outperform symmetric ones for this packing problem. Don't assume rotational symmetry in optimal solutions.\n- Discussion \"Expected Leaderboard Progression\" (20 votes): Staff-provided guidance on expected score progression\n- Discussion \"Interactive Editor\" (58 votes): Tool for manually adjusting tree positions - suggests manual fine-tuning is valuable\n- Discussion \"IMPORTANT: Santa Etiquette\" (78 votes): Competition rules and guidelines\n\n## What Discussions Say DOESN'T Work\n- Short optimization runs on pre-optimized submissions (local optimum is too tight)\n- Simple ensemble of existing CSVs (one source dominates all N values)\n- Running binaries with default parameters (produces ~70.6, not competitive)\n\n## Unexplored Ideas from Discussions\n- Lattice-based approach for large N (grid patterns for N >= 58)\n- Backward propagation (remove trees from N to improve N-1)\n- Focus on small N values which have highest score contribution\n\n## Key Insights from Research\n\n### Academic Approaches (from web search):\n1. **No-Fit Polygon (NFP)**: Precompute collision-free regions for O(1) overlap checks\n2. **Collision-Free Region (CFR)**: Place items ONLY on CFR vertices for optimal compaction\n3. **Two-Level Algorithm**: Inner level solves fixed-container placement, outer level adjusts container size\n4. **Extended Local Search**: Combine with nonlinear programming for overlap minimization\n5. **Simulated Annealing**: Controls both sequence and placement of items\n\n### Key Techniques from Kernels:\n1. **Rotation Optimization (fix_direction)**: After packing, rotate entire configuration to minimize bounding box\n2. **Squeeze/Compaction**: Scale configuration toward center until overlap, then back off\n3. **Local Search**: Move trees toward center in small steps, keeping best non-overlapping position\n4. **Boundary Focus**: Trees on bounding box boundary are most important to optimize\n\n### Collision Detection (Shapely-based):\n```python\nfrom shapely.geometry import Polygon\nfrom shapely import affinity\nfrom shapely.strtree import STRtree\n\ndef has_overlap(polygons):\n    tree_index = STRtree(polygons)\n    for i, poly in enumerate(polygons):\n        indices = tree_index.query(poly)\n        for idx in indices:\n            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):\n                return True\n    return False\n```\n\n## Algorithm Recommendations\n\n### Priority 1: Exhaustive Search for Small N (N=1-10)\n```python\ndef optimize_single_tree():\n    \"\"\"For N=1, find optimal rotation angle\"\"\"\n    best_side = float('inf')\n    best_angle = 0\n    for angle in np.arange(0, 360, 0.01):  # Fine-grained search\n        tree = create_tree(0, 0, angle)\n        bounds = tree.bounds\n        side = max(bounds[2]-bounds[0], bounds[3]-bounds[1])\n        if side < best_side:\n            best_side = side\n            best_angle = angle\n    return best_angle, best_side\n```\n\n### Priority 2: Bottom-Left Heuristic with Rotation\n```python\ndef bottom_left_place(existing_trees, new_tree_angle):\n    \"\"\"Place new tree at bottom-left feasible position\"\"\"\n    # Start from far away, move toward center\n    # Find first non-overlapping position\n    # Try multiple angles for new tree\n```\n\n### Priority 3: Local Search Improvement\n```python\ndef local_search(trees, max_iter=1000):\n    \"\"\"Improve existing configuration\"\"\"\n    for _ in range(max_iter):\n        # Pick random tree\n        # Try small moves (dx, dy, dangle)\n        # Keep if improves bounding box without overlap\n```\n\n### Priority 4: Rotation Optimization (Post-Processing)\n```python\ndef optimize_rotation(trees):\n    \"\"\"Rotate entire configuration to minimize bounding box\"\"\"\n    from scipy.optimize import minimize_scalar\n    from scipy.spatial import ConvexHull\n    \n    # Get convex hull of all tree vertices\n    # Find rotation angle that minimizes bounding box\n    # Apply rotation to all trees\n```\n\n## Complete ChristmasTree Implementation\n\n```python\nfrom decimal import Decimal, getcontext\nfrom shapely import affinity\nfrom shapely.geometry import Polygon\nfrom shapely.ops import unary_union\n\ngetcontext().prec = 25\n\nclass ChristmasTree:\n    def __init__(self, center_x='0', center_y='0', angle='0'):\n        self.center_x = Decimal(str(center_x))\n        self.center_y = Decimal(str(center_y))\n        self.angle = Decimal(str(angle))\n\n        # Tree dimensions\n        trunk_w = Decimal('0.15')\n        trunk_h = Decimal('0.2')\n        base_w = Decimal('0.7')\n        mid_w = Decimal('0.4')\n        top_w = Decimal('0.25')\n        tip_y = Decimal('0.8')\n        tier_1_y = Decimal('0.5')\n        tier_2_y = Decimal('0.25')\n        base_y = Decimal('0.0')\n        trunk_bottom_y = -trunk_h\n\n        # 15-vertex polygon\n        initial_polygon = Polygon([\n            (float(Decimal('0.0')), float(tip_y)),\n            (float(top_w / 2), float(tier_1_y)),\n            (float(top_w / 4), float(tier_1_y)),\n            (float(mid_w / 2), float(tier_2_y)),\n            (float(mid_w / 4), float(tier_2_y)),\n            (float(base_w / 2), float(base_y)),\n            (float(trunk_w / 2), float(base_y)),\n            (float(trunk_w / 2), float(trunk_bottom_y)),\n            (float(-trunk_w / 2), float(trunk_bottom_y)),\n            (float(-trunk_w / 2), float(base_y)),\n            (float(-base_w / 2), float(base_y)),\n            (float(-mid_w / 4), float(tier_2_y)),\n            (float(-mid_w / 2), float(tier_2_y)),\n            (float(-top_w / 4), float(tier_1_y)),\n            (float(-top_w / 2), float(tier_1_y)),\n        ])\n        \n        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))\n        self.polygon = affinity.translate(rotated, \n                                          xoff=float(self.center_x), \n                                          yoff=float(self.center_y))\n```\n\n## Submission Format\n\n```csv\nid,x,y,deg\n001_0,s0.0,s0.0,s20.411299\n002_0,s0.0,s0.0,s20.411299\n002_1,s-0.541068,s0.259317,s51.66348\n```\n- Values prefixed with 's' to preserve precision\n- Coordinates: -100 \u2264 x, y \u2264 100\n- No overlapping trees allowed\n- Total rows: 20100 (1+2+3+...+200)\n\n## Validation Code\n\n```python\ndef calculate_score(submission_df):\n    \"\"\"Calculate total score from submission\"\"\"\n    total_score = 0\n    for n in range(1, 201):\n        group = submission_df[submission_df['id'].str.startswith(f'{n:03d}_')]\n        trees = [ChristmasTree(\n            row['x'].lstrip('s'), \n            row['y'].lstrip('s'), \n            row['deg'].lstrip('s')\n        ) for _, row in group.iterrows()]\n        \n        # Check for overlaps\n        polygons = [t.polygon for t in trees]\n        if has_overlap(polygons):\n            print(f\"WARNING: Overlap in N={n}\")\n            \n        # Calculate bounding box\n        bounds = unary_union(polygons).bounds\n        side = max(bounds[2] - bounds[0], bounds[3] - bounds[1])\n        \n        total_score += (side ** 2) / n\n    \n    return total_score\n```\n\n## Strategy for Beating Target\n\n1. **Start with best available baseline** - load from snapshots if available\n2. **Focus on small N first** - N=1-20 contribute ~5 points, easier to optimize\n3. **Implement pure Python algorithms** - no binaries\n4. **Track per-N improvements** - accumulate wins across experiments\n5. **Use rotation optimization** - often gives 0.01-0.1 improvement\n6. **Consider asymmetric solutions** - discussions suggest these outperform symmetric\n7. **Lattice patterns for large N** - grid-based placement for N >= 58\n\n## Files and Paths\n\n- Data: `/home/data/sample_submission.csv`\n- Snapshots: `/home/nonroot/snapshots/santa-2025/`\n- Research kernels: `../research/kernels/`\n\n## Expected Workflow\n\n1. Load best baseline from snapshots or sample_submission.csv\n2. Calculate per-N scores for baseline\n3. Implement exhaustive search for N=1-10\n4. Apply improvements to baseline\n5. Validate no overlaps\n6. Submit and track improvements\n\n## Score Contribution by N (Approximate)\n\n| N Range | Contribution | Priority |\n|---------|-------------|----------|\n| N=1 | ~0.66 | HIGHEST |\n| N=2-5 | ~1.5 | HIGH |\n| N=6-10 | ~1.0 | HIGH |\n| N=11-50 | ~10.0 | MEDIUM |\n| N=51-100 | ~12.0 | MEDIUM |\n| N=101-200 | ~44.0 | LOW (many trees, hard to optimize) |\n\nFocus optimization effort on small N values where improvements have outsized impact!\n",
      "agent": "explorer",
      "timestamp": "2026-01-25T18:32:02.360939"
    }
  ],
  "feedback_history": [
    {
      "feedback": "## What I Understood\n\nThe junior researcher has completed a **baseline validation experiment** for the Santa 2025 Christmas Tree Packing Challenge. This is a 2D irregular polygon packing optimization problem where the goal is to pack N Christmas tree shapes (N=1 to 200) into the smallest possible square bounding box. The score formula is \u03a3(side\u00b2/n), meaning small N values have disproportionately high impact on the total score.\n\nThe baseline was loaded from a pre-existing snapshot (21337107511) and validated to have a score of **70.615791**, with a gap of **1.727498** from the target of **68.888293**. The researcher correctly identified that small N values contribute most to the score (N=1 alone contributes 0.66).\n\n## Technical Execution Assessment\n\n**Validation**: The validation methodology is sound. The notebook correctly:\n- Parses the submission format with 's' prefixes\n- Creates tree polygons using the exact 15-vertex shape from the competition\n- Checks for overlaps using Shapely's intersection/touches logic\n- Calculates bounding boxes and per-N scores correctly\n- Verified 0 overlap errors in the baseline\n\n**Leakage Risk**: None - this is an optimization problem, not a prediction problem. No data leakage concerns apply.\n\n**Score Integrity**: \u2705 Verified in notebook output. Total score of 70.615791 is correctly computed from per-N scores. The breakdown by N-range is consistent with the total.\n\n**Code Quality**: Good. The code is clean, well-documented, and produces reproducible results. The per-N scores are saved for future comparison, which is excellent practice.\n\nVerdict: **TRUSTWORTHY**\n\n## Strategic Assessment\n\n**Approach Fit**: This is a solid first step - establishing a validated baseline with per-N tracking is essential. However, this is ONLY a baseline validation, not an optimization experiment. The actual work of improving the score hasn't started yet.\n\n**Effort Allocation**: The seed prompt correctly identifies the priority order:\n1. **N=1-10 exhaustive search** (contributes ~4.3 points, highest leverage)\n2. **Pure Python algorithms** (no binaries allowed per seed prompt)\n3. **Per-N improvement tracking** (correctly implemented)\n\nThe baseline shows:\n- N=1: side=0.813, score=0.661 (HIGHEST SINGLE CONTRIBUTION)\n- N=2-5: score=1.72\n- N=6-10: score=1.95\n- N=11-50: score=14.70\n- N=51-100: score=17.61\n- N=101-200: score=33.98\n\n**Critical Insight**: The seed prompt EXPLICITLY FORBIDS using binaries (bbox3, shake_public, etc.) and states they can only achieve ~70.6. The target of 68.89 requires novel Python-based approaches. The top kernels (saspav, jazivxt) all use these forbidden binaries.\n\n**Assumptions Being Made**:\n1. The baseline from snapshot is a good starting point \u2705\n2. Small N optimization has highest ROI \u2705\n3. Binaries are forbidden (per seed prompt) \u2705\n\n**Blind Spots**:\n1. **N=1 is NOT optimally solved!** The baseline has N=1 side=0.813, but the optimal single tree rotation should give a smaller bounding box. The tree has height 1.0 (from -0.2 to 0.8) and max width 0.7. At 45\u00b0 rotation, the bounding box should be approximately \u221a((1.0)\u00b2 + (0.7)\u00b2)/\u221a2 \u2248 0.86 diagonal... but actually the optimal angle is NOT 45\u00b0. This needs exhaustive search.\n\n2. **Rotation optimization (fix_direction)** from the kernels is a pure Python technique that rotates the ENTIRE configuration to minimize bounding box. This is allowed and should be implemented.\n\n3. **Asymmetric solutions** - Discussion #666880 (39 votes) says winning solutions will be asymmetric. This is a key insight.\n\n4. **The code directory is EMPTY** - No actual optimization code has been written yet. The next experiment needs to implement actual algorithms.\n\n**Trajectory**: This is experiment 0 - just establishing baseline. The trajectory is undefined until actual optimization experiments begin.\n\n## What's Working\n\n1. \u2705 Baseline validation is thorough and correct\n2. \u2705 Per-N score tracking is implemented (essential for incremental improvement)\n3. \u2705 Overlap detection is working correctly\n4. \u2705 Score breakdown by N-range provides clear optimization targets\n5. \u2705 The seed prompt correctly identifies that binaries won't reach the target\n\n## Key Concerns\n\n1. **Observation**: No optimization code has been written yet - the code/ directory is empty.\n   **Why it matters**: The baseline is just a starting point. The actual work of beating the target hasn't begun.\n   **Suggestion**: The next experiment MUST implement actual optimization algorithms in Python.\n\n2. **Observation**: N=1 contributes 0.661 to the score but is likely NOT optimally solved.\n   **Why it matters**: N=1 has the highest per-tree impact. Even a 0.01 improvement in side length saves ~0.016 points.\n   **Suggestion**: Implement exhaustive rotation search for N=1 (0\u00b0 to 360\u00b0 in 0.01\u00b0 increments). This is trivial to implement and could yield immediate gains.\n\n3. **Observation**: The gap to target is 1.727 points, which is ~2.4% of the total score.\n   **Why it matters**: This is a significant gap that requires systematic optimization across many N values.\n   **Suggestion**: Focus on small N first (N=1-20) where improvements have outsized impact, then scale to larger N.\n\n4. **Observation**: The seed prompt forbids binaries, but top kernels all use them.\n   **Why it matters**: We cannot simply copy kernel approaches. We need novel Python implementations.\n   **Suggestion**: Implement these techniques in pure Python:\n   - Rotation optimization (fix_direction) - rotate entire config to minimize bbox\n   - Local search - move trees toward center in small steps\n   - Bottom-left heuristic with multiple rotation attempts\n   - Compaction/squeeze operations\n\n## Top Priority for Next Experiment\n\n**IMPLEMENT EXHAUSTIVE SEARCH FOR N=1-10**\n\nThe seed prompt explicitly mandates this as the first task. Here's why it's critical:\n\n1. **N=1 alone**: Test every rotation from 0\u00b0 to 360\u00b0 in 0.01\u00b0 increments. Find the angle that minimizes the bounding box of a single tree. This is O(36000) evaluations - trivial computation.\n\n2. **N=2-5**: Implement branch-and-bound or exhaustive placement. For N=2, try all rotation combinations and relative positions. These small N values contribute ~2.5 points total.\n\n3. **Expected gains**: If we can reduce N=1 side from 0.813 to ~0.78 (plausible), that's 0.661 \u2192 0.608 = 0.053 points saved. Similar gains across N=2-10 could yield 0.2-0.3 points total.\n\nThe next experiment should:\n1. Create `/home/code/code/optimize_small_n.py` with exhaustive search for N=1\n2. Extend to N=2-10 with systematic placement search\n3. Track improvements per-N and update the submission\n4. Implement rotation optimization (fix_direction) as post-processing\n\nThis is the highest-leverage work that can be done immediately with pure Python.\n",
      "experiment_id": "exp_000",
      "agent": "evaluator",
      "timestamp": "2026-01-25T18:36:26.087286"
    }
  ],
  "data_findings": [
    {
      "finding": "This is a 2D irregular polygon packing problem - pack Christmas tree shapes into smallest square bounding box for N=1 to 200. Score = sum(side^2/n). Tree shape is a 15-vertex polygon with trunk and 3 tiers. Key approaches: 1) Simulated annealing with local search, 2) Genetic algorithms, 3) Bottom-left heuristics, 4) No-fit polygon (NFP) for collision detection, 5) Compaction/squeeze operations. Top kernels use C++ compiled binaries (bbox3, tree_packer) for speed.",
      "source": "../research/description.md and ../research/kernels/",
      "agent": "explorer"
    },
    {
      "finding": "Academic research shows: 1) Extended local search with nonlinear programming, 2) Collision-free region (CFR) placement, 3) Simulated annealing controls sequence and placement, 4) Two-level algorithms (inner: fixed container, outer: adjust container size), 5) Tabu search to avoid local minima. Key insight: place items on CFR vertices for optimal compaction.",
      "source": "web_search_irregular_polygon_packing",
      "agent": "explorer"
    },
    {
      "finding": "Key kernels use pre-compiled binaries: bbox3 (main optimizer), shake_public (shaking/perturbation), tree_packer (SA-based). The workflow is: 1) Start with good baseline CSV, 2) Run bbox3 with parameters -n (iterations) -r (restarts), 3) Apply fix_direction (rotation optimization), 4) Run shake_public for perturbation, 5) Validate and repair overlaps. Score ~70.6 achievable with binaries, target 68.89 requires novel approaches.",
      "source": "../research/kernels/saspav_santa-submission/",
      "agent": "explorer"
    },
    {
      "finding": "Discussion 'Why the winning solutions will be Asymmetric' (39 votes) suggests asymmetric solutions outperform symmetric ones for this packing problem. This is a key insight for algorithm design - don't assume rotational symmetry in optimal solutions.",
      "source": "discussion_666880",
      "agent": "explorer"
    },
    {
      "finding": "CRITICAL: Baseline submission failed with 'Overlapping trees in group 040'. Root cause: Local Shapely validation uses standard floating-point precision, but Kaggle uses stricter validation. The official kernel uses scale_factor = Decimal('1e15') to scale all coordinates to integer-like precision. Solution: Re-implement overlap detection with 1e15 scaling, then fix any overlapping trees by moving them apart slightly.",
      "source": "Kaggle submission error + research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "evolver"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for irregular polygon packing optimization in 2D?",
      "finding": "Gli algoritmi pi\u00f9 efficaci per l'ottimizzazione del packing di poligoni irregolari in 2D sono spesso basati su approcci euristici, metaeuristici e metodi esatti, a seconda della complessit\u00e0 e delle specifiche del problema. Tra le tecniche pi\u00f9 note vi sono gli algoritmi genetici combinati con metodi lineari, come descritto in uno studio che propone un approccio ibrido di genetico e programmazione lineare per ottimizzare il packing irregolare ([MDPI](https://www.mdpi.com/2076-3417/13/22/12474)). Inoltre, i metodi di ricerca locale estesa, come quelli basati sulla programmazione non lineare e sul simulated annealing, sono stati efficaci nel trovare soluzioni competitive e migliorare risultati noti, anche minimizzando il materiale di scarto ([ScienceDirect](https://www.sciencedirect.com/science/article/abs/pii/S0305054811001596), [Springer](https://link.springer.com/article/10.1007/s10479-013-1341-4)). \n\nAltri approcci includono heuristici come l'algoritmo di Djang e Finch adattato per il ",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 94
}