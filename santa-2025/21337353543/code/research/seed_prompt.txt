## Current Status
- Best CV score: 70.329514 from exp_016 (jazivxt_why_not ensemble)
- Best LB score: 70.3410 (from exp_010)
- Target: 68.876781 | Gap to target: 1.45 points (2.1%)
- Submissions used: 10/100 (90 remaining - ABUNDANT!)

## Response to Evaluator

**AGREED 100%**: The evaluator correctly identified a CRITICAL BUG in exp_017 (rebuild from corners).

**The Bug:**
- My implementation used tree CENTER for distance calculation
- The chistyakov kernel uses POLYGON BOUNDS (minx, maxx, miny, maxy)
- A tree at center (0,0) with rotation can have polygon bounds extending to ±0.8
- Using tree center ignores rotation and shape, causing WRONG tree selection

**The Fix (from chistyakov kernel):**
```python
# WRONG (what we did):
x, y = float(t['x']), float(t['y'])  # tree center
dist = max(abs(x - corner_x), abs(y - corner_y))

# CORRECT (from chistyakov):
poly = create_tree_polygon(t['x'], t['y'], t['deg'])
bounds = poly.bounds  # (minx, miny, maxx, maxy)
dist = max(
    abs(bounds[0] - corner_x),  # polygon minx
    abs(bounds[2] - corner_x),  # polygon maxx
    abs(bounds[1] - corner_y),  # polygon miny
    abs(bounds[3] - corner_y),  # polygon maxy
)
```

**This is the HIGHEST PRIORITY fix** - the technique wasn't properly tested!

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with binaries - FORBIDDEN

## ✅ EXPERIMENT 018: FIX REBUILD FROM CORNERS BUG

**MANDATORY FIRST TASK**: Fix the distance calculation bug and re-run.

Create: `experiments/018_rebuild_corners_fixed/`

```python
import pandas as pd
import numpy as np
from decimal import Decimal, getcontext
from shapely.geometry import Polygon
from shapely import affinity
from shapely.ops import unary_union
import json
import time

getcontext().prec = 30
SCALE_FACTOR = Decimal('1e18')

# Tree shape vertices
TX = np.array([0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125])
TY = np.array([0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5])

def create_tree_polygon(x, y, angle):
    """Create tree polygon at given position and rotation."""
    x, y, angle = float(x), float(y), float(angle)
    coords = list(zip(TX, TY))
    poly = Polygon(coords)
    poly = affinity.rotate(poly, angle, origin=(0, 0))
    poly = affinity.translate(poly, x, y)
    return poly

def get_bbox_side(trees):
    """Get bounding box side length for a list of trees."""
    if len(trees) == 0:
        return 0
    polygons = [create_tree_polygon(t['x'], t['y'], t['deg']) for t in trees]
    union = unary_union(polygons)
    bounds = union.bounds
    return max(bounds[2] - bounds[0], bounds[3] - bounds[1])

def get_score(trees, n):
    """Calculate score for N trees."""
    side = get_bbox_side(trees)
    return (side ** 2) / n

def rebuild_from_corners_FIXED(large_layout, target_n, current_best_score):
    """
    Extract subset of trees closest to each corner using POLYGON BOUNDS.
    
    THIS IS THE FIXED VERSION - uses polygon bounds, not tree center!
    """
    if len(large_layout) <= target_n:
        return None
    
    # Get layout bounds
    polygons = [create_tree_polygon(t['x'], t['y'], t['deg']) for t in large_layout]
    union = unary_union(polygons)
    bounds = union.bounds
    minx, miny, maxx, maxy = bounds
    
    # 4 corners
    corners = [
        (minx, miny),  # bottom-left
        (minx, maxy),  # top-left
        (maxx, miny),  # bottom-right
        (maxx, maxy),  # top-right
    ]
    
    best_subset = None
    best_score = current_best_score
    
    for corner_x, corner_y in corners:
        # FIXED: Sort trees by max POLYGON BOUNDS distance from corner (Chebyshev)
        trees_with_dist = []
        for t in large_layout:
            # Create polygon to get actual bounds
            poly = create_tree_polygon(t['x'], t['y'], t['deg'])
            b = poly.bounds  # (minx, miny, maxx, maxy)
            
            # Distance is MAX of all 4 bound distances from corner
            dist = max(
                abs(b[0] - corner_x),  # polygon minx
                abs(b[2] - corner_x),  # polygon maxx
                abs(b[1] - corner_y),  # polygon miny
                abs(b[3] - corner_y),  # polygon maxy
            )
            trees_with_dist.append((dist, t))
        
        # Sort by distance (smallest first = closest to corner)
        trees_with_dist.sort(key=lambda x: x[0])
        
        # Extract subset of target_n trees closest to corner
        subset = [t for _, t in trees_with_dist[:target_n]]
        
        # Calculate score
        score = get_score(subset, target_n)
        
        if score < best_score - 1e-9:
            # Validate with strict 1e18 precision
            if validate_no_overlap_strict(subset):
                best_score = score
                best_subset = subset
    
    return (best_subset, best_score) if best_subset else None

# Load exp_016 as baseline
df = pd.read_csv('/home/code/experiments/016_jazivxt_ensemble/submission.csv')
df['N'] = df['id'].astype(str).str.split('_').str[0].astype(int)

best_trees = {}
best_scores = {}
for n, g in df.groupby('N'):
    trees = []
    for _, row in g.iterrows():
        x = str(row['x']).replace('s', '')
        y = str(row['y']).replace('s', '')
        deg = str(row['deg']).replace('s', '')
        trees.append({'x': x, 'y': y, 'deg': deg})
    best_trees[n] = trees
    best_scores[n] = get_score(trees, n)

baseline_total = sum(best_scores.values())
print(f"Baseline score: {baseline_total:.6f}")

# Apply FIXED rebuild from corners
large_n_values = [50, 60, 70, 80, 90, 100, 110, 111, 120, 130, 140, 150, 160, 170, 180, 190, 200]
improvements = []

for large_n in large_n_values:
    large_layout = best_trees[large_n]
    print(f"\nUsing N={large_n} layout as source...")
    
    for target_n in range(2, large_n):
        result = rebuild_from_corners_FIXED(large_layout, target_n, best_scores[target_n])
        
        if result:
            subset, score = result
            improvement = best_scores[target_n] - score
            improvements.append((target_n, improvement, large_n))
            best_trees[target_n] = subset
            best_scores[target_n] = score
            print(f"  N={target_n}: +{improvement:.6f} (from N={large_n} corner)")

final_total = sum(best_scores.values())
print(f"\nBaseline: {baseline_total:.6f}")
print(f"Final: {final_total:.6f}")
print(f"Improvement: {baseline_total - final_total:.6f}")
print(f"N values improved: {len(improvements)}")
```

## ✅ REQUIRED: HIGH-PRECISION OVERLAP VALIDATION

Include this validation code (MANDATORY):

```python
def create_high_precision_tree(x, y, angle):
    """Create tree polygon with 1e18 scaling for strict validation."""
    x = Decimal(str(x))
    y = Decimal(str(y))
    angle = Decimal(str(angle))
    sf = SCALE_FACTOR
    vertices = [
        (float(Decimal('0.0') * sf), float(Decimal('0.8') * sf)),
        (float(Decimal('0.125') * sf), float(Decimal('0.5') * sf)),
        (float(Decimal('0.0625') * sf), float(Decimal('0.5') * sf)),
        (float(Decimal('0.2') * sf), float(Decimal('0.25') * sf)),
        (float(Decimal('0.1') * sf), float(Decimal('0.25') * sf)),
        (float(Decimal('0.35') * sf), float(Decimal('0.0') * sf)),
        (float(Decimal('0.075') * sf), float(Decimal('0.0') * sf)),
        (float(Decimal('0.075') * sf), float(Decimal('-0.2') * sf)),
        (float(Decimal('-0.075') * sf), float(Decimal('-0.2') * sf)),
        (float(Decimal('-0.075') * sf), float(Decimal('0.0') * sf)),
        (float(Decimal('-0.35') * sf), float(Decimal('0.0') * sf)),
        (float(Decimal('-0.1') * sf), float(Decimal('0.25') * sf)),
        (float(Decimal('-0.2') * sf), float(Decimal('0.25') * sf)),
        (float(Decimal('-0.0625') * sf), float(Decimal('0.5') * sf)),
        (float(Decimal('-0.125') * sf), float(Decimal('0.5') * sf)),
    ]
    poly = Polygon(vertices)
    poly = affinity.rotate(poly, float(angle), origin=(0, 0))
    poly = affinity.translate(poly, xoff=float(x * sf), yoff=float(y * sf))
    return poly

def validate_no_overlap_strict(trees_data):
    """Validate no overlaps using 1e18 precision (matches Kaggle)."""
    if len(trees_data) <= 1:
        return True
    polygons = [create_high_precision_tree(t['x'], t['y'], t['deg']) for t in trees_data]
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                return False
    return True
```

## ✅ AFTER FIXING: Submit to Verify CV-LB Alignment

After running the fixed rebuild from corners:
1. Save submission.csv
2. Submit to Kaggle to verify CV-LB alignment
3. We have 90 submissions remaining - USE THEM!

## What NOT to Try
- Running bbox3/sa_fast with "more iterations" - PROVEN NOT TO WORK
- Ensemble mining from same sources - EXHAUSTED
- Local search (SA, NFP, fractional translation) - EXHAUSTED
- The BUGGY version of rebuild from corners - ALREADY TRIED

## Path to Target

Current: 70.329 | Target: 68.877 | Gap: 1.45 points (2.1%)

**Realistic improvement sources:**

| Approach | Expected Improvement | Priority |
|----------|---------------------|----------|
| Fix rebuild from corners bug | 0.01-0.1 points | **HIGHEST** |
| Submit & verify LB | 0 points (validation) | HIGH |
| Try more source layouts | 0.01-0.05 points | MEDIUM |

## SUBMISSION STRATEGY
- Remaining submissions: 90
- Submit after this experiment? **YES** - we need LB feedback!
- Even if score doesn't improve, we learn whether the technique works

## Key Insight

The chistyakov kernel found improvements using this technique. Our implementation was WRONG.
The fix is simple: use polygon bounds instead of tree center for distance calculation.
This is a LOW-EFFORT, HIGH-POTENTIAL fix that MUST be tried before concluding the technique doesn't work.
