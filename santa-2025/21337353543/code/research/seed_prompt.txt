# Santa 2025 - Christmas Tree Packing Challenge - Loop 2 Seed Prompt

## Current Status
- Best CV score: 70.622435 from exp_001 (fix_overlaps)
- Best LB score: **70.622435** (VERIFIED - submission passed!)
- Target: **68.887744** | Gap to target: **1.734 points (2.5%)**
- Submissions used: 2/100 (98 remaining - ABUNDANT!)

## ✅ GOOD NEWS: Baseline Validated!
The exp_001 submission passed Kaggle validation with LB score 70.622435.
CV-LB gap is essentially 0 - our local validation is accurate!

## Response to Evaluator
The evaluator correctly identified that:
1. No actual optimization code has been written yet - just file swapping
2. The code/ directory is still empty
3. N=1 exhaustive search was mandated but not implemented

**I AGREE.** The next experiment MUST implement actual optimization algorithms in Python.
The evaluator's priority is correct: Start with N=1 exhaustive search, then expand.

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with binaries - FORBIDDEN

## ✅ MANDATORY EXPERIMENT 002: N=1 EXHAUSTIVE SEARCH + FRACTIONAL TRANSLATION

### Task 1: Find Optimal N=1 Rotation (HIGHEST PRIORITY!)

N=1 contributes ~0.66 to total score - more than any other single N value!
Top kernels use angle=45° but this may NOT be optimal.

```python
import numpy as np
from shapely.geometry import Polygon
from shapely import affinity

TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def get_bbox_side(angle):
    """Get bounding box side length for tree at given angle."""
    coords = list(zip(TX, TY))
    poly = Polygon(coords)
    poly = affinity.rotate(poly, angle, origin=(0, 0))
    bounds = poly.bounds
    return max(bounds[2] - bounds[0], bounds[3] - bounds[1])

# Exhaustive search: 0° to 360° in 0.01° increments
best_angle = 0
best_side = float('inf')
for angle_int in range(36000):  # 0.01° increments
    angle = angle_int / 100.0
    side = get_bbox_side(angle)
    if side < best_side:
        best_side = side
        best_angle = angle

print(f"Optimal N=1 angle: {best_angle}° with side {best_side:.8f}")
print(f"N=1 score contribution: {best_side**2:.8f}")
```

Expected: If we find a better angle than 45°, we save ~0.01-0.05 points immediately!

### Task 2: Implement Fractional Translation (Pure Python)

From top kernels, fractional translation moves trees in tiny steps:

```python
def fractional_translation(trees, max_iter=200):
    """Move trees in tiny steps to reduce bounding box."""
    frac_steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    
    best_trees = [dict(t) for t in trees]
    best_side = get_bounding_box_side(best_trees)
    
    for iteration in range(max_iter):
        improved = False
        for i in range(len(best_trees)):
            for step in frac_steps:
                for dx, dy in directions:
                    # Try moving tree i
                    test_trees = [dict(t) for t in best_trees]
                    test_trees[i]['x'] = str(float(test_trees[i]['x']) + dx * step)
                    test_trees[i]['y'] = str(float(test_trees[i]['y']) + dy * step)
                    
                    # Check no overlap
                    if not has_overlap(test_trees):
                        new_side = get_bounding_box_side(test_trees)
                        if new_side < best_side - 1e-12:
                            best_side = new_side
                            best_trees = test_trees
                            improved = True
        
        if not improved:
            break
    
    return best_trees
```

### Task 3: Implement Backward Propagation (From Chistyakov Kernel)

For each N from 200 down to 3, try removing boundary-touching trees to improve N-1:

```python
def backward_propagation(trees_by_n):
    """Remove trees from N to improve N-1."""
    for n in range(200, 2, -1):
        trees = trees_by_n[n]
        
        # Get trees touching the bounding box boundary
        boundary_indices = get_bbox_touching_tree_indices(trees)
        
        for idx in boundary_indices:
            # Try removing this tree
            candidate = [t for i, t in enumerate(trees) if i != idx]
            candidate_side = get_bounding_box_side(candidate)
            
            # Compare to current N-1 solution
            current_n_minus_1_side = get_bounding_box_side(trees_by_n[n-1])
            
            if candidate_side < current_n_minus_1_side:
                print(f"N={n-1}: Improved from {current_n_minus_1_side:.8f} to {candidate_side:.8f}")
                trees_by_n[n-1] = candidate
    
    return trees_by_n
```

## ✅ REQUIRED: PER-N TRACKING

Track best solution for EACH N separately:

```python
def compare_per_n_scores(my_solution, baseline):
    improvements = []
    for n in range(1, 201):
        my_score = compute_score_for_n(my_solution, n)
        base_score = compute_score_for_n(baseline, n)
        diff = base_score - my_score  # positive = better
        if diff > 0.0001:
            improvements.append((n, diff))
            print(f"✅ N={n}: IMPROVED by {diff:.6f}")
    return improvements
```

## Experiment Structure

Create: `experiments/002_python_optimization/`

Files to create:
1. `optimize_n1.py` - Exhaustive search for N=1
2. `fractional_translation.py` - Fractional translation implementation
3. `backward_propagation.py` - Backward propagation implementation
4. `main.ipynb` - Main notebook that runs all optimizations

## Expected Gains

| Technique | Expected Improvement |
|-----------|---------------------|
| N=1 optimal rotation | 0.01 - 0.05 points |
| Fractional translation (all N) | 0.1 - 0.3 points |
| Backward propagation | 0.1 - 0.3 points |
| **Total potential** | **0.2 - 0.6 points** |

This won't close the full 1.73 point gap, but it's a START with pure Python.
After this, we can implement more sophisticated algorithms.

## Validation Requirements

Before submitting, validate with strict precision:

```python
from decimal import Decimal, getcontext
getcontext().prec = 25
scale_factor = Decimal('1e18')

def validate_no_overlap_strict(trees):
    """Validate using Kaggle's strict precision."""
    # Create scaled polygons
    # Check all pairs for intersection
    # Return True only if no overlaps
```

## SUBMISSION STRATEGY
- Remaining submissions: 98 (ABUNDANT!)
- **SUBMIT after this experiment** - we need LB feedback on our improvements
- Even small improvements are valuable for accumulation strategy

## What NOT to Try
- Running bbox3 or any binary - FORBIDDEN
- "More iterations" on existing optimizers - FORBIDDEN
- Just ensembling existing CSVs without algorithmic improvement - LIMITED VALUE

## Success Criteria
- ✅ N=1 optimal angle found (different from 45° if better exists)
- ✅ Fractional translation implemented and tested
- ✅ At least one N value improved vs baseline
- ✅ Submission passes Kaggle validation
- ✅ Score < 70.622435 (any improvement counts!)