# Santa 2025 - Evolved Seed Prompt (Loop 3)

## Current Status
- **Best CV Score**: 70.6224 (from exp_001, exp_002)
- **Best LB Score**: 70.6224 (verified on Kaggle)
- **Target**: 68.8877
- **Gap to Target**: 1.73 points (2.45%)
- **Submissions Used**: 3/100 (92 remaining)

## ⚠️ CRITICAL: LOCAL OPTIMUM CONFIRMED

Experiments exp_001 and exp_002 produced IDENTICAL scores (70.6224).
This confirms the baseline is at a LOCAL OPTIMUM.

**What was tried and FAILED:**
1. N=1 exhaustive rotation search → 45° is already optimal (no improvement)
2. Fractional translation for N=2-20 → 0 improvements found
3. Backward propagation (N=200 to N=3) → 0 improvements found

**CONCLUSION:** Simple local search CANNOT improve the baseline.
We need FUNDAMENTALLY DIFFERENT approaches.

## Response to Evaluator

The evaluator correctly identified that:
1. ✅ Local search methods cannot escape local optima
2. ✅ The baseline was already optimized by sophisticated C++ tools
3. ✅ We need global optimization or different initial configurations

**I agree with the evaluator's recommendation to implement simulated annealing from scratch.**

However, I want to add an important insight: The zaburo kernel shows that CONSTRUCTIVE approaches (building from scratch with alternating rows) can find DIFFERENT local optima. We should try BOTH:
1. Simulated annealing from scratch
2. Constructive heuristics that build solutions differently

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with local search - PROVEN USELESS

## ✅ MANDATORY: IMPLEMENT SIMULATED ANNEALING FROM SCRATCH

The evaluator provided a concrete implementation template. Use it:

```python
import random
import math

def simulated_annealing(trees, T_init=1.0, T_min=0.0001, cooling=0.9995, max_iter=100000):
    """SA for a single N configuration."""
    current = [dict(t) for t in trees]
    current_score = get_bbox_side(current)
    best = [dict(t) for t in current]
    best_score = current_score
    T = T_init
    
    for iteration in range(max_iter):
        # Random perturbation: move or rotate a random tree
        candidate = perturb(current)
        if has_overlap(candidate):
            continue
        
        candidate_score = get_bbox_side(candidate)
        delta = candidate_score - current_score
        
        # Accept if better, or with probability exp(-delta/T) if worse
        if delta < 0 or random.random() < math.exp(-delta / T):
            current = [dict(t) for t in candidate]
            current_score = candidate_score
            if current_score < best_score:
                best = [dict(t) for t in current]
                best_score = current_score
        
        T *= cooling
        if T < T_min:
            break
    
    return best, best_score

def perturb(trees):
    """Randomly perturb one tree's position or rotation."""
    result = [dict(t) for t in trees]
    idx = random.randint(0, len(result) - 1)
    
    # Choose perturbation type
    if random.random() < 0.5:
        # Move tree
        dx = random.uniform(-0.1, 0.1)
        dy = random.uniform(-0.1, 0.1)
        result[idx]['x'] = str(float(result[idx]['x']) + dx)
        result[idx]['y'] = str(float(result[idx]['y']) + dy)
    else:
        # Rotate tree
        dangle = random.uniform(-10, 10)
        result[idx]['deg'] = str(float(result[idx]['deg']) + dangle)
    
    return result
```

**Key parameters to tune:**
- Initial temperature: Start high enough to accept 50-80% of worse moves
- Cooling rate: Slow enough to explore (0.9995 or slower)
- Perturbation size: Start large, decrease with temperature
- Number of iterations: As many as time allows

## ✅ ALTERNATIVE: RANDOM RESTART HILL CLIMBING

If SA is too slow, try random restarts:
1. Generate 100 random initial configurations for each N
2. Apply local search to each
3. Keep the best result
4. This explores different basins of attraction

## ✅ ALTERNATIVE: CONSTRUCTIVE APPROACH (from zaburo kernel)

Build solutions from scratch using alternating rows:
```python
def build_alternating_rows(n):
    """Build solution using alternating rows of trees at 0° and 180°."""
    trees = []
    rest = n
    row = 0
    
    while rest > 0:
        angle = 0 if row % 2 == 0 else 180
        x_offset = 0 if row % 2 == 0 else 0.35  # Half tree width
        y = row * 0.5  # Vertical spacing
        
        # Calculate how many trees fit in this row
        trees_in_row = min(rest, calculate_row_capacity(row))
        
        for i in range(trees_in_row):
            trees.append({
                'idx': len(trees),
                'x': str(0.7 * i + x_offset),
                'y': str(y),
                'deg': str(angle)
            })
        
        rest -= trees_in_row
        row += 1
    
    return trees
```

## Score Breakdown Analysis

| N Range | Score | % of Total | Improvement Needed |
|---------|-------|------------|-------------------|
| N=1 | 0.66 | 0.9% | 0.02 (ALREADY OPTIMAL) |
| N=2-5 | 1.72 | 2.4% | 0.04 |
| N=6-10 | 1.95 | 2.8% | 0.05 |
| N=11-50 | 14.70 | 20.8% | 0.36 |
| N=51-100 | 17.61 | 24.9% | 0.43 |
| N=101-200 | 33.98 | 48.1% | 0.83 |

**Key Insight:** Large N values (N=51-200) contribute 73% of the score.
Focus optimization effort on these N values!

## Experiment Plan

### Experiment 003: Simulated Annealing from Scratch

1. **Create experiment folder**: `experiments/003_simulated_annealing/`
2. **Implement SA in pure Python** (no binaries!)
3. **Test on small N first** (N=10, N=20, N=30) to verify it works
4. **Run on all N values** if small N test shows promise
5. **Compare per-N scores** to baseline
6. **Keep any N where we improved**

**Expected outcome:** Find different local optima that may be better for some N values.

### Experiment 004 (if 003 fails): Constructive Approach

1. Implement alternating row construction (from zaburo kernel)
2. Apply local search to the constructed solution
3. Compare to baseline

## Validation Requirements

**CRITICAL:** Use strict overlap detection with integer scaling:
```python
from decimal import Decimal, getcontext
getcontext().prec = 30
SCALE = 10**18

def validate_no_overlap(trees):
    from shapely import Polygon
    polygons = []
    for tree in trees:
        coords = [(int(Decimal(str(x)) * SCALE), 
                   int(Decimal(str(y)) * SCALE)) 
                  for x, y in get_tree_vertices(tree)]
        polygons.append(Polygon(coords))
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                return False, f"Trees {i} and {j} overlap"
    return True, "OK"
```

## Submission Strategy

- **Remaining submissions**: 92
- **Strategy**: Submit after EVERY experiment
- LB feedback is FREE information - use it!
- Even if score is worse, we learn what doesn't work

## What NOT to Try

1. ❌ More local search on the baseline (proven useless)
2. ❌ Running binaries (produces same ~70.6 score)
3. ❌ Fractional translation (already tried, 0 improvements)
4. ❌ Backward propagation (already tried, 0 improvements)

## Success Criteria

- ✅ **SUCCESS**: Score improved by > 0.01 from 70.6224
- ⚠️ **MARGINAL**: Score improved by 0.001 - 0.01
- ❌ **FAILURE**: Score same or worse

If this experiment fails, pivot to constructive approach.
