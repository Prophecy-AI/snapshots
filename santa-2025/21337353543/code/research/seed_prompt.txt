## Current Status
- Best CV score: 70.3295 from exp_016 (jazivxt_ensemble)
- Best LB score: 70.3410 (exp_010)
- Target: 68.876781 | Gap to target: 1.45 points (2.1%)

## CV-LB Relationship Analysis
- CV = LB exactly (verified across 7 submissions)
- This is NOT a distribution shift problem - it's purely an optimization gap
- The gap is 1.45 points that must be closed through better solutions

## Response to Evaluator

**AGREED**: Local search approaches are EXHAUSTED:
- Simulated annealing: 0 improvements
- Rotation optimization: 0 improvements
- Fractional translation: 0.000033 improvement
- NFP local search: 0 improvements

**AGREED**: Ensemble strategy is the ONLY thing that has consistently worked:
- exp_005: 70.62 → 70.52 (0.10 improvement)
- exp_009: 70.62 → 70.37 (0.25 improvement from santa-2025.csv)
- exp_010: 70.37 → 70.34 (0.03 improvement from more sources)

**NEW APPROACH IDENTIFIED**: "Rebuild from corners" technique from chistyakov kernel
- Extract subsets of trees from larger optimized layouts
- Check if corner-based subsets give better bounding boxes for smaller N
- This is NOVEL and hasn't been tried yet

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- More local search variations - EXHAUSTED, don't try again
- Ensemble from same sources - EXHAUSTED, need NEW sources or NEW technique

## ✅ MANDATORY EXPERIMENT: REBUILD FROM CORNERS

Implement the "rebuild from corners" technique from chistyakov kernel:

```python
# For each large layout (N=100 to N=200):
#   For each corner of the bounding box:
#     Sort trees by distance from corner
#     For each subset size k (from 1 to N):
#       Extract k closest trees to corner
#       Calculate bounding box of subset
#       If better than current best for k trees, KEEP IT

def rebuild_from_corners(large_layout, current_best_per_n):
    improvements = []
    bounds = get_bounds(large_layout)
    corners = [(bounds[0], bounds[1]), (bounds[0], bounds[3]), 
               (bounds[2], bounds[1]), (bounds[2], bounds[3])]
    
    for corner_x, corner_y in corners:
        # Sort trees by max distance from corner
        trees_by_dist = sorted(large_layout, 
            key=lambda t: max(abs(t.x - corner_x), abs(t.y - corner_y)))
        
        # Try each subset size
        subset = []
        for tree in trees_by_dist:
            subset.append(tree)
            k = len(subset)
            
            subset_score = get_score(subset, k)
            if subset_score < current_best_per_n[k]:
                improvements.append((k, subset_score, subset.copy()))
                current_best_per_n[k] = subset_score
    
    return improvements
```

This technique exploits the fact that optimized large layouts often contain 
well-packed subsets that are better than independently optimized smaller layouts.

## ✅ REQUIRED: PER-N TRACKING

Track best solution for EACH N separately:
- Load baseline per-N scores from exp_016
- After rebuild_from_corners, compare per-N
- Keep only N values where you improved
- Even small improvements accumulate!

## ✅ VALIDATION

Use strict 1e18 scaling validation:
```python
from decimal import Decimal, getcontext
getcontext().prec = 30
SCALE = 10**18

def validate_no_overlap(trees):
    # ... (standard validation code)
```

## Expected Outcome

The rebuild_from_corners technique could find improvements for small-to-medium N values
(N=10 to N=100) by extracting well-packed subsets from larger optimized layouts.

Expected improvement: 0.01 - 0.1 points (based on chistyakov's results)

## SUBMISSION STRATEGY
- Remaining submissions: 90
- Submit after this experiment? YES - we have abundant submissions
- LB feedback is valuable even if score doesn't improve

## What NOT to Try
- More local search (SA, NFP, fractional translation) - EXHAUSTED
- Ensemble from existing sources - EXHAUSTED
- Running C++ binaries - FORBIDDEN

## Validation Notes
- CV = LB exactly, so CV is reliable
- Use strict 1e18 overlap validation
- All N values must pass validation before submission
