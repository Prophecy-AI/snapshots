# Santa 2025 - Christmas Tree Packing Challenge - Loop 2 Seed Prompt

## Current Status
- Best CV score: 70.622435 from exp_001 (fix_overlaps - using snapshot 21329068588)
- Best LB score: **PENDING** - exp_000 failed with overlaps, exp_001 not yet submitted
- Target: **68.887744** | Gap to target: **1.735 points** (~2.5%)
- Submissions: 1 used, 94 remaining (ABUNDANT - submit after EVERY experiment!)

## Response to Evaluator

The evaluator correctly identified that:
1. **No actual optimization code exists** - The code/ directory is empty after 2 experiments
2. **No strict overlap detection implemented** - We're dependent on pre-existing snapshots
3. **The fixed submission hasn't been verified** - We need to submit to confirm it passes

**I AGREE with all concerns.** The next experiment MUST:
1. Submit exp_001 to verify it passes Kaggle validation
2. Implement actual optimization code (not just swap files)
3. Start with N=1 exhaustive rotation search (highest impact, trivial to implement)

## ⚠️ CRITICAL: SUBMIT exp_001 FIRST!

Before ANY optimization work, submit the current candidate to verify it passes Kaggle validation.
We have 94 submissions remaining - this is FREE information.

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with binaries - FORBIDDEN

## ✅ MANDATORY EXPERIMENT 002: IMPLEMENT N=1 OPTIMIZATION

**This is the HIGHEST PRIORITY task.** N=1 contributes ~0.66 to the total score.

### Step 1: Find Optimal N=1 Rotation

The tree shape has:
- Height: 1.0 (from y=-0.2 to y=0.8)
- Width: 0.7 (at base)

For a single tree, the bounding box depends ONLY on rotation angle.
The optimal angle is NOT 0° or 45° - it needs exhaustive search.

```python
import numpy as np
from shapely.geometry import Polygon
from shapely import affinity

TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def get_bbox_side(angle):
    """Get bounding box side length for tree at given rotation angle."""
    coords = list(zip(TX, TY))
    poly = Polygon(coords)
    poly = affinity.rotate(poly, angle, origin=(0, 0))
    bounds = poly.bounds
    return max(bounds[2] - bounds[0], bounds[3] - bounds[1])

# Exhaustive search
best_angle = 0
best_side = float('inf')
for angle_int in range(36000):  # 0.01° increments
    angle = angle_int / 100.0
    side = get_bbox_side(angle)
    if side < best_side:
        best_side = side
        best_angle = angle

print(f"Optimal N=1 angle: {best_angle}°, side: {best_side:.6f}")
print(f"N=1 score contribution: {best_side**2:.6f}")
```

### Step 2: Compare to Baseline N=1

Load the baseline submission and check what angle is used for N=1.
If our optimal angle is different, we've found an improvement!

### Step 3: Update Submission with Optimal N=1

Create a new submission with the optimal N=1 rotation.

## ✅ EXPERIMENT 003+: IMPLEMENT BACKWARD PROPAGATION

From the chistyakov kernel, a pure Python optimization approach:

**Backward Propagation Algorithm:**
1. Start with N=200 configuration
2. For each N from 200 down to 2:
   - Find trees touching the bounding box boundary
   - Try removing each boundary tree one at a time
   - Keep the removal that gives smallest bounding box for N-1
   - If this beats the current N-1 solution, update it

```python
def get_bbox_touching_trees(trees):
    """Find indices of trees touching the bounding box boundary."""
    polygons = [create_tree_polygon(t) for t in trees]
    union = unary_union(polygons)
    bounds = union.bounds
    bbox = box(bounds[0], bounds[1], bounds[2], bounds[3])
    
    touching = []
    for i, poly in enumerate(polygons):
        if poly.boundary.intersects(bbox.boundary):
            touching.append(i)
    return touching

def backward_propagation(trees_by_n, max_depth=5):
    """Improve smaller N by removing trees from larger N."""
    improved = {}
    
    for n in range(200, 1, -1):
        trees = trees_by_n[n].copy()
        target_n = n - 1
        
        # Only look at trees touching boundary
        touching = get_bbox_touching_trees(trees)
        
        best_side = get_side_length(trees_by_n[target_n])
        best_trees = None
        
        for idx in touching:
            candidate = [t for i, t in enumerate(trees) if i != idx]
            side = get_side_length(candidate)
            if side < best_side:
                best_side = side
                best_trees = candidate
        
        if best_trees is not None:
            improved[target_n] = best_trees
            print(f"N={target_n}: Improved!")
        
        # Limit depth to avoid too much computation
        if n - target_n > max_depth:
            break
    
    return improved
```

## ✅ EXPERIMENT 004+: IMPLEMENT LOCAL SEARCH

**Fractional Translation Algorithm:**
Move each tree by tiny amounts (0.001 to 0.00001) in 8 directions.
Keep moves that reduce bounding box without causing overlaps.

```python
def fractional_translation(trees, max_iter=200):
    """Improve configuration by tiny translations."""
    steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005]
    directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (1,-1), (-1,1), (-1,-1)]
    
    best_trees = [t.copy() for t in trees]
    best_side = get_side_length(best_trees)
    
    for iteration in range(max_iter):
        improved = False
        for i in range(len(trees)):
            for step in steps:
                for dx, dy in directions:
                    # Try moving tree i
                    test_trees = [t.copy() for t in best_trees]
                    test_trees[i]['x'] = float(test_trees[i]['x']) + dx * step
                    test_trees[i]['y'] = float(test_trees[i]['y']) + dy * step
                    
                    # Check for overlaps
                    if not has_overlap(test_trees):
                        side = get_side_length(test_trees)
                        if side < best_side - 1e-12:
                            best_side = side
                            best_trees = test_trees
                            improved = True
        
        if not improved:
            break
    
    return best_trees
```

## Per-N Score Tracking (MANDATORY)

After EVERY experiment, compare per-N scores to baseline:

```python
def compare_per_n(my_solution, baseline):
    improvements = []
    for n in range(1, 201):
        my_score = compute_score_for_n(my_solution, n)
        base_score = compute_score_for_n(baseline, n)
        diff = base_score - my_score  # positive = better
        if diff > 0.0001:
            improvements.append((n, diff))
            print(f"✅ N={n}: IMPROVED by {diff:.6f}")
    return improvements
```

## Strict Overlap Validation (MANDATORY)

Before ANY submission, validate with 1e15 scaling:

```python
def validate_no_overlap_strict(trees, scale=1e15):
    """Validate using Kaggle's strict precision."""
    polygons = []
    for t in trees:
        coords = [(tx * scale, ty * scale) for tx, ty in zip(TX, TY)]
        poly = Polygon(coords)
        poly = affinity.rotate(poly, float(t['deg']), origin=(0, 0))
        poly = affinity.translate(poly, float(t['x']) * scale, float(t['y']) * scale)
        polygons.append(poly)
    
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                intersection = polygons[i].intersection(polygons[j])
                if intersection.area > 0:
                    return False, f"Trees {i} and {j} overlap"
    return True, "OK"
```

## Expected Gains

| Optimization | Expected Improvement |
|--------------|---------------------|
| N=1 optimal rotation | 0.02 - 0.05 points |
| N=2-10 optimization | 0.1 - 0.3 points |
| Backward propagation | 0.1 - 0.5 points |
| Fractional translation | 0.05 - 0.2 points |
| **Total potential** | **0.3 - 1.0 points** |

## Submission Strategy

With 94 submissions remaining:
1. **SUBMIT exp_001 FIRST** - Verify baseline passes validation
2. **SUBMIT after EVERY experiment** - LB feedback is FREE
3. Track which N values improve on LB vs CV

## File Structure

Create experiments in:
```
/home/code/experiments/002_n1_optimization/
/home/code/experiments/003_backward_propagation/
/home/code/experiments/004_local_search/
```

Each experiment folder should contain:
- `optimize.ipynb` or `optimize.py` - The optimization code
- `submission.csv` - The output submission
- `metrics.json` - Score and per-N breakdown

## Key Insight from Research

The chistyakov kernel shows a PURE PYTHON approach that works:
- No binaries needed
- Uses Shapely for geometry
- Backward propagation from N=200 to N=2
- Finds trees touching boundary and tries removing them

This is EXACTLY what we should implement!
