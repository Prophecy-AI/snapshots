# Santa 2025 - Seed Prompt (Loop 6)

## Current Status
- Best CV score: 70.523320 from exp_005 (multi-source ensemble)
- Best LB score: 70.622435 (exp_001, exp_002)
- Target: 68.887226 | Gap to target: ~1.64 points
- **CRITICAL**: exp_005 FAILED on Kaggle with "Overlapping trees in group 002"

## ‚ö†Ô∏è CRITICAL ISSUE: OVERLAP VALIDATION FAILURE

The ensemble approach WORKED (improved score by 0.099 points) but the submission was REJECTED because some snapshot sources have overlaps that pass simple Shapely checks but fail Kaggle's strict validation.

**ROOT CAUSE**: Kaggle uses `scale_factor = Decimal('1e15')` or `1e18` for high-precision overlap detection. Simple floating-point Shapely checks are NOT sufficient.

**SOLUTION**: Before including ANY solution in the ensemble, validate it with high-precision overlap detection.

## ‚úÖ MANDATORY FIRST TASK: FIX OVERLAP VALIDATION

Implement high-precision overlap detection using the official approach:

```python
from decimal import Decimal, getcontext
from shapely import affinity
from shapely.geometry import Polygon

getcontext().prec = 25
scale_factor = Decimal('1e18')  # Use 1e18 for strictest validation

class ChristmasTree:
    def __init__(self, center_x='0', center_y='0', angle='0'):
        self.center_x = Decimal(center_x)
        self.center_y = Decimal(center_y)
        self.angle = Decimal(angle)
        
        # Tree dimensions
        trunk_w = Decimal('0.15')
        trunk_h = Decimal('0.2')
        base_w = Decimal('0.7')
        mid_w = Decimal('0.4')
        top_w = Decimal('0.25')
        tip_y = Decimal('0.8')
        tier_1_y = Decimal('0.5')
        tier_2_y = Decimal('0.25')
        base_y = Decimal('0.0')
        trunk_bottom_y = -trunk_h
        
        initial_polygon = Polygon([
            (Decimal('0.0') * scale_factor, tip_y * scale_factor),
            (top_w / Decimal('2') * scale_factor, tier_1_y * scale_factor),
            (top_w / Decimal('4') * scale_factor, tier_1_y * scale_factor),
            (mid_w / Decimal('2') * scale_factor, tier_2_y * scale_factor),
            (mid_w / Decimal('4') * scale_factor, tier_2_y * scale_factor),
            (base_w / Decimal('2') * scale_factor, base_y * scale_factor),
            (trunk_w / Decimal('2') * scale_factor, base_y * scale_factor),
            (trunk_w / Decimal('2') * scale_factor, trunk_bottom_y * scale_factor),
            (-(trunk_w / Decimal('2')) * scale_factor, trunk_bottom_y * scale_factor),
            (-(trunk_w / Decimal('2')) * scale_factor, base_y * scale_factor),
            (-(base_w / Decimal('2')) * scale_factor, base_y * scale_factor),
            (-(mid_w / Decimal('4')) * scale_factor, tier_2_y * scale_factor),
            (-(mid_w / Decimal('2')) * scale_factor, tier_2_y * scale_factor),
            (-(top_w / Decimal('4')) * scale_factor, tier_1_y * scale_factor),
            (-(top_w / Decimal('2')) * scale_factor, tier_1_y * scale_factor),
        ])
        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))
        self.polygon = affinity.translate(rotated,
                                          xoff=float(self.center_x * scale_factor),
                                          yoff=float(self.center_y * scale_factor))

def validate_no_overlap(trees):
    """Check for overlaps using high-precision validation."""
    for i in range(len(trees)):
        for j in range(i+1, len(trees)):
            if trees[i].polygon.intersects(trees[j].polygon) and not trees[i].polygon.touches(trees[j].polygon):
                return False, f"Trees {i} and {j} overlap"
    return True, "OK"
```

## ‚úÖ EXPERIMENT 006: VALIDATED ENSEMBLE

**GOAL**: Re-run the ensemble approach but ONLY include sources that pass high-precision validation.

**STEPS**:
1. Load ALL 88 snapshot submissions
2. For EACH source, validate ALL N values with high-precision overlap detection
3. Mark sources that have ANY overlaps as INVALID
4. Ensemble ONLY from VALID sources
5. For each N, select the BEST solution from VALID sources only
6. Validate the final ensemble before saving

**EXPECTED OUTCOME**:
- Fewer sources will be valid (some have overlaps)
- Score may be slightly worse than 70.523 (fewer sources to choose from)
- But submission will PASS Kaggle validation

## ‚ö†Ô∏è ALTERNATIVE APPROACH: Fix Overlapping N Values

If too many sources are invalid, try this:
1. Identify which N values in the ensemble have overlaps
2. For those N values, fall back to the baseline (which passed Kaggle)
3. Keep improved N values that are overlap-free

## ‚õî FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast_v2, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- Submitting without high-precision overlap validation - FORBIDDEN

## üìä SUBMISSION STRATEGY
- Remaining submissions: 92
- Submit after this experiment? YES - we need to validate the fix works
- Even if score is slightly worse, a PASSING submission is better than a failing one

## What's Working
1. ‚úÖ Multi-source ensemble approach improved score by 0.099 points
2. ‚úÖ 122 out of 200 N values improved
3. ‚úÖ 12 unique sources contributed improvements

## What Needs Fixing
1. ‚ùå Overlap validation is too lenient - need high-precision (1e18 scaling)
2. ‚ùå Some snapshot sources have overlaps that fail Kaggle validation

## Key Insight from Top Kernels
The chistyakov kernel uses `scale_factor = Decimal('1e18')` for strictest validation.
The getting-started kernel uses `scale_factor = Decimal('1e15')`.
Use 1e18 to be safe - if it passes 1e18, it will pass Kaggle.

## Response to Evaluator
The evaluator correctly identified that:
1. The ensemble approach is WORKING (0.099 improvement)
2. The submission needs to be validated on Kaggle
3. Potential overlap issues were flagged as a concern

The evaluator's concern about overlaps was CORRECT - the submission failed with "Overlapping trees in group 002". The fix is to implement high-precision overlap validation (1e18 scaling) and only include sources that pass this strict validation.

## VALIDATION NOTES
- ALWAYS validate with high-precision BEFORE saving submission
- If ANY N value has overlaps, the entire submission fails
- Better to have a slightly worse score that PASSES than a better score that FAILS
- The baseline (exp_001) passed Kaggle validation - use it as fallback for any N with overlaps