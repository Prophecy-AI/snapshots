# Santa 2025 - Evolved Seed Prompt (Loop 3)

## Current Status
- Best CV score: 70.622435 from exp_001 (fix_overlaps)
- Best LB score: 70.622435 (verified on Kaggle)
- Target: 68.887744 | Gap to target: **1.734 points (2.5%)**
- Submissions used: 2/100 (93 remaining - ABUNDANT!)

## ⚠️ CRITICAL: STUCK AT LOCAL OPTIMUM

**The last 2 experiments produced IDENTICAL scores (70.622435).**

This proves:
1. The baseline from snapshot is ALREADY at a local optimum
2. Simple local search (fractional translation, backward propagation) CANNOT improve it
3. N=1 is already at optimal angle (45°)
4. We need FUNDAMENTALLY DIFFERENT approaches

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with local search - FORBIDDEN (PROVEN TO NOT WORK)
- Loading baseline then trying small perturbations - FORBIDDEN (PROVEN TO NOT WORK)

## Response to Evaluator

The evaluator correctly identified that:
1. ✅ The baseline is at a local optimum - CONFIRMED by experiment
2. ✅ Simple local search cannot improve it - CONFIRMED
3. ✅ We need global optimization or fundamentally different approaches

I agree with the evaluator's strategic pivot recommendation. The next experiment MUST try something fundamentally different.

## ✅ MANDATORY NEXT EXPERIMENT: SIMULATED ANNEALING FROM SCRATCH

**Why SA?**
- Can escape local optima by accepting worse moves probabilistically
- Proven effective for packing problems (top kernels use SA in C++)
- We need to implement it in PURE PYTHON (no binaries)

**Implementation Requirements:**

```python
import random
import math
from shapely.geometry import Polygon
from shapely import affinity
from shapely.ops import unary_union

def simulated_annealing_for_n(n, initial_trees, T_init=1.0, T_min=0.0001, 
                               cooling=0.9995, max_iter=50000):
    """
    Simulated annealing for a single N value.
    
    Args:
        n: Number of trees
        initial_trees: List of dicts with 'x', 'y', 'deg' keys
        T_init: Initial temperature (start high to explore)
        T_min: Minimum temperature (stop when reached)
        cooling: Cooling rate (0.9995 = slow cooling, more exploration)
        max_iter: Maximum iterations
    
    Returns:
        best_trees: Best configuration found
        best_score: Best bounding box side length
    """
    current = [dict(t) for t in initial_trees]
    current_score = get_bbox_side(current)
    best = [dict(t) for t in current]
    best_score = current_score
    T = T_init
    
    for iteration in range(max_iter):
        # Generate candidate by perturbing ONE random tree
        candidate = [dict(t) for t in current]
        i = random.randint(0, n-1)
        
        # Choose perturbation type
        perturb_type = random.choice(['translate', 'rotate', 'both'])
        
        if perturb_type in ['translate', 'both']:
            # Move by small amount (scaled by temperature)
            dx = random.gauss(0, 0.1 * T)
            dy = random.gauss(0, 0.1 * T)
            candidate[i]['x'] = str(float(candidate[i]['x']) + dx)
            candidate[i]['y'] = str(float(candidate[i]['y']) + dy)
        
        if perturb_type in ['rotate', 'both']:
            # Rotate by small angle (scaled by temperature)
            dangle = random.gauss(0, 10 * T)  # degrees
            new_angle = (float(candidate[i]['deg']) + dangle) % 360
            candidate[i]['deg'] = str(new_angle)
        
        # Check for overlaps
        if has_overlap(candidate):
            continue  # Reject invalid moves
        
        candidate_score = get_bbox_side(candidate)
        delta = candidate_score - current_score
        
        # Accept if better, or with probability exp(-delta/T) if worse
        if delta < 0 or random.random() < math.exp(-delta / T):
            current = candidate
            current_score = candidate_score
            
            if current_score < best_score:
                best = [dict(t) for t in current]
                best_score = current_score
        
        # Cool down
        T *= cooling
        if T < T_min:
            break
    
    return best, best_score
```

## ✅ ALTERNATIVE: CONSTRUCTIVE APPROACH (DIFFERENT BASIN)

The zaburo kernel shows that building solutions FROM SCRATCH using a grid pattern can find different configurations:

```python
def build_grid_solution(n):
    """
    Build a solution using alternating rows of trees.
    Trees at 0° and 180° can interlock efficiently.
    """
    trees = []
    row = 0
    placed = 0
    
    while placed < n:
        # Alternate between 0° and 180° rows
        angle = 0 if row % 2 == 0 else 180
        x_offset = 0 if row % 2 == 0 else 0.35  # Half tree width offset
        y = row * 0.5  # Row spacing
        
        # Place trees in this row
        trees_in_row = min(n - placed, estimate_row_capacity(row))
        for i in range(trees_in_row):
            trees.append({
                'idx': placed,
                'x': str(0.7 * i + x_offset),
                'y': str(y),
                'deg': str(angle)
            })
            placed += 1
        
        row += 1
    
    return trees
```

This gives a DIFFERENT starting point that SA can then optimize.

## ✅ REQUIRED: TEST ON SMALL N FIRST

Before running on all 200 N values, TEST on small N:

```python
# Test SA on N=10, N=20, N=30 first
test_ns = [10, 20, 30]
for n in test_ns:
    baseline_trees = load_baseline_for_n(n)
    baseline_score = get_bbox_side(baseline_trees)
    
    # Try SA
    sa_trees, sa_score = simulated_annealing_for_n(n, baseline_trees)
    
    print(f"N={n}: baseline={baseline_score:.6f}, SA={sa_score:.6f}")
    if sa_score < baseline_score:
        print(f"  ✅ IMPROVEMENT: {baseline_score - sa_score:.6f}")
    else:
        print(f"  ❌ No improvement")
```

**If SA shows improvement on small N → Scale up to all N**
**If SA shows NO improvement → Try constructive approach instead**

## ✅ REQUIRED: PER-N TRACKING

Track best solution for EACH N separately:

```python
best_per_n = {}  # {n: {'trees': [...], 'score': float}}

# After each experiment, update best_per_n
for n in range(1, 201):
    my_score = get_score_for_n(my_solution, n)
    if n not in best_per_n or my_score < best_per_n[n]['score']:
        best_per_n[n] = {'trees': my_solution[n], 'score': my_score}
        print(f"✅ N={n}: NEW BEST {my_score:.6f}")

# Final submission = ensemble of best per-N
```

## Experiment Structure

```
experiments/003_simulated_annealing/
├── main.ipynb          # Main SA implementation
├── submission.csv      # Final submission
├── metrics.json        # Results
└── per_n_results.json  # Per-N tracking
```

## Key Parameters to Tune

| Parameter | Start Value | Range | Notes |
|-----------|-------------|-------|-------|
| T_init | 1.0 | 0.5 - 5.0 | Higher = more exploration |
| cooling | 0.9995 | 0.999 - 0.99999 | Slower = more thorough |
| max_iter | 50000 | 10000 - 500000 | More = better but slower |
| perturb_scale | 0.1 | 0.01 - 0.5 | Translation step size |
| angle_scale | 10 | 1 - 45 | Rotation step size (degrees) |

## Success Criteria

- ✅ **SUCCESS**: Any N value improved by > 0.0001
- ✅ **GOOD**: Total score improved by > 0.01
- ✅ **EXCELLENT**: Total score < 70.5

## What NOT to Try

- ❌ More fractional translation (already tried, 0 improvements)
- ❌ More backward propagation (already tried, 0 improvements)
- ❌ Running bbox3 or any binary (produces same 70.6 score)
- ❌ Small perturbations on baseline (local optimum)

## SUBMISSION STRATEGY

**SUBMIT AFTER THIS EXPERIMENT** regardless of result!
- We have 93 submissions remaining
- LB feedback is FREE information
- Even if SA doesn't improve, we learn what doesn't work
- If SA improves even slightly, that's valuable data

## Validation Notes

Before submission, validate:
1. No overlaps using strict precision (scale_factor = 1e15)
2. All 200 N values present
3. Correct CSV format (id, x, y, deg with 's' prefix)

```python
from decimal import Decimal, getcontext
getcontext().prec = 30
SCALE = 10**18

def validate_no_overlap_strict(trees):
    """Validate using integer-scaled coordinates."""
    polygons = []
    for tree in trees:
        coords = [(int(Decimal(str(x)) * SCALE), 
                   int(Decimal(str(y)) * SCALE)) 
                  for x, y in get_tree_vertices(tree)]
        polygons.append(Polygon(coords))
    
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                return False, f"Trees {i} and {j} overlap"
    return True, "OK"
```
