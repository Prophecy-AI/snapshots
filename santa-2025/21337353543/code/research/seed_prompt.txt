## Current Status
- Best CV score: 70.329514 from exp_016 (jazivxt_ensemble)
- Best LB score: 70.3410 (exp_010)
- Target: 68.876781 | Gap to target: 1.45 points (2.1%)
- Submissions: 10/100 used, 90 remaining

## ⚠️ CRITICAL: FIX THE BUG IN REBUILD FROM CORNERS

The evaluator identified a **CRITICAL BUG** in exp_017 that explains why it found 0 improvements.

**YOUR IMPLEMENTATION (WRONG):**
```python
for t in large_layout:
    x, y = float(t['x']), float(t['y'])  # Uses tree CENTER
    dist = max(abs(x - corner_x), abs(y - corner_y))
```

**CHISTYAKOV KERNEL (CORRECT):**
```python
candidates = {
    max(
        abs(tree.polygon.bounds[0] - corner_x),  # polygon minx
        abs(tree.polygon.bounds[2] - corner_x),  # polygon maxx
        abs(tree.polygon.bounds[1] - corner_y),  # polygon miny
        abs(tree.polygon.bounds[3] - corner_y),  # polygon maxy
    ): tree for tree in layout
}
```

**WHY THIS MATTERS:**
- A tree at center (0,0) with rotation can have polygon bounds extending to ±0.8
- The polygon bounds determine the actual bounding box contribution
- Using tree center ignores the tree's rotation and shape
- This causes the algorithm to select the WRONG trees for each subset

## Response to Evaluator

The evaluator correctly identified:
1. ✅ **CRITICAL BUG** - The distance calculation is fundamentally wrong
2. ✅ **Technique not properly tested** - We can't conclude it doesn't work until we fix the bug
3. ✅ **Need to verify LB** - Current best (70.329514) hasn't been submitted

I AGREE with all evaluator recommendations. The immediate priority is:
1. **FIX THE BUG** and re-run rebuild from corners
2. **SUBMIT** current best to verify CV-LB alignment
3. **EXPAND ENSEMBLE** with any missing datasets

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY] Fix Rebuild from Corners Bug**

Create `experiments/018_rebuild_corners_fixed/`:

```python
def rebuild_from_corners_fixed(large_layout, target_n, current_best_score):
    """Extract subset of trees closest to each corner using POLYGON BOUNDS."""
    if len(large_layout) <= target_n:
        return None
    
    # Create polygons for all trees
    polygons = [create_tree_polygon(t['x'], t['y'], t['deg']) for t in large_layout]
    
    # Get layout bounds
    union = unary_union(polygons)
    bounds = union.bounds
    minx, miny, maxx, maxy = bounds
    
    corners = [(minx, miny), (minx, maxy), (maxx, miny), (maxx, maxy)]
    
    best_subset = None
    best_score = current_best_score
    
    for corner_x, corner_y in corners:
        # Sort trees by max POLYGON BOUNDS distance from corner (Chebyshev)
        trees_with_dist = []
        for i, t in enumerate(large_layout):
            poly = polygons[i]
            b = poly.bounds  # (minx, miny, maxx, maxy)
            dist = max(
                abs(b[0] - corner_x),  # polygon minx
                abs(b[2] - corner_x),  # polygon maxx
                abs(b[1] - corner_y),  # polygon miny
                abs(b[3] - corner_y),  # polygon maxy
            )
            trees_with_dist.append((dist, t))
        
        trees_with_dist.sort(key=lambda x: x[0])
        subset = [t for _, t in trees_with_dist[:target_n]]
        
        score = get_score(subset, target_n)
        if score < best_score - 1e-9:
            if validate_no_overlap_strict(subset):
                best_score = score
                best_subset = subset
    
    return (best_subset, best_score) if best_subset else None
```

**Expected gain**: 0.01-0.1 points (the technique works for chistyakov, it should work for us)

### 2. **[HIGH PRIORITY] Submit Current Best**

After fixing the bug, submit to verify CV-LB alignment:
- Current CV: 70.329514
- Last verified LB: 70.3410 (exp_010)
- Need to confirm the gap hasn't changed

### 3. **[MEDIUM PRIORITY] Try More Source Layouts**

The chistyakov kernel only uses N=111 as source. Try ALL large N values:
- N=50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200
- Each large layout might have good corner subsets for different target N values

### 4. **[MEDIUM PRIORITY] Zaburo Constructive + Optimization**

The zaburo kernel creates a "well-aligned initial solution" using alternating rows:
- Row 0: trees at angle 0°
- Row 1: trees at angle 180°, offset by 0.35 (half tree width)
- This creates a tight packing pattern

This could be a good STARTING POINT for optimization (different from current local optima).

## What NOT to Try

- ❌ Running bbox3/sa_fast with "more iterations" (already at local optimum)
- ❌ Ensemble from existing sources (exhausted - only 0.000042 improvement from 3781 snapshots)
- ❌ Local search on current solutions (SA, fractional translation found ~0 improvements)

## Validation Notes

- Use high-precision (1e18 scaling) for overlap detection
- All N values must pass strict validation before submission
- Compare per-N scores to identify which N values improved

## SUBMISSION STRATEGY

- Remaining submissions: 90
- **SUBMIT AFTER THIS EXPERIMENT** - We have abundant submissions
- LB feedback is valuable - use it to verify CV-LB alignment

## Key Insight from Chistyakov Kernel

"Most problems are always with the corner, so if we check smaller squares for each corner, we check 99% of positive cases."

The technique exploits the structure of larger optimized layouts to improve smaller N values WITHOUT running optimization - just subset extraction. But it ONLY works if you use POLYGON BOUNDS for distance, not tree center.
