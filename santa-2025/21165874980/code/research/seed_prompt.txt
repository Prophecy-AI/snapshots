# Santa 2025 - Christmas Tree Packing Challenge - Loop 8 Strategy

## Current Status
- Best CV score: 70.647327 from exp_000 (001_baseline)
- Best LB score: 70.6473 (CONFIRMED - matches CV exactly!)
- Target: 68.919154 | Gap to target: 1.728 points (2.4%)
- Submissions used: 4/100 (89 remaining - ABUNDANT!)

## CV-LB Calibration
- CV = 70.647327, LB = 70.647327 → Perfect match!
- This means our local scoring is accurate and we can trust CV

## CRITICAL INSIGHT FROM EVALUATOR (MUST IMPLEMENT)

The evaluator identified the **MISSING PIECE** that we haven't implemented:

**The REPAIR Strategy from yongsukprasertsuk kernel:**
1. Run optimizer (bbox3 or sa_v1_parallel) - produces some overlapping solutions
2. Validate with Shapely - identify which N values have overlaps
3. **REPAIR overlapping N values by replacing with baseline** - ensures valid submission
4. Run fix_direction for rotation tightening
5. Keep only the improvements that are valid

**The 183 overlapping N values from exp_007 are NOT a failure - they just need to be REPAIRED!**

Even if only 17 out of 200 N values improve, that's still progress toward target.

## Response to Evaluator

**I AGREE with the evaluator's analysis.** The key insight is:

1. **WRONG conclusion**: "Both bbox3 AND sa_v1_parallel produce overlapping trees" as if this invalidates the approach
2. **CORRECT understanding**: Overlaps are EXPECTED. The repair step handles this.

The yongsukprasertsuk kernel shows the complete pipeline:
- `repair_overlaps_in_place(WORK_SUBMISSION, donor_path=BASELINE_CSV)` 
- This replaces overlapping N values with the baseline solution
- The result is a VALID submission that keeps only the improvements

**I will implement the repair + ensemble strategy as the evaluator recommended.**

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY] Implement REPAIR + ENSEMBLE Strategy**

Use the optimized zaburo solutions from exp_007 and REPAIR them:

```python
# Load optimized zaburo solutions (88.33 score, 183 overlaps)
optimized_path = '/home/code/experiments/007_sa_optimization/solutions/submission_88.326787.csv'

# For each N=1-200:
for n in range(1, 201):
    if has_overlap(optimized[n]):
        # REPAIR: Use baseline for overlapping N
        final_solution[n] = baseline[n]
    elif score(optimized[n]) < score(baseline[n]):
        # KEEP: Use optimized if it's better
        final_solution[n] = optimized[n]
    else:
        # KEEP: Use baseline if it's better
        final_solution[n] = baseline[n]

# Run fix_direction for rotation tightening
fix_direction(final_solution)
```

**Expected outcome**: Even if only 17 N values improve, that could be 0.1-0.5 points improvement.

### 2. **[HIGH PRIORITY] Run bbox3 with REPAIR**

The yongsukprasertsuk kernel shows the complete 3-phase approach:
- Phase A: 2 min runs with n=[1000,1200,1500,1800,2000], r=[30,60,90]
- Phase B: 10 min runs on top 3 candidates
- Phase C: 20 min runs on best 2

**CRITICAL**: After each phase, run `repair_overlaps_in_place()` to fix overlaps.

### 3. **[MEDIUM PRIORITY] Tessellation approach for specific N values**

The egortrushin kernel shows tessellation-based SA for specific N values:
- N=72: nt=[4, 9] grid
- N=100: nt=[5, 10] grid
- N=110: nt=[5, 11] grid
- N=144: nt=[6, 12] grid
- N=156: nt=[6, 13] grid
- N=196: nt=[7, 14] grid
- N=200: nt=[7, 15] grid (optimize 210, delete 10 worst)

These create fundamentally different configurations that might beat the baseline for these specific N values.

### 4. **[MEDIUM PRIORITY] fix_direction rotation tightening**

The yongsukprasertsuk kernel shows rotation tightening:
- For each N, find the optimal rotation angle that minimizes bounding box
- This can squeeze out micro-improvements without changing tree positions

## What NOT to Try

1. ❌ Running more SA/bbox3 without the REPAIR step
2. ❌ Generating new initial configurations without optimization
3. ❌ Ensemble approaches without overlap validation
4. ❌ Concluding that overlapping solutions are useless

## SUBMISSION STRATEGY

**SUBMIT AGGRESSIVELY!** We have 89 submissions remaining.

- Submit after EVERY experiment that produces a valid submission
- LB feedback tells us what ACTUALLY works
- Even if the repair only gives 0.01 improvement, SUBMIT IT to verify

## Validation Notes

- Use Shapely for overlap detection (matches Kaggle's checker exactly)
- CV scoring is accurate (CV = LB confirmed)
- Always validate before submission to avoid "Overlapping trees" errors

## Key Code to Implement

From yongsukprasertsuk kernel:

```python
def repair_overlaps_in_place(submission_path, donor_path=BASELINE_CSV):
    res = score_and_validate_submission(submission_path)
    if res["ok"]:
        return res
    
    for n in res["failed_overlap_n"]:
        replace_group(submission_path, donor_path, f"{n:03d}", submission_path)
    
    # Quick tighten after repair
    fix_direction(submission_path, submission_path, passes=1)
    return score_and_validate_submission(submission_path)
```

**THE TARGET OF 68.919 IS ACHIEVABLE.** The gap is 1.728 points (2.4%). Top performers have scores in the 67-68 range using the exact strategies described above.
