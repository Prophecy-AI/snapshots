# Santa 2025 - Christmas Tree Packing Challenge

## Problem Overview
This is a 2D polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (N trees for N=1 to 200) into the smallest possible square bounding box. The score is the sum of (s_n^2 / n) for all N values, where s_n is the side length of the bounding box for the N-tree configuration. Lower is better.

**Target Score: 68.919** (need to beat this)
**Current Best Available: 70.647** (from jazivxt/bucket-of-chump dataset)
**Gap to close: ~1.73 points**

## Tree Shape Specifications
- Total height: 1.0 (tip at y=0.8, trunk bottom at y=-0.2)
- Max width: 0.7 (at base)
- 15-vertex polygon with tiered structure
- Trunk: width 0.15, height 0.2
- Base tier: width 0.7
- Mid tier: width 0.4
- Top tier: width 0.25

Vertex coordinates (before rotation):
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## Pre-Optimized Datasets Available
Download these for baseline:
```bash
kaggle datasets download -d jazivxt/bucket-of-chump --unzip  # Score: 70.647
kaggle datasets download -d saspav/santa-2025-csv --unzip    # Score: 70.659
```

The jazivxt dataset includes a `bbox3` binary optimizer that can be used for further optimization.

## Score Breakdown Analysis
- **N=1-20 contributes 8.06 points (11.4% of total)**
- **N=21-200 contributes 62.59 points (88.6% of total)**
- N=1 alone: 0.661 points (side=0.813, at 45° rotation)
- N=2: 0.451 points (side=0.950)
- N=3: 0.435 points (side=1.142)

**Key insight**: Small N has higher per-tree contribution but large N dominates total score. Need improvements across ALL N values to close the 1.73 point gap.

## Key Techniques from Research

### 1. Simulated Annealing (SA) - Primary Approach
The kernels use sophisticated SA with multiple move operators:
- **Translation moves**: Gaussian perturbation of (x, y) position
- **Rotation moves**: Angle adjustments (±5°, ±2°, ±0.8°, etc.)
- **Combined moves**: Simultaneous position + rotation changes
- **Boundary-focused moves**: Target trees on the bounding box edges
- **Swap moves**: Exchange positions of two trees
- **Global squeeze**: Scale all trees toward center, then repair overlaps
- **Levy flight**: Large random jumps to escape local optima

### 2. Compaction Operations
- Squeeze toward centroid with decreasing scale factors (0.9995 down to 0.98)
- Local search moving each tree toward center in small steps
- Rotation optimization to minimize bounding box after placement

### 3. C++ Optimizer (bbox3)
The best kernels use a compiled C++ optimizer for speed:
- OpenMP parallelization for overlap checking
- Long double precision for geometric calculations
- Fast RNG (xorshift) for SA
- Efficient polygon overlap detection with bounding box pre-filtering

### 4. Collision Detection
- Point-in-polygon test for vertex containment
- Segment intersection for edge crossings
- Bounding box pre-filter for early rejection
- STRtree spatial indexing for large N

## Recommended Experiment Strategy

### Experiment 1: Establish Baseline
1. Download jazivxt/bucket-of-chump dataset
2. Submit the pre-optimized submission.csv
3. Verify score matches expected ~70.65

### Experiment 2: Compile and Run bbox3 Optimizer
1. Extract bbox3.cpp from kernels (jazivxt_why-not or smartmanoj_santa-claude)
2. Compile with: `g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp`
3. Run optimization on baseline for extended time (3+ hours)
4. Focus on boundary trees and squeeze operations

### Experiment 3: Multi-Start Optimization
- Run multiple optimization passes with different random seeds
- Keep best solution per N value
- Blend solutions from different runs

### Experiment 4: Small N Focus (N=1-20)
- For N=1: Verify optimal rotation (should be ~45°)
- For N=2-5: Try exhaustive/near-exhaustive search
- More SA iterations for small N (higher score contribution)

### Experiment 5: Asymmetric Solutions
Discussion mentions asymmetric solutions may outperform symmetric ones:
- Don't assume rotational symmetry in packings
- Try random restarts with different initial configurations
- Perturb symmetric solutions to find asymmetric improvements

### Experiment 6: Tessellation Approaches for Large N
For N>100, consider:
- Regular lattice patterns as starting points
- Hexagonal packing arrangements
- Interlocking tree orientations (alternating angles)

### Experiment 7: Per-N Specialization
- Different optimization strategies for different N ranges
- More iterations for high-contribution N values
- Blend best solutions from multiple runs into final submission

## Implementation Notes

### Scoring Function
```python
def calculate_score(side_lengths):
    return sum(s**2 / n for n, s in side_lengths.items())
```

### Submission Format
- Values must be prefixed with 's' (e.g., "s0.123456")
- Coordinates constrained to -100 ≤ x, y ≤ 100
- No overlapping trees allowed

### Key Files
- `../research/kernels/jazivxt_why-not/` - bbox3 optimizer with global dynamics
- `../research/kernels/smartmanoj_santa-claude/` - SA optimizer in C++ with swap moves
- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - Runner script
- `../research/kernels/inversion_santa-2025-getting-started/` - Basic greedy algorithm

## Critical Insights

1. **Pre-optimized solutions are at local optima** - Running more SA iterations on them yields diminishing returns. Need fundamentally different approaches or better starting points.

2. **The gap is ~1.73 points** - This is significant. Micro-optimizations won't close it. Need either:
   - Much better initial configurations
   - Novel packing patterns (tessellations, asymmetric)
   - Focus on specific N values where current solutions are suboptimal

3. **N=1 has worst packing efficiency** - Ratio of actual/theoretical is 1.15 for N=1, suggesting room for improvement in small N.

4. **Rotation optimization is crucial** - After placing trees, rotating the entire configuration can reduce bounding box size significantly.

5. **Boundary trees matter most** - Trees touching the bounding box edges determine the score. Focus optimization on these.

## Validation
- Calculate local score before submission using Shapely
- Check for overlaps using polygon intersection
- Verify coordinate bounds (-100 to 100)
- Compare against baseline score to ensure improvement

## Reference EDA
See `exploration/eda.ipynb` for:
- Per-N score contribution analysis
- Side length vs N plots
- Comparison of available pre-optimized solutions
