# Santa 2025 - Christmas Tree Packing Challenge

## Problem Overview
This is a 2D polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (N trees for N=1 to 200) into the smallest possible square bounding box. The score is the sum of (s_n^2 / n) for all N values, where s_n is the side length of the bounding box for the N-tree configuration. Lower is better.

**Target Score: 68.919** (need to beat this)
**Current Best Available: 70.647** (from jazivxt/bucket-of-chump dataset)
**Gap to close: ~1.73 points**

## Tree Shape Specifications
- Total height: 1.0 (tip at y=0.8, trunk bottom at y=-0.2)
- Max width: 0.7 (at base)
- 15-vertex polygon with tiered structure
- Trunk: width 0.15, height 0.2
- Base tier: width 0.7
- Mid tier: width 0.4
- Top tier: width 0.25

## Pre-Optimized Datasets Available
Download these for baseline:
```bash
kaggle datasets download -d jazivxt/bucket-of-chump --unzip  # Score: 70.647
kaggle datasets download -d saspav/santa-2025-csv --unzip    # Score: 70.659
```

The jazivxt dataset includes a `bbox3` binary optimizer that can be used for further optimization.

## Key Techniques from Research

### 1. Simulated Annealing (SA) - Primary Approach
The kernels use sophisticated SA with multiple move operators:
- **Translation moves**: Gaussian perturbation of (x, y) position
- **Rotation moves**: Angle adjustments (±5°, ±2°, ±0.8°, etc.)
- **Combined moves**: Simultaneous position + rotation changes
- **Boundary-focused moves**: Target trees on the bounding box edges
- **Swap moves**: Exchange positions of two trees
- **Global squeeze**: Scale all trees toward center, then repair overlaps
- **Levy flight**: Large random jumps to escape local optima

### 2. Compaction Operations
- Squeeze toward centroid with decreasing scale factors (0.9995 down to 0.98)
- Local search moving each tree toward center in small steps
- Rotation optimization to minimize bounding box after placement

### 3. C++ Optimizer (bbox3)
The best kernels use a compiled C++ optimizer for speed:
- OpenMP parallelization for overlap checking
- Long double precision for geometric calculations
- Fast RNG (xorshift) for SA
- Efficient polygon overlap detection with bounding box pre-filtering

### 4. Collision Detection
- Point-in-polygon test for vertex containment
- Segment intersection for edge crossings
- Bounding box pre-filter for early rejection
- STRtree spatial indexing for large N

## Score Contribution Analysis
From EDA, the biggest score contributors are small N values:
- N=1: 0.661 (single tree, optimal rotation ~45°)
- N=2: 0.451
- N=3: 0.435
- N=4-10: ~0.38-0.42 each

Small N values have disproportionate impact due to the s^2/n formula.

## Recommended Experiment Strategy

### Experiment 1: Establish Baseline
1. Download jazivxt/bucket-of-chump dataset
2. Submit the pre-optimized submission.csv
3. Verify score matches expected ~70.65

### Experiment 2: Run bbox3 Optimizer
1. Compile the bbox3 C++ optimizer from kernels
2. Run optimization on the baseline for extended time
3. Focus on boundary trees and squeeze operations

### Experiment 3: Small N Optimization
Focus on N=1 to N=20 where score contribution is highest:
- For N=1: Find optimal rotation angle (should be ~45°)
- For N=2-5: Try exhaustive search of configurations
- Use greedy + local search for small N

### Experiment 4: Asymmetric Solutions
Discussion mentions asymmetric solutions may outperform symmetric ones:
- Don't assume rotational symmetry in packings
- Try random restarts with different initial configurations
- Multi-start SA with diverse seeds

### Experiment 5: Tessellation Approaches
For large N (>100), consider:
- Regular lattice patterns as starting points
- Hexagonal packing arrangements
- Interlocking tree orientations

### Experiment 6: Per-N Specialization
- Different optimization strategies for different N ranges
- More iterations for high-contribution N values
- Blend best solutions from multiple runs

## Implementation Notes

### Scoring Function
```python
def calculate_score(side_lengths):
    return sum(s**2 / n for n, s in side_lengths.items())
```

### Submission Format
- Values must be prefixed with 's' (e.g., "s0.123456")
- Coordinates constrained to -100 ≤ x, y ≤ 100
- No overlapping trees allowed

### Key Files
- `../research/kernels/jazivxt_why-not/` - bbox3 optimizer
- `../research/kernels/smartmanoj_santa-claude/` - SA optimizer in C++
- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - Runner script

## Critical Insights

1. **Pre-optimized solutions are at local optima** - Running more SA iterations on them yields diminishing returns. Need fundamentally different approaches or better starting points.

2. **The gap is ~1.73 points** - This is significant. Micro-optimizations won't close it. Need either:
   - Much better initial configurations
   - Novel packing patterns (tessellations, asymmetric)
   - Focus on specific N values where current solutions are suboptimal

3. **Small N matters most** - Due to s^2/n weighting, improving N=1-20 has more impact than improving N=150-200.

4. **Rotation optimization is crucial** - After placing trees, rotating the entire configuration can reduce bounding box size.

## Validation
- Calculate local score before submission
- Check for overlaps using Shapely polygon intersection
- Verify coordinate bounds (-100 to 100)
