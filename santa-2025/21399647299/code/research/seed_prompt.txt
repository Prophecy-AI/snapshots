## SANTA 2025 STRATEGY - LOOP 42

## Current Status
- **Best CV score**: 70.316492 (exp_022)
- **Best LB score**: 70.3165 (exp_022, verified)
- **Target**: 68.861114 | **Gap**: 1.455 points (2.07%)
- **Top LB (#1)**: 68.894566 (Jingle bins, 953 submissions!)
- **Gap to #1**: 1.422 points

## ğŸš¨ CRITICAL REALITY CHECK ğŸš¨

**The target (68.861114) is BELOW the current #1 leaderboard score (68.894566)!**

This means we need to BEAT THE COMPETITION LEADER to hit our target. The top team has:
- 953 submissions (we have 20)
- Accumulated per-N improvements over weeks
- Likely custom algorithms beyond public kernels

**Our current approach (running bbox3 variations) has hit a ceiling at ~70.316.**
**We need a 2% improvement that NO public approach has achieved.**

## What We've Learned (42 experiments)

### APPROACHES THAT DON'T WORK:
1. âŒ Running bbox3/sa_fast with different parameters â†’ Same ~70.3 score
2. âŒ Ensemble of snapshot solutions â†’ Best was 70.306 (only 0.01 improvement)
3. âŒ Backward propagation â†’ No improvement
4. âŒ Simulated annealing from scratch â†’ No improvement
5. âŒ Exhaustive search for N=2 â†’ Baseline already optimal
6. âŒ NFP-based placement â†’ No improvement
7. âŒ Multi-start random â†’ Much worse than baseline
8. âŒ Fractional translation â†’ No improvement

### WHAT THE TOP TEAMS DO:
1. âœ… 953 submissions - accumulate per-N improvements
2. âœ… Extended optimization runs (hours/days, not minutes)
3. âœ… Asymmetric solutions (per discussion "Why winning solutions will be Asymmetric")
4. âœ… Crystallization patterns (blue/pink tree orientations)
5. âœ… Custom algorithms not in public kernels

## â›” FORBIDDEN (WILL BE REJECTED)
- Running bbox3/sa_fast with "more iterations" - we've done this 40+ times
- "Optimizing" existing CSV files - doesn't work
- Ensemble of same optimizer outputs - doesn't work
- Any approach that gave < 0.01 improvement in previous experiments

## ğŸ“‹ NEXT EXPERIMENT: FUNDAMENTALLY DIFFERENT APPROACH

### Option 1: EXTENDED BBOX3 OPTIMIZATION (4-8 HOURS)
The evaluator noted bbox3 was only run for ~10 minutes. Top teams run for HOURS/DAYS.

```bash
# Run bbox3 for 4-8 hours with aggressive parameters
./bbox3 -i input.csv -o output.csv -n 2000 -r 96 -t 28800  # 8 hours
```

**CRITICAL**: This is different from "more iterations" because:
- Previous runs: 10-30 minutes
- This run: 4-8 HOURS (24-48x longer)
- Use current best (exp_022) as starting point

### Option 2: IMPLEMENT CRYSTALLIZATION PATTERN GENERATOR

The "Why Not" kernel shows blue/pink crystallization patterns. Implement a generator:

```python
def generate_crystallization_pattern(n):
    """Generate trees using blue/pink lattice interlock pattern."""
    # Blue trees: angles 0-90 or 270-360
    # Pink trees: angles 90-270
    # Lattice offset: dx=0.5, dy=0.3 (from analysis)
    
    trees = []
    for i in range(n):
        is_blue = i % 2 == 0
        angle = 45 if is_blue else 225  # Opposite orientations
        x = (i % grid_size) * lattice_spacing
        y = (i // grid_size) * lattice_spacing
        if not is_blue:
            x += dx_offset
            y += dy_offset
        trees.append((x, y, angle))
    return trees
```

### Option 3: BRANCH-AND-BOUND FOR SMALL N

N=1-10 contribute ~4.32 points (6.1% of total). Guarantee optimal for these:

```python
def branch_and_bound_n(n, max_depth=10):
    """Find optimal placement for N trees using B&B."""
    # For N=2: exhaustive search over all angle pairs
    # For N=3-10: B&B with pruning based on bbox lower bound
    
    best_score = float('inf')
    best_config = None
    
    def search(placed_trees, remaining):
        nonlocal best_score, best_config
        
        # Pruning: if current bbox already >= best, skip
        current_bbox = compute_bbox(placed_trees)
        if current_bbox >= best_score:
            return
        
        if not remaining:
            score = current_bbox ** 2 / n
            if score < best_score:
                best_score = score
                best_config = placed_trees.copy()
            return
        
        # Try all valid placements for next tree
        for angle in range(0, 360, 5):
            for x in np.arange(-2, 2, 0.1):
                for y in np.arange(-2, 2, 0.1):
                    if not overlaps(placed_trees, (x, y, angle)):
                        search(placed_trees + [(x, y, angle)], remaining - 1)
    
    search([], n)
    return best_config
```

## ğŸ“Š SUBMISSION STRATEGY

With 80 submissions remaining:
1. **SUBMIT EVERY EXPERIMENT** - LB feedback is critical
2. Track per-N improvements across all submissions
3. Build ensemble of best per-N from all experiments
4. Even small improvements (0.001) accumulate over 200 N values

## ğŸ¯ SUCCESS CRITERIA

- **IMMEDIATE**: Any improvement over 70.316492
- **SHORT-TERM**: Score below 70.0
- **TARGET**: Score below 68.861114 (beat #1)

## EXPERIMENT TEMPLATE

```python
# experiments/043_[approach_name]/

# 1. Load current best solution
df_best = pd.read_csv('experiments/022_extended_cpp_optimization/optimized.csv')

# 2. Implement your approach
# ... your code here ...

# 3. Compare per-N scores
for n in range(1, 201):
    my_score = compute_score(my_solution, n)
    best_score = compute_score(df_best, n)
    if my_score < best_score:
        print(f"âœ… N={n}: IMPROVED by {best_score - my_score:.6f}")
        improvements.append((n, my_score))

# 4. Create submission with improvements only
# Keep best per-N from all sources

# 5. Validate no overlaps
for n, trees in solution.items():
    assert not has_overlap(trees), f"N={n} has overlaps!"

# 6. Save and submit
df.to_csv('/home/submission/submission.csv', index=False)
```

## REMEMBER

- The target IS reachable - top team achieved 68.894
- We need 953-level effort (many submissions, extended runs)
- Every 0.001 improvement matters when accumulated over 200 N values
- SUBMIT EVERYTHING - LB feedback is free information
