## Current Status
- Best CV score: 70.3165 from exp_022 (verified on LB)
- Best LB score: 70.3165 (exp_022)
- Target: 68.870074 | Gap to target: 1.45 points (2.1%)
- Submissions used: 16/100 (84 remaining)

## CRITICAL: SUBMISSION VALIDATION ISSUE

**10 out of 16 submissions (62.5%) FAILED due to overlaps!**

The overlap validation is a MAJOR issue. Before ANY submission:
1. Use strict float-based validation (tolerance=1e-12)
2. If ANY N value has potential overlap, fall back to exp_022's solution for that N
3. The exp_022 submission is the ONLY verified-safe baseline

## Submission Log
| Exp | Approach | CV | LB | Notes |
|-----|----------|----|----|-------|
| 001 | valid_baseline | 70.615 | 70.615 | ✅ PASSED |
| 002 | backward_prop | 70.615 | 70.615 | ✅ PASSED |
| 010 | safe_ensemble | 70.365 | 70.365 | ✅ PASSED |
| 016 | mega_ensemble | 70.354 | 70.354 | ✅ PASSED |
| 019 | external_ensemble | 70.343 | 70.343 | ✅ PASSED |
| 022 | fixed_overlap | 70.316 | 70.316 | ✅ PASSED - BEST |
| 007-009, 013, 020-021, 032-034 | various | - | FAIL | ❌ Overlapping trees |

## What We've Learned

### ALGORITHM EXHAUSTION CONFIRMED
After 35 experiments with 11+ novel algorithms:
- SA, GA, B&B, lattice, CP, gradient, tessellation, physics, jostle, BLF, NFP
- **ALL found ZERO improvement over baseline**
- The baseline is at an EXTREMELY strong local optimum

### ONLY ENSEMBLE WORKED
- The ONLY approach that improved score was ensemble (combining external sources)
- Improvement: 70.615 → 70.316 (0.30 points from ensemble)
- External sources have been EXHAUSTED - our baseline beats all 6253+ external files

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- Creating submissions that fail overlap validation - FORBIDDEN

## ✅ NEXT EXPERIMENT: EXHAUSTIVE SNAPSHOT SEARCH

Since all novel algorithms failed, search ALL snapshots exhaustively:

### SPECIFIC TASK:

```python
import glob
import pandas as pd
from shapely import Polygon
import math
import numpy as np

# Tree polygon vertices
TX = np.array([0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125])
TY = np.array([0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5])

def get_tree_polygon(x, y, angle_deg):
    angle_rad = math.radians(angle_deg)
    cos_a = math.cos(angle_rad)
    sin_a = math.sin(angle_rad)
    vertices = [(tx * cos_a - ty * sin_a + x, tx * sin_a + ty * cos_a + y) for tx, ty in zip(TX, TY)]
    return Polygon(vertices)

def validate_strict(trees, tolerance=1e-12):
    n = len(trees)
    polygons = [get_tree_polygon(x, y, a) for x, y, a in trees]
    for i in range(n):
        for j in range(i + 1, n):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                if polygons[i].intersection(polygons[j]).area > tolerance:
                    return False
    return True

# 1. Load exp_022 as the SAFE baseline
baseline = pd.read_csv('/home/code/experiments/022_fixed_overlap/submission.csv')

# 2. Search ALL snapshot files
snapshot_files = glob.glob('/home/nonroot/snapshots/santa-2025/*/code/**/*.csv', recursive=True)
print(f"Found {len(snapshot_files)} snapshot files")

# 3. For each N, find the best VALID solution
best_per_n = {}  # n -> (score, trees, source)

for n in range(1, 201):
    # Start with baseline
    baseline_trees = parse_trees(baseline, n)
    baseline_score = compute_score(baseline_trees, n)
    best_per_n[n] = (baseline_score, baseline_trees, 'baseline')

# 4. Search snapshots
for snap_file in snapshot_files:
    try:
        df = pd.read_csv(snap_file)
        for n in range(1, 201):
            trees = parse_trees(df, n)
            if trees is None or len(trees) != n:
                continue
            
            # STRICT validation
            if not validate_strict(trees):
                continue
            
            score = compute_score(trees, n)
            if score < best_per_n[n][0] - 0.0001:  # Only accept significant improvements
                best_per_n[n] = (score, trees, snap_file)
                print(f"N={n}: Found better solution {score:.6f} from {snap_file}")
    except:
        continue

# 5. Create submission with best per-N
# 6. Validate ENTIRE submission before saving
# 7. Fall back to exp_022 for any N with validation concerns
```

## VALIDATION CODE (MANDATORY)

Before EVERY submission, validate ALL N values:
```python
for n in range(1, 201):
    if not validate_strict(solution[n]):
        print(f"N={n} has overlap - falling back to exp_022")
        solution[n] = baseline[n]
```

## SUCCESS CRITERIA
- Any improvement over 70.316 that PASSES Kaggle validation
- Even 0.001 improvement is valuable at this stage
- MUST pass validation - no more failed submissions