# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
Pack Christmas tree toys (15-vertex polygons) into the smallest square bounding box for N=1 to N=200 trees. 
Score = Σ(side_length² / N) for all N. **Lower is better.**

## Current Status
- **Best Score**: 70.676102 (from pre-optimized santa-2025.csv)
- **Target Score**: 68.894234
- **Gap**: 1.78 points (2.6%)
- **CRITICAL**: The pre-optimized submission is at a very tight local optimum - standard short optimization runs cannot escape it.

## Pre-optimized Resources Available
Located at `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`:
- `santa-2025.csv` - Best known submission (70.676102)
- `bbox3` - Compiled C++ optimizer binary
- `bucket-of-chump/` - Additional optimized configurations
- `santa25-public/` - Public shared solutions
- `telegram/` - Telegram shared solutions

## Tree Geometry (15 vertices)
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```
- Tree height: 1.0 (from -0.2 to 0.8)
- Tree width: 0.7 (base tier)
- Trunk: 0.15 wide, 0.2 tall

## Key Optimization Approaches from Kernels

### 1. bbox3.cpp (jazivxt/why-not)
C++ optimizer with advanced techniques:
- Complex Number Vector Coordination
- Fluid Dynamics simulation
- Hinge Pivot moves
- Density Gradient Flow
- Global Boundary Tension
- Aggressive overlap repair
- Parameters: `-n <iterations>` `-r <rounds>`
- Uses OpenMP for parallelization

### 2. tree_packer_v21.cpp (smartmanoj/santa-claude)
C++ optimizer with:
- Swap move operator (exchange positions of two trees)
- Multi-angle restarts
- Higher temperature Simulated Annealing
- Squeeze, compaction, localSearch phases
- Backward propagation (bp.cpp) - removes trees from larger N configs to improve smaller N
- Parameters: `-n <iterations>` `-r <rounds>`

### 3. Ensemble Approach (jonathanchan)
- Collect best configuration for each N from multiple sources
- Sources: bucket-of-chump, SmartManoj GitHub, santa-2025-try3, santa25-public, telegram
- For N=1: optimal angle is 45 degrees (minimizes bounding box)
- Fractional translation: find translations shorter than box length

### 4. Fractional Translation
Micro-adjust tree positions at step sizes [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001] in 8 directions. Moves trees toward center to minimize bounding box while avoiding overlaps.

### 5. Backward Propagation
Start from N=200, work down to N=2. For each N, try removing each tree. If resulting (N-1) config has smaller bounding box than stored (N-1) config, save it.

## Scoring Function
```python
def get_score(trees, n):
    xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])
    side = max(xys.max(axis=0) - xys.min(axis=0))
    return side**2 / n
```

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s45.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- id: `{n:03d}_{tree_index}` (e.g., 001_0, 002_0, 002_1)
- x, y, deg: prefixed with 's' to preserve precision
- Total rows: 20100 (1+2+3+...+200)
- Coordinates must be within [-100, 100]

## Overlap Detection
```python
from shapely.strtree import STRtree

def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

## CRITICAL INSIGHTS FROM PREVIOUS EXPERIMENTS

### What DOESN'T Work:
1. **Short optimization runs** - The local optimum is too tight
2. **Simple ensemble** - santa-2025.csv already dominates all N values
3. **Backward propagation alone** - Only helps if larger N configs have better sub-configurations
4. **Micro-optimization** - Running same optimizers on same starting point won't close the 1.78 point gap
5. **12 experiments with SA/C++ optimizer = ALL SAME SCORE** - Pre-optimized baselines are at LOCAL OPTIMUM

### What MIGHT Work (Strategies to Beat Target):

#### 1. **MUCH LONGER OPTIMIZATION RUNS (CRITICAL)**
- Top solutions run for HOURS, not minutes
- jonathanchan kernel: `-n 15000` iterations, `-r 80` rounds
- Multiple generations with perturbation to escape local optima
- Run bbox3 with: `-n 100000 -r 512` (overnight)

#### 2. **LATTICE/GRID-BASED APPROACH FOR LARGE N (N >= 58)**
The egortrushin kernel uses a fundamentally different approach:
- Start with 2 base trees in specific configuration
- Translate them in x and y directions to create grid pattern
- Parameters: `nt = [nx, ny]` where nx*ny = N
- Optimize base configuration and translation vectors
- Can achieve tighter bounds than random optimization for large N

**Implementation:**
```python
# For N >= 58, try crystalline packing
# Start with 2 base trees, translate to create grid
# nt = [rows, cols] such that rows * cols >= N
# Optimize the base configuration and translation vectors
```

#### 3. **FOCUS ON SMALL N VALUES (1-10)**
- N=1 contributes 0.66 to score (highest single contribution)
- Small N values have lowest efficiency (1.5-2.6 trees/unit area)
- Try exhaustive search for optimal rotation angles
- For N=1: optimal angle is 45 degrees

#### 4. **ASYMMETRIC SOLUTIONS**
- Discussion "Why the winning solutions will be Asymmetric" (38 votes) suggests asymmetric layouts outperform symmetric for large N
- Try breaking symmetry in optimized configurations
- Symmetric solutions may be optimal for small N but asymmetric for large N

#### 5. **PERTURBATION TO ESCAPE LOCAL OPTIMA**
- Randomly perturb best solution to escape local optima
- sa_v1_parallel includes: `perturb(pop[0].second, 0.1 + 0.05 * (r % 3), seed)`
- Try larger perturbations (0.2-0.5) to escape deeper local optima

#### 6. **CONSTRUCTIVE APPROACHES (NOT LOCAL SEARCH)**
- Greedy backtracking with beam search
- Build solutions tree-by-tree from scratch
- Random initialization + optimization (not from pre-optimized CSV)

## Recommended Experiment Strategy

### Phase 1: Establish Baseline (FIRST EXPERIMENT)
1. Copy best pre-optimized submission (santa-2025.csv)
2. Verify score matches 70.676102
3. Submit to confirm LB score

### Phase 2: Extended Optimization (HOURS, NOT MINUTES)
1. Run bbox3 with much longer parameters: `-n 100000 -r 512`
2. Run tree_packer_v21 with: `-n 50000 -r 256`
3. Apply backward propagation after each run
4. Run overnight if possible

### Phase 3: Alternative Approaches (KEY TO BEATING TARGET)
1. **Implement lattice-based approach for N >= 58**
2. Focus optimization on worst-performing N values
3. Try asymmetric perturbations
4. Build new solutions from scratch for specific N values

### Phase 4: Ensemble
1. Collect results from all optimization runs
2. For each N, keep configuration with smallest bounding box
3. Validate for overlaps before submission

## Validation Checklist
1. No overlapping trees (use has_overlap function)
2. All coordinates within [-100, 100]
3. All 200 configurations present (20100 rows)
4. Values prefixed with 's' in submission

## Key Files to Use
- Pre-optimized: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/santa-2025.csv`
- bbox3 binary: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/bbox3`
- Kernel code: `../research/kernels/` (jazivxt_why-not, smartmanoj_santa-claude, jonathanchan)
- Backward prop: `/home/nonroot/snapshots/santa-2025/21116303805/code/experiments/005_backward_propagation/backward_prop.py`
- Fractional translation: `/home/nonroot/snapshots/santa-2025/21116303805/code/experiments/004_sa_v1_parallel/fractional_translation.py`

## Time Budget
- Kaggle notebooks: ~12 hour limit
- bbox3 with `-n 10000 -r 64`: ~1-2 hours
- bbox3 with `-n 100000 -r 512`: ~10+ hours
- Plan for multiple optimization passes
- Submit best result before time runs out

## Per-N Score Analysis (from state.json)
- N=1: contributes 0.66 to score (highest single contribution)
- Small N (1-10): lowest efficiency (1.5-2.6 trees/unit area)
- Large N (100+): higher efficiency (3.0+ trees/unit area)
- Focus improvements on small N for maximum impact

## MICRO-OPTIMIZATION = WASTED EXPERIMENTS!
The gap of 1.78 points requires FUNDAMENTALLY DIFFERENT approaches, not incremental improvements. Focus on:
1. Lattice-based packing for large N
2. Much longer optimization runs
3. Asymmetric solutions
4. Constructive approaches from scratch
