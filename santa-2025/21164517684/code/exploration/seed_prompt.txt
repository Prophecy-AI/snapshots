# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
Pack 1-200 Christmas tree shapes into the smallest square bounding box for each N.
- Score = sum(s_n^2/n) for n=1 to 200, where s_n is the side length of the bounding box
- Lower score is better
- Target: 68.919154

## Tree Shape
15-vertex polygon:
- Tip at (0, 0.8), trunk bottom at (0, -0.2)
- Width: 0.7 at base, 0.4 mid, 0.25 top
- Trunk: 0.15 wide, 0.2 tall
- Total height: 1.0

## Submission Format
CSV with columns: id, x, y, deg
- id format: NNN_T (e.g., "001_0" for N=1, tree 0)
- Values prefixed with 's' (e.g., "s0.123456")
- Coordinates must be in range [-100, 100]

## Pre-Optimized Solutions Available
Located in `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`:
- `santa-2025.csv` - Best single source (~70.68 score)
- `santa25-public/` - Multiple versions (v61-v76)
- `telegram/` - Solutions at 71.97 and 72.49
- `bbox3` - Pre-compiled optimizer binary

## Key Optimization Techniques

### 1. C++ Optimizer (tree_packer_v21) - HIGHEST PRIORITY
From `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`:
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer_v21.exe a.cpp
./tree_packer_v21.exe -n 20000 -r 256
```
Key operations:
- Squeeze: Scale all trees toward center
- Compaction: Move trees toward center in small steps
- Local search: Try small moves in 8 directions + rotations
- Simulated annealing: Accept worse moves with decreasing probability
- Swap moves: Exchange positions of two trees
- Multi-start: Try different initial angles

### 2. bbox3 Binary Optimizer
From `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`:
```bash
./bbox3 -n 2000 -r 96
```
Multi-phase approach:
- Phase A: Short 2-min runs to find promising (n,r) parameters
- Phase B: 10-min medium runs on top candidates
- Phase C: 20-min long runs on best few

### 3. Rotation Tightening (fix_direction)
After placing trees, rotate entire configuration to minimize bounding box:
- Use convex hull of all tree vertices
- Optimize rotation angle 0-90 degrees using scipy.minimize_scalar
- Can improve score significantly

### 4. Backward Propagation
Start from N=200, work down to N=2:
- For each N, try removing each boundary-touching tree
- If resulting (N-1) config is better than stored, save it
- Greedy deletion of trees that reduce bounding box most

### 5. Ensemble Approach
Collect best configurations from multiple sources:
- Public kernels and datasets
- Multiple optimization runs with different seeds
- Select best configuration per N value

## Recommended Workflow

### Step 1: Start from Pre-Optimized Solution
```python
# Copy best available solution
import shutil
shutil.copy('/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/santa-2025.csv', 'submission.csv')
```

### Step 2: Compile and Run C++ Optimizer
```bash
# Compile tree_packer_v21
g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer_v21.exe tree_packer_v21.cpp

# Run with high iterations (use all available threads)
export OMP_NUM_THREADS=$(nproc)
./tree_packer_v21.exe -n 20000 -r 256
```

### Step 3: Apply Backward Propagation
```bash
g++ -O3 -std=c++17 -o bp.exe bp.cpp
./bp.exe submission.csv submission.csv
```

### Step 4: Iterate
Run tree_packer → backward_propagation → tree_packer loop until convergence.

### Step 5: Ensemble Best Configurations
For each N, select the configuration with smallest bounding box from all runs.

## Critical Implementation Notes

### Overlap Detection
- Use ZERO tolerance for overlaps
- Check: `poly_i.intersects(poly_j) and not poly_i.touches(poly_j)`
- Kaggle rejects submissions with ANY overlap

### Precision
- Use `long double` in C++ for maximum precision
- Use `Decimal` in Python with precision >= 30
- Values prefixed with 's' in submission CSV

### Validation Before Submission
```python
from shapely.geometry import Polygon
from shapely.ops import unary_union

def validate_no_overlaps(trees):
    for i in range(len(trees)):
        for j in range(i+1, len(trees)):
            if trees[i].intersects(trees[j]) and not trees[i].touches(trees[j]):
                return False
    return True
```

## Score Breakdown by N
- N=1 to 10: ~0.5-1.0 each (highest impact due to 1/n weighting)
- N=11 to 50: ~0.3-0.5 each
- N=51 to 100: ~0.25-0.35 each
- N=101 to 200: ~0.2-0.3 each
- **Focus optimization effort on smaller N values for maximum impact**

## What NOT to Try
- Python-based optimization (too slow for competitive results)
- Short optimization runs (need hours, not minutes)
- Lenient overlap thresholds (Kaggle uses strict validation)
- Single random seed (use multiple starts)

## Expected Progression
1. Pre-optimized baseline: ~70.68
2. After tree_packer optimization: ~69-70
3. After backward propagation: ~68.5-69
4. After ensemble + long runs: Target ~68.92

## Key Insight from Past Experiments
The pre-optimized santa-2025.csv is already at a tight local optimum. Standard optimization approaches (short SA runs, simple local search) cannot improve it. Need:
1. Much longer optimization runs (hours, not minutes)
2. Lattice-based approaches for large N
3. Ensemble from multiple independent optimization runs
4. Focus on small N values (highest score contribution)

## Discussion Insights
- Symmetric solutions may be optimal for some N values
- Asymmetric solutions often beat symmetric for large N
- Tessellation/lattice patterns work well for N >= 58
- Small N (1-10) contribute most to score - focus here first
