# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
Pack Christmas tree-shaped polygons (15 vertices each) into the smallest possible square bounding box for N=1 to N=200 trees. Score = sum of (side_length^2 / N) for all N values. Lower is better.

**Target Score: 68.889699** (current best ~70.647)
**Gap to close: ~1.76 points (2.5%)**

## Tree Geometry (CRITICAL - Must Match Exactly)
```python
# 15-vertex Christmas tree polygon
TRUNK_W = 0.15, TRUNK_H = 0.2
BASE_W = 0.7, MID_W = 0.4, TOP_W = 0.25
TIP_Y = 0.8, TIER_1_Y = 0.5, TIER_2_Y = 0.25, BASE_Y = 0.0
TRUNK_BOTTOM_Y = -0.2

# Vertices (counterclockwise from tip):
vertices = [
    (0.0, 0.8),           # Tip
    (0.125, 0.5),         # Right top tier
    (0.0625, 0.5),
    (0.2, 0.25),          # Right mid tier
    (0.1, 0.25),
    (0.35, 0.0),          # Right base
    (0.075, 0.0),         # Right trunk
    (0.075, -0.2),
    (-0.075, -0.2),       # Left trunk
    (-0.075, 0.0),
    (-0.35, 0.0),         # Left base
    (-0.1, 0.25),         # Left mid tier
    (-0.2, 0.25),
    (-0.0625, 0.5),       # Left top tier
    (-0.125, 0.5),
]
```

## ⛔ BLOCKED AFTER BASELINE (exp_000)
After getting baseline score, the following are PERMANENTLY FORBIDDEN:
- Running bbox3, sa_fast_v2, eazy_optimizer, or ANY pre-compiled binary
- "More iterations" or "different parameters" on existing optimizers
- Ensembling outputs from the same optimizer

## ✅ REQUIRED: IMPLEMENT FROM SCRATCH
All experiments after baseline MUST implement a novel algorithm:
1. **Tessellation/Lattice Packing** - 2 base trees translated in grid pattern (HIGHEST PRIORITY)
2. **No-Fit Polygon (NFP)** - precompute collision-free regions in Python
3. **Branch-and-bound** - exhaustive search for small N (N<=15)
4. **Genetic algorithm** - evolve population with custom operators
5. **Deletion Cascade** - propagate improvements from large N to small N

DO NOT USE PRE-COMPILED BINARIES. IMPLEMENT THE ALGORITHM.

## Key Approaches from Research

### 1. TESSELLATION APPROACH (HIGHEST PRIORITY for N >= 20)
From jiweiliu kernel - achieves ~0.15 improvement in 2 minutes:

```python
# Core idea: 2 base trees + grid translation
# For N trees, use ncols x nrows grid where 2*ncols*nrows ≈ N

# Initial 2-tree seed configuration (optimized values)
initial_seeds = [
    (-4.191683864412409, -4.498489528496051, 74.54421568660419),
    (-4.92202045352307, -4.727639556649786, 254.5401905706735),
]

# Translation vectors
a_init = 0.8744896974945239  # x-direction step
b_init = 0.7499641699190263  # y-direction step

# Grid generation:
# For each (i, j) in grid:
#   tree1 = seed[0] + i*a + j*b
#   tree2 = seed[1] + i*a + j*b
```

**SA Parameters for tessellation:**
- Tmax: 0.001, Tmin: 0.000001
- nsteps: 10, nsteps_per_T: 10000
- position_delta: 0.002, angle_delta: 1.0
- delta_t: 0.002 (translation step)

### 2. DELETION CASCADE (Propagate improvements)
After optimizing large N, propagate to smaller N:
```python
for n in range(200, 1, -1):
    for tree_to_remove in range(n):
        candidate = remove_tree(config[n], tree_to_remove)
        if score(candidate) < score(config[n-1]):
            config[n-1] = candidate
```

### 3. SMALL N OPTIMIZATION (N <= 15)
Small N values contribute most to score:
- N=1: contributes 0.66 (optimal at 45 degrees, side=0.8132)
- N=2-10: Low efficiency (37-65%), high score contribution

For small N, try:
- Exhaustive angle search (0.001 degree increments)
- Branch-and-bound placement
- All permutations of tree orderings

### 4. FRACTIONAL TRANSLATION (Fine-tuning)
From jonathanchan kernel - squeeze out small improvements:
```python
steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]
directions = [(1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,-1), (1,-1), (-1,1)]
# Try moving each tree by step in each direction
```

### 5. ROTATION TIGHTENING (fix_direction)
After placement, optimize global rotation to minimize bounding box:
```python
from scipy.optimize import minimize_scalar
# Find angle that minimizes max(width, height) of convex hull
```

## Collision Detection (CRITICAL for validity)
```python
@njit
def polygons_overlap(v1, v2):
    """Check if two 15-vertex polygons overlap."""
    # 1. Quick bounding box check
    # 2. Point-in-polygon for all vertices
    # 3. Edge-edge intersection check
    # Return True if ANY overlap (not just touching)
```

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s45.0
002_0,s0.154097,s-0.038540,s203.629377
002_1,s-0.541068,s0.259317,s51.66348
```
- Prepend 's' to all numeric values
- Use high precision (15+ decimal places)
- Coordinates must be in [-100, 100]

## Validation Requirements
1. NO overlapping trees (Kaggle rejects overlaps)
2. Use Decimal arithmetic for precision
3. Validate before submission with overlap check

## Score Calculation
```python
def calculate_score(trees_by_n):
    total = 0
    for n, trees in trees_by_n.items():
        bounds = get_bounding_box(trees)
        side = max(bounds.width, bounds.height)
        total += (side ** 2) / n
    return total
```

## Recommended Experiment Sequence

### exp_000: Baseline
- Load best pre-optimized submission from snapshots
- Verify score matches expected ~70.647
- DO NOT run any optimizer

### exp_001: Implement Tessellation from Scratch
- Implement 2-tree seed + grid translation
- Use Numba for acceleration
- Target N >= 20 configurations
- Expected improvement: 0.1-0.3 points

### exp_002: Deletion Cascade
- Propagate tessellation improvements to smaller N
- Work backwards from N=200 to N=2
- Expected improvement: 0.05-0.1 points

### exp_003: Small N Exhaustive Search
- For N=2 to N=15, try exhaustive placement
- Branch-and-bound with pruning
- Expected improvement: 0.05-0.1 points

### exp_004: Fractional Translation Fine-tuning
- Apply micro-adjustments to all trees
- Use 8-direction search with decreasing step sizes
- Expected improvement: 0.01-0.05 points

## Key Insights from Previous Attempts

1. **Pre-optimized solutions are at tight local optima** - Standard SA cannot improve them
2. **Tessellation is fundamentally different** - Exploits periodicity, not local search
3. **Small N matters most** - N=1-10 contribute ~30% of total score
4. **Precision is critical** - Use 20+ decimal places, Decimal arithmetic
5. **CV = LB exactly** - Local scoring is 100% accurate

## Files and Resources
- Best pre-optimized: Check /home/nonroot/snapshots/santa-2025/*/
- Tree geometry: ../research/kernels/inversion_santa-2025-getting-started/
- Tessellation code: /home/nonroot/snapshots/santa-2025/21165872902/code/jiweiliu_optimizer.py
- bbox3 runner: ../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/

## What DOESN'T Work (Avoid These)
- Running bbox3/sa_fast with more iterations (local optima)
- Simple ensemble of same-source files (one dominates all N)
- fix_direction without overlap repair (causes precision issues)
- Short optimization runs (need hours, not minutes)

## Target Breakdown
- Current: ~70.647
- Target: 68.889699
- Gap: 1.76 points
- Need ~2.5% improvement across all N values
- Focus on: Tessellation for large N, exhaustive for small N
