# Seed Prompt: Santa 2025 Tree Packing

## Problem Definition
- **Goal**: Pack $N$ identical Christmas trees (irregular 2D polygons) into the smallest square box for each $N \in [1, 200]$.
- **Metric**: Minimize $\sum_{n=1}^{200} \frac{s_n^2}{n}$, where $s_n$ is the side of the bounding square.
- **Constraints**: No overlap. Coordinates in $[-100, 100]$.
- **Independence**: Each $N$ is an independent problem, but solutions for $N$ and $N-1$ are often related.

## Tree Geometry
- Defined in `inversion/santa-2025-getting-started`.
- 15-vertex polygon.
- Rotatable.

## Winning Strategy: C++ Optimization Engine
The top kernels (`smartmanoj/santa-claude`, `jazivxt/why-not`) use a C++ solver embedded in the notebook. This is **MANDATORY** for competitive performance.

### Core Components (from `smartmanoj/santa-claude`):
1.  **Simulated Annealing (SA)**:
    - Perturb positions $(x, y)$ and rotation $\theta$.
    - Use temperature schedule to escape local optima.
    - **Moves**: Translation, Rotation, Swap (swapping positions of two trees).
2.  **Physics-Based Compaction**:
    - "Squeeze" function: Linearly scale coordinates towards center until overlap.
    - "Compaction" function: Move trees towards center with small steps, resolving overlaps.
    - **Separation Vectors**: Calculate vector to resolve overlap (approximate MTV).
3.  **Backward Propagation (BP)**:
    - **Concept**: A good packing for $N$ often contains a good packing for $N-1$.
    - **Algorithm**: Take best solution for $N$. Try removing each tree $i$. If the remaining $N-1$ trees (after re-compacting) give a better score for $N-1$ than currently known, update $N-1$.
    - **Iterative Loop**: Run Solver $\rightarrow$ Run BP $\rightarrow$ Repeat.

### Lattice / Crystallization
- For large $N$ ($>50$), optimal packings form a **lattice structure**.
- **Pattern**: Alternating "Blue" (upward, $0^\circ \pm 90^\circ$) and "Pink" (downward, $180^\circ \pm 90^\circ$) trees.
- **Initialization**: Consider initializing large $N$ with a hexagonal or square lattice of alternating orientations.

## Recommended Experiments
1.  **Implement C++ Solver**:
    - Copy `tree_packer_v21.cpp` and `bp.cpp` from `smartmanoj/santa-claude`.
    - Compile with `-O3 -march=native -fopenmp`.
    - Run with multiple threads (one per $N$ or parallel restarts).
2.  **Refine Backward Propagation**:
    - Extend BP to try removing *two* trees (to jump from $N$ to $N-2$).
    - Try "Forward Propagation": Insert a tree into best $N$ to seed $N+1$.
3.  **Lattice Initialization**:
    - Create a generator for "perfect" lattice packings.
    - Use these as starting points for the SA solver for $N > 100$.
4.  **No-Fit Polygon (NFP)**:
    - The current solver uses point-in-polygon and segment intersection.
    - Pre-computing NFP might speed up overlap checks, but rotation makes it complex. Sticking to fast intersection tests is likely better for continuous rotation.

## Validation
- **Exact Overlap Check**: Use `shapely` in Python for final validation, but C++ `segInt` is sufficient for the solver.
- **Visual Inspection**: Plot large $N$ solutions to check for "crystallization" defects.

## Notebook References
- `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`: **GOLD STANDARD**. Contains `tree_packer_v21.cpp` and `bp.cpp`.
- `../research/kernels/jazivxt_why-not/why-not.ipynb`: Contains `bbox3.cpp` (alternative physics solver) and lattice analysis code.
- `../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb`: Basic geometry and visualization.
