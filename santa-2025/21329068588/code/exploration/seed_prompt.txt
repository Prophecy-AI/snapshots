# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree toys (1-200 trees per configuration) into the smallest possible square bounding box.

**Scoring Formula:** score = Σ(s_n²/n) for n=1 to 200, where s_n is the side length of the bounding square for n trees.
**Target Score:** 68.894234 (lower is better)
**Best Achieved:** ~70.647 (gap of ~1.75 points, 2.5%)

## Tree Geometry
The Christmas tree is a 15-vertex polygon with:
- Trunk: width=0.15, height=0.2
- Three tiers of branches (base_w=0.7, mid_w=0.4, top_w=0.25)
- Tip at y=0.8, base at y=0
- Total height: 1.0 (from trunk bottom at -0.2 to tip at 0.8)

Vertices (TX, TY):
```
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## Key Insights from Previous Work

### 1. N=1 is Already Optimal
- Optimal angle: 45 degrees (minimizes bounding box)
- Side length: 0.8132, contributes 0.6612 to score
- No further improvement possible for N=1

### 2. Small N Values (1-15) Have Lowest Packing Efficiency
- Efficiency ranges from 37-65% vs 70%+ for large N
- These contribute most to the total score
- Focus optimization effort here for maximum impact

### 3. Tessellation/Lattice Approach for Large N (N >= 58)
The egortrushin kernel uses a fundamentally different approach:
- Start with 2 base trees in a specific configuration
- Translate them in x and y directions to create a grid pattern
- Use SA to optimize the base configuration and translation vectors
- Target N values: 72, 100, 110, 144, 156, 196, 200
- This generates crystalline/lattice packings that can be tighter than random optimization

### 4. Fractional Translation Optimization
The jonathanchan kernel uses fine-grained translation steps:
- Steps: [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]
- 8 directions for each step
- Combined with SA and local search

### 5. Backward Propagation
Start from N=200, work down to N=2:
- For each N, try removing each tree
- If resulting (N-1) config is better than stored, save it
- Can find better configurations for smaller N values

### 6. Precision is Critical
- Use Decimal arithmetic with 20+ decimal places
- Submissions with 15 decimal places may fail validation
- Kaggle rejects overlapping trees - precision loss causes false overlaps

## Recommended Approaches (Priority Order)

### 1. [HIGHEST PRIORITY] Implement Tessellation for Large N
```python
# For N >= 58, try crystalline packing
# Start with 2 base trees, translate to create grid
# nt = [rows, cols] such that rows * cols >= N
# Optimize the base configuration and translation vectors
```

### 2. [HIGH PRIORITY] Long-Running Simulated Annealing
Top solutions run for HOURS, not minutes:
- `-n 15000+` iterations
- `-r 80+` rounds
- Multiple generations with perturbation to escape local optima

### 3. [HIGH PRIORITY] Focus on Small N Values (1-20)
- Exhaustive search for optimal rotation angles
- Try all 360 degrees in 0.001 increments
- These have highest score contribution per tree

### 4. [MEDIUM PRIORITY] C++ Optimizers
Available optimizers:
- bbox3.cpp: Complex number geometry, global squeeze, overlap repair
- sa_v1_parallel: Simulated annealing with fractional translation
- tree_packer_v18/v21: Tree packing optimizers

### 5. [MEDIUM PRIORITY] Ensemble from Multiple Sources
- Combine best configurations from different approaches
- For each N, take the configuration with smallest bounding box
- Validate for overlaps before combining

## Technical Implementation Notes

### Overlap Detection
```python
# Use Shapely for polygon operations
from shapely.geometry import Polygon
from shapely.strtree import STRtree

# Check if two polygons overlap (not just touch)
def overlaps(poly1, poly2):
    return poly1.intersects(poly2) and not poly1.touches(poly2)
```

### Scoring Function
```python
def calculate_score(submission_df):
    total_score = 0
    for n in range(1, 201):
        trees = get_trees_for_n(submission_df, n)
        side = get_bounding_box_side(trees)
        total_score += (side ** 2) / n
    return total_score
```

### Submission Format
- id: NNN_i (NNN = number of trees, i = tree index)
- x, y: coordinates with 's' prefix (e.g., "s0.123456")
- deg: rotation angle with 's' prefix
- Coordinates must be in range [-100, 100]

## What NOT to Try
- Simple ensemble (one source often dominates all N values)
- Short optimization runs (local optimum is too tight)
- fix_direction post-processing (causes precision loss and overlaps)
- Low-precision coordinates (use 20+ decimal places)

## Pre-Optimized Solutions
Check `/home/nonroot/snapshots/santa-2025/` for pre-optimized submissions.
Best known score: ~70.647 from snapshot analysis.

## Academic Approaches to Consider
From web research on 2D irregular polygon packing:
1. **No-Fit Polygon (NFP)**: Precompute NFPs for O(1) overlap checks
2. **Bottom-Left Heuristics**: Fast initial placement
3. **Simulated Annealing**: Global optimization with temperature schedule
4. **Genetic Algorithms**: Population-based optimization with crossover
5. **Mixed Integer Programming**: Exact solutions for small instances

## Validation Checklist
Before submitting:
1. Check for overlaps in ALL N configurations
2. Verify coordinate precision (20+ decimal places)
3. Ensure coordinates are in [-100, 100] range
4. Verify 's' prefix on all values
5. Calculate local score to verify improvement

## Key Kernels to Reference
- `../research/kernels/inversion_santa-2025-getting-started/`: Basic greedy algorithm
- `../research/kernels/jazivxt_why-not/`: bbox3.cpp optimizer
- `../research/kernels/smartmanoj_santa-claude/`: Claude-assisted optimization
- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`: Multi-phase optimization

## Gap Analysis
- Current best: ~70.647
- Target: 68.894234
- Gap: 1.75 points (2.5%)
- Need to improve packing efficiency from 69.5% to 71.3%
- Theoretical minimum (perfect packing): ~49.125
