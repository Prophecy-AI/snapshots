# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree toys (1-200 trees per configuration) into the smallest possible square bounding box.

**Scoring Formula:** score = Σ(s_n²/n) for n=1 to 200, where s_n is the side length of the bounding square for n trees.
**Target Score:** 68.894234 (lower is better)
**Best Achieved:** ~70.647 (gap of ~1.75 points, 2.5%)
**Best Pre-optimized:** `/home/nonroot/snapshots/santa-2025/21328309254/code/submission.csv` (score: 70.647327)

## Tree Geometry
The Christmas tree is a 15-vertex polygon with:
- Trunk: width=0.15, height=0.2
- Three tiers of branches (base_w=0.7, mid_w=0.4, top_w=0.25)
- Tip at y=0.8, base at y=0
- Total height: 1.0 (from trunk bottom at -0.2 to tip at 0.8)

Vertices (TX, TY):
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## Insights from Discussions (MANDATORY)

### Discussion "Why the winning solutions will be Asymmetric" (38 votes)
- Asymmetric solutions outperform symmetric/lattice solutions for most N values
- The tree shape has no rotational symmetry, so optimal packings are inherently asymmetric
- For large N, tessellation helps but still needs asymmetric fine-tuning

### Discussion "Expected Leaderboard Progression" (20 votes)
- Top scores expected to converge around 68.9-69.0 range
- Diminishing returns after extensive optimization
- Focus on N values with highest score contribution

### Discussion "Where do these high-scoring CSVs originate from?" (12 votes)
- Best solutions come from long-running C++ optimizers
- Telegram groups share optimized solutions
- Ensemble of multiple sources is key strategy

## What Discussions Say DOESN'T Work
- Short optimization runs (minutes) - local optimum is too tight
- Simple greedy placement - needs global optimization
- Low-precision coordinates - causes false overlap detection
- fix_direction post-processing - causes precision loss

## Unexplored Ideas from Discussions
- Hybrid tessellation + local search for medium N (30-60)
- Genetic algorithms with custom crossover operators for tree configurations
- No-Fit Polygon (NFP) precomputation for faster overlap checks

## Key Insights from Previous Work

### 1. N=1 is Already Optimal
- Optimal angle: 45 degrees (minimizes bounding box)
- Side length: 0.8132, contributes 0.6612 to score
- No further improvement possible for N=1

### 2. Small N Values (1-15) Have Lowest Packing Efficiency
- Efficiency ranges from 37-65% vs 70%+ for large N
- These contribute most to the total score
- Focus optimization effort here for maximum impact

### 3. Tessellation/Lattice Approach for Large N (N >= 58)
The egortrushin kernel uses a fundamentally different approach:
- Start with 2 base trees in a specific configuration
- Translate them in x and y directions to create a grid pattern
- Use SA to optimize the base configuration and translation vectors
- Target N values: 72, 100, 110, 144, 156, 196, 200
- This generates crystalline/lattice packings that can be tighter than random optimization

### 4. Fractional Translation Optimization
The jonathanchan kernel uses fine-grained translation steps:
- Steps: [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]
- 8 directions for each step
- Combined with SA and local search

### 5. Backward Propagation
Start from N=200, work down to N=2:
- For each N, try removing each tree
- If resulting (N-1) config is better than stored, save it
- Can find better configurations for smaller N values

### 6. Precision is Critical
- Use Decimal arithmetic with 20+ decimal places
- Submissions with 15 decimal places may fail validation
- Kaggle rejects overlapping trees - precision loss causes false overlaps

### 7. Well-Aligned Initial Solution
From zaburo kernel (score ~88.33 as starting point):
- Pack trees in rows with alternating orientations (0 and 180 degrees)
- Use spacing of 0.7 (base width) between trees in a row
- Alternate rows have x_offset of 0.35 (half base width)
- Creates a brick-like pattern for initial placement

## Recommended Approaches (Priority Order)

### 1. [HIGHEST PRIORITY] Implement Tessellation for Large N
```python
# For N >= 58, try crystalline packing
# Start with 2 base trees, translate to create grid
# nt = [rows, cols] such that rows * cols >= N
# Optimize the base configuration and translation vectors
```

### 2. [HIGH PRIORITY] Long-Running Simulated Annealing
Top solutions run for HOURS, not minutes:
- `-n 15000+` iterations
- `-r 80+` rounds
- Multiple generations with perturbation to escape local optima
- Use C++ for speed (bbox3.cpp, sa_v1_parallel)

### 3. [HIGH PRIORITY] Focus on Small N Values (1-20)
- Exhaustive search for optimal rotation angles
- Try all 360 degrees in 0.001 increments
- These have highest score contribution per tree

### 4. [MEDIUM PRIORITY] C++ Optimizers
Available optimizers from kernels:
- bbox3.cpp: Complex number geometry, global squeeze, overlap repair
- sa_v1_parallel: Simulated annealing with fractional translation
- tree_packer_v18/v21: Tree packing optimizers

### 5. [MEDIUM PRIORITY] Ensemble from Multiple Sources
- Combine best configurations from different approaches
- For each N, take the configuration with smallest bounding box
- Validate for overlaps before combining
- Sources: Telegram groups, GitHub repos, Kaggle datasets

## Technical Implementation Notes

### Overlap Detection
```python
# Use Shapely for polygon operations
from shapely.geometry import Polygon
from shapely.strtree import STRtree

# Check if two polygons overlap (not just touch)
def overlaps(poly1, poly2):
    return poly1.intersects(poly2) and not poly1.touches(poly2)
```

### Scoring Function (Numba-optimized)
```python
from numba import njit
import math
import numpy as np

TX = np.array([0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125])
TY = np.array([0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5])

@njit
def score_group(xs, ys, degs, tx, ty):
    n = xs.size
    V = tx.size
    mnx = mny = 1e300
    mxx = mxy = -1e300
    for i in range(n):
        r = degs[i] * math.pi / 180.0
        c, s = math.cos(r), math.sin(r)
        for j in range(V):
            X = c * tx[j] - s * ty[j] + xs[i]
            Y = s * tx[j] + c * ty[j] + ys[i]
            mnx, mxx = min(mnx, X), max(mxx, X)
            mny, mxy = min(mny, Y), max(mxy, Y)
    side = max(mxx - mnx, mxy - mny)
    return side * side / n
```

### Submission Format
- id: NNN_i (NNN = number of trees, i = tree index)
- x, y: coordinates with 's' prefix (e.g., "s0.123456789012345678901")
- deg: rotation angle with 's' prefix
- Coordinates must be in range [-100, 100]
- Use 20+ decimal places for precision

## What NOT to Try
- Simple ensemble (one source often dominates all N values)
- Short optimization runs (local optimum is too tight)
- fix_direction post-processing (causes precision loss and overlaps)
- Low-precision coordinates (use 20+ decimal places)
- Random restarts without perturbation strategy

## Pre-Optimized Solutions
Check `/home/nonroot/snapshots/santa-2025/` for pre-optimized submissions.
Best known: `/home/nonroot/snapshots/santa-2025/21328309254/code/submission.csv` (score: 70.647327)

## Academic Approaches to Consider
From web research on 2D irregular polygon packing:
1. **No-Fit Polygon (NFP)**: Precompute NFPs for O(1) overlap checks
2. **Bottom-Left Heuristics**: Fast initial placement
3. **Simulated Annealing**: Global optimization with temperature schedule
4. **Genetic Algorithms**: Population-based optimization with crossover
5. **Mixed Integer Programming**: Exact solutions for small instances

## Validation Checklist
Before submitting:
1. Check for overlaps in ALL N configurations (1-200)
2. Verify coordinate precision (20+ decimal places)
3. Ensure coordinates are in [-100, 100] range
4. Verify 's' prefix on all values
5. Calculate local score to verify improvement
6. Compare against best known score for each N

## Key Kernels to Reference
- `../research/kernels/inversion_santa-2025-getting-started/`: Basic greedy algorithm, tree geometry
- `../research/kernels/jazivxt_why-not/`: bbox3.cpp optimizer with global squeeze
- `../research/kernels/smartmanoj_santa-claude/`: Claude-assisted optimization
- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`: Multi-phase optimization
- `../research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation/`: Ensemble + fractional translation
- `../research/kernels/zaburo_88-32999-a-well-aligned-initial-solution/`: Well-aligned initial solution

## Gap Analysis
- Current best: 70.647327
- Target: 68.894234
- Gap: 1.753 points (2.5%)
- Need to improve packing efficiency from 69.5% to 71.3%
- Theoretical minimum (perfect packing): ~49.125

## Strategy for Beating Target
1. Start with best pre-optimized solution from snapshots (70.647)
2. Run long C++ optimization (hours, not minutes) with bbox3 or sa_v1_parallel
3. Focus on N values with largest gaps to theoretical optimum
4. Try tessellation for large N (100+) - this is underexplored
5. Ensemble best results from multiple approaches
6. Validate thoroughly before each submission
7. Consider hybrid approaches: tessellation + local search
