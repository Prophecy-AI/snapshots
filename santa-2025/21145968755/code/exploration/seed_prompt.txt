# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D geometric packing optimization problem:
- Pack Christmas tree-shaped polygons (N=1 to 200 trees) into the smallest square bounding box
- Score = Σ(side_n²/n) for n=1 to 200 (lower is better)
- Target score: 68.919154
- Best pre-optimized baseline: ~70.676

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Tip at (0, 0.8)
- Three tiers of branches at y=0.5, 0.25, 0
- Trunk from y=0 to y=-0.2, width 0.15
- Base width 0.7, mid width 0.4, top width 0.25
- Trees can be rotated (angle in degrees) and positioned (x, y coordinates)

## CRITICAL INSIGHT: Pre-optimized Solutions are at Local Optimum
Previous experiments have shown:
- Simulated annealing: 0 improvements
- Backward propagation: 0 improvements  
- Lattice construction: Produces WORSE scores
- C++ optimizers (bbox3, tree_packer): Negligible improvement (~1e-9)
- Local search methods DO NOT WORK on pre-optimized baselines

**The pre-optimized solutions are at a tight local optimum. Local search cannot escape.**

## Available Pre-optimized Resources
Best pre-optimized CSVs are in:
- `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`
  - `santa-2025-csv/santa-2025.csv` - Main pre-optimized solution (~70.676)
  - `bucket-of-chump/submission.csv` - Another good solution
  - `best_ensemble.csv` - Ensemble of best per-N configurations
  - `bbox3` - C++ optimizer binary

## Approaches That MUST Be Tried

### 1. Greedy Backtracking with Beam Search (HIGHEST PRIORITY)
Build solutions from scratch, NOT from pre-optimized:
```python
# Pseudocode for greedy backtracking
def greedy_backtracking(n_trees, beam_width=10, max_depth=10):
    """Build configuration tree-by-tree with beam search"""
    states = [empty_configuration()]
    
    for tree_idx in range(n_trees):
        candidates = []
        for state in states:
            # Try many placements for next tree
            for angle in np.linspace(0, 360, 36):
                for attempt in range(100):
                    pos = find_valid_position(state, angle)
                    if pos:
                        new_state = add_tree(state, pos, angle)
                        candidates.append((score(new_state), new_state))
        
        # Keep top beam_width states
        candidates.sort(key=lambda x: x[0])
        states = [c[1] for c in candidates[:beam_width]]
    
    return min(states, key=score)
```

### 2. Random Initialization + Optimization
Generate completely new starting configurations:
```python
def random_initialization(n_trees):
    """Create random valid configuration"""
    trees = []
    for i in range(n_trees):
        for attempt in range(1000):
            x = random.uniform(-5, 5)
            y = random.uniform(-5, 5)
            angle = random.uniform(0, 360)
            if no_overlap(trees, (x, y, angle)):
                trees.append((x, y, angle))
                break
    return trees
```

### 3. Per-N Independent Construction
For each N, try multiple construction strategies independently:
- Don't inherit from N+1 configuration
- Try different seed angles (0°, 45°, 90°, etc.)
- Try different placement orders (center-out, spiral, random)

### 4. Corner Extraction (Has Shown Small Improvements)
Extract corner configurations from larger N solutions:
- For N=54, check if corners of N=163 solution work better
- This found 0.000634 improvement in previous experiments

### 5. Ensemble Strategy
Combine best per-N configurations from multiple sources:
```python
def ensemble_best_per_n(sources):
    """Pick best configuration for each N from multiple sources"""
    best = {}
    for n in range(1, 201):
        best_score = float('inf')
        for source in sources:
            score_n = compute_score_for_n(source, n)
            if score_n < best_score and no_overlap(source, n):
                best_score = score_n
                best[n] = source[n]
    return best
```

## Key Techniques from Top Kernels

### bbox3 C++ Optimizer
- Uses simulated annealing with complex number geometry
- Fluid dynamics for tree movement
- Hinge pivot rotations
- Global boundary tension
- Run with: `./bbox3 -n <iterations> -r <restarts>`

### fix_direction Rotation Optimization
- Rotates entire configuration to minimize bounding box
- Uses scipy.optimize.minimize_scalar on convex hull
- Can provide small improvements after any change

### Overlap Detection
- Use Shapely STRtree for efficient spatial queries
- Check polygon intersection (not just touching)
- Scale factor 1e15 for precision

## Validation Requirements
- All trees must not overlap (intersect but not touch is OK)
- Coordinates must be in range [-100, 100]
- Format: id,x,y,deg with 's' prefix on values

## Recommended Experiment Order

1. **Baseline**: Load best pre-optimized CSV, verify score ~70.676
2. **Ensemble**: Combine all available pre-optimized sources
3. **Greedy Backtracking**: Implement beam search construction for small N (1-50)
4. **Random Restarts**: Generate 100+ random configurations per N, keep best
5. **Hybrid**: Use random construction + local refinement
6. **Corner Extraction**: Systematic search for corner improvements

## Code Structure
```
experiments/
  001_baseline/           # Load pre-optimized, verify
  002_ensemble/           # Combine sources
  003_greedy_backtrack/   # Beam search construction
  004_random_init/        # Random initialization
  005_hybrid/             # Combined approaches
```

## Scoring Function
```python
def compute_total_score(submission_df):
    total = 0
    for n in range(1, 201):
        trees = load_trees_for_n(submission_df, n)
        side = compute_bounding_box_side(trees)
        total += side**2 / n
    return total
```

## Key Files
- Sample submission: `/home/data/sample_submission.csv`
- Pre-optimized: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`
- bbox3 binary: Copy from pre-optimized directory

## DO NOT WASTE TIME ON:
- More simulated annealing iterations on pre-optimized solutions
- Different SA parameters (temperature, cooling rate)
- Backward propagation from pre-optimized
- Lattice-based construction (produces worse results)
- Local search variants (hill climbing, tabu search) on pre-optimized

## FOCUS ON:
- Constructive approaches that build from scratch
- Beam search with multiple parallel states
- Random initialization with many restarts
- Ensemble of diverse construction methods
