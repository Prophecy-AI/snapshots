# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D geometric packing optimization problem:
- Pack Christmas tree-shaped polygons (N=1 to 200 trees) into the smallest square bounding box
- Score = Σ(side_n²/n) for n=1 to 200 (lower is better)
- **Target score: 68.919154** (current #1 on leaderboard)
- Best pre-optimized baseline: ~70.676 (gap of ~1.75 points)

## Tree Geometry (15-vertex polygon)
```
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```
- Tip at (0, 0.8), trunk bottom at y=-0.2
- Base width 0.7, mid width 0.4, top width 0.25, trunk width 0.15
- Trees can be rotated (angle in degrees) and positioned (x, y coordinates)

## CRITICAL INSIGHT: Pre-optimized Solutions are at Local Optimum
Previous experiments (12+ attempts) have shown:
- Simulated annealing: 0 improvements
- Backward propagation: 0 improvements  
- Lattice construction: Produces WORSE scores
- C++ optimizers (bbox3, tree_packer_v21): Negligible improvement (~1e-9)
- Local search methods DO NOT WORK on pre-optimized baselines

**The pre-optimized solutions are at a tight local optimum. Local search cannot escape.**

## Available Pre-optimized Resources
Best pre-optimized CSVs are in:
- `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`
  - `santa-2025-csv/santa-2025.csv` - Main pre-optimized solution (~70.676)
  - `bucket-of-chump/submission.csv` - Another good solution
  - `best_ensemble.csv` - Ensemble of best per-N configurations
  - `bbox3` - C++ optimizer binary

## MANDATORY FIRST EXPERIMENT: Baseline Verification
```python
# Load and verify pre-optimized solution
import pandas as pd
import shutil

# Copy best pre-optimized
src = '/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/santa-2025-csv/santa-2025.csv'
shutil.copy(src, 'submission.csv')

# Verify score
score = compute_total_score('submission.csv')
print(f"Baseline score: {score}")  # Should be ~70.676
```

## Approaches That MUST Be Tried (Priority Order)

### 1. External Dataset Search (HIGHEST PRIORITY)
The top teams (68.9 score) likely have access to better pre-optimized solutions.
Search for Kaggle datasets with better solutions:
```bash
kaggle datasets list -s "santa 2025" --sort-by votes
```
Download and ensemble any found solutions.

### 2. Greedy Backtracking with Beam Search
Build solutions from scratch, NOT from pre-optimized:
```python
def greedy_backtracking(n_trees, beam_width=10):
    """Build configuration tree-by-tree with beam search"""
    states = [{'trees': [], 'score': 0}]
    
    for tree_idx in range(n_trees):
        candidates = []
        for state in states:
            # Try many placements for next tree
            for angle in np.linspace(0, 360, 72):  # 5-degree increments
                for attempt in range(50):
                    pos = find_valid_position_greedy(state['trees'], angle)
                    if pos:
                        new_trees = state['trees'] + [(pos[0], pos[1], angle)]
                        new_score = compute_side(new_trees)
                        candidates.append({'trees': new_trees, 'score': new_score})
                        break
        
        # Keep top beam_width states
        candidates.sort(key=lambda x: x['score'])
        states = candidates[:beam_width]
    
    return min(states, key=lambda x: x['score'])
```

### 3. Random Multi-Start Construction
Generate many random configurations and keep best:
```python
def random_construction(n_trees, num_restarts=1000):
    best_config = None
    best_score = float('inf')
    
    for restart in range(num_restarts):
        config = build_random_config(n_trees)
        if config and not has_overlap(config):
            score = compute_side(config)**2 / n_trees
            if score < best_score:
                best_score = score
                best_config = config
    
    return best_config
```

### 4. Per-N Independent Optimization
For each N from 1 to 200:
- Try 10+ different construction strategies
- Use different seed angles (0°, 30°, 45°, 60°, 90°, etc.)
- Try different placement orders (center-out, spiral, random)
- Keep the best result for each N

### 5. Corner Extraction from Larger N
Extract subsets from larger configurations:
```python
def corner_extraction(source_n, target_n):
    """Try using corners of N=source_n for N=target_n"""
    source_trees = load_config(source_n)
    # Get trees that define the bounding box corners
    corner_trees = get_boundary_trees(source_trees)
    # Try using subsets of these
    for subset in combinations(corner_trees, target_n):
        if not has_overlap(subset):
            score = compute_score(subset)
            # Compare with current best for target_n
```

## Key Techniques from Top Kernels

### bbox3 C++ Optimizer (from jazivxt/why-not)
```cpp
// Key parameters
constexpr double NEIGHBOR_RADIUS = 0.5;
constexpr double PIVOT_ANGLE_MAX = 10.0;
constexpr double GLOBAL_TENSION_STRENGTH = 0.05;

// Run with: ./bbox3 -n <iterations> -r <restarts>
```

### tree_packer_v21 C++ Optimizer (from smartmanoj/santa-claude)
```cpp
// Key operations:
// 1. Squeeze: scale 0.9995 to 0.98 toward center
// 2. Compaction: move trees toward center in steps
// 3. Local search: 8 directions + rotations
// 4. Swap moves: exchange positions of two trees
// 5. Multi-start: different initial angles
```

### fix_direction Rotation Optimization
```python
from scipy.optimize import minimize_scalar
from scipy.spatial import ConvexHull

def optimize_rotation(trees):
    """Rotate entire config to minimize bounding box"""
    points = get_all_vertices(trees)
    hull_points = points[ConvexHull(points).vertices]
    
    def bbox_at_angle(angle):
        rotated = rotate_points(hull_points, angle)
        return max(rotated.max(0) - rotated.min(0))
    
    result = minimize_scalar(bbox_at_angle, bounds=(0, 90), method='bounded')
    return result.x, result.fun
```

## Validation Requirements
- All trees must not overlap (intersect but not touch is OK)
- Coordinates must be in range [-100, 100]
- Format: `id,x,y,deg` with 's' prefix on values (e.g., `s0.123`)

## Scoring Function
```python
def compute_total_score(df):
    total = 0
    for n in range(1, 201):
        trees = load_trees_for_n(df, n)
        side = compute_bounding_box_side(trees)
        total += side**2 / n
    return total
```

## Overlap Detection (Fast)
```python
from shapely.geometry import Polygon
from shapely.strtree import STRtree

def has_overlap(trees):
    polygons = [create_tree_polygon(t) for t in trees]
    tree_index = STRtree(polygons)
    
    for i, poly in enumerate(polygons):
        candidates = tree_index.query(poly)
        for j in candidates:
            if i != j and poly.intersects(polygons[j]) and not poly.touches(polygons[j]):
                return True
    return False
```

## Recommended Experiment Order

1. **001_baseline**: Load best pre-optimized CSV, verify score ~70.676
2. **002_dataset_search**: Search for external datasets with better solutions
3. **003_ensemble**: Combine all available sources, pick best per-N
4. **004_greedy_beam**: Implement beam search construction for N=1-50
5. **005_random_multi**: Random construction with 1000+ restarts per N
6. **006_corner_extract**: Systematic corner extraction search

## DO NOT WASTE TIME ON:
- More SA iterations on pre-optimized solutions
- Different SA parameters (temperature, cooling rate)
- Backward propagation from pre-optimized
- Lattice-based construction (produces worse results)
- Local search variants on pre-optimized

## FOCUS ON:
- Finding better external pre-optimized solutions
- Constructive approaches that build from scratch
- Beam search with multiple parallel states
- Random initialization with many restarts
- Ensemble of diverse construction methods

## Key Files
- Sample submission: `/home/data/sample_submission.csv`
- Pre-optimized: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`
- bbox3 binary: Copy from pre-optimized directory
