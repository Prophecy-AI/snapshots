# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.659959 from exp_000 (saspav baseline)
- Best LB score: 70.659959 (confirmed via 2 submissions)
- Target: 68.919154 | Gap to target: 1.74 points (2.5%)
- Submissions used: 3/100 (97 remaining)

## CRITICAL: Submission Failure Analysis

**exp_006 (Eazy Optimizer) FAILED on LB with "Overlapping trees in group 069"**

Root cause analysis:
1. The Eazy optimizer modified 192/200 N values
2. Local Shapely-based validation showed 0 overlaps
3. Kaggle server uses STRICTER overlap detection (SAT-based with high precision)
4. The optimizer introduced precision-level overlaps that pass local checks but fail on server

**KEY INSIGHT: The saspav baseline is at an EXTREMELY strong local optimum**
- Any modification risks introducing overlaps
- Even sophisticated optimizers (Eazy, SA) achieve 0 or negligible improvement
- The baseline has been optimized by top competitors with proper overlap handling

## What We've Learned (7 experiments)

| Exp | Approach | Result |
|-----|----------|--------|
| exp_000 | Saspav baseline | 70.659959 (LB confirmed) |
| exp_001 | C++ SA optimizer | 0 improvement |
| exp_002 | Lattice construction | 88.33 (much worse) |
| exp_003 | Lattice + SA | 85.93 (still worse) |
| exp_004 | Invalid ensemble | Had overlaps |
| exp_005 | Valid ensemble | No improvement |
| exp_006 | Eazy optimizer | INVALID (server overlaps) |

## Response to Evaluator

The evaluator correctly identified:
1. ✅ Local search approaches are EXHAUSTED - confirmed by Eazy optimizer failure
2. ✅ bbox3 optimizer uses different strategy with overlap repair
3. ✅ Rotation optimization (fix_direction) is worth trying
4. ✅ Per-N targeted optimization could help

However, the submission failure reveals a CRITICAL issue:
- Our overlap detection is NOT strict enough
- We need to use the EXACT same overlap detection as Kaggle server
- Any optimizer must have overlap repair mechanism

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Implement bbox3 optimizer with overlap repair

The bbox3 optimizer from "why-not" kernel has key advantages:
- Uses aggressive overlap repair mechanism
- If optimization creates overlaps, reverts to donor solution
- Multi-phase approach (Phase A: 2min, Phase B: 10min, Phase C: 20min)
- Parameters: -n (iterations), -r (radius)

**Implementation plan:**
1. Extract bbox3.cpp from the "why-not" kernel
2. Compile with OpenMP support
3. Run with saspav baseline as donor
4. Use repair_overlaps_in_place() to fix any invalid configs

### 2. **[HIGH PRIORITY]** Implement stricter overlap detection

Before ANY optimization, we need overlap detection that matches Kaggle server:
- Use Decimal precision (not float)
- Use SAT (Separating Axis Theorem) instead of Shapely
- Test with known-good baseline to verify

### 3. **[MEDIUM PRIORITY]** Rotation optimization (fix_direction)

From bbox3-runner kernel:
```python
from scipy.optimize import minimize_scalar
from scipy.spatial import ConvexHull

def optimize_rotation(trees, angle_max=89.999, epsilon=1e-7):
    # Get all tree vertices
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points_np = np.array(all_points)
    
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    def bbox_side_at_angle(angle_deg):
        angle_rad = np.radians(angle_deg)
        c, s = np.cos(angle_rad), np.sin(angle_rad)
        rot_matrix_T = np.array([[c, s], [-s, c]])
        rotated = hull_points.dot(rot_matrix_T)
        return max(rotated.max(axis=0) - rotated.min(axis=0))
    
    result = minimize_scalar(bbox_side_at_angle, bounds=(0.001, angle_max), method='bounded')
    return result.x, result.fun
```

This is computationally cheap and can reduce bounding box without moving trees.

### 4. **[LOWER PRIORITY]** Per-N targeted optimization

Focus on N values with worst efficiency:
- N=1: score 0.661 (efficiency 1.86x theoretical)
- N=2-10: efficiency 0.77-0.93x
- These contribute 5.2% of total score but have most room for improvement

## What NOT to Try

1. ❌ Running more SA/local search on baseline (exhausted)
2. ❌ Lattice construction (produces much worse results)
3. ❌ Simple ensembling (baseline already wins for all N)
4. ❌ Any optimizer without overlap repair mechanism

## Validation Requirements

**CRITICAL: Before submitting ANY optimized solution:**
1. Validate with Decimal precision overlap detection
2. Use SAT-based overlap check, not Shapely
3. If ANY overlaps detected, revert to baseline for those N values
4. Test on known-good baseline first to verify detection matches server

## SUBMISSION STRATEGY
- Remaining submissions: 97
- Submit after this experiment? YES if:
  - bbox3 optimizer produces valid output
  - Score improves over baseline
  - Overlap validation passes with strict detection
- Do NOT submit if local validation is uncertain

## Technical Notes

The bbox3-runner kernel workflow:
1. Load baseline CSV
2. Run bbox3 optimizer with parameters
3. Apply fix_direction (rotation optimization)
4. Run repair_overlaps_in_place() with donor CSV
5. Validate final output
6. Only save if valid and improved

This ensures submissions are always valid even if optimization introduces overlaps.