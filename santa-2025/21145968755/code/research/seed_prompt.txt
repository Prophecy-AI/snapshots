## Current Status
- Best CV score: 70.659959 from exp_000 (saspav baseline)
- Best LB score: 70.6600 (multiple submissions confirm baseline is valid)
- Target: 68.919154 | Gap to target: 1.74 (2.46%)

## Critical Strategic Insight

**OUR BASELINE (70.66) IS BETTER THAN THE PUBLIC LB TOP (71.19)!**

This means:
1. The saspav baseline we're using is already highly optimized
2. The target (68.92) requires techniques NOT publicly shared
3. Top teams have found ways to beat 68.92 but haven't shared their methods
4. We need to DISCOVER novel techniques, not just copy public kernels

## Experiment History Summary (13 experiments, all ~70.66)
- exp_000: Baseline (70.659959) ✓
- exp_001-003: SA, lattice construction - no improvement
- exp_004-006: Lattice+SA, ensemble - no improvement
- exp_007-008: Eazy optimizer, rotation - 0.000015 improvement
- exp_009-011: bbox3, tree removal - 0.000001 improvement
- exp_012: Genetic Algorithm - 0 improvement

**CONCLUSION: Local optimization is EXHAUSTED. The baseline is at an extremely strong local optimum.**

## Response to Evaluator

The evaluator correctly identified that:
1. The GA implementation was too conservative (mutation strength 0.1)
2. Overlap rejection means very few configurations are explored
3. We need AGGRESSIVE global search with overlap REPAIR

I agree with all points. The key insight is that we need to:
1. Use LARGE mutations (0.5-1.0 tree widths, not 0.1)
2. REPAIR overlaps instead of rejecting them
3. Apply local optimization AFTER global perturbation

The evaluator also suggested backward iteration and asymmetric solutions. We tried backward iteration (exp_009) with 0 improvement - the baseline is already independently optimized for each N.

## Gap Analysis

- N=1-10 have worst efficiency (1.86x-1.06x theoretical minimum)
- N=1-10 contribute 6.1% of total score
- If N=1-10 matched theoretical optimum, would close 44.8% of gap
- Worst 50 N values contribute 11.77 points
- Need 14.8% improvement on worst 50 to reach target

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** MEMETIC ALGORITHM with Overlap Repair

The bbox3.cpp code has an `aggressive_repair` function that repairs overlaps instead of rejecting them. Implement:

```python
# Memetic Algorithm with Overlap Repair
for generation in range(100):
    for individual in population:
        # 1. LARGE mutation (0.5-1.0 tree widths)
        mutated = apply_large_mutation(individual, strength=0.5)
        
        # 2. REPAIR overlaps (don't reject!)
        repaired = aggressive_repair(mutated)
        
        # 3. LOCAL optimization (bbox3)
        optimized = run_bbox3(repaired, iterations=1000)
        
        # 4. Selection
        if optimized.score < individual.score:
            individual = optimized
```

Key changes from exp_012:
- Mutation strength: 0.5-1.0 (not 0.1)
- Overlap handling: REPAIR (not reject)
- Post-mutation: LOCAL optimization

### 2. **[HIGH PRIORITY]** Basin Hopping with Large Perturbations

Different from GA - uses random large perturbations followed by local optimization:

```python
for iteration in range(1000):
    # 1. Large random perturbation
    perturbed = apply_random_perturbation(current, strength=1.0)
    
    # 2. Repair overlaps
    repaired = aggressive_repair(perturbed)
    
    # 3. Local optimization
    optimized = run_bbox3(repaired, iterations=5000)
    
    # 4. Accept if better
    if optimized.score < best_score:
        best = optimized
        best_score = optimized.score
```

### 3. **[MEDIUM PRIORITY]** Constraint Programming for Small N

For N=1-10 (worst efficiency), try exact methods:
- Formulate as constraint satisfaction problem
- Use OR-Tools CP-SAT solver
- Find globally optimal configurations for small N

### 4. **[MEDIUM PRIORITY]** Different Lattice Patterns

The 'why-not' kernel shows Blue/Pink tree orientations and lattice interlock patterns:
- Analyze the baseline configurations for patterns
- Try different interlock offsets
- Explore asymmetric configurations

### 5. **[LOW PRIORITY]** Differential Evolution

Global optimization that maintains population diversity:
- Use DE/rand/1/bin strategy
- Large mutation factor (F=0.8-1.0)
- High crossover rate (CR=0.9)

## What NOT to Try

1. ❌ More SA iterations (already exhausted)
2. ❌ Small mutations (0.1 strength) - doesn't escape local optimum
3. ❌ Overlap rejection - too restrictive
4. ❌ Simple ensembling - baseline already wins for all N
5. ❌ Backward iteration - baseline is independently optimized

## Validation Notes

- CV scheme: Sum of (side^2 / N) for N=1-200
- Overlap checking: Use Shapely with 1e-12 tolerance
- The Kaggle server uses stricter SAT-based overlap detection

## SUBMISSION STRATEGY

- Remaining submissions: 91
- Submit after this experiment? **YES** - we have abundant submissions
- Any improvement over baseline (70.659959) should be submitted immediately

## Key Files

- Baseline: `/home/code/external_data/saspav/santa-2025.csv`
- bbox3 optimizer: `/home/code/research/kernels/jazivxt_why-not/why-not.ipynb` (contains bbox3.cpp with aggressive_repair)
- Backpacking kernel: `/home/code/research/kernels/crodoc_74-75-backpacking-christmas-trees/`

## Success Criteria

Any score below 70.659959 is an improvement. The target (68.919154) requires ~2.46% improvement across all N values, or ~14.8% improvement on the worst 50 N values.
