# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.659959 from exp_000 (001_baseline)
- Best LB score: 70.6600 (PERFECT CV-LB MATCH!)
- Target: 68.919154 | Gap to target: 1.74 points (2.53%)

## CV-LB Relationship Analysis
- CV and LB match exactly (70.659959 ≈ 70.6600)
- This is an optimization problem, not prediction - no distribution shift concerns
- Our scoring function is correctly calibrated

## Response to Evaluator
The evaluator correctly identified:
1. ✅ Baseline is solid and verified
2. ✅ LB submission confirmed CV-LB match (now done)
3. ✅ Gap of 1.74 points requires fundamentally different approaches
4. ✅ Local search on pre-optimized solutions doesn't work

Key insight from evaluator: "The top teams (68.9 score) are using approaches that produce fundamentally better configurations, not just better-optimized versions of the same configurations."

## Key Findings from Analysis

### Per-N Score Distribution
- N=1-20: 11.4% of score, avg efficiency 0.62 (WORST - most room for improvement)
- N=21-50: 15.5% of score, avg efficiency 0.67
- N=51-100: 25.0% of score, avg efficiency 0.70
- N=101-150: 24.3% of score, avg efficiency 0.72
- N=151-200: 23.8% of score, avg efficiency 0.73 (BEST)

### Theoretical Analysis
- Best packing efficiency achieved: 0.7444 at N=181
- If ALL N matched this efficiency: score would be 65.99 (4.67 points better!)
- Current average efficiency: 0.6982
- Target requires ~2.5% improvement across all N

### What Top Teams Do (from research)
1. **Lattice-based approaches** with 3-4 tree repeating blocks for N>=58
2. **Chaotic/SA packing** for N<58
3. **Fractional translation** with tiny steps (0.001 to 0.00001)
4. **C++ optimizers** with AVX2 vectorization for speed
5. **Multi-source ensemble** picking best per-N from 15+ sources

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Run C++ SA Optimizer on Current Best
The Jonathan Chan kernel shows significant improvements from SA + fractional translation.
```bash
# Compile and run the C++ optimizer
g++ -O3 -march=native -std=c++17 -fopenmp -o sa_optimizer sa_v1_parallel.cpp
./sa_optimizer -i submission.csv -o optimized.csv -n 20000 -r 80
```
This should squeeze out small improvements from the current baseline.

### 2. **[HIGH PRIORITY]** Implement Bottom-Left Beam Search Construction
For small N (1-20) where efficiency is worst:
- Use bottom-left placement heuristic
- Beam search with width 20-50
- Try multiple starting angles (0°, 30°, 45°, 60°, 90°)
- This could improve the 11.4% of score from N=1-20

### 3. **[HIGH PRIORITY]** Search for Better External Datasets
Top teams may have shared better solutions:
```bash
kaggle datasets list -s "santa 2025" --sort-by dateCreated
```
Look for datasets updated after our current best (saspav).

### 4. **[MEDIUM PRIORITY]** Lattice Construction for Large N
For N>=58, construct crystalline lattice patterns:
- 2-tree alternating up-down pattern
- 3-tree and 4-tree repeating blocks
- Systematic search over lattice parameters

### 5. **[MEDIUM PRIORITY]** Fix Direction Rotation Optimization
Apply rotation optimization to minimize bounding box:
```python
from scipy.optimize import minimize_scalar
# Rotate entire configuration to minimize max(width, height)
```

## What NOT to Try
- ❌ More SA on pre-optimized solutions without new construction (already at local optimum)
- ❌ Random perturbation without systematic search
- ❌ Reinforcement learning (proven ineffective for this problem)
- ❌ Neural network approaches (combinatorial optimization beats them here)

## SUBMISSION STRATEGY
- Remaining submissions: 94
- **SUBMIT AFTER EVERY EXPERIMENT** - we have abundant submissions
- LB feedback is free information - USE IT!

## Validation Notes
- Score = Σ(side_n²/n) for n=1 to 200
- Lower is better
- No overlap allowed (trees can touch but not intersect)
- Coordinates must be in [-100, 100]

## Available Resources
- bbox3 binary: `/home/code/external_data/saspav/bbox3`
- Best CSV: `/home/code/external_data/saspav/santa-2025.csv` (score: 70.659959)
- Jonathan Chan C++ code: `research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation/`

## Next Experiment: 002_cpp_optimizer
1. Extract and compile the C++ SA optimizer from Jonathan Chan's kernel
2. Run it on our current best submission
3. Apply fractional translation refinement
4. Submit the result to verify improvement

## CRITICAL: Previous experiments showed SA on pre-optimized = 0 improvement
The strategy document notes that previous runs showed SA, backward propagation, and C++ optimizers produced 0 improvement on pre-optimized solutions. This suggests:
1. The pre-optimized solutions are already at local optima
2. We need CONSTRUCTIVE approaches that find different basins
3. Focus on small N (1-20) where efficiency is worst and construction might find better solutions
4. Try lattice-based construction for large N

## Alternative Next Experiment: 002_small_n_construction
If C++ optimizer shows 0 improvement, pivot to:
1. Implement bottom-left beam search for N=1-20
2. Try multiple random constructions with different starting configurations
3. Use jostle moves (swap + rotate) to escape local optima