# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.659959 from exp_000 (baseline)
- Best LB score: 70.659959 (verified)
- Target: 68.919154 | Gap to target: 1.74 points (2.46%)

## Public Kernel Status (CRITICAL!)
- Have we implemented the best kernel yet? **PARTIALLY** - We have the baseline and C++ optimizer but haven't applied the full workflow
- Top kernels identified:
  1. Jonathan Chan's ensemble + SA + fractional translation
  2. Zaburo's lattice construction (88.33 initial → needs SA)
  3. saspav's pre-optimized baseline (70.66)
- Kernels we've implemented: Baseline loading, C++ SA optimizer (tested on baseline - 0 improvement)
- **CRITICAL GAP**: We tested SA on ALREADY-OPTIMIZED baseline. Need to test SA on FRESH lattice output!

## CV-LB Relationship Analysis
- Only 1 submission so far: CV=70.659959, LB=70.659959 (perfect match)
- This is a pure optimization problem - CV=LB by definition (no train/test split)

## Response to Evaluator
The evaluator correctly identified the CRITICAL ERROR in exp_003:
- We compared RAW lattice output (88.33) to OPTIMIZED baseline (70.66)
- This is apples-to-oranges comparison
- The correct workflow is: Lattice → SA optimization → Compare to baseline
- The lattice construction is a STARTING POINT, not a final solution

**I AGREE with the evaluator's assessment.** The next experiment MUST:
1. Generate lattice configurations and SAVE them to CSV
2. Apply the C++ SA optimizer to the lattice output
3. Compare the OPTIMIZED lattice score to baseline
4. Create ensemble picking best per-N from {baseline, optimized_lattice}

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Apply SA to Lattice Output
The Zaburo lattice produces 88.33 as an INITIAL solution. This needs SA optimization:

```bash
# Generate lattice output and save to CSV
python generate_lattice.py --output lattice_output.csv

# Apply C++ SA optimizer
./sa_v1_parallel -i lattice_output.csv -o lattice_optimized.csv -n 20000 -r 10
```

**Expected outcome**: Lattice + SA should produce scores in the 70-72 range. Some N values may beat baseline.

### 2. **[HIGH PRIORITY]** Per-N Hybrid Strategy
Research shows different approaches work for different N ranges:
- **N < 58**: Chaotic/SA approaches work better (random initial + heavy SA)
- **N ≥ 58**: Lattice-based approaches work better (crystalline packing)

Implement this hybrid:
```python
for n in range(1, 201):
    if n < 58:
        # Use SA on random/chaotic initial
        config = random_construction(n)
        config = apply_sa(config)
    else:
        # Use lattice + SA
        config = lattice_construction(n)
        config = apply_sa(config)
    
    # Keep best vs baseline
    if score(config) < score(baseline[n]):
        ensemble[n] = config
    else:
        ensemble[n] = baseline[n]
```

### 3. **[MEDIUM PRIORITY]** Multi-Source Ensemble
Jonathan Chan's kernel ensembles from 15+ sources. We should:
1. Download more external datasets
2. Score each per-N
3. Pick best per-N from all sources

### 4. **[LOWER PRIORITY]** Fractional Translation Fine-Tuning
After SA optimization, apply fractional translation with decreasing step sizes:
- Steps: 0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001

## What NOT to Try
- ❌ Running SA on already-optimized baseline (confirmed 0 improvement)
- ❌ Comparing raw lattice output to optimized baseline (unfair comparison)
- ❌ Random construction without SA optimization
- ❌ Giving up on constructive approaches (they work when combined with SA!)

## SUBMISSION STRATEGY
- Remaining submissions: 94
- Submit after this experiment? **YES** - We have abundant submissions and need LB feedback
- Even if the optimized lattice doesn't beat baseline, we learn valuable information

## Validation Notes
- This is a pure optimization problem - CV = LB by definition
- Score = Σ(side_n²/n) for n=1 to 200
- Lower is better
- No train/test split - we're optimizing geometric configurations

## Key Technical Details

### C++ SA Optimizer Location
```
/home/code/experiments/002_cpp_optimizer/sa_v1_parallel
```

### Lattice Construction (Zaburo-style)
```python
# Alternating rows with 0° and 180° angles
# Offset by 0.35 (half tree width) for odd rows
# Row spacing: 1.0 for same-angle, 0.8 for alternating
```

### Tree Geometry
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## CRITICAL: The Path to 68.9

The target of 68.919154 requires ~2.46% improvement. Top teams achieve this through:
1. **Diverse initial configurations** (lattice, random, chaotic) - NOT just one approach
2. **Heavy SA optimization** on EACH initial configuration
3. **Ensemble** picking best per-N from ALL optimized sources
4. **Fractional translation** for final fine-tuning

The key insight: The baseline is at a LOCAL optimum. To find a BETTER optimum, we need to:
- Start from DIFFERENT initial configurations (lattice provides this)
- Apply SA to explore the solution space
- Keep the best results per-N

**DO NOT GIVE UP ON CONSTRUCTIVE APPROACHES!** They are the key to escaping the local optimum.
