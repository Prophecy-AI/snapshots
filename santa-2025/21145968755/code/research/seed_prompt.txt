# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.659959 from exp_000 (saspav baseline)
- Best LB score: 70.659959 (verified with 2 submissions)
- Target: 68.919154 | Gap to target: 1.74 points (2.46%)

## CRITICAL BUG FIXED
**Experiment 005 was INVALID** - the submission had 168/200 N values with overlapping trees.
The "score" of 51.42 was completely wrong. After comprehensive validation:
- 707 CSV files scanned
- 634 valid sources (no overlaps)
- Best VALID score is still 70.659959

**ALL future experiments MUST include overlap validation!**

## Response to Evaluator
The evaluator correctly identified the critical bug - overlapping trees. The comprehensive
scan confirmed that:
1. The source file `submission_opt.csv` has 169/200 overlaps - it's an invalid/debug file
2. The saspav baseline (70.659959) has 0 overlaps - it's our best VALID submission
3. There are NO valid sources with scores better than 70.66 in the snapshots

The evaluator's recommendation to re-run with overlap validation was correct. However,
the analysis shows that simply ensembling existing valid sources provides NO improvement -
the saspav baseline already wins for 193/200 N values.

## Key Insight: We Need ACTUAL Optimization, Not Just Ensembling

The gap to target (1.74 points) cannot be closed by:
- ❌ Ensembling existing sources (already tried - no improvement)
- ❌ Running SA on pre-optimized solutions (already at local optimum)
- ❌ Simple lattice construction (produces worse scores)

What we MUST try:
- ✅ Advanced optimization techniques from Eazy optimizer (square potential gradient, elastic pulse)
- ✅ Multi-scale optimization with proper overlap checking
- ✅ Per-N targeted optimization focusing on worst-performing N values
- ✅ Novel constructive approaches that generate different initial configurations

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Implement Eazy Optimizer with Overlap Validation
The Eazy optimizer uses advanced techniques not in our current toolkit:
- Square Potential Gradient: Pushes trees toward center using log-barrier derivatives
- Elastic Pulse: Periodic squeeze/relax cycles (factor 0.999999 to 1.0000001)
- Complex Orbital Move: Uses complex number rotation for moves
- Multi-scale: 1e-3 → 1e-5 → 1e-7 → 1e-9

**Key difference**: This optimizer generates VALID solutions (has overlap checking built-in).

### 2. **[HIGH PRIORITY]** Target Worst-Performing N Values
From previous analysis:
- N=1-20 has lowest efficiency (0.62 avg) - most room for improvement
- N=1 has worst efficiency (0.529)
- Small N values contribute only 11.4% of score but have most room for improvement

Focus optimization time on N=1-50 where improvements are most likely.

### 3. **[MEDIUM PRIORITY]** Try Different Initial Configurations
The pre-optimized baseline may be stuck in a local optimum. Try:
- Random multi-start with different initial angles
- Lattice-based initial configurations for large N (>58)
- Chaotic initial configurations for small N (<58)

### 4. **[LOWER PRIORITY]** Hybrid Lattice + SA for Large N
Research suggests:
- For N >= 58: Use crystalline/lattice packing
- For N < 58: Use chaotic SA
- Top teams use 3-4 tree repeating blocks

## What NOT to Try
- ❌ Ensembling without overlap validation (produces invalid submissions)
- ❌ Using sources from snapshots without checking for overlaps
- ❌ Simple SA on pre-optimized solutions (already at local optimum)
- ❌ Submitting without verifying 0 overlaps for all 200 N values

## Validation Requirements (MANDATORY)
Every experiment MUST:
1. Check for overlaps on ALL 200 N values before scoring
2. Only report scores for configurations with 0 overlaps
3. Verify submission file has exactly 20100 rows
4. Confirm no overlapping trees before submission

## Overlap Checking Code (MUST USE)
```python
def check_overlaps_for_n(df, n):
    """Check if configuration N has overlapping trees"""
    prefix = f"{n:03d}_"
    trees = df[df['id'].str.startswith(prefix)]
    if len(trees) != n:
        return True, float('inf')
    
    polygons = [create_tree_polygon(row['x'], row['y'], row['deg']) 
                for _, row in trees.iterrows()]
    
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]):
                intersection = polygons[i].intersection(polygons[j])
                if intersection.area > 1e-10:
                    return True, intersection.area
    return False, 0

def validate_submission(df):
    """Validate entire submission has no overlaps"""
    for n in range(1, 201):
        has_overlap, _ = check_overlaps_for_n(df, n)
        if has_overlap:
            return False, n
    return True, None
```

## SUBMISSION STRATEGY
- Remaining submissions: 93
- Submit after EVERY valid experiment (we have abundant submissions)
- But ONLY submit if overlap validation passes for ALL 200 N values

## CV Scheme
Score = Σ(side_n² / n) for n=1 to 200
Lower is better. Must have 0 overlapping trees.
