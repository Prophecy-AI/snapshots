# Santa 2025 - Christmas Tree Packing Challenge

## Problem Overview
This is a 2D bin packing optimization problem where we need to fit Christmas tree-shaped polygons into the smallest possible square bounding box for configurations of N=1 to 200 trees.

**Scoring:** score = Σ(S_n²/n) for n=1 to 200, where S_n is the side length of the bounding square for n trees. **Lower is better.**

**Target Score:** Beat 68.901319

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Trunk: 0.15 width × 0.2 height
- Base tier: 0.7 width at y=0
- Middle tier: 0.4 width at y=0.25
- Top tier: 0.25 width at y=0.5
- Tip: at y=0.8
- Total height: ~1.0 units

Trees can be positioned (x, y) and rotated (deg parameter, 0-360 degrees).

## Key Techniques from Top Kernels

### 1. C++ Optimizers (Critical for Performance)
The top solutions use compiled C++ optimizers for speed:
- **bbox3**: Main optimizer with parameters `-n` (iterations) and `-r` (restarts)
  - Fast runs: n=1000-2000, r=30-90
  - Long runs: n=5000-10000, r=256
  - Uses OpenMP for parallelization
- **shake_public**: Additional shaking/perturbation optimizer
- **tree_packer_v21**: Advanced optimizer with SA, swap moves, multi-start

### 2. Simulated Annealing (SA)
Key SA components from `smartmanoj_santa-claude`:
- **Move operators:**
  - Translation: small steps (0.01-0.001 units) in 8 directions + toward center
  - Rotation: angle changes (5°, 2°, 0.8°, 0.3°, 0.1°)
  - Swap: exchange positions of two trees
- **Temperature schedule:** Start high (T0), decay to Tm
- **Acceptance:** exp(-delta/T) for worse solutions

### 3. Local Search Techniques
- **Compaction:** Move trees toward centroid in small steps
- **Squeeze:** Scale all trees toward center (lambda=0.9995 to 0.98)
- **Boundary focus:** Prioritize optimizing trees that touch the bounding box

### 4. Rotation Tightening (fix_direction)
Post-processing to optimize global rotation:
```python
# Use scipy.optimize.minimize_scalar on convex hull
# Find angle that minimizes max(width, height) of rotated bounding box
res = minimize_scalar(lambda a: calculate_bbox_side_at_angle(a, hull_points),
                      bounds=(0.001, 89.999), method='bounded')
```

### 5. Backward Propagation
Improve smaller configurations by removing trees from larger ones:
- Start from N=200, work down to N=2
- For each n-tree config, try removing boundary-touching trees
- If resulting (n-1) config is better than stored, update it

### 6. Greedy Initialization
- Place first tree at origin
- For each new tree:
  - Start far from center (radius ~20)
  - Use weighted random angle (sin(2*angle) favors corners)
  - Move toward center until collision
  - Back up until no collision

## Collision Detection
Use Shapely library with high precision:
```python
from shapely import affinity
from shapely.geometry import Polygon
from shapely.strtree import STRtree
from decimal import Decimal, getcontext

getcontext().prec = 25  # High precision
scale_factor = Decimal('1e15')  # Scale for precision

# Overlap check: intersects but not just touches
if poly.intersects(other) and not poly.touches(other):
    # Overlap detected
```

## Recommended Approach

### Phase 1: Start from Best Available Solution
1. Use pre-optimized submission CSVs from top kernels as baseline
2. Score the baseline to establish starting point

### Phase 2: Run C++ Optimizers
1. Compile bbox3 and other C++ tools with `-O3 -march=native -fopenmp`
2. Run multiple iterations with different n/r parameters
3. Keep best results, revert on regressions

### Phase 3: Post-Processing
1. Apply fix_direction() to optimize rotation of each configuration
2. Run shake_public for additional perturbation
3. Validate no overlaps exist

### Phase 4: Targeted Improvement
1. Identify configurations with highest S²/n contribution
2. Focus optimization effort on those N values
3. Use backward propagation to improve smaller N from larger N

## Validation
Always validate submissions:
1. Check for overlaps using Shapely
2. Verify coordinates within bounds (-100 ≤ x,y ≤ 100)
3. Ensure 's' prefix on all numeric values in CSV

## File Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```

## Reference Implementations
- Getting Started: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 Runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- SA + Backward Prop: `../research/kernels/smartmanoj_santa-claude/`
- Combined Approach: `../research/kernels/saspav_santa-submission/`
- bbox3 C++ Source: `../research/kernels/jazivxt_why-not/`

## Key Insights
1. **Asymmetric solutions often win** - Don't assume symmetric packing is optimal
2. **Larger N values contribute more to score** - Focus on N=100-200 range
3. **Incremental improvement** - Start from good baseline, improve iteratively
4. **Parallelization critical** - Use OpenMP for C++ optimizers
5. **Precision matters** - Use high-precision Decimal arithmetic
