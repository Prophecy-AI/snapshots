# Santa 2025 - Christmas Tree Packing Challenge

## Current Status
- Best CV score: 70.626088 from exp_001 (002_valid_baseline)
- Best LB score: 70.626088 (verified)
- Target: 68.897509 | Gap to target: 1.728579 (2.51%)

## CV-LB Relationship Analysis
- Only 1 valid LB submission so far (exp_000 failed with overlaps)
- CV and LB match exactly (70.626088), confirming local scoring is accurate
- **CRITICAL**: Local overlap detection is LESS strict than Kaggle's
- candidate_029.csv (score 70.624381) FAILED LB with "Overlapping trees in group 040"
- Must use more conservative overlap detection or always validate on LB

## Response to Evaluator
- Technical verdict was TRUSTWORTHY. Baseline is LB-verified and reliable.
- Evaluator's top priority: **CRITICAL STRATEGIC PIVOT NEEDED** - 38 experiments using standard techniques all converged to 70.624. The target requires something different.
- I AGREE with the evaluator. The snapshot evidence is clear: bbox3, SA, GA, MIP, tessellation, ensemble, deletion cascade, corner rebuild, basin hopping, greedy beam search - ALL converged to the same local optimum.
- Key concerns raised: The gap is 1.73 points (2.51%) which is NOT a fine-tuning gap. Need structural improvements.
- **My response**: We need fundamentally different approaches. The standard optimization techniques have been exhausted. We must try:
  1. NFP-based placement for guaranteed non-overlap
  2. More aggressive lattice-based initialization
  3. Stricter overlap detection (add buffer) to avoid LB failures
  4. Focus on N=2-50 where improvements have highest leverage

## Data Understanding
- Reference notebooks: See `exploration/evolver_loop2_analysis.ipynb` for gap analysis
- Key patterns:
  - Trees show crystallization pattern (alternating orientations ~50/50 for large N)
  - N=1 is already at theoretical minimum (0.813 side at 45°)
  - Score = Σ(S²/n), so small N has disproportionate impact
  - Need ~1.23% reduction in ALL side lengths uniformly to reach target

## Problem Overview
This is a 2D bin packing optimization problem where we need to fit Christmas tree-shaped polygons into the smallest possible square bounding box for configurations of N=1 to 200 trees.

**Scoring:** score = Σ(S_n²/n) for n=1 to 200, where S_n is the side length of the bounding square for n trees. **Lower is better.**

**Target Score:** Beat 68.897509

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Trunk: 0.15 width × 0.2 height
- Base tier: 0.7 width at y=0
- Middle tier: 0.4 width at y=0.25
- Top tier: 0.25 width at y=0.5
- Tip: at y=0.8
- Total height: ~1.0 units

Trees can be positioned (x, y) and rotated (deg parameter, 0-360 degrees).

## Recommended Approaches (Priority Ordered)

### 1. **NFP-Based Placement** (HIGHEST PRIORITY - NOT TRIED)
The No-Fit Polygon (NFP) technique guarantees non-overlapping placements:
- NFP describes all positions where two polygons don't overlap
- If reference point is INSIDE NFP → overlap; ON boundary → touching; OUTSIDE → no overlap
- This is MORE ROBUST than Shapely intersection checks
- Can be combined with optimization to find tighter packings

**Implementation approach:**
1. Compute NFP for tree polygon with itself (at various rotations)
2. Use NFP to guide placement - only place trees where reference point is outside NFP
3. This guarantees no overlaps, avoiding LB validation failures

### 2. **Stricter Overlap Detection** (CRITICAL)
Current local validation is less strict than Kaggle's. Solutions that pass locally fail on LB.
- Add a small buffer (e.g., 0.001 units) to overlap detection
- Use `polygon.buffer(0.001).intersects(other)` instead of direct intersection
- This will reject borderline cases that Kaggle rejects

### 3. **Lattice-Based Initialization with Optimal Spacing**
The "Why Not" kernel shows trees form crystallization patterns:
- Alternating orientations (up/down) in a lattice
- Optimal spacing depends on N
- Initialize with mathematically optimal lattice, then fine-tune

### 4. **Focus on N=2-50** (HIGH LEVERAGE)
Score contribution analysis:
- N=1: Already optimal (0.661 contribution)
- N=2-10: High leverage (4.33 total contribution)
- N=11-50: Medium leverage (14.70 total contribution)
- N=51-200: Lower leverage (51.59 total contribution)

Improving N=2-50 by 5% would give ~1.0 point improvement.

### 5. **Fractional Translation with Finer Steps**
The jonathanchan kernel uses very fine step sizes:
- Steps: 0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001
- 8 directions: N, S, E, W, NE, NW, SE, SW
- This can squeeze out small improvements after SA

### 6. **Ensemble from More Sources**
The snapshot used 107 sources but still converged to same optimum.
- Look for sources with DIFFERENT structural approaches
- Not just different optimization runs of same structure

## What NOT to Try (Exhausted)
- More bbox3 iterations (38 experiments tried, no improvement)
- Standard SA with same initialization
- Tessellation patterns (tried, worse than baseline)
- Genetic algorithm (tried, no improvement)
- MIP for small N (tried, baseline already optimal)
- Basin hopping (tried, no improvement)
- Greedy beam search (tried, no improvement)
- Deletion cascade (tried, no improvement)

## Validation Notes
- **ALWAYS** use more conservative overlap detection
- Test on LB early to verify solutions are valid
- CV matches LB when solution is valid
- If CV improves but LB fails, the solution has overlaps

## Key Techniques from Top Kernels

### C++ Optimizers (Critical for Performance)
- **bbox3**: Main optimizer with parameters `-n` (iterations) and `-r` (restarts)
- **sa_v1_parallel**: SA with fractional translation
- Uses OpenMP for parallelization

### Simulated Annealing (SA)
Key SA components:
- **Move operators:**
  - Translation: small steps (0.01-0.001 units) in 8 directions + toward center
  - Rotation: angle changes (5°, 2°, 0.8°, 0.3°, 0.1°)
  - Swap: exchange positions of two trees
- **Temperature schedule:** Start high (T0), decay to Tm
- **Acceptance:** exp(-delta/T) for worse solutions

### Post-Processing
1. Apply fix_direction() to optimize rotation of each configuration
2. Run fractional_translation for fine-tuning
3. Validate no overlaps exist with STRICT detection

## File Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```

## Reference Implementations
- Getting Started: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 Runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- SA + Fractional Translation: `../research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation/`
- Why Not (bbox3 C++): `../research/kernels/jazivxt_why-not/`

## Pre-optimized Solutions Available
- Current best valid: `/home/submission/submission.csv` (70.626088)
- Snapshot candidates: `/home/nonroot/snapshots/santa-2025/21222392487/code/submission_candidates/`

## Key Insights
1. **38 experiments all converged to same optimum** - Need fundamentally different approach
2. **Local validation is less strict than Kaggle's** - Use conservative overlap detection
3. **Small N values have highest leverage** - Focus on N=2-50
4. **Trees form crystallization patterns** - Alternating orientations
5. **NFP technique not tried** - Could provide guaranteed non-overlap placements
6. **1.23% reduction in all side lengths needed** - This is the uniform improvement target

## Score Contribution Analysis
The score formula S²/n means:
- N=1: S² contributes fully (weight = 1.0) - ALREADY OPTIMAL
- N=10: S² contributes S²/10 (weight = 0.1)
- N=100: S² contributes S²/100 (weight = 0.01)
- N=200: S² contributes S²/200 (weight = 0.005)

**CRITICAL INSIGHT:** Improving small N values has disproportionate impact on total score!