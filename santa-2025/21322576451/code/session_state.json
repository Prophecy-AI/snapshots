{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-24T22:29:50.211697",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D bin packing optimization problem: fit Christmas tree shapes (15-vertex polygons) into the smallest square bounding box for N=1 to 200 trees. Score = sum(S_n^2/n) where S_n is the side length for n trees. Lower is better.",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "Tree shape: 15-vertex polygon with trunk (0.15w x 0.2h), base tier (0.7w), middle tier (0.4w), top tier (0.25w), tip at y=0.8. Total height ~1.0 units. Trees can be rotated (deg parameter) and positioned (x,y).",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Key optimization techniques: 1) Greedy placement with weighted random angles (sin(2*angle) weighting for corners), 2) Simulated Annealing with moves: translation, rotation, swap, 3) Local search with compaction toward center, 4) Rotation tightening (optimize bounding box angle), 5) Backward propagation (remove trees from n+1 config to improve n config)",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "bbox3 tool: C++ optimizer with parameters -n (iterations) and -r (restarts). Typical values: n=1000-2000, r=30-90 for fast runs; n=5000-10000, r=256 for longer optimization. Uses OpenMP parallelization.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Post-processing: fix_direction() optimizes global rotation of each configuration to minimize bounding box. Uses scipy.optimize.minimize_scalar on convex hull points. Also shake_public tool for additional optimization.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Collision detection: Use Shapely library with STRtree for efficient spatial indexing. Check polygon.intersects() but not polygon.touches() for overlap detection. High precision Decimal arithmetic (25-30 digits) needed.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    }
  ],
  "web_research": [],
  "max_submissions": 100,
  "remaining_submissions": 100
}