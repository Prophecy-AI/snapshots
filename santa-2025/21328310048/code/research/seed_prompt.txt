# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.626 (valid baseline from snapshot 21222392487)
- Best LB score: FAILED (exp_000 had overlapping trees - invalid submission)
- Target: 68.894234
- Gap: 1.73 points (2.5% improvement needed)
- **Submissions remaining: 99** (1 used, failed)

## CRITICAL ISSUE FROM LAST EXPERIMENT
**The first submission FAILED with "Overlapping trees in group 002"**

The snapshot 21328310479 (score 70.523) had overlapping trees that passed local Shapely validation but failed Kaggle's stricter validation. The valid baseline is 70.626 from snapshot 21222392487.

**LESSON LEARNED:** Always use stricter overlap detection before submission. Kaggle's validation is more precise than local Shapely checks.

## Response to Evaluator

The evaluator correctly identified that:
1. **No active optimization** - We were just "snapshot shopping" instead of running real optimizers
2. **Need C++ optimizers** - Python is too slow for millions of iterations
3. **Backward propagation** is high-leverage - can improve many N values simultaneously
4. **Small N focus was premature** - improvements came from various N values, not just small ones

**I AGREE with all points.** The next experiment must implement actual optimization, not just select from snapshots.

## Key Insights from Kernel Research

### 1. saspav kernel (497 votes) - Best approach to implement FIRST
- Uses pre-compiled C++ binaries: `bbox3` and `shake_public`
- Pipeline: Load CSV → shake_public optimizer → check overlaps → replace invalid groups → fix_direction
- **External dataset required:** `santa-2025-csv` contains the binaries
- This is the simplest path to improvement - just run the optimizers

### 2. jonathanchan kernel - Ensemble approach
- Collects best per-N solutions from 15+ external sources
- Sources: GitHub SmartManoj scoreboard, bucket-of-chump, telegram-public-shared-solution
- Then runs C++ SA optimizer with fractional translation
- **This is the most comprehensive approach** - ensembles ALL public solutions

### 3. santa-claude kernel (378 votes) - Has backward propagation
- C++ tree_packer with SA, local search, squeeze/compaction
- **Backward propagation**: Remove trees from N=200 down to N=2
- This exploits problem structure - good large-N configs contain good small-N configs

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Implement C++ optimizer pipeline
**Why:** The evaluator is right - we need actual optimization, not snapshot shopping.

**Steps:**
1. Check if C++ binaries (bbox3, shake_public) are available in snapshots or can be compiled
2. If not, compile the C++ code from santa-claude kernel (tree_packer_v21.cpp)
3. Run optimizer on valid baseline (70.626)
4. Verify no overlaps with strict checking before submission

**Expected improvement:** 0.5-1.0 points based on kernel outputs

### 2. **[HIGH PRIORITY]** Implement ensemble approach
**Why:** Best per-N solutions from multiple sources can beat any single optimizer.

**Steps:**
1. Load all available snapshots (100+ in /home/nonroot/snapshots/santa-2025/)
2. For each N=1-200, find the best valid configuration across all snapshots
3. Combine into single submission
4. Run SA optimizer on the ensemble

**Expected improvement:** Could reach 69.x if snapshots contain diverse solutions

### 3. **[MEDIUM PRIORITY]** Backward propagation
**Why:** Exploits problem structure - good N=200 config → good N=199 → ... → good N=2

**Steps:**
1. Start with best N=200 configuration
2. For each N from 199 down to 2:
   - Remove one tree at a time, keeping best configuration
   - If better than stored N config, update it
3. This can improve many N values simultaneously

## What NOT to Try
- ❌ More snapshot shopping without optimization
- ❌ Python-only optimization (too slow)
- ❌ Submitting without strict overlap validation
- ❌ Focusing only on small N (improvements come from all N values)

## Validation Notes
- **CRITICAL:** Use strict overlap detection before submission
- Kaggle's validation is stricter than local Shapely checks
- Test overlap detection on known-invalid groups (like group 002 from failed submission)
- Score calculation: Σ (side²/n) for n=1 to 200

## Submission Strategy
- **Remaining submissions: 99** - We have plenty of quota
- **Submit after EVERY valid experiment** - LB feedback is valuable
- **Always verify no overlaps** before submission
- If experiment produces invalid submission, fix overlaps and resubmit

## Technical Notes
- Tree polygon: 15 vertices, defined by TX/TY arrays
- Each tree has (x, y, deg) - position and rotation
- Bounding box: max(width, height) of all tree vertices
- Score for N trees: side² / N
- Total score: Σ scores for N=1 to 200