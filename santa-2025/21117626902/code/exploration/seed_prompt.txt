# Santa 2025 Christmas Tree Packing - Seed Prompt

## Problem Overview
Pack Christmas tree toys (15-vertex polygons) into the smallest square bounding box for N=1 to 200 trees.
- **Metric**: sum(side^2 / N) for all N from 1 to 200 - LOWER IS BETTER
- **Target Score**: Beat 68.922808
- **Tree Geometry**: 15-vertex polygon with trunk (0.15w x 0.2h), base tier (0.7w), mid tier (0.4w), top tier (0.25w), tip at y=0.8
- **Position**: Defined at center of trunk top (x, y, rotation angle in degrees)
- **Constraints**: No overlapping trees (touching is allowed), coordinates must be in [-100, 100]

## Key Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (HIGHEST PRIORITY)
From `../research/kernels/jazivxt_why-not/why-not.ipynb` and `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`:
- **Simulated annealing** with temperature scheduling
- **Local search** with multiple move types: translation, rotation, swap
- **Squeeze/compaction**: Move trees toward center to reduce bounding box
- **Multi-start optimization** with different random seeds
- Parameters: `-n` (iterations), `-r` (restarts)
- Uses OpenMP for parallelization
- Key features: Complex number vector coordination, fluid dynamics, hinge pivot, density gradient flow

### 2. fix_direction - Rotation Tightening
From `../research/kernels/saspav_santa-submission/santa-submission.ipynb`:
- After placing trees, find optimal rotation angle for entire configuration
- Uses `scipy.optimize.minimize_scalar` with bounds (0.001, 89.999)
- Computes convex hull of all tree vertices
- Rotates entire configuration to minimize bounding box side length
- Can reduce score by finding better axis alignment

### 3. Backward Propagation
From `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`:
- Start from N=200 configuration
- Remove boundary-touching trees one by one
- If resulting (N-1) configuration is better than stored, save it
- Propagate improvements down to smaller N values
- Key insight: Good N=200 packing may contain good N=199, N=198, etc.

### 4. Greedy Placement (Baseline)
From `../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb`:
- Build configurations incrementally from N=1 to N=200
- For each new tree: start far from center, move toward center until collision
- Use weighted angle distribution favoring diagonal directions (corners)
- Back up until no overlap
- Keep 10 random attempts, select best

## Implementation Strategy

### Experiment 1: Baseline with Pre-optimized CSV
1. Download best available pre-optimized submission from Kaggle datasets
2. Run fix_direction rotation tightening
3. Validate no overlaps using shapely
4. Score and submit

### Experiment 2: C++ Optimizer (bbox3 or tree_packer)
1. Compile C++ optimizer with OpenMP: `g++ -O3 -march=native -std=c++17 -fopenmp -o optimizer optimizer.cpp`
2. Run with high iterations: `-n 10000 -r 256`
3. Apply fix_direction post-processing
4. Validate and submit

### Experiment 3: Backward Propagation
1. Start from best N=200 configuration
2. Implement backward propagation in C++
3. For each N from 200 to 2:
   - Find boundary-touching trees
   - Try removing each, keep best result
   - If better than stored N-1 config, save it
4. Apply fix_direction to all configurations
5. Submit

### Experiment 4: Constructive Greedy with Beam Search
**CRITICAL: If pre-optimized baseline is at local optimum, local search won't help!**
1. Build solutions from scratch using greedy placement
2. Use beam search: keep top K configurations at each step
3. For each N, try multiple construction strategies:
   - Different starting angles
   - Different placement orders
   - Different collision resolution strategies
4. This is FUNDAMENTALLY DIFFERENT from optimizing existing solutions

## Technical Details

### Tree Polygon Vertices (15 points)
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

### Overlap Detection
- Use shapely STRtree for efficient spatial queries
- Check: point-in-polygon AND segment intersection
- Touching (not overlapping) is allowed: `intersects() and not touches()`

### Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- Values prefixed with 's' to preserve precision
- id format: `{N:03d}_{tree_index}`

### Scoring Function
```python
def score(submission):
    total = 0
    for n in range(1, 201):
        trees = get_trees_for_n(submission, n)
        side = get_bounding_box_side(trees)
        total += side**2 / n
    return total
```

## Optimization Techniques from Research

### Corner-Occupying (CCOA) Heuristic
- Place each new tree so it touches two already-placed items
- Yields high-density packings quickly
- Good for initial solution generation

### Squeeze Operation
```python
def squeeze(config):
    cx, cy = centroid(config)
    for scale in [0.9995, 0.999, 0.9985, ...]:
        trial = scale_toward_center(config, cx, cy, scale)
        if not has_overlap(trial):
            config = trial
        else:
            break
    return config
```

### Local Search Moves
1. **Translation**: Move single tree in 8 directions with varying step sizes
2. **Rotation**: Rotate single tree by small angles
3. **Swap**: Exchange positions of two trees
4. **Compaction**: Move trees toward center

## Validation Checklist
Before submitting:
1. Check all N=1 to 200 configurations present
2. Verify no overlaps in any configuration
3. Verify all coordinates in [-100, 100]
4. Verify 's' prefix on all values
5. Calculate local score and compare to expected

## External Resources
- Pre-optimized submissions available on Kaggle datasets (search for "santa-2025-csv", "bucket-of-chump")
- SmartManoj's GitHub has updated submissions: `https://raw.githubusercontent.com/SmartManoj/Santa-Scoreboard/main/submission.csv`

## Priority Order for Experiments
1. **First**: Get baseline working with pre-optimized CSV + fix_direction
2. **Second**: Run C++ optimizer (bbox3/tree_packer) for extended time
3. **Third**: Implement backward propagation
4. **Fourth**: Try constructive approaches if local search plateaus
5. **Fifth**: Ensemble best configurations per N from different approaches
