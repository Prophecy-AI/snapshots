# Santa 2025 - Christmas Tree Packing Challenge

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack N Christmas tree shapes (N=1 to 200) into the smallest possible square bounding box for each N.

**Scoring Formula:** score = Σ(s_n² / n) for n=1 to 200, where s_n is the side length of the square bounding box for n trees.

**Target Score:** 68.890873 (lower is better)

## Tree Geometry
Each Christmas tree is a 15-vertex polygon with:
- Trunk: width=0.15, height=0.2
- Base tier: width=0.7
- Middle tier: width=0.4
- Top tier: width=0.25
- Tip at y=0.8
- Reference point at center of trunk top (0, 0)

Trees can be rotated to any angle (0-360 degrees) and positioned at any (x, y) coordinate.

## Key Approaches from Research

### 1. Simulated Annealing (bbox3 binary)
The dominant approach in public kernels uses a C++ binary optimizer called `bbox3` that implements:
- Complex number vector coordination
- Fluid dynamics-inspired movement
- Hinge pivot rotations
- Density gradient flow
- Global boundary tension
- Parallel overlap checking with OpenMP

### 2. Jostle Algorithm (Academic Research)
From academic literature on 2D irregular bin packing:
- Local search heuristic that iteratively "jostles" pieces
- Alternates packing from different directions
- Works well with free rotation
- Outperforms genetic algorithms in benchmarks

### 3. Rotation Optimization
After placing trees, optimize the global rotation angle:
- Compute convex hull of all tree vertices
- Use scipy.optimize.minimize_scalar to find angle minimizing bounding box
- Apply rotation to all trees while preserving relative positions

### 4. Greedy Placement Heuristics
- Bottom-left placement: Place each tree at the lowest, leftmost valid position
- Radial placement: Place trees along weighted random angles from center
- Step-in/step-out: Move toward center until collision, then back off

## ⛔ BLOCKED AFTER BASELINE (exp_000)
After getting baseline score, the following are PERMANENTLY FORBIDDEN:
- Running bbox3, sa_fast_v2, eazy_optimizer, or ANY pre-compiled binary
- "More iterations" or "different parameters" on existing optimizers
- Ensembling outputs from the same optimizer

## ✅ REQUIRED: IMPLEMENT FROM SCRATCH
All experiments after baseline MUST implement a novel algorithm:
1. **Jostle Algorithm** - Implement the academic jostle heuristic in Python
2. **No-Fit Polygon (NFP)** - Precompute collision-free placement regions
3. **Genetic Algorithm** - Evolve population with custom crossover/mutation
4. **Branch-and-Bound** - Exhaustive search for small N (N≤10)
5. **Constructive Heuristics** - Bottom-left, best-fit decreasing

DO NOT USE PRE-COMPILED BINARIES. IMPLEMENT THE ALGORITHM.

## Per-N Strategy
Different N values may benefit from different approaches:
- **N=1-5:** Optimal solutions may be analytically derivable
- **N=6-20:** Exhaustive search or branch-and-bound feasible
- **N=21-100:** Local search heuristics (Jostle, SA)
- **N=101-200:** Need efficient heuristics, rotation optimization critical

## Implementation Notes

### Collision Detection
Use Shapely library for polygon operations:
```python
from shapely.geometry import Polygon
from shapely.ops import unary_union
from shapely.strtree import STRtree

# Check overlap
if poly1.intersects(poly2) and not poly1.touches(poly2):
    # Collision detected
```

### Bounding Box Calculation
```python
all_polygons = [tree.polygon for tree in trees]
bounds = unary_union(all_polygons).bounds
side_length = max(bounds[2] - bounds[0], bounds[3] - bounds[1])
```

### Submission Format
- Values must be strings prefixed with 's': `s0.123456`
- Format: id,x,y,deg where id is `NNN_T` (N=tree count, T=tree index)
- Coordinates constrained to -100 ≤ x, y ≤ 100

## Recommended Experiments

### exp_000: Baseline
- Use best available pre-optimized submission from snapshots
- Verify score calculation matches expected

### exp_001: Jostle Algorithm Implementation
- Implement Jostle heuristic from academic papers
- Test on small N first (N=10, 20, 50)
- Compare against baseline per-N scores

### exp_002: Per-N Optimization
- Identify which N values have worst s²/n contribution
- Focus optimization effort on high-impact N values
- Use rotation optimization on all solutions

### exp_003: Hybrid Approach
- Combine best placements from different methods
- For each N, keep the solution with smallest bounding box
- Apply global rotation optimization

## Key Insights from Kernels

### bbox3 Runner Kernel
- Uses 3-hour budget with coarse short runs
- Only validates expensive operations on promising candidates
- Keeps best submission, reverts on regressions
- Rotation tightening via convex hull optimization

### Getting Started Kernel
- Greedy radial placement with weighted angles
- Builds incrementally: N+1 solution starts from N solution
- Uses Decimal precision for coordinates

## Validation
- Overlapping trees will cause submission error
- Use STRtree for efficient spatial queries
- Always verify no overlaps before submission

## Resources
- Kernels: `../research/kernels/`
- Sample submission: `/home/data/sample_submission.csv`
- Pre-optimized snapshots: `/home/nonroot/snapshots/santa-2025/`
