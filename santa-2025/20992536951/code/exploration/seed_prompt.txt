# Santa 2025 Seed Prompt: Christmas Tree Packing

## Problem Overview
This is a 2D optimization problem requiring the packing of $n$ identical non-convex polygons ("Christmas trees") into the smallest possible square box for each $n \in [1, 200]$.
- **Metric:** Minimize $\sum_{n=1}^{200} \frac{s_n^2}{n}$, where $s_n$ is the side length of the bounding square for $n$ trees.
- **Constraints:** No overlap between trees. Trees can be rotated and translated.
- **Precision:** High precision is critical (use `long double` in C++ or `Decimal` in Python).

## Tree Geometry
The tree is a non-convex polygon defined by the following vertices (counter-clockwise, starting from tip):
```python
[
    (0.0, 0.8),       # Tip
    (0.125, 0.5),     # Right Top Tier
    (0.0625, 0.5),
    (0.2, 0.25),      # Right Mid Tier
    (0.1, 0.25),
    (0.35, 0.0),      # Right Bottom Tier
    (0.075, 0.0),     # Right Trunk
    (0.075, -0.2),
    (-0.075, -0.2),   # Left Trunk
    (-0.075, 0.0),
    (-0.35, 0.0),     # Left Bottom Tier
    (-0.1, 0.25),
    (-0.2, 0.25),     # Left Mid Tier
    (-0.0625, 0.5),
    (-0.125, 0.5)     # Left Top Tier
]
```

## Winning Techniques

### 1. High-Performance Optimization (C++)
Python is too slow for the core optimization loop. Use C++ with OpenMP.
- **Algorithm:** Simulated Annealing (SA) or Basin Hopping.
- **State Representation:** Array of $(x, y, \theta)$ for each tree.
- **Energy Function:** Box side length $s$ (plus penalty for overlap if using soft constraints).
- **Moves:**
    - Small translation $(dx, dy)$.
    - Small rotation $d\theta$.
    - **Swap:** Swap positions of two trees.
    - **Compaction:** Move trees towards the center (physics-inspired gravity).
    - **Squeeze:** Linearly scale coordinates to shrink the bounding box until collision.

### 2. Backward Propagation (Inter-Problem Transfer)
A key insight is that a good solution for $n$ trees often contains a good solution for $n-1$ trees.
- **Method:**
    1. Solve for $n$ (e.g., $n=200$).
    2. Try removing each tree $i$ from the $n$-solution.
    3. Re-calculate the bounding box for the remaining $n-1$ trees.
    4. If this new bounding box is smaller than the current best for $n-1$, update the $n-1$ solution.
    5. Repeat downwards from $n=200$ to $n=2$.
- **Refinement:** After "dropping" a solution from $n$ to $n-1$, run a short local search/SA to further tighten it.

### 3. Geometry & Collision Detection
- **Efficient Overlap Checks:**
    - Use a grid-based spatial index or Bounding Volume Hierarchy (BVH) to prune checks.
    - **Separating Axis Theorem (SAT)** works for convex polygons, but these are non-convex. Decompose into convex parts (3 trapezoids + 1 rectangle trunk) or use point-in-polygon + edge intersection checks.
    - **Minkowski Sums:** Pre-calculate the "No-Fit Polygon" for the tree shape to quickly check valid relative positions.

### 4. Initialization Strategies
- **Lattice Packing:** Initialize trees in a grid or hexagonal lattice.
- **Greedy Construction:** Place trees one by one, minimizing the increase in bounding box size (as seen in `inversion_santa-2025-getting-started`).
- **Random Multi-Start:** Run thousands of parallel SA instances with random initializations.

## Reference Notebooks
- **`../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb`**:
    - Defines the `ChristmasTree` class and geometry.
    - Implements basic greedy packing with `shapely`.
    - Visualization tools.
- **`../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`**:
    - **CRITICAL:** Contains full C++ source code for a Simulated Annealing optimizer (`tree_packer_v21.cpp`) and Backward Propagation (`bp.cpp`).
    - Demonstrates `squeeze`, `compaction`, and `localSearch` functions.
    - Shows how to compile and run the C++ code from a notebook.

## Action Plan
1.  **Port C++ Optimizer:** Extract the C++ code from `santa-claude.ipynb`, compile it, and run it.
2.  **Implement Backward Propagation:** This is the highest-ROI strategy.
3.  **Parallelize:** Run independent optimizers for different $n$ ranges or different random seeds.
4.  **Refine Geometry:** Ensure collision detection is robust and fast (custom C++ implementation is best).
