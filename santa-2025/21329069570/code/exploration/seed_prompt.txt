# Santa 2025 Christmas Tree Packing Challenge - Seed Prompt

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding box for N=1 to 200 trees.

**Scoring:** score = Σ(side_n² / n) for n=1 to 200. Lower is better.
**Target:** Beat 68.894234

**Tree Shape (15 vertices):**
- Trunk: 0.15 width × 0.2 height (bottom)
- Base tier: 0.7 width at y=0
- Middle tier: 0.4 width at y=0.25
- Top tier: 0.25 width at y=0.5
- Tip: at y=0.8

## Score Analysis (CRITICAL)
Sample submission scores 173.65 - need to reduce by ~60% to beat target.

**Worst score contributors (from EDA):**
- N=8: contributes 1.48 to score
- N=13: contributes 1.32
- N=9: contributes 1.32
- N=7: contributes 1.20
- Small N (4-16) have highest per-tree impact due to s²/n formula

**Key insight:** Optimizing small N values (1-20) is CRITICAL. Each 0.1 reduction in side length for N=1 saves 0.01 in score, but for N=10 it saves 0.001. Focus optimization effort on small N first!

## Key Insights from Discussions (CRITICAL)

### Symmetric vs Asymmetric Solutions
- Discussion "Why winning solutions will be Asymmetric" (38 votes): Asymmetric solutions outperform symmetric for larger N
- Discussion "Symmetric solutions that are apparently optimal" (43 votes): For small N, symmetric/tessellation patterns may be optimal
- **Strategy:** Use symmetric tessellations for small N, asymmetric optimization for large N

### Per-N Optimization is Key
- Different N values require different strategies
- Small N (1-20): Exhaustive search or hand-crafted optimal solutions possible
- Medium N (20-100): Tessellation patterns + local optimization
- Large N (100-200): Simulated annealing with aggressive optimization

### Tessellations
- Efficient tessellation patterns can achieve near-optimal packing
- Trees can interlock with alternating orientations (0°, 90°, 180°, 270°)
- "Lattice crystallization" patterns observed in top solutions

## Academic Approaches for 2D Irregular Packing

### 1. No-Fit Polygon (NFP)
- Precompute collision-free regions for O(1) overlap checks
- NFP enables efficient geometry handling for placement decisions
- Critical for fast simulated annealing iterations

### 2. Simulated Annealing (SA)
- Most successful metaheuristic for this problem class
- Key components:
  - Temperature schedule (exponential cooling)
  - Move operators: translation, rotation, swap
  - Collision-free region placement
- SA with collision-free region placement achieves state-of-the-art results

### 3. Jostle Algorithm
- Iterative repacking from alternating ends
- Effective for local optimization after initial placement
- Low computational cost compared to full SA

### 4. Hybrid Genetic Algorithm + Linear Programming
- GA for global search, LP for local refinement
- Effective for complex shape arrangements

### 5. Constructive Heuristics
- Bottom-left fill
- Greedy placement with weighted angles (sin(2*angle) favors corners)
- Build solutions from scratch, then optimize

## Top Kernel Approaches

### bbox3.cpp (from jazivxt/why-not kernel)
C++ optimizer using:
- Complex number vector coordination
- Fluid dynamics simulation
- Hinge pivot moves
- Density gradient flow
- Global boundary tension
- Simulated annealing with aggressive overlap repair

Key features:
- Uses OpenMP for parallelization
- Implements multiple move types: translation, rotation, swap
- Has aggressive_repair function for overlap resolution
- Global squeeze function for dynamic scaling

### shake_public Tool
- External compiled optimizer
- Used for post-processing solutions
- Applies local moves to reduce bounding box

### Rotation Optimization
- Use convex hull of all tree vertices
- Optimize rotation angle using minimize_scalar
- Can reduce bounding box by rotating entire configuration

## Implementation Strategy

### Phase 1: Baseline (Quick)
1. Start with best available CSV solution (check if pre-optimized solutions exist)
2. Validate no overlaps
3. Calculate baseline score

### Phase 2: Per-N Optimization (Priority Order)
**CRITICAL: Start with small N values - they have highest impact!**

**Small N (1-10):**
- Hand-craft or exhaustively search optimal configurations
- N=1: Single tree, trivial (side = 1.0)
- N=2-4: Can likely find optimal by trying all rotation combinations
- These contribute significantly to score (s²/n is large for small n)

**Medium N (11-50):**
- Use tessellation patterns as starting point
- Apply local SA optimization
- Try multiple initial configurations

**Large N (51-200):**
- Start from tessellation or previous N solution
- Aggressive SA with:
  - Translation moves (small and large)
  - Rotation moves (fine-grained)
  - Swap moves between trees
  - Global squeeze/compression
- Long optimization time (these N values contribute less to score individually but sum up)

### Phase 3: Post-Processing
1. Apply rotation optimization to entire configuration
2. Run jostle/shake algorithms
3. Verify no overlaps before submission

## Critical Implementation Details

### Collision Detection
```python
# Use Shapely with high precision
from shapely.geometry import Polygon
from shapely import affinity
from shapely.strtree import STRtree

# Check overlap (not just touch)
def has_overlap(poly1, poly2):
    return poly1.intersects(poly2) and not poly1.touches(poly2)
```

### Tree Polygon Definition
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

### Bounding Box Calculation
```python
from shapely.ops import unary_union

def get_side_length(trees):
    """Calculate square bounding box side length for a list of tree polygons."""
    union = unary_union([t.polygon for t in trees])
    bounds = union.bounds  # (minx, miny, maxx, maxy)
    width = bounds[2] - bounds[0]
    height = bounds[3] - bounds[1]
    return max(width, height)
```

### Submission Format
- Values must be strings prefixed with 's': `s0.123456`
- Coordinates constrained to -100 ≤ x, y ≤ 100
- Use high precision (6+ decimal places)

## Recommended Experiments (Priority Order)

1. **Baseline Establishment**
   - Load best available solution
   - Validate and score
   - Expected: Should be close to or better than 68.89 if using optimized CSV

2. **Small N Optimization (N=1-20)** ⭐ HIGHEST PRIORITY
   - These have highest per-tree score impact
   - For N=1-5: Try all rotation combinations exhaustively
   - For N=6-20: Use SA with many restarts
   - Target: Reduce each small N score by 20-50%

3. **Tessellation Pattern Discovery**
   - Analyze top solutions for repeating patterns
   - Look for "lattice crystallization" patterns
   - Implement efficient tessellation generators

4. **Simulated Annealing Optimizer**
   - Implement in Python first, then C++ for speed
   - Focus on move operators and cooling schedule
   - Key moves: translate, rotate, swap, squeeze

5. **Per-N Targeted Optimization**
   - After baseline, identify N values with worst scores
   - Apply extra optimization time to those

## What NOT to Do
- Don't optimize all N values equally - focus on high-impact ones (small N)
- Don't use only greedy placement - SA is essential
- Don't ignore rotation optimization - can give easy gains
- Don't submit without overlap validation
- Don't spend too much time on large N (100-200) initially

## Files Reference
- Getting started kernel: `../research/kernels/inversion_santa-2025-getting-started/`
- Advanced optimizer: `../research/kernels/jazivxt_why-not/` (contains bbox3.cpp)
- Submission helper: `../research/kernels/saspav_santa-submission/`
- Sample submission: `/home/data/sample_submission.csv`

## Validation Code
```python
def validate_and_score(csv_path):
    """Validate submission has no overlaps and calculate score."""
    df = pd.read_csv(csv_path)
    df['x_val'] = df['x'].str.replace('s', '').astype(float)
    df['y_val'] = df['y'].str.replace('s', '').astype(float)
    df['deg_val'] = df['deg'].str.replace('s', '').astype(float)
    df['n'] = df['id'].apply(lambda x: int(x.split('_')[0]))
    
    total_score = 0
    for n in range(1, 201):
        group = df[df['n'] == n]
        polys = [get_tree_polygon(row['x_val'], row['y_val'], row['deg_val']) 
                 for _, row in group.iterrows()]
        
        # Check overlaps
        for i in range(len(polys)):
            for j in range(i+1, len(polys)):
                if polys[i].intersects(polys[j]) and not polys[i].touches(polys[j]):
                    print(f"OVERLAP at N={n}, trees {i} and {j}")
                    return None
        
        # Calculate score
        union = unary_union(polys)
        bounds = union.bounds
        side = max(bounds[2] - bounds[0], bounds[3] - bounds[1])
        total_score += side**2 / n
    
    return total_score
```
