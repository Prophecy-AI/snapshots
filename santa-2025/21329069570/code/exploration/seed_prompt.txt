# Santa 2025 Christmas Tree Packing Challenge - Seed Prompt

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding box for N=1 to 200 trees.

**Scoring:** score = Σ(side_n² / n) for n=1 to 200. Lower is better.
**Target:** Beat 68.894234

**Tree Shape (15 vertices):**
- Trunk: 0.15 width × 0.2 height (bottom)
- Base tier: 0.7 width at y=0
- Middle tier: 0.4 width at y=0.25
- Top tier: 0.25 width at y=0.5
- Tip: at y=0.8

## Key Insights from Discussions (CRITICAL)

### Symmetric vs Asymmetric Solutions
- Discussion "Why winning solutions will be Asymmetric" (38 votes): Asymmetric solutions outperform symmetric for larger N
- Discussion "Symmetric solutions that are apparently optimal" (43 votes): For small N, symmetric/tessellation patterns may be optimal
- **Strategy:** Use symmetric tessellations for small N, asymmetric optimization for large N

### Per-N Optimization is Key
- Different N values require different strategies
- Small N (1-20): Exhaustive search or hand-crafted optimal solutions possible
- Medium N (20-100): Tessellation patterns + local optimization
- Large N (100-200): Simulated annealing with aggressive optimization

### Tessellations
- Efficient tessellation patterns can achieve near-optimal packing
- Trees can interlock with alternating orientations (0°, 90°, 180°, 270°)
- "Lattice crystallization" patterns observed in top solutions

## Academic Approaches for 2D Irregular Packing

### 1. No-Fit Polygon (NFP)
- Precompute collision-free regions for O(1) overlap checks
- NFP enables efficient geometry handling for placement decisions
- Critical for fast simulated annealing iterations

### 2. Simulated Annealing (SA)
- Most successful metaheuristic for this problem class
- Key components:
  - Temperature schedule (exponential cooling)
  - Move operators: translation, rotation, swap
  - Collision-free region placement
- SA with collision-free region placement achieves state-of-the-art results

### 3. Jostle Algorithm
- Iterative repacking from alternating ends
- Effective for local optimization after initial placement
- Low computational cost compared to full SA

### 4. Hybrid Genetic Algorithm + Linear Programming
- GA for global search, LP for local refinement
- Effective for complex shape arrangements

### 5. Constructive Heuristics
- Bottom-left fill
- Greedy placement with weighted angles (sin(2*angle) favors corners)
- Build solutions from scratch, then optimize

## Top Kernel Approaches

### bbox3.cpp (from jazivxt/why-not kernel)
C++ optimizer using:
- Complex number vector coordination
- Fluid dynamics simulation
- Hinge pivot moves
- Density gradient flow
- Global boundary tension
- Simulated annealing with aggressive overlap repair

### shake_public Tool
- External compiled optimizer
- Used for post-processing solutions
- Applies local moves to reduce bounding box

### Rotation Optimization
- Use convex hull of all tree vertices
- Optimize rotation angle using minimize_scalar
- Can reduce bounding box by rotating entire configuration

## Implementation Strategy

### Phase 1: Baseline (Quick)
1. Start with best available CSV solution
2. Validate no overlaps
3. Calculate baseline score

### Phase 2: Per-N Optimization
For each N from 1 to 200:

**Small N (1-10):**
- Hand-craft or exhaustively search optimal configurations
- These contribute significantly to score (s²/n is large for small n)

**Medium N (11-50):**
- Use tessellation patterns as starting point
- Apply local SA optimization
- Try multiple initial configurations

**Large N (51-200):**
- Start from tessellation or previous N solution
- Aggressive SA with:
  - Translation moves (small and large)
  - Rotation moves (fine-grained)
  - Swap moves between trees
  - Global squeeze/compression
- Long optimization time (these N values contribute less to score individually but sum up)

### Phase 3: Post-Processing
1. Apply rotation optimization to entire configuration
2. Run jostle/shake algorithms
3. Verify no overlaps before submission

## Critical Implementation Details

### Collision Detection
```python
# Use Shapely with high precision
from shapely.geometry import Polygon
from shapely import affinity
from shapely.strtree import STRtree

# Check overlap (not just touch)
def has_overlap(poly1, poly2):
    return poly1.intersects(poly2) and not poly1.touches(poly2)
```

### Tree Polygon Definition
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

### Submission Format
- Values must be strings prefixed with 's': `s0.123456`
- Coordinates constrained to -100 ≤ x, y ≤ 100
- Use high precision (6+ decimal places)

## Recommended Experiments (Priority Order)

1. **Baseline Establishment**
   - Load best available solution
   - Validate and score

2. **Small N Optimization (N=1-20)**
   - These have highest per-tree score impact
   - Try exhaustive search or hand-crafted patterns

3. **Tessellation Pattern Discovery**
   - Analyze top solutions for repeating patterns
   - Implement efficient tessellation generators

4. **Simulated Annealing Optimizer**
   - Implement in Python first, then C++ for speed
   - Focus on move operators and cooling schedule

5. **Per-N Targeted Optimization**
   - Identify N values with worst scores
   - Apply extra optimization time to those

## What NOT to Do
- Don't optimize all N values equally - focus on high-impact ones
- Don't use only greedy placement - SA is essential
- Don't ignore rotation optimization - can give easy gains
- Don't submit without overlap validation

## Files Reference
- Getting started kernel: `../research/kernels/inversion_santa-2025-getting-started/`
- Advanced optimizer: `../research/kernels/jazivxt_why-not/` (contains bbox3.cpp)
- Submission helper: `../research/kernels/saspav_santa-submission/`
