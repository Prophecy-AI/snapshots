# Christmas Tree Packing Optimization - Seed Prompt

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree toys (15-vertex polygons) into the smallest possible square bounding boxes for configurations of 1-200 trees.

**Scoring:** score = Σ(side_length² / n) for n=1 to 200. Lower is better.
**Target:** Beat 68.922808

## Data Structure
- 200 configurations (n=1 to n=200 trees)
- Each tree has: x, y (center position), deg (rotation angle)
- Total 20,100 rows in submission (1+2+...+200)
- Values prefixed with 's' for string precision

## Tree Geometry (CRITICAL)
15-vertex polygon with:
- Trunk: 0.15 width × 0.2 height
- 3-tier branches: base 0.7w, mid 0.4w, top 0.25w
- Tip at y=0.8, trunk bottom at y=-0.2
- Total height ~1.0, max width 0.7

Vertex coordinates (TX, TY):
```
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## Top Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (Best Performing)
See `../research/kernels/jazivxt_why-not/` and `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`

Key techniques:
- **Complex Number Vector Coordination** for geometric operations
- **Fluid Dynamics** inspired movement
- **Hinge Pivot** rotation optimization
- **Density Gradient Flow** for compaction
- **Global Boundary Tension** to minimize bounding box
- **Aggressive Overlap Repair** using separation vectors (MTV approximation)

Multi-phase optimization:
- Phase A: Short 2-min runs with n=1000-2000, r=30-90
- Phase B: Medium 10-min runs on top candidates
- Phase C: Long 20-min runs for final refinement

### 2. Tree Packer v21 (Advanced C++)
See `../research/kernels/smartmanoj_santa-claude/`

Key techniques:
- **Simulated Annealing** with high temperature for exploration
- **Swap Moves** - exchange positions of two trees
- **Multi-angle Restarts** - try different initial rotations
- **Squeeze** - scale all trees toward center
- **Compaction** - move trees toward center in small steps
- **Local Search** - 8-directional moves + rotation adjustments
- **Backward Propagation** - remove trees from larger configs to improve smaller ones

### 3. Rotation Optimization (fix_direction)
See `../research/kernels/saspav_santa-submission/`

Key technique:
- Use ConvexHull of all tree vertices
- minimize_scalar to find optimal rotation angle (0-90°)
- Rotate entire configuration to minimize bounding box side

## Collision Detection (Essential)

### Basic Approach (used in kernels)
1. **Bounding Box Check** - quick rejection if boxes don't overlap
2. **Point-in-Polygon** - check if any vertex is inside other polygon
3. **Segment Intersection** - check if any edges cross
4. Use STRtree (Shapely) for efficient spatial queries

### Advanced: No-Fit Polygon (NFP)
The NFP is a powerful technique for 2D irregular packing:
- For polygons A and B, NFP represents all positions where B touches/overlaps A
- Reduces overlap detection from O(nm) to O(k) point-in-polygon test
- Can be computed via Minkowski sums or orbital method
- Pre-compute NFP for tree pairs to speed up placement decisions

## Recommended Implementation Strategy

### Approach 1: Implement bbox3-style optimizer (RECOMMENDED)
1. Start with greedy placement (weighted random angles)
2. Apply squeeze/compaction to reduce bounding box
3. Use local search with small position/rotation perturbations
4. Apply rotation optimization (fix_direction) as post-processing
5. Validate no overlaps before accepting improvements

### Approach 2: Simulated Annealing with Swap Moves
1. Initialize with greedy placement
2. SA moves: translate, rotate, swap positions
3. Accept worse solutions with probability exp(-delta/T)
4. Gradually reduce temperature
5. Apply compaction and rotation optimization

### Approach 3: Backward Propagation
1. Start with best known n=200 configuration
2. For n=199 down to 1:
   - Try removing each boundary-touching tree
   - Keep removal that gives smallest bounding box
   - If better than current n-config, save it

## Key Optimization Techniques

### Greedy Placement
```python
def generate_weighted_angle():
    # Favor diagonal orientations for better corner packing
    while True:
        angle = random.uniform(0, 2 * math.pi)
        if random.uniform(0, 1) < abs(math.sin(2 * angle)):
            return angle
```
- Place trees one at a time
- Move from far away toward center until collision
- Back up to valid position

### Squeeze/Compaction
```python
def squeeze(config):
    cx, cy = centroid(config)
    for scale in [0.9995, 0.999, 0.9985, ...]:
        trial = scale_toward_center(config, cx, cy, scale)
        if not has_overlap(trial):
            config = trial
        else:
            break
    return config
```

### Local Search
```python
steps = [0.01, 0.004, 0.0015, 0.0006, 0.00025, 0.0001]
rotations = [5.0, 2.0, 0.8, 0.3, 0.1]
directions = [(1,0), (-1,0), (0,1), (0,-1), (1,1), (1,-1), (-1,1), (-1,-1)]

for tree in config:
    # Try toward-center moves
    for step in steps:
        move_toward_center(tree, step)
        if improves_and_valid(): accept()
    
    # Try 8-directional moves
    for step in steps:
        for dx, dy in directions:
            move(tree, dx*step, dy*step)
            if improves_and_valid(): accept()
    
    # Try rotations
    for rot in rotations:
        for da in [rot, -rot]:
            rotate(tree, da)
            if improves_and_valid(): accept()
```

### Rotation Optimization
```python
from scipy.spatial import ConvexHull
from scipy.optimize import minimize_scalar

def optimize_rotation(trees):
    # Collect all polygon vertices
    all_points = []
    for tree in trees:
        all_points.extend(tree.polygon.exterior.coords)
    
    # Get convex hull
    hull_points = points[ConvexHull(points).vertices]
    
    # Find optimal rotation angle
    def bbox_side_at_angle(angle_deg):
        rotated = rotate_points(hull_points, angle_deg)
        return max(rotated.max(0) - rotated.min(0))
    
    result = minimize_scalar(bbox_side_at_angle, bounds=(0, 90), method='bounded')
    return result.x  # optimal angle
```

## Validation Requirements
1. No overlapping trees (intersects but not touches)
2. Coordinates within [-100, 100]
3. Values as strings with 's' prefix

## Implementation Notes

### Precision
- Use Decimal for high precision calculations
- Scale factor (e.g., 1e15) for integer-like operations
- Round to 6-12 decimal places for submission

### Performance
- Use OpenMP for parallel overlap checking (C++)
- STRtree for spatial indexing (Python/Shapely)
- Cache polygon computations
- Process all n-configurations in parallel

### Submission Format
```
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```

## Recommended Experiments (Priority Order)

1. **Implement basic greedy + squeeze + rotation optimization**
   - Should beat baseline significantly
   - Reference: getting-started notebook
   - Expected improvement: 10-20%

2. **Add local search with position/rotation perturbations**
   - Focus on boundary-touching trees (they define bounding box)
   - Reference: tree_packer_v21
   - Expected improvement: 5-10%

3. **Implement simulated annealing with swap moves**
   - Higher exploration capability
   - Reference: tree_packer_v21
   - Expected improvement: 2-5%

4. **Try backward propagation**
   - Leverage good large-n solutions for smaller n
   - Reference: smartmanoj kernel
   - Expected improvement: 1-3%

5. **Multi-start with different initial angles**
   - Run multiple times with different random seeds
   - Keep best result for each n
   - Expected improvement: 1-2%

## Critical Success Factors

1. **Focus on boundary trees** - Trees touching the bounding box edges determine the score
2. **Rotation is key** - The fix_direction optimization can significantly reduce bounding box
3. **Iterative refinement** - Multiple passes of squeeze + local search + rotation
4. **Validate thoroughly** - Overlapping submissions are rejected

## References
- Getting Started: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 Runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- Why Not (bbox3.cpp): `../research/kernels/jazivxt_why-not/`
- Santa Submission: `../research/kernels/saspav_santa-submission/`
- Santa Claude: `../research/kernels/smartmanoj_santa-claude/`
