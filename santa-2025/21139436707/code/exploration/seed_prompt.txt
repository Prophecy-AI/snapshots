# Christmas Tree Packing Optimization - Seed Prompt

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree toys (15-vertex polygons) into the smallest possible square bounding boxes for configurations of 1-200 trees.

**Scoring:** score = Σ(side_length² / n) for n=1 to 200. Lower is better.
**Target:** Beat 68.922808

## Data Structure
- 200 configurations (n=1 to n=200 trees)
- Each tree has: x, y (center position), deg (rotation angle)
- Total 20,100 rows in submission (1+2+...+200)
- Values prefixed with 's' for string precision

## Tree Geometry (CRITICAL)
15-vertex polygon with:
- Trunk: 0.15 width × 0.2 height
- 3-tier branches: base 0.7w, mid 0.4w, top 0.25w
- Tip at y=0.8, trunk bottom at y=-0.2
- Total height ~1.0, max width 0.7

## Top Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (Best Performing)
See `../research/kernels/jazivxt_why-not/` and `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`

Key techniques:
- **Complex Number Vector Coordination** for geometric operations
- **Fluid Dynamics** inspired movement
- **Hinge Pivot** rotation optimization
- **Density Gradient Flow** for compaction
- **Global Boundary Tension** to minimize bounding box
- **Aggressive Overlap Repair** using separation vectors (MTV approximation)

Multi-phase optimization:
- Phase A: Short 2-min runs with n=1000-2000, r=30-90
- Phase B: Medium 10-min runs on top candidates
- Phase C: Long 20-min runs for final refinement

### 2. Tree Packer v21 (Advanced C++)
See `../research/kernels/smartmanoj_santa-claude/`

Key techniques:
- **Simulated Annealing** with high temperature for exploration
- **Swap Moves** - exchange positions of two trees
- **Multi-angle Restarts** - try different initial rotations
- **Squeeze** - scale all trees toward center
- **Compaction** - move trees toward center in small steps
- **Local Search** - 8-directional moves + rotation adjustments
- **Backward Propagation** - remove trees from larger configs to improve smaller ones

### 3. Rotation Optimization (fix_direction)
See `../research/kernels/saspav_santa-submission/`

Key technique:
- Use ConvexHull of all tree vertices
- minimize_scalar to find optimal rotation angle (0-90°)
- Rotate entire configuration to minimize bounding box side

## Collision Detection (Essential)
1. **Bounding Box Check** - quick rejection if boxes don't overlap
2. **Point-in-Polygon** - check if any vertex is inside other polygon
3. **Segment Intersection** - check if any edges cross
4. Use STRtree (Shapely) for efficient spatial queries

## Recommended Implementation Strategy

### Approach 1: Implement bbox3-style optimizer
1. Start with greedy placement (weighted random angles)
2. Apply squeeze/compaction to reduce bounding box
3. Use local search with small position/rotation perturbations
4. Apply rotation optimization (fix_direction) as post-processing
5. Validate no overlaps before accepting improvements

### Approach 2: Simulated Annealing with Swap Moves
1. Initialize with greedy placement
2. SA moves: translate, rotate, swap positions
3. Accept worse solutions with probability exp(-delta/T)
4. Gradually reduce temperature
5. Apply compaction and rotation optimization

### Approach 3: Backward Propagation
1. Start with best known n=200 configuration
2. For n=199 down to 1:
   - Try removing each boundary-touching tree
   - Keep removal that gives smallest bounding box
   - If better than current n-config, save it

## Key Optimization Techniques

### Greedy Placement
- Place trees one at a time
- Use weighted random angles (favor diagonal orientations for corners)
- Move from far away toward center until collision
- Back up to valid position

### Squeeze/Compaction
```
for scale in [0.9995, 0.999, ...]:
    scale all positions toward center
    if no overlap: accept
    else: break
```

### Local Search
- Try small translations (0.01, 0.004, 0.0015, ...)
- Try small rotations (5°, 2°, 0.8°, ...)
- 8-directional moves + toward-center moves
- Accept if reduces bounding box without overlap

### Rotation Optimization
- Collect all polygon vertices
- Compute convex hull
- Find angle that minimizes max(width, height) of rotated hull
- Apply rotation to all trees

## Validation Requirements
1. No overlapping trees (intersects but not touches)
2. Coordinates within [-100, 100]
3. Values as strings with 's' prefix

## Implementation Notes

### Precision
- Use Decimal for high precision calculations
- Scale factor for integer-like operations
- Round to 6-12 decimal places for submission

### Performance
- Use OpenMP for parallel overlap checking
- STRtree for spatial indexing
- Cache polygon computations

### Submission Format
```
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```

## Recommended Experiments (Priority Order)

1. **Implement basic greedy + squeeze + rotation optimization**
   - Should beat baseline significantly
   - Reference: getting-started notebook

2. **Add local search with position/rotation perturbations**
   - Focus on boundary-touching trees
   - Reference: tree_packer_v21

3. **Implement simulated annealing with swap moves**
   - Higher exploration capability
   - Reference: tree_packer_v21

4. **Try backward propagation**
   - Leverage good large-n solutions for smaller n
   - Reference: smartmanoj kernel

5. **Multi-start with different initial angles**
   - Run multiple times with different random seeds
   - Keep best result for each n

## References
- Getting Started: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 Runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- Why Not (bbox3.cpp): `../research/kernels/jazivxt_why-not/`
- Santa Submission: `../research/kernels/saspav_santa-submission/`
- Santa Claude: `../research/kernels/smartmanoj_santa-claude/`
