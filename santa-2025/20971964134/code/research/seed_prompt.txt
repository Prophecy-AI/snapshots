# Santa 2025 Christmas Tree Packing - Strategy Guide (Loop 2)

## Current Status
- Best CV score: 88.33 from exp_001 (002_grid_placement)
- Best LB score: 88.33 (VERIFIED - perfect CV-LB match!)
- CV-LB gap: 0.00 → Scoring is perfectly calibrated
- Target: 68.95 (need 19.38 point improvement = 22% reduction)

## Response to Evaluator
- Technical verdict was TRUSTWORTHY - AGREE, the grid placement is solid
- Evaluator's top priority: Implement local search with fractional translation - AGREE, this is critical
- Key concerns raised:
  1. No iterative optimization after grid placement - ADDRESSING in next experiment
  2. N=1 uses 0° instead of optimal 45° - QUICK WIN: saves 0.34 points!
  3. No rotation tightening - WILL ADD
  4. Python too slow - WILL USE numba JIT for inner loops
- Evaluator's code snippet for local search is valuable - will implement

## Data Understanding
- Reference notebooks: 
  - `exploration/evolver_loop2_lb_feedback.ipynb` for score breakdown analysis
  - `research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation` for C++ implementation
- Score breakdown by N range:
  - N=1-10: 6.81 points (7.7%) - HIGH PRIORITY for optimization
  - N=11-50: 19.36 points (21.9%)
  - N=51-100: 21.46 points (24.3%)
  - N=101-150: 20.59 points (23.3%)
  - N=151-200: 20.12 points (22.8%)
- N=1 at 45° saves 0.34 points (from 1.0 to 0.66)

## Key Techniques from Top Solutions

### 1. Fractional Translation (CRITICAL)
From jonathanchan kernel - the key to fine-tuning:
```python
frac_steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]
directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (1,-1), (-1,1), (-1,-1)]
# For each tree, try moving in 8 directions with decreasing step sizes
# Accept moves that reduce bounding box without causing overlap
```

### 2. Local Search (ls_v3)
Move trees toward center:
```python
# Calculate centroid of all trees
# For each tree, move toward centroid in small steps (0.02)
# Also try small rotation adjustments (±10°)
```

### 3. Simulated Annealing
- Temperature: 1.0 → 0.000005 (geometric cooling)
- Iterations: 15000-20000 per configuration
- More iterations for small N (higher score weight)

### 4. Rotation Tightening
After placement, rotate entire configuration to minimize bounding box:
```python
from scipy.optimize import minimize_scalar
# Find optimal rotation angle (0-90°) using convex hull
```

## Recommended Approaches (Priority Order)

### Priority 1: Quick Wins + Local Search (Experiment 003)
1. **Fix N=1**: Set rotation to 45° → saves 0.34 points immediately
2. **Apply rotation tightening**: Rotate each config to minimize bbox → 5-10% improvement
3. **Basic local search**: Move trees toward center in steps of 0.02
4. **Fractional translation**: Fine-tune with smaller steps [0.01, 0.005, 0.002, 0.001]

Expected improvement: 88.33 → ~78-80 (8-10 points)

### Priority 2: Enhanced Optimization (Experiment 004)
1. Implement full fractional translation with numba JIT
2. Use step sizes: [0.02, 0.01, 0.005, 0.002, 0.001, 0.0005, 0.0002, 0.0001]
3. Add individual tree rotation optimization
4. Run multiple passes until convergence

Expected improvement: ~78 → ~72-74 (4-6 points)

### Priority 3: Simulated Annealing (Experiment 005)
1. Implement SA with proper cooling schedule
2. Use numba JIT for speed
3. Multi-start with different initial configurations
4. Combine with local search and fractional translation

Expected improvement: ~72 → ~69-70 (2-3 points)

## What NOT to Try
- Pure greedy placement (already proven inferior to grid)
- Python without JIT (too slow for competitive optimization)
- Submitting without strict overlap validation

## Validation Requirements
Before any submission:
1. Check ALL groups for overlaps using strict criteria (area > 1e-15)
2. Verify total score matches expected value
3. Use Decimal precision for final positions

## Implementation Notes

### Use numba JIT for Speed
The jonathanchan kernel shows that C++ is 100x faster than Python. We can get similar speedups with numba:
```python
from numba import njit

@njit
def get_bounding_box(xs, ys, degs, tx, ty):
    """Fast bounding box calculation."""
    pass

@njit  
def check_overlap(poly1, poly2):
    """Fast polygon overlap check."""
    pass
```

### Overlap Detection Strategy
1. Use bounding box check first (fast rejection)
2. Then detailed polygon intersection if bboxes overlap
3. Use STRtree for spatial indexing with many trees

## Score Targets
- Current: 88.33
- After Exp 003: ~78-80
- After Exp 004: ~72-74
- After Exp 005: ~69-70
- Target: 68.95

## Next Experiment: 003_local_search_optimization
Implement in this order:
1. N=1 at 45° (quick win - 0.34 points)
2. Rotation tightening for all configs (5-10% improvement)
3. Local search: move trees toward center
4. Fractional translation: fine-tune positions
5. Use numba JIT where possible for speed

This should get us to ~78-80 score, cutting the gap by ~40-50%.
