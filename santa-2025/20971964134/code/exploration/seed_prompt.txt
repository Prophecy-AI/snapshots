# 2D Christmas Tree Packing Optimization - Techniques Guide

## Problem Overview
This is a 2D bin packing optimization problem where the goal is to pack Christmas tree-shaped polygons (1-200 trees per configuration) into the smallest possible square bounding box. The score is the sum of (side_length^2 / n) for all n from 1 to 200. Lower is better.

**Target score to beat: 68.947559**

## Data Understanding
**Reference notebooks for data characteristics:**
- See `exploration/eda.ipynb` for tree geometry analysis and submission format details
- Tree shape: 15-vertex polygon with tip at (0, 0.8), trunk bottom at (0, -0.2)
- Tree dimensions: Width 0.7 at base, 0.4 mid, 0.25 top; Trunk 0.15 wide, 0.2 tall
- Submission format: id (NNN_T), x, y, deg (all prefixed with 's' for string precision)
- Total rows: 20,100 (sum of 1 to 200)

## Core Optimization Techniques

### 1. Greedy Initial Placement
- Place first tree at origin
- For each subsequent tree:
  - Start far from center at random angle
  - Move toward center until collision
  - Back up until no overlap
- Use weighted angle distribution favoring diagonal directions (abs(sin(2*angle))) to better fill square corners
- Try multiple random starting angles (10+ attempts) and keep best placement

### 2. Collision Detection
- Use Shapely library for polygon operations
- STRtree for efficient spatial indexing (O(log n) queries)
- Check intersection but not just touching (touches vs intersects)
- Use high precision Decimal arithmetic (25+ digits) with scale factor (1e15 to 1e18) for numerical stability
- No-fit polygon (NFP) technique for precise collision boundaries

### 3. Rotation Tightening (Critical Technique)
After placing trees, rotate the entire configuration to minimize bounding box:
- Extract all polygon vertices
- Compute convex hull of all points
- Use scipy.optimize.minimize_scalar to find optimal rotation angle (0-90 degrees)
- Apply rotation around configuration center
- This can significantly reduce bounding box size (often 5-10% improvement)

### 4. Local Search Optimization
- Move trees toward center in small steps (0.02, 0.008, 0.003, 0.001, 0.0004)
- Try 8-directional moves (cardinal + diagonal)
- Rotate individual trees by small angles (5, 2, 0.8, 0.3, 0.1 degrees)
- Accept moves that reduce bounding box without causing overlap
- Focus on boundary trees (those touching the bounding box edges)

### 5. Squeeze/Compaction
- Scale all positions toward center by factor (0.9995 down to 0.98)
- Accept largest squeeze that doesn't cause overlap
- Repeat iteratively until no improvement

### 6. Simulated Annealing
- Higher temperature allows accepting worse solutions temporarily
- Gradually decrease temperature (geometric cooling)
- Helps escape local minima
- Key parameters: initial temp, cooling rate, iterations per temperature
- Combine with local search moves

### 7. Swap Moves
- Exchange positions of two trees
- Particularly useful for boundary trees
- Can unlock better configurations that local moves cannot reach

### 8. Backward Propagation (Advanced)
- Start from N=200 configuration
- Identify trees touching bounding box boundary
- Remove boundary trees one at a time
- If resulting (N-1) configuration is better than stored best, update it
- Continue down to N=2
- This leverages good large configurations to improve smaller ones

### 9. L-BFGS Overlap Minimization
- Define overlap penalty function based on NFP
- Use L-BFGS to minimize total overlap
- Allows continuous optimization of positions
- Good for fine-tuning after discrete moves

## Implementation Approaches

### Python-based (Slower but easier)
- Use Shapely for geometry
- Decimal for precision
- Good for prototyping and validation
- ~10-15 seconds per configuration

### C++ Optimized (Faster, recommended for competition)
- Custom polygon intersection code (point-in-polygon, segment intersection)
- OpenMP parallelization across different N values
- Long double precision
- Can run 100x more iterations than Python
- Use -O3 -march=native optimization flags

### bbox3 Binary Optimizer
- Pre-compiled optimizer used in top solutions
- Parameters: -n (iterations, 1000-2000 typical), -r (rotation steps, 4-96)
- Higher values = better results but slower
- Run multiple times with different parameters
- Typical command: `./bbox3 -n 2000 -r 96`

## Multi-Phase Strategy
1. **Phase A (Quick exploration)**: Short runs (2 min) with various parameters to find promising settings
   - n_values: [1000, 1200, 1500, 1800, 2000]
   - r_values: [30, 60, 90]
2. **Phase B (Medium refinement)**: 10 min runs on top candidates
3. **Phase C (Deep optimization)**: 20 min runs on best few configurations
4. **Neighborhood search**: Try small variations around best parameters

## Validation
- Always check for overlaps before submission
- Use STRtree for efficient overlap detection
- Replace invalid configurations with known-good fallback
- Score calculation: sum(side^2/n) for n=1 to 200
- Validate each N independently

## Key Insights from Top Solutions
1. Rotation tightening is essential - can improve score significantly
2. Boundary trees are most important for optimization
3. Multi-start with different initial angles helps find better solutions
4. Backward propagation can improve many configurations at once
5. High precision arithmetic prevents floating point errors causing invalid overlaps
6. Lattice-like patterns emerge in optimal solutions (alternating orientations)
7. Small N configurations contribute more to score (1/n weighting)

## Recommended Workflow
1. Start with greedy placement for all N (or use existing good solution as baseline)
2. Apply rotation tightening to each configuration
3. Run local search/compaction iteratively
4. Use backward propagation to propagate improvements
5. Run simulated annealing for global optimization
6. Validate all configurations for overlaps
7. Replace any invalid configurations with fallback
8. Iterate with different random seeds/parameters
9. Keep best solution across all runs

## Score Breakdown by N
- N=1 to 10: ~0.5-1.0 each (small but significant due to 1/n weighting)
- N=11 to 50: ~0.3-0.5 each
- N=51 to 100: ~0.25-0.35 each
- N=101 to 200: ~0.2-0.3 each
- Focus optimization effort on smaller N values for maximum impact

## Common Pitfalls
- Floating point precision errors causing false overlaps
- Not validating before submission
- Spending too much time on large N (diminishing returns)
- Not using rotation tightening
- Single random seed (use multiple starts)
