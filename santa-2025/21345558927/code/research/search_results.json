{
  "query": "What techniques do top Kaggle competitors use for 2D polygon packing optimization to achieve sub-70 scores in Santa competitions?",
  "results": [
    {
      "title": "ANSWER",
      "text": "Top Kaggle competitors for 2D polygon packing optimization in Santa competitions often use heuristics such as bottom-left placement strategies, initial solution generation via integer programming or greedy approaches, and local search improvements ([ScienceDirect](https://www.sciencedirect.com/science/article/abs/pii/S0377221702001315), [LIPIcs](https://arxiv.org/abs/2403.20123)). They also employ hybrid algorithms like GA-LP and advanced nesting techniques to enhance packing efficiency ([MDPI](https://www.mdpi.com/2076-3417/13/22/12474), [arXiv](https://arxiv.org/abs/2403.20123)). Reinforcement learning approaches have been noted as less effective, with recent analyses suggesting heuristic and combinatorial optimization methods are more successful as of early 2026 ([Medium](https://hmnshudhmn24.medium.com/kaggle-santa-2025-why-reinforcement-learning-is-failing)).",
      "url": ""
    },
    {
      "title": "An algorithm for polygon placement using a bottom-left strategy",
      "text": "An algorithm for polygon placement using a bottom-left strategy - ScienceDirect\n[Skip to main content](#screen-reader-main-content)[Skip to article](#screen-reader-main-title)\n[![Elsevier logo](https://www.sciencedirect.com/shared-assets/24/images/elsevier-non-solus-new-grey.svg)ScienceDirect](https://www.sciencedirect.com/)\n[My account](https://www.sciencedirect.com/user/login?targetURL=/science/article/pii/S0377221702001315&amp;from=globalheader)\n[Sign in](https://www.sciencedirect.com/user/institution/login?targetURL=/science/article/pii/S0377221702001315)\n* [Access through**your organization**](https://www.sciencedirect.com/user/institution/login?targetUrl=/science/article/pii/S0377221702001315)\n* [Purchase PDF](https://www.sciencedirect.com/getaccess/pii/S0377221702001315/purchase)\nSearch ScienceDirect\n## Article preview\n* [Abstract](#preview-section-abstract)\n* [Introduction](#preview-section-introduction)\n* [Section snippets](#preview-section-snippets)\n* [References (20)](#preview-section-references)\n* [Cited by (107)](#preview-section-cited-by)\n[![Elsevier](https://www.sciencedirect.com/us-east-1/prod/bd96d51d266808527bf1018bd38b59c0b4bc6286/image/elsevier-non-solus.svg)](https://www.sciencedirect.com/journal/european-journal-of-operational-research)\n## [European Journal of Operational Research](https://www.sciencedirect.com/journal/european-journal-of-operational-research)\n[Volume 141, Issue 2](https://www.sciencedirect.com/journal/european-journal-of-operational-research/vol/141/issue/2),1 September 2002, Pages 371-381\n[![European Journal of Operational Research](https://ars.els-cdn.com/content/image/1-s2.0-S0377221725X00254-cov150h.gif)](https://www.sciencedirect.com/journal/european-journal-of-operational-research/vol/141/issue/2)\n# An algorithm for polygon placement using a bottom-left strategy\nAuthor links open overlay panelKathryn A.Dowslanda,SubodhVaidb,William B.Dowslanda\nShow more\nAdd to Mendeley\nShare\nCite\n[https://doi.org/10.1016/S0377-2217(02)00131-5](https://doi.org/10.1016/S0377-2217(02)00131-5)[Get rights and content](https://s100.copyright.com/AppDispatchServlet?publisherName=ELS&amp;contentID=S0377221702001315&amp;orderBeanReset=true)\n## Abstract\nThis paper describes a fast and efficient implementation of a bottom-left (BL) placement algorithm for polygon packing. The algorithm allows pieces to be nested within the partial layout produced by previously placed pieces, and produces an optimal BL layout in the sense that the positions considered are guaranteed to contain the bottom-left position of the infinite set of possibilities. Full details of the way in which these positions are calculated are given. Computational experiments comparing the results of different orderings on a variety of datasets from the literature are reported, and these illustrate that problems having in excess of 100 pieces of several piece types can be solved within one minute on a modern desktop PC. The procedure can easily be incorporated into algorithms that apply more sophisticated piece selection procedures.\n## Introduction\nThe problem of packing a given set of pieces into a sheet of fixed width in such a way as to minimise the length required occurs in a range of practical situations, including sheet-metal cutting and marker layout problems in the garment industry. A popular approach to solving such problems is to order the pieces and then place them in turn, choosing the leftmost feasible position, and breaking ties by selecting the lowest. This is known as a bottom-left (BL) placement policy. Early implementations usually involved one or more orderings based on the dimensions of the pieces, or a random sample of orderings from which the best solution was chosen. The advantages of this type of approach are its speed and simplicity, when compared with more sophisticated methods that may be able to produce solutions of higher quality. As a result there are still many commercial environments where such single pass placement policies are appropriate. Moreover interest in recent years has been boosted by implementations of modern heuristics, such as tabu search or genetic algorithms, that use a bottom-left placement policy as the basis of cost/fitness evaluation.\nAlthough there are a variety of slightly different interpretations of the bottom-left policy, these can be broadly partitioned into two classes. These are illustrated in Fig. 1, in which we assume that pieces 1\u20134 have already been placed and piece 5 is about to be placed using the relevant bottom-left definition. In the first class (Fig. 1(a)), pieces can only be placed to the right of the current packing front, in this case in-front of pieces 1, 3 or 4. The position shown is obviously the leftmost possibility within this region. Although this has the advantage of simplifying the calculations required, it will not allow smaller pieces later in the ordering to fill in gaps behind pieces already placed. The second class (Fig. 1(b)) remedies this by using a true leftmost placement policy, and allowing placements behind the packing front, a process sometimes referred to as hole-filling. When the pieces are rectangular the geometry in both cases is relatively simple. However, when irregular pieces are involved the calculation of the leftmost position for the next piece involves a complex geometric calculation, particularly if positions behind the packing front are to be considered. Although there are a number of published papers describing bottom-left algorithms for irregular pieces, many fail to provide details of the geometric calculations. Of those that do describe the geometry, most do not include hole-filling, or reduce the feasible positions to a finite set of points (often based on a grid). Others are restricted to very small problem instances or suggest prohibitive amounts of computational time for instances of moderate size. In this paper we present a bottom-left algorithm, complete with geometric details, that has proved to be both fast and effective on datasets of up to several hundred irregular pieces.\nThe next section provides an overview of the problem and cites some of the published bottom-left algorithms for its solution. This is followed by an outline of the underlying geometric concept of our algorithm, the no-fit polygon. We describe the algorithmic framework, filling in the details in the following section, before going on to outline a series of modifications designed to reduce the computational effort required. Finally computational experiments, comparing different ordering rules on a range of different datasets, are presented.\n## Section snippets\n## The problem\nThe problem can be stated as follows.\n*Given*: A stock sheet of infinite length and fixed width W, and a set of irregular pieces,*i*=1,\u2026,*n*, represented as simple polygons (i.e. polygons without holes).\n*Objective*: To pack all of the pieces onto the sheet without overlap, so as to minimise the length required.\nWe assume that rotation of the pieces is not allowed and that the*n*pieces constitute*m*piece types or shapes,*k*=1,\u2026,*m*, where there are*b**k*copies of type*k*, and \u2211*k*=1*m**b**k*=*n*. The vertices of each\n## The basic algorithm\nIn this section we describe the framework that forms the basis of our algorithm. Shapes are packed onto the sheet starting from the left-hand edge of the sheet and moving towards the right-hand (open) end, such that each shape assumes a bottom-left position. This process can be stated formally as follows:\n> Given an ordering of pieces and a partial packing of pieces 1 to (\n*> j\n*> \u22121), place piece *> j\n*> as far as to the left as possible, subject to the no overlap constraints. If there is more than one such\n## Improving algorithm efficiency\nThe set of feasible positions in the polygon packing algorithm is found by inspecting the edges of the NFPs of the moving shape and all fixed shapes already placed. It is obvious that the number of NFP edges increases as we move from the leftm...",
      "url": "https://www.sciencedirect.com/science/article/abs/pii/S0377221702001315"
    },
    {
      "title": "Optimizing Two-Dimensional Irregular Packing: A Hybrid Approach ...",
      "text": "Next Article in Journal\n\n[The Detection of Aggressive Driving Patterns in Two-Wheeled Vehicles Using Sensor-Based Approaches](https://www.mdpi.com/2076-3417/13/22/12475)\n\nPrevious Article in Journal\n\n[Evaluation of Factors Affecting the MgO\u2013C Refractory Lining Degradation in a Basic Oxygen Furnace](https://www.mdpi.com/2076-3417/13/22/12473)\n\n## Journals\n\n[Active Journals](https://www.mdpi.com/about/journals) [Find a Journal](https://www.mdpi.com/about/journalfinder) [Journal Proposal](https://www.mdpi.com/about/journals/proposal) [Proceedings Series](https://www.mdpi.com/about/proceedings)\n\n[**Topics**](https://www.mdpi.com/topics)\n\n## Information\n\n[For Authors](https://www.mdpi.com/authors) [For Reviewers](https://www.mdpi.com/reviewers) [For Editors](https://www.mdpi.com/editors) [For Librarians](https://www.mdpi.com/librarians) [For Publishers](https://www.mdpi.com/publishing_services) [For Societies](https://www.mdpi.com/societies) [For Conference Organizers](https://www.mdpi.com/conference_organizers)\n\n[Open Access Policy](https://www.mdpi.com/openaccess) [Institutional Open Access Program](https://www.mdpi.com/ioap) [Special Issues Guidelines](https://www.mdpi.com/special_issues_guidelines) [Editorial Process](https://www.mdpi.com/editorial_process) [Research and Publication Ethics](https://www.mdpi.com/ethics) [Article Processing Charges](https://www.mdpi.com/apc) [Awards](https://www.mdpi.com/awards) [Testimonials](https://www.mdpi.com/testimonials)\n\n[**Author Services**](https://www.mdpi.com/authors/english)\n\n## Initiatives\n\n[Sciforum](https://sciforum.net) [MDPI Books](https://www.mdpi.com/books) [Preprints.org](https://www.preprints.org) [Scilit](https://www.scilit.com) [SciProfiles](https://sciprofiles.com) [Encyclopedia](https://encyclopedia.pub) [JAMS](https://jams.pub) [Proceedings Series](https://www.mdpi.com/about/proceedings)\n\n## About\n\n[Overview](https://www.mdpi.com/about) [Contact](https://www.mdpi.com/about/contact) [Careers](https://careers.mdpi.com) [News](https://www.mdpi.com/about/announcements) [Press](https://www.mdpi.com/about/press) [Blog](http://blog.mdpi.com/)\n\n[Sign In / Sign Up](https://www.mdpi.com/user/login)\n\n## Notice\n\nYou can make submissions to other journals\n[here](https://susy.mdpi.com/user/manuscripts/upload).\n\n_clear_\n\n## Notice\n\nYou are accessing a machine-readable page. In order to be human-readable, please install an RSS reader.\n\nContinueCancel\n\n_clear_\n\nAll articles published by MDPI are made immediately available worldwide under an open access license. No special\npermission is required to reuse all or part of the article published by MDPI, including figures and tables. For\narticles published under an open access Creative Common CC BY license, any part of the article may be reused without\npermission provided that the original article is clearly cited. For more information, please refer to\n[https://www.mdpi.com/openaccess](https://www.mdpi.com/openaccess).\n\nFeature papers represent the most advanced research with significant potential for high impact in the field. A Feature\nPaper should be a substantial original Article that involves several techniques or approaches, provides an outlook for\nfuture research directions and describes possible research applications.\n\nFeature papers are submitted upon individual invitation or recommendation by the scientific editors and must receive\npositive feedback from the reviewers.\n\nEditor\u2019s Choice articles are based on recommendations by the scientific editors of MDPI journals from around the world.\nEditors select a small number of articles recently published in the journal that they believe will be particularly\ninteresting to readers, or important in the respective research area. The aim is to provide a snapshot of some of the\nmost exciting work published in the various research areas of the journal.\n\nOriginal Submission Date Received: .\n\n[Submit to this Journal](https://susy.mdpi.com/user/manuscripts/upload?form%5Bjournal_id%5D%3D90) [Review for this Journal](https://susy.mdpi.com/volunteer/journals/review) [Propose a Special Issue](https://www.mdpi.com/journalproposal/sendproposalspecialissue/applsci)\n\n[\u25ba\u25bc\\\nArticle Menu](https://www.mdpi.com/www.mdpi.com)\n\n## Article Menu\n\n- [Academic Editor](https://www.mdpi.com/www.mdpi.com#academic_editors)\n[Gaetano Zizzo](https://sciprofiles.com/profile/233465?utm_source=mdpi.com&utm_medium=website&utm_campaign=avatar_name)\n\n- [Recommended Articles](https://www.mdpi.com/www.mdpi.com)\n- [Related Info Link](https://www.mdpi.com/www.mdpi.com#related)\n\n\n- [Google Scholar](http://scholar.google.com/scholar?q=Optimizing%20Two-Dimensional%20Irregular%20Packing%3A%20A%20Hybrid%20Approach%20of%20Genetic%20Algorithm%20and%20Linear%20Programming)\n\n- [More by Authors Links](https://www.mdpi.com/www.mdpi.com#authors)\n\n\n- on DOAJ\n\n\n- [Liu, C.](http://doaj.org/search/articles?source=%7B%22query%22%3A%7B%22query_string%22%3A%7B%22query%22%3A%22%5C%22Cheng%20Liu%5C%22%22%2C%22default_operator%22%3A%22AND%22%2C%22default_field%22%3A%22bibjson.author.name%22%7D%7D%7D)\n- [Si, Z.](http://doaj.org/search/articles?source=%7B%22query%22%3A%7B%22query_string%22%3A%7B%22query%22%3A%22%5C%22Zhujun%20Si%5C%22%22%2C%22default_operator%22%3A%22AND%22%2C%22default_field%22%3A%22bibjson.author.name%22%7D%7D%7D)\n- [Hua, J.](http://doaj.org/search/articles?source=%7B%22query%22%3A%7B%22query_string%22%3A%7B%22query%22%3A%22%5C%22Jun%20Hua%5C%22%22%2C%22default_operator%22%3A%22AND%22%2C%22default_field%22%3A%22bibjson.author.name%22%7D%7D%7D)\n- [Jia, N.](http://doaj.org/search/articles?source=%7B%22query%22%3A%7B%22query_string%22%3A%7B%22query%22%3A%22%5C%22Na%20Jia%5C%22%22%2C%22default_operator%22%3A%22AND%22%2C%22default_field%22%3A%22bibjson.author.name%22%7D%7D%7D)\n\n- on Google Scholar\n\n\n- [Liu, C.](http://scholar.google.com/scholar?q=Cheng%20Liu)\n- [Si, Z.](http://scholar.google.com/scholar?q=Zhujun%20Si)\n- [Hua, J.](http://scholar.google.com/scholar?q=Jun%20Hua)\n- [Jia, N.](http://scholar.google.com/scholar?q=Na%20Jia)\n\n- on PubMed\n\n\n- [Liu, C.](http://www.pubmed.gov/?cmd=Search&term=Cheng%20Liu)\n- [Si, Z.](http://www.pubmed.gov/?cmd=Search&term=Zhujun%20Si)\n- [Hua, J.](http://www.pubmed.gov/?cmd=Search&term=Jun%20Hua)\n- [Jia, N.](http://www.pubmed.gov/?cmd=Search&term=Na%20Jia)\n\n[Article Views](https://www.mdpi.com/www.mdpi.com#metrics)\n\n[Citations-](https://www.mdpi.com/www.mdpi.com#metrics)\n\n- [Table of Contents](https://www.mdpi.com/www.mdpi.com#table_of_contents)\n\nAltmetric [_share_ Share](https://www.mdpi.com/www.mdpi.com) [_announcement_ Help](https://www.mdpi.com/www.mdpi.com) [_format\\_quote_ Cite](javascript:void(0);) [_question\\_answer_ Discuss in SciProfiles](https://sciprofiles.com/discussion-groups/public/10.3390/app132212474?utm_source=mpdi.com&utm_medium=publication&utm_campaign=discuss_in_sciprofiles)\n\n## Need Help?\n\n### Support\n\nFind support for a specific problem in the support section of our website.\n\n[Get Support](https://www.mdpi.com/about/contactform)\n\n### Feedback\n\nPlease let us know what you think of our products and services.\n\n[Give Feedback](https://www.mdpi.com/feedback/send)\n\n### Information\n\nVisit our dedicated information section to learn more about MDPI.\n\n[Get Information](https://www.mdpi.com/authors)\n\n_clear_\n\n## JSmol Viewer\n\n_clear_\n\n_first\\_page_\n\n[Download PDF](https://www.mdpi.com/2076-3417/13/22/12474/pdf?version=1700299125)\n\n_settings_\n\n[Order Article Reprints](https://www.mdpi.com/2076-3417/13/22/12474/reprints)\n\nFont Type:\n\n_Arial__Georgia__Verdana_\n\nFont Size:\n\nAaAaAa\n\nLine Spacing:\n\n_\uf034__\uf034__\uf034_\n\nColumn Width:\n\n_\uf035__\uf035__\uf035_\n\nBackground:\n\nOpen AccessArticle\n\n# Optimizing Two-Dimensional Irregular Packing: A Hybrid Approach of Genetic Algorithm and Linear Programming\n\nby\n\nCheng Liu\n\nCheng Liu\n\n[SciProfiles](https://sciprofiles.com/profile/author/a1gxUFRla1FIcnlDQ1ZMTCtLYjUxTXB6dTlIcWtsaERCOHUrSzNkam9Ebz0=?utm_source=mdpi.com&utm_medium=website&utm_campaign=avatar_name) [Scilit](https://scilit.com/scholars?q=Cheng%20...",
      "url": "https://www.mdpi.com/2076-3417/13/22/12474"
    },
    {
      "title": "Kaggle Competitions - Optimization",
      "text": "Checking your browser - reCAPTCHA\nChecking your browser before accessing www.kaggle.com ...\nClick[here](#)if you are not automatically redirected after 5 seconds.",
      "url": "https://www.kaggle.com/competitions?tagIds=15002-Optimization"
    },
    {
      "title": "Best-fit bin packing - Wikipedia",
      "text": "Best-fit bin packing - Wikipedia\n[Jump to content](#bodyContent)\n[![](https://en.wikipedia.org/static/images/icons/wikipedia.png)![Wikipedia](https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg)![The Free Encyclopedia](https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg)](https://en.wikipedia.org/wiki/Main_Page)\n[Search](https://en.wikipedia.org/wiki/Special:Search)\nSearch\n# Best-fit bin packing\nAdd languages\n[Add links](https://www.wikidata.org/wiki/Special:EntityPage/Q108208260#sitelinks-wikipedia)\nFrom Wikipedia, the free encyclopedia\n**Best-fit**is an[online algorithm](https://en.wikipedia.org/wiki/Online_algorithm)for[bin packing](https://en.wikipedia.org/wiki/Bin_packing). Its input is a list of items of different sizes. Its output is a*packing*- a partition of the items into bins of fixed capacity, such that the sum of sizes of items in each bin is at most the capacity. Ideally, we would like to use as few bins as possible, but minimizing the number of bins is an NP-hard problem. The best-fit algorithm uses the following[heuristic](https://en.wikipedia.org/wiki/Heuristic):\n* It keeps a list of open bins, which is initially empty.\n* When an item arrives, it finds the bin with the*maximum load*into which the item can fit, if any. The*load*of a bin is defined as the sum of sizes of existing items in the bin before placing the new item.\n* If such a bin is found, the new item is placed inside it.\n* Otherwise, a new bin is opened and the coming item is placed inside it.\n## Approximation ratio\n[[edit](https://en.wikipedia.org/w/index.php?title=Best-fit_bin_packing&amp;action=edit&amp;section=1)]\nDenote by BF(L) the number of bins used by Best-Fit, and by OPT(L) the optimal number of bins possible for the list L. The analysis of BF(L) was done in several steps.\n* The first upper bound ofBF(L)&#x2264;1.7OPT+3{\\\\displaystyle BF(L)\\\\leq 1.7\\\\mathrm {OPT} +3}![{\\displaystyle BF(L)\\leq 1.7\\mathrm {OPT} +3}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d76c1b6a7470194a741c95dc840e8bc5428ced2f)was proven by Ullman[&#91;1&#93;](#cite_note-Ullman71-1)in 1971.\n* An improved upper boundBF(L)&#x2264;1.7OPT+2{\\\\displaystyle BF(L)\\\\leq 1.7\\\\mathrm {OPT} +2}![{\\displaystyle BF(L)\\leq 1.7\\mathrm {OPT} +2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/5dbc9d649daee60612381c9decadd404ccb4b052)was proved by Garey, Graham and Ullman,[&#91;2&#93;](#cite_note-GareyGU72-2)Johnson and Demers.[&#91;3&#93;](#cite_note-3)\n* Afterward, it was improved by Garey, Graham, Johnson, Ullman, Yao and Chi-Chih[&#91;4&#93;](#cite_note-GareyGJY-4)toBF(L)&#x2264;&#x2308;1.7OPT&#x2309;{\\\\displaystyle BF(L)\\\\leq \\\\lceil 1.7\\\\mathrm {OPT} \\\\rceil }![{\\displaystyle BF(L)\\leq \\lceil 1.7\\mathrm {OPT} \\rceil }](https://wikimedia.org/api/rest_v1/media/math/render/svg/16bcbd89a08281cf641eb6e9e09fea63b6c1b1f1).\n* Finally this bound was improved toFF(L)&#x2264;&#x230A;1.7OPT&#x230B;{\\\\displaystyle FF(L)\\\\leq \\\\lfloor 1.7\\\\mathrm {OPT} \\\\rfloor }![{\\displaystyle FF(L)\\leq \\lfloor 1.7\\mathrm {OPT} \\rfloor }](https://wikimedia.org/api/rest_v1/media/math/render/svg/6a2cb96779fb14031f0ed38d9e97a2bad081af22)by D\u00f3sa and Sgall.[&#91;5&#93;](#cite_note-D\u00f3saSgall14-5)They also present an example input listL{\\\\displaystyle L}![{\\displaystyle L}](https://wikimedia.org/api/rest_v1/media/math/render/svg/103168b86f781fe6e9a4a87b8ea1cebe0ad4ede8), for thatBF(L){\\\\displaystyle BF(L)}![{\\displaystyle BF(L)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/bba6fb8e04a7051b49cdc452cc1358a94bad9966)matches this bound.\n## Worst-fit\n[[edit](https://en.wikipedia.org/w/index.php?title=Best-fit_bin_packing&amp;action=edit&amp;section=2)]\n**Worst-Fit**is a \"dual\" algorithm to best-fit: it tries to put the next item in the bin with*minimum*load.\nThis algorithm can behave as badly as[Next-Fit](https://en.wikipedia.org/wiki/Next-fit_bin_packing), and will do so on the worst-case list for thatNF(L)=2&#x22C5;OPT(L)&#x2212;2{\\\\displaystyle NF(L)=2\\\\cdot \\\\mathrm {OPT} (L)-2}![{\\displaystyle NF(L)=2\\cdot \\mathrm {OPT} (L)-2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2b2d6d882219628ed08a2d1da56f815a27da08f0).[&#91;6&#93;](#cite_note-johnson732-6)Furthermore, it holds thatRWF&#x221E;(size&#x2264;&#x03B1;)=RNF&#x221E;(size&#x2264;&#x03B1;){\\\\displaystyle R\\_{WF}^{\\\\infty }({\\\\text{size}}\\\\leq \\\\alpha )=R\\_{NF}^{\\\\infty }({\\\\text{size}}\\\\leq \\\\alpha )}![{\\displaystyle R_{WF}^{\\infty }({\\text{size}}\\leq \\alpha )=R_{NF}^{\\infty }({\\text{size}}\\leq \\alpha )}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0d02ad4a5d1afb6c522a2210ca658ae679b83850).\nSince Worst-Fit is an AnyFit-algorithm, there exists an AnyFit-algorithm such thatRAF&#x221E;(&#x03B1;)=RNF&#x221E;(&#x03B1;){\\\\displaystyle R\\_{AF}^{\\\\infty }(\\\\alpha )=R\\_{NF}^{\\\\infty }(\\\\alpha )}![{\\displaystyle R_{AF}^{\\infty }(\\alpha )=R_{NF}^{\\infty }(\\alpha )}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f77ec8fb43f6da1b4503f217b7a541b97ce638ed).[&#91;6&#93;](#cite_note-johnson732-6)\n## References\n[[edit](https://en.wikipedia.org/w/index.php?title=Best-fit_bin_packing&amp;action=edit&amp;section=3)]\n1. **[^](#cite_ref-Ullman71_1-0)**> Ullman, J. D. (1971). \"The performance of a memory allocation algorithm\". *> Technical Report 100 Princeton Univ\n*> .\n2. **[^](#cite_ref-GareyGU72_2-0)**> Garey, M. R; Graham, R. L; Ullman, J. D. (1972). \"Worst-case analysis of memory allocation algorithms\". *> Proceedings of the fourth annual ACM symposium on Theory of computing - STOC '72\n*> . pp.&#160;\n> 143\u2013\n> 150. [> doi\n](https://en.wikipedia.org/wiki/Doi_(identifier))> :\n[> 10.1145/800152.804907\n](https://doi.org/10.1145/800152.804907)> . [> S2CID\n](https://en.wikipedia.org/wiki/S2CID_(identifier))> &#160;\n[> 26654056\n](https://api.semanticscholar.org/CorpusID:26654056)> .\n3. **[^](#cite_ref-3)**David S. Johnson, Alan J. Demers, Jeffrey D. Ullman, M. R. Garey, Ronald L. Graham.[Worst-Case Performance Bounds for Simple One-Dimensional Packing Algorithms](http://www.math.ucsd.edu/~fan/ron/papers/74_04_one_dimensional_packing.pdf). SICOMP, Volume 3, Issue 4. 1974.\n4. **[^](#cite_ref-GareyGJY_4-0)**> Garey, M. R; Graham, R. L; Johnson, D. S; Yao, Andrew Chi-Chih (1976). [> \"Resource constrained scheduling as generalized bin packing\"\n](https://doi.org/10.1016/0097-3165(76)90001-7)> . *> Journal of Combinatorial Theory, Series A\n*> . **> 21\n**> (3): > 257\u2013\n> 298. [> doi\n](https://en.wikipedia.org/wiki/Doi_(identifier))> :\n[> 10.1016/0097-3165(76)90001-7\n](https://doi.org/10.1016/0097-3165(76)90001-7)> . [> ISSN\n](https://en.wikipedia.org/wiki/ISSN_(identifier))> &#160;\n[> 0097-3165\n](https://search.worldcat.org/issn/0097-3165)> .\n5. **[^](#cite_ref-D\u00f3saSgall14_5-0)**> Gy\u00f6rgy, D\u00f3sa; Sgall, Jir\u00ed (2014). \"Optimal Analysis of Best Fit Bin Packing\". *> Automata, Languages, and Programming\n*> . Lecture Notes in Computer Science. Vol.&#160;8572. pp.&#160;\n> 429\u2013\n> 441. [> doi\n](https://en.wikipedia.org/wiki/Doi_(identifier))> :\n[> 10.1007/978-3-662-43948-7_36\n](https://doi.org/10.1007/978-3-662-43948-7_36)> . [> ISBN\n](https://en.wikipedia.org/wiki/ISBN_(identifier))> &#160;\n[> 978-3-662-43947-0\n](https://en.wikipedia.org/wiki/Special:BookSources/978-3-662-43947-0)> .\n6. ^[***a***](#cite_ref-johnson732_6-0)[***b***](#cite_ref-johnson732_6-1)> Johnson, David S (1973). [> \"Near-optimal bin packing algorithms\"\n](https://dspace.mit.edu/bitstream/handle/1721.1/57819/17595570-MIT.pdf?sequence=2)> > (PDF)\n> . *> Massachusetts Institute of Technology\n*> .\nRetrieved from \"[https://en.wikipedia.org/w/index.php?title=Best-fit\\_bin\\_packing&amp;&amp;oldid=1190559703](https://en.wikipedia.org/w/index.php?title=Best-fit_bin_packing&amp;oldid=1190559703)\"\n[Category](https://en.wikipedia.org/wiki/Help:Category):\n* [Bin packing](https://en.wikipedia.org/wiki/Category:Bin_packing)\nSearch\nSearch\nBest-fit bin packing\n[](#)[](#)[](#)[](#)[](#)[](#)[](#)\nAdd languages[Add topic](#)",
      "url": "https://en.wikipedia.org/wiki/Best-fit_bin_packing"
    },
    {
      "title": "A New Algorithm for Optimal Bin Packing - AAAI",
      "text": "A New Algorithm for Optimal Bin Packing\nRichard E. Korf\nComputer Science Department\nUniversity of California, Los Angeles\nLos Angeles, CA 90095\nkorf@cs.ucla.edu\nAbstract\nWe consider the NP-complete problem of bin packing. Given\na set of numbers, and a set of bins of fixed capacity, find the\nminimum number of bins needed to contain all the numbers,\nsuch that the sum of the numbers assigned to each bin does\nnot exceed the bin capacity. We present a new algorithm for\noptimal bin packing. Rather than considering the different\nbins that each number can be placed into, we consider the dif\u0002ferent ways in which each bin can be packed. Our algorithm\nappears to be asymptotically faster than the best existing op\u0002timal algorithm, and runs more that a thousand times faster\non problems with 60 numbers.\nIntroduction and Overview\nGiven a set of numbers, and a fixed bin capacity, the bin\u0002packing problem is to assign each number to a bin so that the\nsum of all numbers assigned to each bin does not exceed the\nbin capacity. An optimal solution to a bin-packing problem\nuses the fewest number of bins possible. For example, given\nthe set of elements 6, 12, 15, 40, 43, 82, and a bin capacity\nof 100, we can assign 6, 12, and 82 to one bin, and 15, 40,\nand 43 to another, for a total of two bins. This is an optimal\nsolution to this problem instance, since the sum of all the\nelements (198) is greater than 100, and hence at least two\nbins are required.\nOptimal bin packing one of the classic NP-complete prob\u0002lems (Garey & Johnson 1979). The vast majority of the liter\u0002ature on this problem concerns polynomial-time approxima\u0002tion algorithms, such as first-fit and best-fit decreasing, and\nthe quality of the solutions they compute, rather than opti\u0002mal solutions. We discuss these approximation algorithms\nin the next section.\nThe best existing algorithm for optimal bin packing is due\nto Martello and Toth (Martello & Toth 1990a; 1990b). We\npresent a new algorithm for optimal bin packing, which we\ncall bin completion, that explores a different problem space,\nand appears to be asymptotically faster than the Martello and\nToth algorithm. On problems of size 60, bin completion runs\nmore than a thousand times faster than Martello and Toth\u2019s\nalgorithm. We are able to optimally solve problems with 90\nelements in an average of 2.5 seconds per problem.\nCopyright \u0001c 2002, American Association for Artificial Intelli\u0002gence (www.aaai.org). All rights reserved.\nApproximation Algorithms\nA simple approximation algorithm is called first-fit decreas\u0002ing (FFD). The elements are sorted in decreasing order of\nsize, and the bins are kept in a fixed order. Each element\nis placed into the first bin that it fits into, without exceeding\nthe bin capacity. For example, given the elements 82, 43, 40,\n15, 12, 6, and a bin capacity of 100, first-fit decreasing will\nplace 82 in the first bin, 43 in a second bin, 40 in the second\nbin, 15 in the first bin, 12 in the second bin, and 6 in a third\nbin, for a total of three bins, which is one more than optimal.\nA slightly better approximation algorithm is known as\nbest-fit decreasing (BFD). It also sorts the elements in de\u0002creasing order of size, but puts each element into the fullest\nbin in which is fits. It can be implemented by keeping the\nbins sorted in increasing order of their remaining capacity,\nand placing each element into the first bin in which it fits.\nFor example, given the set of elements 82, 43, 40, 15, 12, 6,\nbest-fit decreasing will place 82 in bin a, 43 in bin b, 40 in\nbin b, 15 in bin b, because it is fuller than bin a, 12 in bin a,\nand 6 in bin a, for a total of two bins, which is optimal.\nBoth FFD and BFD can be implemented in O(n log n)\ntime, but are not guaranteed to return optimal solutions.\nHowever, either algorithm is guaranteed to return a solution\nthat uses no more than 11/9 of the optimal number of bins\n(Johnson 1973). On average, BFD performs slightly better\nthan FFD. For example, on problems of 90 elements, where\nthe elements are uniformly distributed from zero to one mil\u0002lion, and the bin capacity is one million, BFD uses an av\u0002erage of 47.732 bins, while FFD uses an average of 47.733\nbins. On these same problem instances, the optimal solution\naverages 47.680 bins. The FFD solution is optimal 94.694%\nof the time, and the BFD solution is optimal 94.832% of the\ntime on these problem instances.\nOptimal Solutions\nGiven the high quality solutions returned by these approxi\u0002mation algorithms, why bother trying to find optimal solu\u0002tions? There are at least four reasons. In some applications,\nit may be important to have optimal solutions. In particular,\nwith small numbers of bins, even a single extra bin is rel\u0002atively expensive. In addition, being able to determine the\noptimal solutions to problem instances allows us to more ac\u0002curately gauge the quality of approximate solutions. For ex\u0002ample, the above comparisons of FFD and BFD solutions to\nAAAI-02 731\nFrom: AAAI-02 Proceedings. Copyright \u00a9 2002, AAAI (www.aaai.org). All rights reserved. \noptimal solutions were only possible because we could com\u0002pute the optimal solutions. Another reason is that an any\u0002time algorithm for finding optimal solutions, such as those\npresented in this paper, can make use of any additional time\navailable to find better solutions than those returned by BFD\nor FFD, which run very fast in practice. Finally, optimal bin\npacking is an interesting computational challenge, and may\nlead to insights applicable to other problems.\nEstimated Wasted Space or L2 Lower Bound\nA lower bound function for bin packing takes a problem in\u0002stance, and efficiently computes a lower bound on the mini\u0002mum number of bins needed. If we find a solution that uses\nthe same number of bins as a lower bound, then we know\nthat solution is optimal, and we can terminate the search.\nAn obvious lower bound is to sum all the elements, divide\nby the bin capacity, and round up to the next larger integer.\nA better bound starts with the sum of the elements, and adds\nan estimate of the total bin capacity that must be wasted in\nany solution, before dividing by the bin capacity. This is\nthe L2 bound of Martello and Toth (Martello & Toth 1990a;\n1990b), but we give a simpler and more intuitive algorithm\nfor computing it below.\nFor example, consider the set of elements 99, 97, 94, 93,\n8, 5, 4, 2, with a bin capacity of 100. There is no element\nsmall enough to go in the same bin as the 99, so that bin\nwill have one unit of wasted space in any solution. The only\nelement small enough to go in the same bin as the 97 is the\n2, so the 2 can be placed with the 97 without sacrificing\noptimality, leaving a second unit of wasted space.\nThere are two remaining elements that could be placed\nwith the 94, the 5 or the 4. In reality, only one of these el\u0002ements could be placed with the 94, but to make our lower\u0002bound calculation efficient and avoid any branching, we as\u0002sume that we can place as much of their sum (9) as will fit in\nthe bin with the 94, or 6 units. Thus, we assume there is no\nwasted space in this bin, and 3 units are carried over to the\nnext bin, which contains the 93. The sum of all elements less\nthan or equal to the residual capacity of this bin (7) is just\nthe 3 units carried over from the previous bin. Therefore,\nat least 7 \u2212 3=4 additional units will be wasted between\nthis bin and the previous one. Finally, there are no remain\u0002ing elements to be placed with the 8, so 92 units must be\nwasted in this bin. Thus, the total wasted space will be at\nleast 1 + 1 + 4 + 92 = 98 units, which is added to the sum\nof all the elements before dividing by the bin capacity.\nThis estimated wasted-space calculation proceeds as fol\u0002lows. We consider the elements in decreasing order of size.\nGiven an element x, the residual capacity r of the bin con\u0002taining x is r = c \u2212 x, where c is the bin capacity. We\nthen consider the sum s of all elements less than or equal to\nr, which have not already been assigned to a previous bin.\nThere are thr...",
      "url": "https://cdn.aaai.org/AAAI/2002/AAAI02-110.pdf"
    },
    {
      "title": "algorithm - Packing arbitrary polygons within an arbitrary boundary",
      "text": "2024 Developer survey is here and we would like to hear from you!\n[Take the 2024 Developer Survey](https://stackoverflow.com/dev-survey/start?utm_medium=referral&utm_source=stackexchange-community&utm_campaign=dev-survey-2024&utm_content=announcement-banner)\n\n##### Collectives\u2122 on Stack Overflow\n\nFind centralized, trusted content and collaborate around the technologies you use most.\n\n[Learn more about Collectives](https://stackoverflow.com/collectives)\n\n**Teams**\n\nQ&A for work\n\nConnect and share knowledge within a single location that is structured and easy to search.\n\n[Learn more about Teams](https://stackoverflow.co/teams/)\n\nGet early access and see previews of new features.\n\n[Learn more about Labs](https://stackoverflow.co/labs/)\n\n# [Packing arbitrary polygons within an arbitrary boundary](https://stackoverflow.com/questions/6864382/packing-arbitrary-polygons-within-an-arbitrary-boundary)\n\n[Ask Question](https://stackoverflow.com/questions/ask)\n\nAsked12 years, 10 months ago\n\nModified [11 years, 3 months ago](https://stackoverflow.com/questions/6864382/packing-arbitrary-polygons-within-an-arbitrary-boundary?lastactivity)\n\nViewed\n8k times\n\n15\n\nI was wondering if anybody could point me to the best algorithm/heuristic which will fit my particular polygon packing problem. I am given a single polygon as a boundary (convex or concave may also contain holes) and a single \"fill\" polygon (may also be convex or concave, does not contain holes) and I need to fill the boundary polygon with a specified number of fill polygons. (I'm working in 2D).\n\nMany of the polygon packing heuristics I've found assume that the boundary and/or filling polygons will be rectangular and also that the filling polygons will be of different sizes. In my case, the filling polygons may be non-rectangular, but all will be exactly the same.\n\nMaybe this is a particular type of packing problem? If somebody has a definition for this type of polygon packing I'll gladly google away, but so far I've not found anything which is similar enough to be of great use.\n\nThanks.\n\n- [algorithm](https://stackoverflow.com/questions/tagged/algorithm)\n- [polygon](https://stackoverflow.com/questions/tagged/polygon)\n- [heuristics](https://stackoverflow.com/questions/tagged/heuristics)\n- [packing](https://stackoverflow.com/questions/tagged/packing)\n\n[Share](https://stackoverflow.com/q/6864382)\n\n[Improve this question](https://stackoverflow.com/posts/6864382/edit)\n\nFollow\n\nasked Jul 28, 2011 at 19:12\n\n[![Craig's user avatar](https://www.gravatar.com/avatar/015502b5e2de5fa52ffa72f5b2bbbd75?s=64&d=identicon&r=PG)](https://stackoverflow.com/users/863506/craig)\n\n[Craig](https://stackoverflow.com/users/863506/craig) Craig\n\n56411 gold badge55 silver badges2020 bronze badges\n\n4\n\n- No, this doesn't look like some well-known special case of the packing problem. Anything that works with distinct shapes should trivially work with identical shapes too. If you have an algorithm that works well for a rectangular boundary, you can try to adapt it for an arbitrary boundary. Modify it so that you can at a flip opre-fill your boundary with some shapes that cannot be moved or deleted (e.g. there's only one way to place them). Solve for a rectangular boundary, pre-filled with some shapes that just leave your original boundary unfilled. Not all algorithms can be adapted like this.\n\n\u2013\u00a0[n. m. could be an AI](https://stackoverflow.com/users/775806/n-m-could-be-an-ai)\n\nCommentedJul 28, 2011 at 20:22\n\n- The case with only one kind of filling polygon is definitely a special case of the general situation with different filling polys. I believe most heuristics for solving this kind of cutting/packing problem uses the no-fit polygon, so googling \"no-fit irregular packing\"' or something like that could be a good start.\n\n\u2013\u00a0[Anders Forsgren](https://stackoverflow.com/users/678410/anders-forsgren)\n\nCommentedJul 28, 2011 at 23:05\n\n- I think you should as this in the theoretical cs version of SO.\n\n\u2013\u00a0[Ira Baxter](https://stackoverflow.com/users/120163/ira-baxter)\n\nCommentedAug 31, 2011 at 5:25\n\n- for the algorithm: this is commonly called \"nesting\", which means to pack irregular, potentially non-convex, 2D/3D shapes into some piece of \"stock\" that is then cut. things need not be nested literally, but they could be.\n\n\u2013\u00a0[Christoph Rackwitz](https://stackoverflow.com/users/2602877/christoph-rackwitz)\n\nCommentedJun 26, 2023 at 19:18\n\n\n[Add a comment](https://stackoverflow.com/questions/6864382/packing-arbitrary-polygons-within-an-arbitrary-boundary)\u00a0\\|\n\n## 4 Answers 4\n\nSorted by:\n[Reset to default](https://stackoverflow.com/questions/6864382/packing-arbitrary-polygons-within-an-arbitrary-boundary?answertab=scoredesc#tab-top)\n\nHighest score (default)Trending (recent votes count more)Date modified (newest first)Date created (oldest first)\n\n4\n\nThe question you ask is very hard. To put this in perspective, the (much) simpler case where you're packing the interior of your bounded polygon with non-overlapping disks is already hard, and disks are the simplest possible \"packing shape\" (with any other shape you have to consider orientation as well as size and center location).\n\nIn fact, I think it's an open problem in [computational geometry](http://en.wikipedia.org/wiki/Computational_geometry) to determine for an arbitrary integer N and arbitrary bounded polygonal region (in the Euclidean plane), what is the \"optimal\" (in the sense of covering the greatest percentage of the polygon interior) packing of N inscribed non-overlapping disks, where you are free to choose the radius and center location of each disk. I'm sure the \"best\" answer _is_ known for certain special polygonal shapes (like rectangles, circles, and triangles), but for arbitrary shapes your best \"heuristic\" is probably:\n\n1. Start your shape counter at N.\n2. Add the largest \"packing shape\" you can fit completely inside the polygonal boundary without overlapping any other packing shapes.\n3. Decrement your shape counter.\n4. If your shape counter is > 0, go to step 2.\n\nI say \"probably\" because \"largest first\" isn't always the best way to pack things into a confined space. You can dig into that particular flavor of craziness by reading about the [bin packing problem](http://en.wikipedia.org/wiki/Bin_packing_problem) and [knapsack problem](http://en.wikipedia.org/wiki/Knapsack_problem).\n\n**EDIT:** Step 2 by itself is hard. A reasonable strategy would be to pick an arbitrary point on the interior of the polygon as the center and \"inflate\" the disk until it touches either the boundary or another disk (or both), and then \"slide\" the disk while continuing to inflate it so that it remains inside the boundary without overlapping any other disks until it is \"trapped\" - with at least 2 points of contact with the boundary and/or other disks. But it isn't easy to formalize this \"sliding process\". And even if you get the sliding process right, this strategy doesn't guarantee that you'll find the biggest \"inscribable disk\" - your \"locally maximal\" disk could be trapped in a \"lobe\" of the interior which is connected by a narrow \"neck\" of free space to a larger \"lobe\" where a larger disk would fit.\n\n[Share](https://stackoverflow.com/a/7342898)\n\n[Improve this answer](https://stackoverflow.com/posts/7342898/edit)\n\nFollow\n\n[edited Feb 27, 2013 at 20:29](https://stackoverflow.com/posts/7342898/revisions)\n\nanswered Sep 8, 2011 at 3:46\n\n[![Peter's user avatar](https://www.gravatar.com/avatar/f031e9e9b7476fc5d3674fe4a9c59ef2?s=64&d=identicon&r=PG)](https://stackoverflow.com/users/227491/peter)\n\n[Peter](https://stackoverflow.com/users/227491/peter) Peter\n\n2,53611 gold badge2323 silver badges3232 bronze badges\n\n[Add a comment](https://stackoverflow.com/questions/6864382/packing-arbitrary-polygons-within-an-arbitrary-boundary)\u00a0\\|\n\n3\n\nThanks for the replies, my requirements were such that I was able to further simplify the problem by not having to deal with orientation and I then even further simplified by only really wor...",
      "url": "https://stackoverflow.com/questions/6864382/packing-arbitrary-polygons-within-an-arbitrary-boundary"
    },
    {
      "title": "Search code, repositories, users, issues, pull requests...",
      "text": "GitHub - adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-: In this re-defined optimization problem, help Santa fit Christmas tree toys into the smallest (2-dimension) parcel size possible so that he can efficiently mail these stocking stuffers around the globe. Santa needs the dimensions of the smallest possible square box that fits shipments of between 1-200 trees.\n[Skip to content](#start-of-content)\n## Navigation Menu\nToggle navigation\n[](https://github.com/)\n[Sign in](https://github.com/login?return_to=https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\nAppearance settings\nSearch or jump to...\n# Search code, repositories, users, issues, pull requests...\n</option></form>\nSearch\nClear\n[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)\n# Provide feedback\n</option></form>\nWe read every piece of feedback, and take your input very seriously.\nInclude my email address so I can be contacted\nCancelSubmit feedback\n# Saved searches\n## Use saved searches to filter your results more quickly\n</option></form>\nName\nQuery\nTo see all available qualifiers, see our[documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).\nCancelCreate saved search\n[Sign in](https://github.com/login?return_to=https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\n[Sign up](https://github.com/signup?ref_cta=Sign+up&amp;ref_loc=header+logged+out&amp;ref_page=/%3Cuser-name%3E/%3Crepo-name%3E&amp;source=header-repo&amp;source_repo=adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\nAppearance settings\nResetting focus\nYou signed in with another tab or window.[Reload]()to refresh your session.You signed out in another tab or window.[Reload]()to refresh your session.You switched accounts on another tab or window.[Reload]()to refresh your session.Dismiss alert\n{{ message }}\n[adityapawar327](https://github.com/adityapawar327)/**[Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)**Public\n* [Notifications](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)You must be signed in to change notification settings\n* [Fork1](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\n* [Star2](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\nIn this re-defined optimization problem, help Santa fit Christmas tree toys into the smallest (2-dimension) parcel size possible so that he can efficiently mail these stocking stuffers around the globe. Santa needs the dimensions of the smallest possible square box that fits shipments of between 1-200 trees.\n[www.kaggle.com/code/adityapawar327/santa-2025-christmas-tree-packing-challenge-v1](https://www.kaggle.com/code/adityapawar327/santa-2025-christmas-tree-packing-challenge-v1)\n[2stars](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/stargazers)[1fork](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/forks)[Branches](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/branches)[Tags](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/tags)[Activity](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/activity)\n[Star](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\n[Notifications](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)You must be signed in to change notification settings\n# adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-\nmain\n[Branches](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/branches)[Tags](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/tags)\n[](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/branches)[](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/tags)\nGo to file\nCode\nOpen more actions menu\n## Folders and files\n|Name|Name|\nLast commit message\n|\nLast commit date\n|\n## Latest commit\n## History\n[2 Commits](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/commits/main/)\n[](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/commits/main/)\n|\n[README.md](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/blob/main/README.md)\n|\n[README.md](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/blob/main/README.md)\n|\n|\n|\n[santa-2025-christmas-tree-packing-challenge-v1.ipynb](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/blob/main/santa-2025-christmas-tree-packing-challenge-v1.ipynb)\n|\n[santa-2025-christmas-tree-packing-challenge-v1.ipynb](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/blob/main/santa-2025-christmas-tree-packing-challenge-v1.ipynb)\n|\n|\n|\nView all files\n|\n## Repository files navigation\n# Santa 2025 - Christmas Tree Packing Challenge V1\n[](#santa-2025---christmas-tree-packing-challenge-v1)\nThis repository contains my approach for the[Santa 2025 - Christmas Tree Packing Challenge](https://www.kaggle.com/competitions/santa-2025)on Kaggle.\n## Overview\n[](#overview)\nThe objective of this challenge is to optimally pack rotatable Christmas trees (polygonal shapes) into the smallest possible square, minimizing the bounding box area for each value of N (number of trees from 1 to 200). The final solution is evaluated by an ensemble score that combines all cases.\n**Notebook Link**:[Santa 2025 - Christmas Tree Packing Challenge V1](https://www.kaggle.com/code/adityapawar327/santa-2025-christmas-tree-packing-challenge-v1)\n**Public Score**: 85.92\n## Table of Contents\n[](#table-of-contents)\n* Library Imports and Environment Setup\n* Global Configuration and Precision Settings\n* ChristmasTree Class Definition\n* Utility Functions (Scoring/Collision)\n* Simulated Annealing Algorithm (N &lt; 20)\n* Grid Search Algorithm (N &gt;= 20)\n* Hybrid &amp; Ensemble Solvers\n* Main Computation Loop (N = 1 to 200)\n* Submission Formatting and Export\n## Methodology\n[](#methodology)\n* **Small N (&lt; 20):**Uses Simulated Annealing for efficient search in small configuration spaces.\n* **Large N (&gt;= 20):**Uses a tailored Grid Search for tractable solution space exploration.\n* **Hybrid/Ensemble:**Runs multiple seeds and chooses the best solution for each N.\n* **Collision Detection:**Employs Shapely geometry operations to prevent tree overlap.\n* **Performance:**Code leverages parallelization (`ProcessPoolExecutor`) and high-precision (Decimal) arithmetic.\n## Usage\n[](#usage)\n1. Install dependencies:\n* `shapely`,`numpy`,`pandas`,`matplotlib`,`tqdm`\n* Run the notebook or script sequentially to output results and save a`submission.csv`.\n* Check the score on important N cases (e.g., 1, 10, 25, 50, 100, 150, 200).\n## Output\n[](#output)\n* The notebook prints key logs during computation.\n* A`submission.csv`is generated with columns:`id`,`x`,`y`,`deg`(example row:`001\\_0, s-9.146226, s-0.12832, s-224.999647`).\n## License\n[](#license)\nThis project is released under the[Apache 2.0 License](http://www.apache.org/licenses/LICENSE-2.0).\n## Author\n[](#author)\nAditya Pawar ([Kaggle Profile](https://www.kaggle.com/adityapawar327))\nFor questions or collaboration, feel free to reach out via Kaggle discussions or connect on[LinkedIn](https://www.linkedin.com/in/adityapawar327).\n## About\nIn this re-defined optimization problem, help Santa fit Christmas tree toys into the smallest (2-dimension) parcel size possible so that ...",
      "url": "https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-"
    },
    {
      "title": "A General Heuristic Approach for Maximum Polygon Packing",
      "text": "A General Heuristic Approach for Maximum\nPolygon Packing\nCanhui Luo #\nHuazhong University of Science and Technology, Wuhan, China\nZhouxing Su1 #\nHuazhong University of Science and Technology, Wuhan, China\nZhipeng L\u00fc #\nHuazhong University of Science and Technology, Wuhan, China\nAbstract\nThis work proposes a general heuristic packing approach to address the Maximum Polygon Packing\nProblem introduced by the CG:SHOP 2024 Challenge. Our solver primarily consists of two steps:\n(1) Partitioning the container and polygons to form a series of small-scale subproblems; (2) For each\nsubproblem, sequentially placing polygons into the container and attempting to eliminate overlaps.\n2012 ACM Subject Classification Theory of computation \u2192 Computational geometry; Computing\nmethodologies \u2192 Search methodologies\nKeywords and phrases packing, polygon, heuristic, differential evolution, local search, tabu search\nDigital Object Identifier 10.4230/LIPIcs.SoCG.2024.86\nCategory CG Challenge\nFunding This work was supported in part by the National Natural Science Foundation of China\n(NSFC) under Grant 72101094 and the Special Project for Knowledge Innovation of Hubei Province\nunder Grant 2022013301015175.\nAcknowledgements We want to thank the organizers of CG:SHOP 2024 and all other participants\nfor creating such an engaging challenge. We also want to thank Dominik Krupke for providing a\nhelpful official validator for solutions.\n1 Introduction\nThe recent CG:SHOP 2024 Challenge introduced a variant of irregular packing problems\nknown as the Maximum Polygon Packing (MPP) problem. The MPP problem involves a\nconvex polygonal container C and a polygon set P = {p1, p2, ..., pN }, where polygon piis\nassociated with a value vi. It seeks for a non-overlapping packing with the maximum total\nvalue. The challenge presents a total of 180 instances whose number of polygons ranges from\n28 to 50,000. The official document [4] gives a detailed description of the challenge.\nOur proposed algorithm employs a general process to solve these instances indiscriminately,\nand the overall framework is presented in Figure 1. We first partition a large-scale problem\ninto multiple small-scale subproblems (Section 2) and then solve each subproblem using\nupper-level polygon ordering (Section 3.1) and lower-level packing optimization techniques\n(Section 3.2). Section 4 presents our experimental results, followed by conclusions.\n1 Corresponding author: Zhouxing Su\n\u00a9 Canhui Luo, Zhouxing Su, and Zhipeng L\u00fc;\nlicensed under Creative Commons License CC-BY 4.0\n40th International Symposium on Computational Geometry (SoCG 2024).\nEditors: Wolfgang Mulzer and Jeff M. Phillips; Article No. 86; pp. 86:1\u201386:9\nLeibniz International Proceedings in Informatics\nSchloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik, Dagstuhl Publishing, Germany\n86:2 A General Heuristic Approach for Maximum Polygon Packing\nInput polygon set P and container C\nUpper-level polygon ordering\nLower-level packing optimization\nFinished?\n \nPacking\nAssemble and return the complete solution\nMPP1 MPP2 MPPm\n( ) 0? Overlap Scurr== ( ) Update Sbest best\nReturn S\nPartitioning\nYes\nNo\nYes\nNo\nSelect next one\nFigure 1 The framework of our proposed algorithm.\n2 Partitioning\nIn this section, we present the decomposition of the original large-scale problem into a series\nof smaller MPP subproblems. It involves two components: partitioning the container C into\nmultiple regions and assigning polygons to each region.\n2.1 Container Partitioning\nThe container partitioning process consists of two steps, as shown in Figure 2. Initially, we\narrange two-dimensional square grids starting from the bottom-left corner of the bounding\nbox until the entire container is covered. The subregions formed by the intersection of the\ncontainer with all the grids constitute its partition C = C1 \u222a C2 \u222a ... \u222a Cm. Subsequently,\nwe merge the small subregions with adjacent grids, which are difficult to be used effectively.\nThe grid is dimensioned to keep the scale of each subproblem at approximately 300 polygons,\nmaking a trade-off between effectiveness and efficiency of lower-level packing optimization.\n2.2 Polygon Assignment\nWe adopt a simple approach of randomly assigning polygons to each subregion. Specifically, for\neach subregion Ci, we randomly select a polygon pj from P until\nP\nj\narea(pj )\narea(Ci) \u2265\nPN\ni=0\narea(pi)\narea(C)\n.\nThe advantage of random assignment lies in ensuring that the overall characteristics of each\nsubproblem align with the original problem.\nC. Luo, Z. Su, and Z. L\u00fc 86:3\nFigure 2 The partitioning process for the instance jigsaw_cf1_4fd4c46e. Step 1 (left): Cover the\ncontainer with squares; Step 2: Intersect and merge small regions (from the middle to the right).\nminimum translation\nminimum translation\nIFP\nContainer\nFigure 3 Examples of NFP between two polygons and IFP between container and polygon.\n3 Packing\n3.1 Upper-Level Polygon Ordering\nWe define a priority for each polygon. We repeatedly select one remaining polygon with the\nhighest priority (ties are broken by value) and try to insert it into the current solution. If the\ninsertion with lower-level packing optimization fails, we skip the current polygon and turn to\nthe next one. For the majority of instances, the priority is defined as the value-to-area ratio\nof a polygon (we also call it unit value). Polygons with higher unit values are prioritized\nfor putting in the container, which is called the Unit Value First (UVF) strategy. For\nsmall-scale instances (N < 100), we employ the \u03b1\u03b2-random strategy. It randomly selects\n\u03b1% and \u03b2% of the polygons and reassigns their UVF-based priority to the highest and the\nlowest, respectively. These instances are run for multiple times to ensure comprehensive\noptimization, with \u03b1 and \u03b2 set to 10 in our implementation.\n3.2 Lower-Level Packing Optimization\nThe position of a polygon can be represented by the coordinates l = (x, y) of a reference point,\nsuch as the bottom-left corner of the boundary. Then, the translation of a polygon can be\nrepresented by a vector pointing from its original position to its new position. Given a feasible\npacking S and a polygon p to be placed, it is impossible to find a non-overlapping position\nfor p without moving other polygons in most cases. This section introduces the algorithm for\neliminating overlaps for an invalid packing, which involves solving an unconstrained nonlinear\nproblem and heuristic polygon movement.\nS o C G 2 0 2 4\n86:4 A General Heuristic Approach for Maximum Polygon Packing\n3.2.1 Overlap Minimization\nTo determine the appropriate translation for the polygons, we utilized the no-fit polygon\n(NFP) and inner-fit polygon (IFP), which are fundamental in algorithmic approaches to\ngeometric design and optimization challenges. For a fixed polygon pi and a movable polygon\npj , NFP(pi, pj ) describes their non-overlapping positions with boundaries in contact precisely,\nwhich can be utilized to determine the minimum translation for pj to avoid overlap. Similarly,\nIFP(pi, pj ) is employed to determine the minimum translation to place pj inside pi. Figure 3\nillustrates the polygon translations determined using NFP (left) and IFP (right). The readers\nmay refer to Burke et al. [2] for a more detailed description.\nFor a packing S, based on NFP and IFP, we define the overlap between polygons pi\nand pj as fij (S), representing the minimum translation to separate them, and f0i(S) as the\nminimum translation for moving pi to fit into the container. Subsequently, we employ the\nseparation algorithm proposed by Imamichi et al. [7] to minimize the overlap, which involves\nsolving an unconstrained nonlinear programming problem as follows:\nmin\nS\nF(S) = X\n0\u2264i<j\u2264N\nf\n2\nij (S) (1)\nThe model relaxes the non-overlapping constraint but introduces repulsion forces between\nany two overlapped polygons. We use the classic L-BFGS (limited memory BFGS) method\nto solve this problem. It makes the packing S converge to a local optimum but strongly\ndepends on the initial layout. ...",
      "url": "https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.86/LIPIcs.SoCG.2024.86.pdf"
    }
  ]
}