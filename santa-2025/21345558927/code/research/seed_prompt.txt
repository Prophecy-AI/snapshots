# Santa 2025 - Evolved Strategy (Loop 2)

## Current Status
- **Best CV score**: 70.615102 (exp_001 - valid baseline)
- **Best LB score**: 70.615102 (PASSED Kaggle validation)
- **Target**: 68.882921
- **Gap to target**: 1.73 points (2.5% improvement needed)
- **Submissions remaining**: 98/100

## Submission Log
| Exp | Approach | CV | LB | Notes |
|-----|----------|----|----|-------|
| 000 | ensemble | 70.523 | FAILED | Overlapping trees in group 002 |
| 001 | valid_baseline | 70.615 | 70.615 | PASSED - high precision coords |

## Response to Evaluator

The evaluator correctly identified that:
1. **No algorithm implementation yet** - The code folder is empty after 2 experiments
2. **Small N values are the biggest opportunity** - N=1-10 contribute 6.1% of total score
3. **Tessellation approach not attempted** - But my analysis shows simple lattice is WORSE than baseline

**Key finding from my analysis**: A C++ optimizer in snapshot 21165870845 achieved **69.65** (only 0.77 from target!) but the solution has OVERLAPS and cannot be submitted. This proves:
1. Better scores ARE achievable (the optimizer found them)
2. The challenge is maintaining valid non-overlapping solutions
3. We need to implement optimization that respects overlap constraints

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() with ANY binary - FORBIDDEN
- Running ANY pre-compiled binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with C++ tools - FORBIDDEN

## ✅ CRITICAL INSIGHT: WHY BINARIES FAIL

The C++ optimizer in snapshot 21165870845 achieved 69.65 but with OVERLAPS:
- N=2: Trees 0 and 1 overlap (area=1.80e-01)
- N=3: Trees 0 and 1 overlap (area=1.29e-01)
- N=4: Trees 0 and 1 overlap (area=1.90e-01)

**The optimizer finds better scores by allowing tiny overlaps that violate Kaggle's strict validation.**

## ✅ NEXT EXPERIMENT: IMPLEMENT OVERLAP-AWARE OPTIMIZATION

### Approach: Backward Propagation with Strict Overlap Checking

Based on Chistyakov's kernel, implement backward propagation:
1. Start from N=200 configuration
2. For each N from 200 down to 2:
   - Find trees that touch the bounding box
   - Try removing each boundary-touching tree
   - Keep the removal that gives smallest bounding box for N-1
   - VALIDATE no overlaps before accepting

```python
from shapely.geometry import Polygon, box
from decimal import Decimal, getcontext

getcontext().prec = 30
SCALE = 10**18

def validate_no_overlap(trees):
    """Strict overlap validation using integer-scaled coordinates."""
    polygons = []
    for x, y, angle in trees:
        verts = get_tree_vertices(x, y, angle)
        int_verts = [(int(Decimal(str(vx)) * SCALE), int(Decimal(str(vy)) * SCALE)) for vx, vy in verts]
        polygons.append(Polygon(int_verts))
    
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                inter = polygons[i].intersection(polygons[j])
                if inter.area > 0:
                    return False
    return True

def backward_propagation(configs):
    """Propagate improvements from larger N to smaller N."""
    improved = {}
    
    for n in range(200, 1, -1):
        trees = list(configs[n])
        
        # Find trees touching bounding box
        boundary_indices = get_bbox_touching_indices(trees)
        
        best_score = calculate_score_for_n(configs[n-1])
        best_candidate = None
        
        for idx in boundary_indices:
            candidate = trees[:idx] + trees[idx+1:]
            
            # CRITICAL: Validate no overlaps
            if not validate_no_overlap(candidate):
                continue
                
            score = calculate_score_for_n(candidate)
            if score < best_score:
                best_score = score
                best_candidate = candidate
        
        if best_candidate is not None:
            improved[n-1] = best_candidate
            print(f"N={n-1}: Improved to {best_score:.6f}")
    
    return improved
```

### Alternative: Small N Exhaustive Search

For N=2-5, try exhaustive angle search with strict overlap validation:

```python
def exhaustive_small_n(n, angle_step=1.0):
    """Exhaustive search for small N with strict overlap validation."""
    best_score = float('inf')
    best_config = None
    
    angles = np.arange(0, 360, angle_step)
    
    # For N=2, try all angle pairs
    for a1 in angles:
        for a2 in angles:
            # Place trees using bottom-left heuristic
            config = place_trees_bottom_left(n, [a1, a2])
            
            # Validate no overlaps
            if not validate_no_overlap(config):
                continue
            
            score = calculate_score_for_n(config)
            if score < best_score:
                best_score = score
                best_config = config
    
    return best_score, best_config
```

## ✅ REQUIRED: PER-N TRACKING

Track best solution for EACH N value separately:

```python
# Load baseline per-N scores
baseline_scores = {}
for n in range(1, 201):
    baseline_scores[n] = calculate_score_for_n(baseline_configs[n])

# After optimization, compare per-N scores
improved_n = []
for n in range(1, 201):
    new_score = calculate_score_for_n(new_configs[n])
    if new_score < baseline_scores[n] - 0.0001:  # Meaningful improvement
        improved_n.append(n)
        print(f"✅ N={n}: {baseline_scores[n]:.6f} -> {new_score:.6f}")

# Save improvements even if total score is worse
```

## ✅ SUBMISSION FORMAT

Use 's' prefix for precision preservation:
```python
def format_submission(configs):
    rows = []
    for n in range(1, 201):
        for i, (x, y, deg) in enumerate(configs[n]):
            rows.append({
                'id': f'{n:03d}_{i}',
                'x': f's{x:.20f}',
                'y': f's{y:.20f}',
                'deg': f's{deg:.20f}'
            })
    return pd.DataFrame(rows)
```

## Score Breakdown (from analysis)

| N Range | Score | % of Total |
|---------|-------|------------|
| 1-10 | 4.33 | 6.1% |
| 11-20 | 3.72 | 5.3% |
| 21-50 | 10.98 | 15.5% |
| 51-100 | 17.61 | 24.9% |
| 101-150 | 17.13 | 24.3% |
| 151-200 | 16.84 | 23.9% |

**Key insight**: N=1 is already optimal (0.6612). Focus on N=2-10 for highest impact.

## What NOT to Try

1. ❌ Simple lattice approach (Zaburo) - WORSE than baseline for all N
2. ❌ Running bbox3/sa_fast binaries - produces overlaps
3. ❌ Loading pre-optimized solutions and running C++ optimizer - same issue

## SUBMIT AFTER EVERY EXPERIMENT

With 98 submissions remaining, submit every valid experiment to get LB feedback.
