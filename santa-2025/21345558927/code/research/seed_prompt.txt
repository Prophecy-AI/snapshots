# Santa 2025 - Evolved Strategy (Loop 3)

## Current Status
- **Best CV score**: 70.615101 from exp_002 (backward_propagation)
- **Best LB score**: 70.615102 from exp_001 (valid_baseline)
- **Target**: 68.881647 (lower is better)
- **Gap to target**: 1.73 points (2.5% improvement needed)
- **Submissions used**: 2/100 (98 remaining - ABUNDANT!)

## ⚠️ CRITICAL: STUCK AT LOCAL OPTIMUM!

Experiments exp_001 and exp_002 produced nearly identical scores (70.615102 vs 70.615101).
The backward propagation approach found only 1 improvement with 4.6e-7 total gain.
**The baseline is at an extremely strong local optimum.**

## What We've Learned
1. **Backward propagation doesn't work** - Removing trees from N to create N-1 yields no improvement
2. **Simple lattice approach is WORSE** - Zaburo's grid approach is 16-27% worse than baseline
3. **Pre-compiled binaries (bbox3, sa_fast) produce ~70.6** - Cannot beat this ceiling
4. **N=1 is already optimal** at 45° with score 0.6612
5. **Small N values (N=2-10) contribute 6.1% of total score** - High leverage targets

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with binaries - FORBIDDEN

## ✅ NEXT EXPERIMENT: EXHAUSTIVE SEARCH FOR N=2-5

The evaluator correctly identified this as the highest-leverage approach:
- N=2 has only 360×360 = 129,600 angle combinations at 1° resolution
- N=3-5 can use branch-and-bound with pruning
- These small N values contribute disproportionately to score

### Implementation Plan

```python
# experiments/003_small_n_exhaustive/analysis.ipynb

import numpy as np
from numba import njit
from shapely.geometry import Polygon
from itertools import product
import time

# Tree geometry
TX = np.array([0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125])
TY = np.array([0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5])

@njit
def get_tree_vertices_fast(x, y, angle_rad):
    """Get tree vertices with Numba acceleration."""
    cos_a = np.cos(angle_rad)
    sin_a = np.sin(angle_rad)
    rx = TX * cos_a - TY * sin_a + x
    ry = TX * sin_a + TY * cos_a + y
    return rx, ry

def calculate_bbox_size(trees):
    """Calculate bounding box side length for trees [(x, y, angle), ...]."""
    all_xs, all_ys = [], []
    for x, y, angle in trees:
        rx, ry = get_tree_vertices_fast(x, y, np.radians(angle))
        all_xs.extend(rx)
        all_ys.extend(ry)
    return max(max(all_xs) - min(all_xs), max(all_ys) - min(all_ys))

def check_overlap(trees):
    """Check if any trees overlap using Shapely."""
    polygons = []
    for x, y, angle in trees:
        rx, ry = get_tree_vertices_fast(x, y, np.radians(angle))
        polygons.append(Polygon(zip(rx, ry)))
    
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                inter = polygons[i].intersection(polygons[j])
                if inter.area > 1e-12:
                    return True
    return False

def place_tree_bottom_left(existing_trees, angle):
    """Place a new tree at bottom-left feasible position."""
    # Start from origin and search for valid placement
    for y in np.arange(-2, 5, 0.05):
        for x in np.arange(-2, 5, 0.05):
            candidate = existing_trees + [(x, y, angle)]
            if not check_overlap(candidate):
                return (x, y, angle)
    return None

def exhaustive_n2(angle_step=1.0):
    """Exhaustive search for N=2 optimal configuration."""
    best_score = float('inf')
    best_config = None
    
    angles = np.arange(0, 360, angle_step)
    total = len(angles) ** 2
    
    for i, a1 in enumerate(angles):
        for a2 in angles:
            # Tree 1 at origin
            tree1 = (0, 0, a1)
            
            # Tree 2 placed using bottom-left heuristic
            tree2 = place_tree_bottom_left([tree1], a2)
            
            if tree2 is not None:
                config = [tree1, tree2]
                bbox = calculate_bbox_size(config)
                score = bbox ** 2 / 2  # Score formula: s²/n
                
                if score < best_score:
                    best_score = score
                    best_config = config
        
        if i % 36 == 0:
            print(f"Progress: {i}/{len(angles)} angles, best score: {best_score:.6f}")
    
    return best_score, best_config

# Run for N=2
print("Searching for optimal N=2 configuration...")
score_n2, config_n2 = exhaustive_n2(angle_step=1.0)
print(f"N=2 best score: {score_n2:.6f}")
print(f"N=2 best config: {config_n2}")

# Compare to baseline
baseline_n2_score = 0.4508  # From previous analysis
print(f"Baseline N=2 score: {baseline_n2_score:.6f}")
print(f"Improvement: {baseline_n2_score - score_n2:.6f}")
```

### Expected Outcomes
1. **If we find improvement for N=2-5**: Scale up to all N, accumulate per-N improvements
2. **If baseline is optimal for N=2-5**: Confirms baseline is extremely well-optimized, need different approach

### After Small N Search
If small N search succeeds, implement for all N:
1. Use exhaustive search for N=2-10
2. Use constructive heuristic + local search for N=11-50
3. Use tessellation/grid approach for N=51-200

## Alternative Approaches to Try (if exhaustive search fails)

### 1. Asymmetric Placement Strategy
Discussion 666880 suggests asymmetric solutions beat symmetric ones.
- Instead of grid/lattice, try random perturbations from baseline
- Use simulated annealing with LARGE perturbations (not small tweaks)

### 2. Genetic Algorithm with Custom Operators
```python
def crossover(parent1, parent2, n):
    """Swap partial solutions between parents."""
    split = n // 2
    child = parent1[:split] + parent2[split:]
    return child

def mutate(config, mutation_rate=0.1):
    """Rotate/translate random trees."""
    for i in range(len(config)):
        if random.random() < mutation_rate:
            x, y, angle = config[i]
            # Random perturbation
            config[i] = (x + random.gauss(0, 0.1), 
                        y + random.gauss(0, 0.1), 
                        (angle + random.gauss(0, 10)) % 360)
    return config
```

### 3. No-Fit Polygon (NFP) Approach
Precompute feasible placement regions for each tree pair:
- NFP(A, B) = set of positions where B can be placed without overlapping A
- Enables O(1) collision checks during optimization

## ✅ MANDATORY: PER-N TRACKING

Track best solution for EACH N separately:
```python
# After each experiment
for n in range(1, 201):
    my_score = calculate_score_for_n(my_solution, n)
    baseline_score = baseline_scores[n]
    if my_score < baseline_score - 1e-6:
        print(f"✅ N={n}: IMPROVED by {baseline_score - my_score:.6f}")
        # Save this N's solution
```

## ✅ SUBMIT EVERY EXPERIMENT

With 98 submissions remaining, submit EVERY valid experiment:
- LB feedback tells us what ACTUALLY works
- Even if CV is worse, LB might be different
- Track what we learn from each submission

## What NOT to Try
- ❌ Running bbox3/sa_fast with different parameters (already at ceiling)
- ❌ Simple lattice/grid approaches (proven worse than baseline)
- ❌ Backward propagation (yields no improvement)
- ❌ Any approach that modifies existing solutions incrementally

## Success Criteria
- ✅ **SUCCESS**: Score improved by > 0.01 from baseline (70.615)
- ⚠️ **MARGINAL**: Score improved by 0.001 - 0.01
- ❌ **FAILURE**: Score same or worse → try different approach immediately
