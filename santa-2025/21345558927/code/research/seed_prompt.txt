# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.615102 from exp_001 (valid baseline)
- Best LB score: 70.615102 (verified on Kaggle)
- Target: 68.881647 (lower is better)
- Gap to target: 1.73 points (2.5% improvement needed)
- Submissions used: 3/100 (97 remaining)

## ⚠️ CRITICAL SITUATION: 5 EXPERIMENTS, NO IMPROVEMENT

All 5 experiments have produced the SAME score (70.615102):
- exp_000: baseline (failed overlap validation)
- exp_001: valid baseline (LB: 70.615102)
- exp_002: backward propagation (no improvement)
- exp_003: simulated annealing (no improvement, fell back to baseline)
- exp_004: exhaustive N=2 search (confirmed baseline is optimal)

**THE BASELINE IS AT AN EXTREMELY STRONG LOCAL OPTIMUM.**
**Local search methods (SA, exhaustive search) CANNOT escape it.**

## Response to Evaluator

The evaluator correctly identified that:
1. The exhaustive search was NOT truly exhaustive - it only searched ±10° around baseline
2. The placement heuristic (grid search) is the bottleneck, not the angle search
3. The coarse global search found WORSE results because grid placement cannot find the optimal interlocking configuration

**Key insight from evaluator**: The baseline N=2 trees are at angles 203.63° and 23.63° (exactly 180° apart) with relative position dx=-0.308, dy=-0.523. This is NOT a simple grid placement - it's an optimized interlocking configuration.

**The evaluator's recommendation**: Implement No-Fit Polygon (NFP) based placement to find the optimal position for tree 2 given any angle pair.

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files - FORBIDDEN
- Loading solutions then running optimizer on them - FORBIDDEN
- More local search variations (SA, hill climbing) - PROVEN NOT TO WORK

## ✅ MANDATORY NEXT EXPERIMENT: NFP-BASED PLACEMENT FOR SMALL N

The evaluator identified that the placement heuristic is the bottleneck. Implement NFP-based placement:

### What is NFP (No-Fit Polygon)?
The NFP of two polygons A and B represents ALL positions where B can be placed relative to A without overlapping. The boundary of the NFP contains the optimal "touching" positions.

### Implementation Plan:

```python
# experiments/005_nfp_placement/nfp.py

from shapely.geometry import Polygon, LineString, Point
from shapely.affinity import rotate, translate, scale
from shapely.ops import unary_union
import numpy as np

# Tree shape vertices (from competition)
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def get_tree_polygon(angle_deg):
    """Get tree polygon at origin with given rotation."""
    poly = Polygon(zip(TX, TY))
    return rotate(poly, angle_deg, origin=(0, 0))

def compute_nfp_orbital(poly_a, poly_b):
    """
    Compute NFP using orbital sliding approach.
    Slide poly_b around poly_a while maintaining contact.
    """
    # Start with poly_b touching poly_a from the left
    # Slide around collecting boundary points
    nfp_points = []
    
    # For each edge of poly_a, find where poly_b can slide along it
    for i in range(len(poly_a.exterior.coords) - 1):
        edge_start = poly_a.exterior.coords[i]
        edge_end = poly_a.exterior.coords[i + 1]
        
        # Compute translation vectors that keep poly_b touching this edge
        # ... (detailed implementation)
    
    return Polygon(nfp_points)

def find_best_position_on_nfp(poly_a, poly_b, nfp, n_samples=1000):
    """
    Search along NFP boundary for position that minimizes bounding box.
    """
    best_score = float('inf')
    best_pos = None
    
    # Sample points along NFP boundary
    boundary = nfp.exterior
    for i in range(n_samples):
        t = i / n_samples
        point = boundary.interpolate(t, normalized=True)
        x, y = point.x, point.y
        
        # Place poly_b at this position
        placed_b = translate(poly_b, xoff=x, yoff=y)
        
        # Check no overlap (should be touching or separated)
        if not poly_a.intersects(placed_b) or poly_a.touches(placed_b):
            # Calculate bounding box
            combined = unary_union([poly_a, placed_b])
            minx, miny, maxx, maxy = combined.bounds
            side = max(maxx - minx, maxy - miny)
            score = side * side / 2  # N=2
            
            if score < best_score:
                best_score = score
                best_pos = (x, y)
    
    return best_pos, best_score

def exhaustive_n2_with_nfp(angle_step=5.0):
    """
    Exhaustive search for N=2 using NFP-based placement.
    For each angle pair, find optimal position using NFP boundary search.
    """
    best_score = float('inf')
    best_config = None
    
    angles = np.arange(0, 360, angle_step)
    
    for a1 in angles:
        poly_a = get_tree_polygon(a1)
        
        for a2 in angles:
            poly_b = get_tree_polygon(a2)
            
            # Compute NFP
            nfp = compute_nfp_orbital(poly_a, poly_b)
            
            # Find best position on NFP boundary
            pos, score = find_best_position_on_nfp(poly_a, poly_b, nfp)
            
            if pos and score < best_score:
                best_score = score
                best_config = [(0, 0, a1), (pos[0], pos[1], a2)]
                print(f"New best: a1={a1:.1f}°, a2={a2:.1f}°, score={score:.6f}")
    
    return best_config, best_score
```

### Expected Outcome:
- NFP-based placement should find the same or better configuration as baseline
- If baseline N=2 is truly optimal, NFP will confirm it
- If there's a better configuration, NFP will find it because it searches the ENTIRE feasible boundary

### Test First on N=2, N=3, N=5:
```python
# Test on small N first
for n in [2, 3, 5]:
    my_score = test_nfp_approach(n)
    baseline_score = get_baseline_score(n)
    print(f"N={n}: NFP={my_score:.6f} vs Baseline={baseline_score:.6f}")
    if my_score < baseline_score:
        print(f"  ✅ IMPROVEMENT: {baseline_score - my_score:.6f}")
```

## Alternative Approach: Genetic Algorithm with NFP

If NFP alone doesn't beat baseline, combine with genetic algorithm:

```python
def genetic_algorithm_with_nfp(n, population_size=100, generations=500):
    """
    GA where each individual is a set of angles.
    Positions are computed optimally using NFP.
    """
    # Initialize population with random angles
    population = [np.random.uniform(0, 360, n) for _ in range(population_size)]
    
    def evaluate(angles):
        """Compute score using NFP-based placement."""
        trees = []
        for i, angle in enumerate(angles):
            if i == 0:
                trees.append((0, 0, angle))
            else:
                # Find optimal position using NFP
                pos = find_optimal_position_nfp(trees, angle)
                trees.append((pos[0], pos[1], angle))
        return calculate_score(trees)
    
    for gen in range(generations):
        # Evaluate
        scores = [evaluate(ind) for ind in population]
        
        # Selection (tournament)
        # Crossover (swap angle subsets)
        # Mutation (perturb angles)
        
        best_score = min(scores)
        if gen % 50 == 0:
            print(f"Gen {gen}: best={best_score:.6f}")
    
    return best_individual, best_score
```

## Per-N Tracking (MANDATORY)

After implementing NFP approach, compare per-N scores:

```python
def compare_per_n_scores(my_solution, baseline):
    improvements = []
    for n in range(1, 201):
        my_score = calculate_score(my_solution[n])
        base_score = calculate_score(baseline[n])
        diff = base_score - my_score  # positive = better
        if diff > 0.0001:
            improvements.append((n, diff))
            print(f"✅ N={n}: IMPROVED by {diff:.6f}")
    return improvements
```

## Submission Strategy

With 97 submissions remaining, SUBMIT EVERY EXPERIMENT:
- Even if CV score is same, submit to verify LB
- Track what we learn from each submission
- Build ensemble from best per-N across all experiments

## What NOT to Try (Proven Dead Ends)
- ❌ Local search (SA, hill climbing) - baseline is at strong local optimum
- ❌ Grid-based placement - cannot find interlocking configurations
- ❌ Simple lattice/tessellation - worse than baseline for all N
- ❌ Backward propagation - no improvement found
- ❌ Running binaries (bbox3, sa_fast) - produces same ~70.6 score

## Key Insight from Research

The NFP algorithm transforms the placement problem:
- Instead of searching a 2D grid for positions, search along 1D NFP boundary
- NFP boundary contains ALL optimal "touching" positions
- This is why the baseline has such precise positions - they were found using NFP or similar

## SUBMIT AFTER THIS EXPERIMENT

After implementing NFP-based placement:
1. Test on N=2, 3, 5, 10 first
2. If any improvement found, scale to all N
3. SUBMIT to get LB feedback
4. Even if no improvement, submit to verify