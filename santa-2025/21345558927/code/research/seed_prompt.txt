# Santa 2025 - Evolved Seed Prompt (Loop 4)

## Current Status
- Best CV score: 70.615102 from exp_001 (valid baseline)
- Best LB score: 70.615101 (exp_001 and exp_002)
- Target: 68.881647 (lower is better) | Gap to target: 1.73 points (2.5%)

## ⚠️ CRITICAL: STUCK AT LOCAL OPTIMUM!

**Last 3 experiments produced IDENTICAL scores:**
- exp_001: 70.615102 (baseline)
- exp_002: 70.615101 (backward propagation - NO improvement)
- exp_003: 70.615102 (SA - NO improvement, introduced overlaps)

**CONFIRMED FINDINGS:**
1. The baseline is at an EXTREMELY strong local optimum
2. SA with 5000 iterations found ZERO improvements across all 200 N values
3. Any perturbation from baseline creates overlaps (8 configs became invalid)
4. Local search methods CANNOT escape this optimum

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files - FORBIDDEN
- More SA/local search variations - PROVEN TO NOT WORK

## Response to Evaluator

The evaluator correctly identified that:
1. SA was a reasonable test but confirmed the baseline is at a tight local optimum
2. We need to pivot to GLOBAL search or CONSTRUCTIVE approaches
3. **Exhaustive search for N=2-3 is the highest-leverage next step**

I agree with this assessment. The key insight is:
- N=2 contributes 0.4508 to total score
- N=3 contributes 0.4347 to total score
- Combined: 0.88 points (51% of the 1.73 gap to target!)
- Exhaustive search for N=2 is computationally feasible (129,600 combinations at 1° resolution)

## ✅ MANDATORY NEXT EXPERIMENT: EXHAUSTIVE SEARCH FOR N=2

**Create: experiments/004_exhaustive_n2/**

Implement exhaustive search for N=2:

```python
import numpy as np
from numba import njit, prange
from code.tree_geometry import get_tree_vertices_numba, TX, TY
from code.overlap_check import polygons_overlap_numba

@njit
def compute_bbox_for_two_trees(a1, x2, y2, a2):
    """Compute bounding box for tree1 at origin with angle a1, tree2 at (x2,y2) with angle a2."""
    # Get vertices for both trees
    rx1, ry1 = get_tree_vertices_numba(0, 0, a1)
    rx2, ry2 = get_tree_vertices_numba(x2, y2, a2)
    
    # Find bounding box
    min_x = min(rx1.min(), rx2.min())
    max_x = max(rx1.max(), rx2.max())
    min_y = min(ry1.min(), ry2.min())
    max_y = max(ry1.max(), ry2.max())
    
    side = max(max_x - min_x, max_y - min_y)
    return side

@njit
def find_best_position_for_tree2(a1, a2, step=0.01):
    """Given angles a1 and a2, find the best position for tree2 that minimizes bbox."""
    # Tree 1 is at origin
    # Search for tree 2 position in a grid around tree 1
    best_score = np.inf
    best_x, best_y = 0.0, 0.0
    
    # Search range based on tree size (tree is about 1.0 units tall, 0.7 wide)
    for x2 in np.arange(-1.5, 1.5, step):
        for y2 in np.arange(-1.5, 1.5, step):
            # Check for overlap
            rx1, ry1 = get_tree_vertices_numba(0, 0, a1)
            rx2, ry2 = get_tree_vertices_numba(x2, y2, a2)
            
            if not polygons_overlap_numba(rx1, ry1, rx2, ry2):
                side = compute_bbox_for_two_trees(a1, x2, y2, a2)
                score = side * side / 2  # N=2
                if score < best_score:
                    best_score = score
                    best_x, best_y = x2, y2
    
    return best_score, best_x, best_y

@njit(parallel=True)
def exhaustive_search_n2(angle_step=1.0, position_step=0.02):
    """Exhaustive search over all angle combinations for N=2."""
    n_angles = int(360 / angle_step)
    
    best_score = np.inf
    best_a1, best_a2 = 0.0, 0.0
    best_x2, best_y2 = 0.0, 0.0
    
    for i in prange(n_angles):
        a1 = i * angle_step
        local_best_score = np.inf
        local_best_a2, local_best_x2, local_best_y2 = 0.0, 0.0, 0.0
        
        for j in range(n_angles):
            a2 = j * angle_step
            score, x2, y2 = find_best_position_for_tree2(a1, a2, position_step)
            
            if score < local_best_score:
                local_best_score = score
                local_best_a2 = a2
                local_best_x2 = x2
                local_best_y2 = y2
        
        # Thread-safe update (simplified - use proper synchronization in real code)
        if local_best_score < best_score:
            best_score = local_best_score
            best_a1 = a1
            best_a2 = local_best_a2
            best_x2 = local_best_x2
            best_y2 = local_best_y2
    
    return best_score, best_a1, best_a2, best_x2, best_y2
```

**IMPORTANT NOTES:**
1. Start with coarse search (1° angles, 0.05 position step)
2. Refine around best solutions (0.1° angles, 0.01 position step)
3. Compare to baseline N=2 score: 0.450779
4. If improved, save the new configuration

## ✅ AFTER N=2: EXTEND TO N=3

If N=2 search finds improvements, extend to N=3:
- N=3 has 360³ = 46.6M angle combinations at 1° resolution
- Use coarser grid (5° or 10°) then refine
- Or use branch-and-bound with pruning

## ✅ REQUIRED: PER-N TRACKING

Track best solution for EACH N separately:
```python
# After finding better N=2 configuration:
if new_n2_score < baseline_n2_score:
    print(f"✅ N=2: IMPROVED by {baseline_n2_score - new_n2_score:.6f}")
    # Update only N=2 in submission, keep all other N values from baseline
```

## Expected Outcome

- If exhaustive search finds a better N=2 configuration:
  - Improvement could be 0.01-0.05 points (2-10% of N=2 score)
  - This would be the FIRST real improvement from baseline!
  
- If exhaustive search confirms baseline is optimal for N=2:
  - Valuable information - baseline N=2 is globally optimal
  - Move on to N=3, N=4, etc.

## What NOT to Try
- ❌ More SA variations (proven to not work)
- ❌ More local search (proven to not work)
- ❌ Running binaries (forbidden)
- ❌ Optimizing existing CSV files (doesn't work)

## SUBMIT AFTER EXPERIMENT

Even if the experiment doesn't improve the score, SUBMIT IT to get LB feedback.
We have 97 submissions remaining - use them!