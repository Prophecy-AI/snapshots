# Santa 2025 - Evolved Strategy (Loop 3)

## Current Status
- **Best CV score**: 70.615101 from exp_002 (backward_propagation)
- **Best LB score**: 70.615101 (exp_002)
- **Target**: 68.881647 (lower is better)
- **Gap to target**: 1.73 points (2.52%)
- **Submissions used**: 3/100 (97 remaining)

## ⚠️ CRITICAL: WE ARE STUCK AT LOCAL OPTIMUM

**Evidence:**
1. exp_001 and exp_002 produced IDENTICAL scores (70.615101)
2. Backward propagation found only 1 improvement with 4.6e-7 total gain
3. Exhaustive N=2 search found WORSE score than baseline (0.521 vs 0.450)
4. The baseline is at an extremely strong local optimum

**Conclusion:** Incremental optimization CANNOT reach target. Need fundamentally different approach.

## Response to Evaluator

The evaluator correctly identified that:
1. No Python optimization code has been saved to /home/code/code/
2. Backward propagation confirmed baseline is at local optimum
3. Need to implement exhaustive search for small N

I agree with all points. The next experiment MUST:
1. Create reusable code in /home/code/code/
2. Implement a fundamentally different algorithm
3. Test on small N first before scaling up

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with binaries - FORBIDDEN
- Backward propagation (already tried, no improvement)
- Simple lattice/grid approach (already tried, worse than baseline)

## Theoretical Analysis (from Loop 3)

| Packing Efficiency | Theoretical Score |
|-------------------|-------------------|
| 70% | 70.18 (current ~70.6) |
| 72% | ~68.9 (TARGET!) |
| 75% | 65.50 |
| 80% | 61.41 |

**Key insight**: Target requires ~72% packing efficiency. Current is ~70%.
This is a 2% efficiency improvement - achievable but requires better algorithms.

## Score Improvement Scenarios

| N Range | Current Score | Required Improvement |
|---------|--------------|---------------------|
| N=2-10 | 3.67 | 47.3% (unrealistic) |
| N=2-20 | 7.39 | 23.5% (very hard) |
| N=2-50 | 18.37 | 9.4% (challenging) |
| All N | 70.62 | 2.5% (achievable) |

**Strategy**: Need small improvements across ALL N, not big improvements on small N.

## ✅ NEXT EXPERIMENT: SIMULATED ANNEALING FROM SCRATCH

**Why SA?** 
- Can escape local optima with temperature-based acceptance
- Works well for continuous optimization (positions, angles)
- Can be implemented in pure Python with Numba acceleration

**Implementation Plan:**

```python
# /home/code/code/sa_optimizer.py

import numpy as np
from numba import njit
from shapely.geometry import Polygon

# Tree geometry
TX = np.array([0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125])
TY = np.array([0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5])

@njit
def get_tree_vertices_fast(x, y, angle_rad):
    cos_a, sin_a = np.cos(angle_rad), np.sin(angle_rad)
    rx = TX * cos_a - TY * sin_a + x
    ry = TX * sin_a + TY * cos_a + y
    return rx, ry

def simulated_annealing(trees, n_iterations=10000, T_start=1.0, T_end=0.001):
    """
    SA with large perturbations to escape local optima.
    
    Moves:
    1. Translate single tree by random amount
    2. Rotate single tree by random angle
    3. Swap two trees
    4. Translate ALL trees (shift entire configuration)
    """
    current = np.array(trees)  # (n, 3) array of (x, y, angle)
    current_score = calculate_score(current)
    best = current.copy()
    best_score = current_score
    
    T = T_start
    cooling_rate = (T_end / T_start) ** (1 / n_iterations)
    
    for i in range(n_iterations):
        # Generate neighbor
        neighbor = current.copy()
        move_type = np.random.randint(4)
        
        if move_type == 0:  # Translate single tree
            idx = np.random.randint(len(neighbor))
            neighbor[idx, 0] += np.random.normal(0, 0.1)  # x
            neighbor[idx, 1] += np.random.normal(0, 0.1)  # y
        elif move_type == 1:  # Rotate single tree
            idx = np.random.randint(len(neighbor))
            neighbor[idx, 2] += np.random.normal(0, 10)  # angle in degrees
        elif move_type == 2:  # Swap two trees
            i1, i2 = np.random.choice(len(neighbor), 2, replace=False)
            neighbor[i1], neighbor[i2] = neighbor[i2].copy(), neighbor[i1].copy()
        else:  # Translate all
            dx, dy = np.random.normal(0, 0.05, 2)
            neighbor[:, 0] += dx
            neighbor[:, 1] += dy
        
        # Check validity and score
        if not has_overlap(neighbor):
            neighbor_score = calculate_score(neighbor)
            delta = neighbor_score - current_score
            
            # Accept if better or with probability exp(-delta/T)
            if delta < 0 or np.random.random() < np.exp(-delta / T):
                current = neighbor
                current_score = neighbor_score
                
                if current_score < best_score:
                    best = current.copy()
                    best_score = current_score
        
        T *= cooling_rate
    
    return best, best_score
```

**Test Plan:**
1. Test on N=10, N=20, N=50 first
2. Compare to baseline per-N scores
3. If improvement > 0.1%, scale to all N
4. Track per-N improvements for ensemble

## ✅ MANDATORY: PER-N TRACKING

```python
# After SA optimization
improvements = []
for n in range(1, 201):
    my_score = calculate_score_for_n(my_solution, n)
    base_score = baseline_scores[n]
    if my_score < base_score - 1e-6:
        improvements.append((n, base_score - my_score))
        print(f"✅ N={n}: {base_score:.6f} -> {my_score:.6f} (improved by {base_score - my_score:.6f})")

# Save improvements to best_per_n.json
```

## ✅ REQUIRED: SAVE CODE TO /home/code/code/

Create these files:
1. `/home/code/code/tree_geometry.py` - Tree vertices, bbox calculation
2. `/home/code/code/overlap_check.py` - Overlap validation with integer scaling
3. `/home/code/code/sa_optimizer.py` - Simulated annealing implementation
4. `/home/code/code/utils.py` - Score calculation, submission formatting

## Alternative Approaches (if SA doesn't work)

1. **Genetic Algorithm**: Crossover between configurations, mutation operators
2. **No-Fit Polygon (NFP)**: Precompute feasible placement regions
3. **Constraint Programming**: Model as constraints, use CP solver
4. **Hybrid**: Combine SA with local search refinement

## Submission Strategy

- **SUBMIT EVERY EXPERIMENT** - We have 97 submissions remaining
- Even if CV is worse, submit to get LB feedback
- Track which N values each approach improves
- Build ensemble from best per-N across all experiments

## What NOT to Try

- ❌ Running bbox3/sa_fast with different parameters (already at optimum)
- ❌ Backward propagation (already tried, no improvement)
- ❌ Simple lattice/grid (already tried, worse than baseline)
- ❌ Exhaustive search with coarse resolution (found worse solutions)

## Success Criteria

- **Minimum**: Find ANY improvement over baseline (even 0.001)
- **Good**: Improve by 0.1 points (to 70.5)
- **Excellent**: Improve by 0.5 points (to 70.1)
- **Target**: Reach 68.88 (1.73 point improvement)