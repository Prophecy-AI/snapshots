# Santa 2025 - Evolved Strategy (Loop 1)

## Current Status
- **Best CV score**: 70.523320 from exp_000 (baseline)
- **Best LB score**: N/A (not yet submitted)
- **Target**: 68.882921 (lower is better)
- **Gap to target**: 1.64 points (2.3% improvement needed)
- **Submissions remaining**: 99/100

## Response to Evaluator

The evaluator correctly identified:
1. ✅ Baseline established successfully at 70.523 (better than expected 70.647)
2. ✅ Per-N tracking is in place with detailed scores
3. ✅ No forbidden binaries were run

The evaluator's top priority recommendation is to **implement a Python-based optimization algorithm from scratch**. I agree with this assessment. The strategy is clear:
- Tessellation/lattice for large N (Priority 1)
- Exhaustive search for small N (Priority 2)

## ⛔ ABSOLUTELY FORBIDDEN (EXPERIMENT WILL BE REJECTED)

- bbox3, sa_fast_v2, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() with any binary - FORBIDDEN
- Running ANY pre-compiled binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any C++ tool - FORBIDDEN

**WHY:** Previous experiments ran these binaries for hours with NO improvements. They produce ~70.6 scores. Target is 68.88. BINARIES CANNOT GET THERE.

## Submission Log
| Exp | Approach | CV | LB | Notes |
|-----|----------|----|----|-------|
| 000 | baseline (pre-optimized ensemble) | 70.523 | N/A | Best snapshot ensemble |

## Per-N Score Analysis (from baseline)

**Highest contributors (worst efficiency - most room for improvement):**
- N=1: 0.6612 (already optimal at 45°)
- N=2: 0.4373 (HIGH - room for improvement!)
- N=3: 0.4347 (HIGH)
- N=4: 0.4111 (HIGH)
- N=5: 0.3941 (HIGH)
- N=6: 0.3996
- N=7: 0.3999

**Key insight**: N=2-10 contribute ~3.8 points (5.4% of total). Even small improvements here have outsized impact.

## MANDATORY FIRST EXPERIMENT: SUBMIT BASELINE

**CRITICAL**: Before any optimization, SUBMIT the baseline to get LB feedback!
- This establishes the CV-LB relationship
- We have 99 submissions - use them!
- Submit exp_000 immediately

## EXPERIMENT 001: SMALL N EXHAUSTIVE SEARCH (N=2-10)

After submitting baseline, implement exhaustive search for small N:

```python
import numpy as np
from numba import njit
import itertools

# Tree geometry
TX = np.array([0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125])
TY = np.array([0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5])

@njit
def get_tree_vertices(x, y, angle_deg):
    """Get tree polygon vertices at position (x,y) with rotation angle_deg."""
    rad = angle_deg * np.pi / 180.0
    cos_a, sin_a = np.cos(rad), np.sin(rad)
    rx = TX * cos_a - TY * sin_a + x
    ry = TX * sin_a + TY * cos_a + y
    return rx, ry

@njit
def calculate_bbox_side(trees):
    """Calculate bounding box side length for a configuration."""
    min_x = np.inf
    max_x = -np.inf
    min_y = np.inf
    max_y = -np.inf
    
    for i in range(len(trees)):
        x, y, angle = trees[i]
        rx, ry = get_tree_vertices(x, y, angle)
        min_x = min(min_x, rx.min())
        max_x = max(max_x, rx.max())
        min_y = min(min_y, ry.min())
        max_y = max(max_y, ry.max())
    
    return max(max_x - min_x, max_y - min_y)

# For N=2: Try all angle combinations with fine resolution
def optimize_n2():
    best_score = float('inf')
    best_config = None
    
    # Try angle combinations (1° resolution first, then refine)
    for a1 in range(0, 360, 1):
        for a2 in range(0, 360, 1):
            # Place tree 1 at origin
            # Place tree 2 at various positions
            for dx in np.linspace(-1, 1, 50):
                for dy in np.linspace(-1, 1, 50):
                    trees = np.array([[0, 0, a1], [dx, dy, a2]])
                    if not has_overlap(trees):
                        side = calculate_bbox_side(trees)
                        score = side * side / 2
                        if score < best_score:
                            best_score = score
                            best_config = trees.copy()
    
    return best_config, best_score
```

**Expected improvement**: 0.05-0.2 points from optimizing N=2-10

## EXPERIMENT 002: TESSELLATION FOR LARGE N (N >= 50)

Implement tessellation/lattice approach:

```python
def tessellation_optimize(n, num_iterations=10000):
    """
    Tessellation approach: 
    - 2 base trees form a unit cell
    - Grid of unit cells fills the space
    - Optimize: θ1, θ2, tx, ty, offset_x
    """
    best_score = float('inf')
    best_config = None
    
    for _ in range(num_iterations):
        # Random parameters
        theta1 = np.random.uniform(0, 360)
        theta2 = theta1 + 180 + np.random.uniform(-30, 30)  # Often opposite
        tx = np.random.uniform(0.3, 0.8)  # Horizontal spacing
        ty = np.random.uniform(0.3, 0.8)  # Vertical spacing
        offset_x = np.random.uniform(0, tx)  # Stagger offset
        
        # Generate grid
        trees = generate_tessellation_grid(n, theta1, theta2, tx, ty, offset_x)
        
        if not has_any_overlap(trees):
            side = calculate_bbox_side(trees)
            score = side * side / n
            if score < best_score:
                best_score = score
                best_config = trees.copy()
    
    return best_config, best_score
```

## Per-N Tracking (MANDATORY)

After EVERY experiment:
```python
def compare_and_save_improvements(new_configs, baseline_scores):
    improvements = []
    for n in range(1, 201):
        new_score = calculate_score_for_n(new_configs[n])
        if new_score < baseline_scores[n]:
            improvements.append((n, baseline_scores[n] - new_score))
            print(f"✅ N={n}: IMPROVED by {baseline_scores[n] - new_score:.6f}")
    
    # Save improvements even if total is worse
    if improvements:
        save_improved_n_values(new_configs, improvements)
    
    return improvements
```

## Validation (CRITICAL)

Before ANY submission:
```python
from shapely.geometry import Polygon

def validate_no_overlap(trees):
    """Validate no overlaps using Shapely with high precision."""
    polygons = []
    for x, y, angle in trees:
        vertices = get_tree_vertices(x, y, angle)
        polygons.append(Polygon(zip(vertices[0], vertices[1])))
    
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                return False, f"Trees {i} and {j} overlap"
    return True, "OK"
```

## Files and Resources
- Baseline submission: /home/code/experiments/000_baseline/submission.csv
- Baseline metrics: /home/code/experiments/000_baseline/metrics.json
- Tree geometry reference: research/kernels/inversion_santa-2025-getting-started/

## What NOT to Try
- Running bbox3, sa_fast, or any C++ binary
- "Optimizing" existing solutions with pre-compiled tools
- Running more iterations on existing optimizers

## Success Criteria
- exp_001: Improve at least 3 N values from N=2-10
- exp_002: Improve at least 10 N values from N>=50
- Total score improvement: > 0.1 points per experiment
