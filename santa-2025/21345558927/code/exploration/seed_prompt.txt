# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
Pack Christmas tree shapes (15-vertex polygons) into the smallest square bounding box for N=1 to 200 trees.
- **Score formula**: Σ(s²/n) where s = side length of bounding box for each N
- **Target**: 68.882921 (lower is better)
- **Current best from snapshots**: ~70.647
- **Gap to close**: ~1.76 points (2.5% improvement needed)

## ⛔ ABSOLUTELY FORBIDDEN (EXPERIMENT WILL BE REJECTED)

The following are PERMANENTLY FORBIDDEN after baseline:
- bbox3 - FORBIDDEN
- sa_fast_v2 - FORBIDDEN  
- eazy_optimizer - FORBIDDEN
- tree_packer - FORBIDDEN (all versions: v18, v21, etc.)
- shake_public - FORBIDDEN
- subprocess.run() with any binary - FORBIDDEN
- os.system() with any binary - FORBIDDEN
- ANY pre-compiled binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any C++ tool - FORBIDDEN
- Running "more iterations" on any optimizer - FORBIDDEN

**WHY BINARIES DON'T WORK:**
Previous experiments ran bbox3, tree_packer_v18, tree_packer_v21, sa_v1_parallel for hours.
Result: NO improvements. The pre-optimized solutions are at tight local optima.
Binaries produce ~70.6. Target is 68.88. BINARIES CANNOT GET THERE.

## ✅ MANDATORY FIRST TASK: ESTABLISH BASELINE

1. Find best pre-optimized submission in /home/nonroot/snapshots/santa-2025/
2. Load it and verify score locally
3. DO NOT run any optimizer on it
4. This is your baseline (~70.647)

## ✅ MANDATORY: IMPLEMENT ALGORITHM IN PYTHON (NOT BINARIES!)

### Priority 1: TESSELLATION/LATTICE APPROACH (For N >= 20)
This is fundamentally different from local search and can achieve sub-69 scores.

**How tessellation works:**
```python
# Start with 2 base trees in a specific configuration
# Tree 1: position (0, 0), angle θ1
# Tree 2: position (dx, dy), angle θ2 (often θ2 = θ1 + 180°)

# Create grid by translating the 2-tree unit cell:
# For N trees, find grid dimensions (rows, cols) where rows * cols >= N
# Translation vectors: tx (horizontal), ty (vertical)

# Place trees:
for row in range(rows):
    for col in range(cols):
        if tree_count < N:
            x = col * tx + (row % 2) * offset_x  # Optional staggering
            y = row * ty
            place_tree(x, y, angle)
            tree_count += 1

# Optimize: Use SA to find best (θ1, θ2, tx, ty, offset_x)
```

**Key insight**: Tessellation exploits periodicity. Instead of optimizing N independent trees, optimize 5-6 parameters that generate the entire configuration.

### Priority 2: SMALL N EXHAUSTIVE SEARCH (N=1 to 15)
Small N values contribute MOST to score:
- N=1: contributes 0.66 (optimal at 45°, side=0.8132)
- N=2-10: Low efficiency, high score contribution

```python
# For N=1: Already optimal at 45 degrees
# For N=2-5: Try all angle combinations (0.1° increments)
# For N=6-15: Branch-and-bound with pruning

def exhaustive_small_n(n, angle_step=0.1):
    best_score = float('inf')
    best_config = None
    
    # Generate all angle combinations
    angles = np.arange(0, 360, angle_step)
    
    for angle_combo in itertools.product(angles, repeat=n):
        # Place trees greedily with these angles
        config = place_trees_greedy(n, angle_combo)
        if not has_overlap(config):
            score = calculate_score(config)
            if score < best_score:
                best_score = score
                best_config = config
    
    return best_config
```

### Priority 3: BACKWARD PROPAGATION (Deletion Cascade)
After optimizing large N, propagate improvements to smaller N:

```python
def backward_propagation(configs):
    """configs[n] = best configuration for n trees"""
    for n in range(200, 1, -1):
        # Try removing each tree from n-tree config
        for tree_idx in range(n):
            candidate = remove_tree(configs[n], tree_idx)
            candidate_score = calculate_score(candidate, n-1)
            
            if candidate_score < calculate_score(configs[n-1], n-1):
                configs[n-1] = candidate
                print(f"Improved N={n-1}: {candidate_score}")
    
    return configs
```

### Priority 4: FRACTIONAL TRANSLATION (Fine-tuning)
After main optimization, squeeze out small improvements:

```python
steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005]
directions = [(1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,-1), (1,-1), (-1,1)]

def fractional_translation(config):
    improved = True
    while improved:
        improved = False
        for tree_idx in range(len(config)):
            for step in steps:
                for dx, dy in directions:
                    new_config = move_tree(config, tree_idx, dx*step, dy*step)
                    if not has_overlap(new_config) and score(new_config) < score(config):
                        config = new_config
                        improved = True
    return config
```

## ✅ MANDATORY: PER-N SOLUTION TRACKING

Track best solution for EACH N value separately:

```python
# Load baseline per-N scores
baseline_scores = {}
for n in range(1, 201):
    baseline_scores[n] = calculate_score_for_n(baseline_config, n)

# After your algorithm runs, compare per-N scores
improved_n = []
for n in range(1, 201):
    new_score = calculate_score_for_n(new_config, n)
    if new_score < baseline_scores[n]:
        improved_n.append(n)
        print(f"N={n}: {baseline_scores[n]:.6f} -> {new_score:.6f}")

# SAVE any N where you improved (even if total is worse)
# Accumulate improvements across experiments
```

## Tree Geometry (15 vertices)
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def get_tree_polygon(x, y, angle_deg):
    """Get tree polygon vertices at position (x,y) with rotation angle_deg."""
    rad = np.radians(angle_deg)
    cos_a, sin_a = np.cos(rad), np.sin(rad)
    
    vertices = []
    for tx, ty in zip(TX, TY):
        # Rotate then translate
        rx = tx * cos_a - ty * sin_a + x
        ry = tx * sin_a + ty * cos_a + y
        vertices.append((rx, ry))
    
    return vertices
```

## Collision Detection (CRITICAL)
```python
from numba import njit

@njit
def point_in_polygon(px, py, polygon):
    """Ray casting algorithm."""
    n = len(polygon)
    inside = False
    j = n - 1
    for i in range(n):
        xi, yi = polygon[i]
        xj, yj = polygon[j]
        if ((yi > py) != (yj > py)) and (px < (xj - xi) * (py - yi) / (yj - yi) + xi):
            inside = not inside
        j = i
    return inside

@njit
def segments_intersect(a1, a2, b1, b2):
    """Check if line segment a1-a2 intersects b1-b2."""
    def ccw(A, B, C):
        return (C[1]-A[1]) * (B[0]-A[0]) > (B[1]-A[1]) * (C[0]-A[0])
    return ccw(a1,b1,b2) != ccw(a2,b1,b2) and ccw(a1,a2,b1) != ccw(a1,a2,b2)

@njit
def polygons_overlap(poly1, poly2):
    """Check if two polygons overlap."""
    # Quick bounding box check
    min1x = min(p[0] for p in poly1)
    max1x = max(p[0] for p in poly1)
    min1y = min(p[1] for p in poly1)
    max1y = max(p[1] for p in poly1)
    min2x = min(p[0] for p in poly2)
    max2x = max(p[0] for p in poly2)
    min2y = min(p[1] for p in poly2)
    max2y = max(p[1] for p in poly2)
    
    if max1x < min2x or max2x < min1x or max1y < min2y or max2y < min1y:
        return False
    
    # Point-in-polygon checks
    for p in poly1:
        if point_in_polygon(p[0], p[1], poly2):
            return True
    for p in poly2:
        if point_in_polygon(p[0], p[1], poly1):
            return True
    
    # Edge intersection checks
    n1, n2 = len(poly1), len(poly2)
    for i in range(n1):
        for j in range(n2):
            if segments_intersect(poly1[i], poly1[(i+1)%n1], poly2[j], poly2[(j+1)%n2]):
                return True
    
    return False
```

## Score Calculation
```python
def calculate_total_score(configs):
    """configs is dict: n -> list of (x, y, angle) tuples"""
    total = 0
    for n in range(1, 201):
        trees = configs[n]
        
        # Get all polygons
        all_vertices = []
        for x, y, angle in trees:
            poly = get_tree_polygon(x, y, angle)
            all_vertices.extend(poly)
        
        # Calculate bounding box
        xs = [v[0] for v in all_vertices]
        ys = [v[1] for v in all_vertices]
        width = max(xs) - min(xs)
        height = max(ys) - min(ys)
        side = max(width, height)
        
        # Score contribution
        total += (side ** 2) / n
    
    return total
```

## Submission Format
```python
def save_submission(configs, filepath):
    """Save configurations to submission CSV."""
    rows = []
    for n in range(1, 201):
        for tree_idx, (x, y, angle) in enumerate(configs[n]):
            rows.append({
                'id': f'{n:03d}_{tree_idx}',
                'x': f's{x:.20f}',  # High precision!
                'y': f's{y:.20f}',
                'deg': f's{angle:.20f}'
            })
    
    df = pd.DataFrame(rows)
    df.to_csv(filepath, index=False)
```

## Insights from Discussions (from kernel analysis)

### From yongsukprasertsuk kernel (bbox3 runner):
- 3-phase approach: Phase A (short 2min runs), Phase B (10min on top candidates), Phase C (20min on best few)
- Uses fix_direction for rotation tightening
- repair_overlaps_in_place for validation
- Key insight: Only process candidates that beat current best

### From smartmanoj kernel (tree_packer_v21):
- Multi-start SA with different angle restarts
- SWAP move operator - swap positions of two trees
- Higher temperature SA for aggressive exploration
- All N values processed in parallel with OpenMP

### From jiweiliu kernel (tessellation):
- Claims ~0.15 improvement in 2 minutes
- Uses Numba for acceleration
- Deletion cascade to propagate improvements
- Grid configs cover N from 20-200

### Key Discussion Insights:
- "Why the winning solutions will be Asymmetric" (40 votes) - asymmetric packings beat symmetric
- Top teams achieve sub-68 scores using novel approaches
- Tessellation/lattice is fundamentally different from local optimization

## What DOESN'T Work (Avoid These)
- Running bbox3/sa_fast with more iterations (local optima)
- Simple ensemble of same-source files (one dominates all N)
- fix_direction without overlap repair (causes precision issues)
- Short optimization runs (need hours, not minutes)
- Copying pre-optimized solutions without implementing new algorithms
- ANY pre-compiled binary optimizer

## Recommended Experiment Sequence

### exp_000: Baseline
- Load best pre-optimized submission from snapshots
- Verify score matches expected ~70.647
- DO NOT run any optimizer

### exp_001: Implement Tessellation from Scratch
- Implement 2-tree seed + grid translation IN PYTHON
- Use Numba for acceleration
- Target N >= 20 configurations
- Expected improvement: 0.1-0.3 points

### exp_002: Deletion Cascade
- Propagate tessellation improvements to smaller N
- Work backwards from N=200 to N=2
- Expected improvement: 0.05-0.1 points

### exp_003: Small N Exhaustive Search
- For N=2 to N=15, try exhaustive placement
- Branch-and-bound with pruning
- Expected improvement: 0.05-0.1 points

### exp_004: Fractional Translation Fine-tuning
- Apply micro-adjustments to all trees
- Use 8-direction search with decreasing step sizes
- Expected improvement: 0.01-0.05 points

## Files and Resources
- Best pre-optimized: /home/nonroot/snapshots/santa-2025/*/
- Tree geometry: ../research/kernels/inversion_santa-2025-getting-started/
- Sample submission: /home/data/sample_submission.csv

## Validation Requirements
1. NO overlapping trees (Kaggle rejects overlaps)
2. Use high precision (20+ decimal places)
3. Coordinates must be in [-100, 100]
4. Validate before submission with overlap check

## CV-LB Relationship
- CV = LB exactly (this is a pure optimization problem)
- Local scoring is 100% accurate
- No distribution shift to worry about
