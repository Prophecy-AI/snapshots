# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
Pack Christmas tree shapes (15-vertex polygons) into the smallest square bounding box for N=1 to 200 trees.
- **Score formula**: Σ(s²/n) where s = side length of bounding box for each N
- **Target**: 68.882921 (lower is better)
- **Current best from snapshots**: ~70.647
- **Gap to close**: ~1.76 points (2.5% improvement needed)
- **Total trees**: 20100 (1+2+3+...+200)

## ⛔ ABSOLUTELY FORBIDDEN (EXPERIMENT WILL BE REJECTED)

The following are PERMANENTLY FORBIDDEN after baseline:
- bbox3 - FORBIDDEN
- sa_fast_v2 - FORBIDDEN  
- eazy_optimizer - FORBIDDEN
- tree_packer - FORBIDDEN (all versions: v18, v21, etc.)
- shake_public - FORBIDDEN
- subprocess.run() with any binary - FORBIDDEN
- os.system() with any binary - FORBIDDEN
- ANY pre-compiled binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any C++ tool - FORBIDDEN
- Running "more iterations" on any optimizer - FORBIDDEN

**WHY BINARIES DON'T WORK:**
Previous experiments ran bbox3, tree_packer_v18, tree_packer_v21, sa_v1_parallel for hours.
Result: NO improvements. The pre-optimized solutions are at tight local optima.
Binaries produce ~70.6. Target is 68.88. BINARIES CANNOT GET THERE.

## ✅ MANDATORY FIRST TASK: ESTABLISH BASELINE

1. Find best pre-optimized submission in /home/nonroot/snapshots/santa-2025/
2. Load it and verify score locally
3. DO NOT run any optimizer on it
4. This is your baseline (~70.647)

## ✅ MANDATORY: IMPLEMENT ALGORITHM IN PYTHON (NOT BINARIES!)

### Priority 1: TESSELLATION/LATTICE APPROACH (For N >= 20)
This is fundamentally different from local search and can achieve sub-69 scores.

**How tessellation works:**
```python
# Start with 2 base trees in a specific configuration
# Tree 1: position (0, 0), angle θ1
# Tree 2: position (dx, dy), angle θ2 (often θ2 = θ1 + 180°)

# Create grid by translating the 2-tree unit cell:
# For N trees, find grid dimensions (rows, cols) where rows * cols >= N
# Translation vectors: tx (horizontal), ty (vertical)

# Place trees:
for row in range(rows):
    for col in range(cols):
        if tree_count < N:
            x = col * tx + (row % 2) * offset_x  # Optional staggering
            y = row * ty
            place_tree(x, y, angle)
            tree_count += 1

# Optimize: Use SA to find best (θ1, θ2, tx, ty, offset_x)
```

**Key insight**: Tessellation exploits periodicity. Instead of optimizing N independent trees, optimize 5-6 parameters that generate the entire configuration.

### Priority 2: SMALL N EXHAUSTIVE SEARCH (N=1 to 15)
Small N values contribute MOST to score:
- N=1: contributes 0.66 (optimal at 45°, side=0.8132)
- N=2-10: Low efficiency, high score contribution

```python
# For N=1: Already optimal at 45 degrees
# For N=2-5: Try all angle combinations (0.1° increments)
# For N=6-15: Branch-and-bound with pruning

def exhaustive_small_n(n, angle_step=0.1):
    best_score = float('inf')
    best_config = None
    
    # Generate all angle combinations
    angles = np.arange(0, 360, angle_step)
    
    for angle_combo in itertools.product(angles, repeat=n):
        # Place trees greedily with these angles
        config = place_trees_greedy(n, angle_combo)
        if not has_overlap(config):
            score = calculate_score(config)
            if score < best_score:
                best_score = score
                best_config = config
    
    return best_config
```

### Priority 3: BACKWARD PROPAGATION (Deletion Cascade)
After optimizing large N, propagate improvements to smaller N:

```python
def backward_propagation(configs):
    """configs[n] = best configuration for n trees"""
    for n in range(200, 1, -1):
        # Try removing each tree from n-tree config
        for tree_idx in range(n):
            candidate = remove_tree(configs[n], tree_idx)
            candidate_score = calculate_score(candidate, n-1)
            
            if candidate_score < calculate_score(configs[n-1], n-1):
                configs[n-1] = candidate
                print(f"Improved N={n-1}: {candidate_score}")
    
    return configs
```

### Priority 4: FRACTIONAL TRANSLATION (Fine-tuning)
After main optimization, squeeze out small improvements:

```python
steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005]
directions = [(1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,-1), (1,-1), (-1,1)]

def fractional_translation(config):
    improved = True
    while improved:
        improved = False
        for tree_idx in range(len(config)):
            for step in steps:
                for dx, dy in directions:
                    new_config = move_tree(config, tree_idx, dx*step, dy*step)
                    if not has_overlap(new_config) and score(new_config) < score(config):
                        config = new_config
                        improved = True
    return config
```

## ✅ MANDATORY: PER-N SOLUTION TRACKING

Track best solution for EACH N value separately:

```python
# Load baseline per-N scores
baseline_scores = {}
for n in range(1, 201):
    baseline_scores[n] = calculate_score_for_n(baseline_config, n)

# After your algorithm runs, compare per-N scores
improved_n = []
for n in range(1, 201):
    new_score = calculate_score_for_n(new_config, n)
    if new_score < baseline_scores[n]:
        improved_n.append(n)
        print(f"N={n}: {baseline_scores[n]:.6f} -> {new_score:.6f}")

# SAVE any N where you improved (even if total is worse)
# Accumulate improvements across experiments
```

## Tree Geometry (15 vertices)
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def get_tree_polygon(x, y, angle_deg):
    """Get tree polygon vertices at position (x,y) with rotation angle_deg."""
    rad = np.radians(angle_deg)
    cos_a, sin_a = np.cos(rad), np.sin(rad)
    
    vertices = []
    for tx, ty in zip(TX, TY):
        # Rotate then translate
        rx = tx * cos_a - ty * sin_a + x
        ry = tx * sin_a + ty * cos_a + y
        vertices.append((rx, ry))
    
    return vertices
```

## Collision Detection (CRITICAL)
```python
from numba import njit
import numpy as np

@njit
def point_in_polygon(px, py, polygon):
    """Ray casting algorithm."""
    n = len(polygon)
    inside = False
    j = n - 1
    for i in range(n):
        xi, yi = polygon[i][0], polygon[i][1]
        xj, yj = polygon[j][0], polygon[j][1]
        if ((yi > py) != (yj > py)) and (px < (xj - xi) * (py - yi) / (yj - yi) + xi):
            inside = not inside
        j = i
    return inside

@njit
def segments_intersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y):
    """Check if line segment a1-a2 intersects b1-b2."""
    def ccw(Ax, Ay, Bx, By, Cx, Cy):
        return (Cy-Ay) * (Bx-Ax) > (By-Ay) * (Cx-Ax)
    return ccw(a1x,a1y,b1x,b1y,b2x,b2y) != ccw(a2x,a2y,b1x,b1y,b2x,b2y) and \
           ccw(a1x,a1y,a2x,a2y,b1x,b1y) != ccw(a1x,a1y,a2x,a2y,b2x,b2y)

@njit
def polygons_overlap(poly1, poly2):
    """Check if two 15-vertex polygons overlap."""
    NV = 15
    
    # Quick bounding box check
    min1x = poly1[0, 0]
    max1x = poly1[0, 0]
    min1y = poly1[0, 1]
    max1y = poly1[0, 1]
    for i in range(1, NV):
        if poly1[i, 0] < min1x: min1x = poly1[i, 0]
        if poly1[i, 0] > max1x: max1x = poly1[i, 0]
        if poly1[i, 1] < min1y: min1y = poly1[i, 1]
        if poly1[i, 1] > max1y: max1y = poly1[i, 1]
    
    min2x = poly2[0, 0]
    max2x = poly2[0, 0]
    min2y = poly2[0, 1]
    max2y = poly2[0, 1]
    for i in range(1, NV):
        if poly2[i, 0] < min2x: min2x = poly2[i, 0]
        if poly2[i, 0] > max2x: max2x = poly2[i, 0]
        if poly2[i, 1] < min2y: min2y = poly2[i, 1]
        if poly2[i, 1] > max2y: max2y = poly2[i, 1]
    
    if max1x < min2x or max2x < min1x or max1y < min2y or max2y < min1y:
        return False
    
    # Point-in-polygon checks
    for i in range(NV):
        if point_in_polygon(poly1[i, 0], poly1[i, 1], poly2):
            return True
        if point_in_polygon(poly2[i, 0], poly2[i, 1], poly1):
            return True
    
    # Edge intersection checks
    for i in range(NV):
        ni = (i + 1) % NV
        for j in range(NV):
            nj = (j + 1) % NV
            if segments_intersect(poly1[i,0], poly1[i,1], poly1[ni,0], poly1[ni,1],
                                  poly2[j,0], poly2[j,1], poly2[nj,0], poly2[nj,1]):
                return True
    
    return False
```

## Score Calculation
```python
def calculate_total_score(configs):
    """configs is dict: n -> list of (x, y, angle) tuples"""
    total = 0
    for n in range(1, 201):
        trees = configs[n]
        
        # Get all polygon vertices
        all_xs = []
        all_ys = []
        for x, y, angle in trees:
            poly = get_tree_polygon(x, y, angle)
            for vx, vy in poly:
                all_xs.append(vx)
                all_ys.append(vy)
        
        # Calculate bounding box
        width = max(all_xs) - min(all_xs)
        height = max(all_ys) - min(all_ys)
        side = max(width, height)
        
        # Score contribution
        total += (side ** 2) / n
    
    return total
```

## Submission Format
```python
def save_submission(configs, filepath):
    """Save configurations to submission CSV."""
    rows = []
    for n in range(1, 201):
        for tree_idx, (x, y, angle) in enumerate(configs[n]):
            rows.append({
                'id': f'{n:03d}_{tree_idx}',
                'x': f's{x:.20f}',  # High precision!
                'y': f's{y:.20f}',
                'deg': f's{angle:.20f}'
            })
    
    df = pd.DataFrame(rows)
    df.to_csv(filepath, index=False)
```

## Insights from Discussions (from kernel analysis)

### From yongsukprasertsuk kernel (bbox3 runner):
- 3-phase approach: Phase A (short 2min runs), Phase B (10min on top candidates), Phase C (20min on best few)
- Uses fix_direction for rotation tightening
- repair_overlaps_in_place for validation
- Key insight: Only process candidates that beat current best

### From smartmanoj kernel (tree_packer_v21):
- Multi-start SA with different angle restarts
- SWAP move operator - swap positions of two trees
- Higher temperature SA for aggressive exploration
- All N values processed in parallel with OpenMP

### From jiweiliu kernel (tessellation):
- Claims ~0.15 improvement in 2 minutes
- Uses Numba for acceleration
- Deletion cascade to propagate improvements
- Grid configs cover N from 20-200

### Key Discussion Insights:
- "Why the winning solutions will be Asymmetric" (40 votes) - asymmetric packings beat symmetric
- Top teams achieve sub-68 scores using novel approaches
- Tessellation/lattice is fundamentally different from local optimization

## Academic Research Insights (from web search)
- **No-Fit Polygon (NFP)**: Standard geometric representation for feasible placements
- **Bottom-left heuristics**: Common for initial placement
- **Guided Cuckoo Search (GCS)**: State-of-the-art heuristic for nesting problems
- **Branch-and-bound**: For exact solutions on small instances
- **Problem is NP-hard**: Heuristic approaches necessary for large N

## What DOESN'T Work (Avoid These)
- Running bbox3/sa_fast with more iterations (local optima)
- Simple ensemble of same-source files (one dominates all N)
- fix_direction without overlap repair (causes precision issues)
- Short optimization runs (need hours, not minutes)
- Copying pre-optimized solutions without implementing new algorithms
- ANY pre-compiled binary optimizer

## Recommended Experiment Sequence

### exp_000: Baseline
- Load best pre-optimized submission from snapshots
- Verify score matches expected ~70.647
- DO NOT run any optimizer

### exp_001: Implement Tessellation from Scratch
- Implement 2-tree seed + grid translation IN PYTHON
- Use Numba for acceleration
- Target N >= 20 configurations
- Expected improvement: 0.1-0.3 points

### exp_002: Deletion Cascade
- Propagate tessellation improvements to smaller N
- Work backwards from N=200 to N=2
- Expected improvement: 0.05-0.1 points

### exp_003: Small N Exhaustive Search
- For N=2 to N=15, try exhaustive placement
- Branch-and-bound with pruning
- Expected improvement: 0.05-0.1 points

### exp_004: Fractional Translation Fine-tuning
- Apply micro-adjustments to all trees
- Use 8-direction search with decreasing step sizes
- Expected improvement: 0.01-0.05 points

## Files and Resources
- Best pre-optimized: /home/nonroot/snapshots/santa-2025/*/
- Tree geometry: ../research/kernels/inversion_santa-2025-getting-started/
- Sample submission: /home/data/sample_submission.csv
- Total rows in submission: 20100 (header + 20100 trees)

## Validation Requirements
1. NO overlapping trees (Kaggle rejects overlaps)
2. Use high precision (20+ decimal places)
3. Coordinates must be in [-100, 100]
4. Validate before submission with overlap check

## CV-LB Relationship
- CV = LB exactly (this is a pure optimization problem)
- Local scoring is 100% accurate
- No distribution shift to worry about
