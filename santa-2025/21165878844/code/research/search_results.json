{
  "query": "What techniques do Kaggle Santa competition winners use to achieve top scores in polygon packing optimization?",
  "results": [
    {
      "title": "ANSWER",
      "text": "The most successful Kaggle\u202fSanta (Christmas\u2011Tree\u2011Packing) solutions rely on **hand\u2011crafted meta\u2011heuristics rather than generic machine\u2011learning or reinforcement\u2011learning**.  Winners first generate a good feasible layout with a fast **greedy or integer\u2011programming seed** and then improve it through **local\u2011search moves** that repeatedly try to eliminate overlaps and tighten the packing.  A common recipe is to **partition the square container and the set of polygons into smaller sub\u2011problems**, solve each sub\u2011problem sequentially, and finally merge the results, which keeps the search space tractable even for instances with tens of thousands of pieces ([Luo\u202fet\u202fal., 2024](https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.86/LIPIcs.SoCG.2024.86.pdf)).  The improvement phase often mixes several **evolutionary and tabu\u2011search operators** \u2013 e.g., differential\u2011evolution mutation of polygon positions, tabu\u2011list\u2011based move rejection, and hill\u2011climbing swaps \u2013 to explore diverse configurations while avoiding cycling.\n\nThe **Shadoks team**, which placed among the top competitors, described a very similar pipeline: an **integer\u2011programming\u2011based greedy initializer** followed by an intensive **local\u2011search refinement** that leverages both **translation\u2011only moves** and value\u2011oriented selection of items.  Their solver also uses **custom heuristics for initial solution generation** and then iteratively improves the packing through **neighbourhood searches** that respect the convex\u2011container constraint ([Shadoks\u202f2024](https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.84/LIPIcs.SoCG.2024.84.pdf)).  Across the leaderboard, participants who tried pure reinforcement\u2011learning approaches reported poor performance, confirming that **deterministic combinatorial heuristics remain the dominant technique for top scores** ([Dhiman\u202f2025](https://hmnshudhmn24.medium.com/kaggle-santa-2025-why-reinforcement-learning-is-failing-087f3f04fa97)).",
      "url": ""
    },
    {
      "title": "A General Heuristic Approach for Maximum Polygon Packing",
      "text": "A General Heuristic Approach for Maximum\nPolygon Packing\nCanhui Luo #\nHuazhong University of Science and Technology, Wuhan, China\nZhouxing Su1 #\nHuazhong University of Science and Technology, Wuhan, China\nZhipeng L\u00fc #\nHuazhong University of Science and Technology, Wuhan, China\nAbstract\nThis work proposes a general heuristic packing approach to address the Maximum Polygon Packing\nProblem introduced by the CG:SHOP 2024 Challenge. Our solver primarily consists of two steps:\n(1) Partitioning the container and polygons to form a series of small-scale subproblems; (2) For each\nsubproblem, sequentially placing polygons into the container and attempting to eliminate overlaps.\n2012 ACM Subject Classification Theory of computation \u2192 Computational geometry; Computing\nmethodologies \u2192 Search methodologies\nKeywords and phrases packing, polygon, heuristic, differential evolution, local search, tabu search\nDigital Object Identifier 10.4230/LIPIcs.SoCG.2024.86\nCategory CG Challenge\nFunding This work was supported in part by the National Natural Science Foundation of China\n(NSFC) under Grant 72101094 and the Special Project for Knowledge Innovation of Hubei Province\nunder Grant 2022013301015175.\nAcknowledgements We want to thank the organizers of CG:SHOP 2024 and all other participants\nfor creating such an engaging challenge. We also want to thank Dominik Krupke for providing a\nhelpful official validator for solutions.\n1 Introduction\nThe recent CG:SHOP 2024 Challenge introduced a variant of irregular packing problems\nknown as the Maximum Polygon Packing (MPP) problem. The MPP problem involves a\nconvex polygonal container C and a polygon set P = {p1, p2, ..., pN }, where polygon piis\nassociated with a value vi. It seeks for a non-overlapping packing with the maximum total\nvalue. The challenge presents a total of 180 instances whose number of polygons ranges from\n28 to 50,000. The official document [4] gives a detailed description of the challenge.\nOur proposed algorithm employs a general process to solve these instances indiscriminately,\nand the overall framework is presented in Figure 1. We first partition a large-scale problem\ninto multiple small-scale subproblems (Section 2) and then solve each subproblem using\nupper-level polygon ordering (Section 3.1) and lower-level packing optimization techniques\n(Section 3.2). Section 4 presents our experimental results, followed by conclusions.\n1 Corresponding author: Zhouxing Su\n\u00a9 Canhui Luo, Zhouxing Su, and Zhipeng L\u00fc;\nlicensed under Creative Commons License CC-BY 4.0\n40th International Symposium on Computational Geometry (SoCG 2024).\nEditors: Wolfgang Mulzer and Jeff M. Phillips; Article No. 86; pp. 86:1\u201386:9\nLeibniz International Proceedings in Informatics\nSchloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik, Dagstuhl Publishing, Germany\n86:2 A General Heuristic Approach for Maximum Polygon Packing\nInput polygon set P and container C\nUpper-level polygon ordering\nLower-level packing optimization\nFinished?\n \nPacking\nAssemble and return the complete solution\nMPP1 MPP2 MPPm\n( ) 0? Overlap Scurr== ( ) Update Sbest best\nReturn S\nPartitioning\nYes\nNo\nYes\nNo\nSelect next one\nFigure 1 The framework of our proposed algorithm.\n2 Partitioning\nIn this section, we present the decomposition of the original large-scale problem into a series\nof smaller MPP subproblems. It involves two components: partitioning the container C into\nmultiple regions and assigning polygons to each region.\n2.1 Container Partitioning\nThe container partitioning process consists of two steps, as shown in Figure 2. Initially, we\narrange two-dimensional square grids starting from the bottom-left corner of the bounding\nbox until the entire container is covered. The subregions formed by the intersection of the\ncontainer with all the grids constitute its partition C = C1 \u222a C2 \u222a ... \u222a Cm. Subsequently,\nwe merge the small subregions with adjacent grids, which are difficult to be used effectively.\nThe grid is dimensioned to keep the scale of each subproblem at approximately 300 polygons,\nmaking a trade-off between effectiveness and efficiency of lower-level packing optimization.\n2.2 Polygon Assignment\nWe adopt a simple approach of randomly assigning polygons to each subregion. Specifically, for\neach subregion Ci, we randomly select a polygon pj from P until\nP\nj\narea(pj )\narea(Ci) \u2265\nPN\ni=0\narea(pi)\narea(C)\n.\nThe advantage of random assignment lies in ensuring that the overall characteristics of each\nsubproblem align with the original problem.\nC. Luo, Z. Su, and Z. L\u00fc 86:3\nFigure 2 The partitioning process for the instance jigsaw_cf1_4fd4c46e. Step 1 (left): Cover the\ncontainer with squares; Step 2: Intersect and merge small regions (from the middle to the right).\nminimum translation\nminimum translation\nIFP\nContainer\nFigure 3 Examples of NFP between two polygons and IFP between container and polygon.\n3 Packing\n3.1 Upper-Level Polygon Ordering\nWe define a priority for each polygon. We repeatedly select one remaining polygon with the\nhighest priority (ties are broken by value) and try to insert it into the current solution. If the\ninsertion with lower-level packing optimization fails, we skip the current polygon and turn to\nthe next one. For the majority of instances, the priority is defined as the value-to-area ratio\nof a polygon (we also call it unit value). Polygons with higher unit values are prioritized\nfor putting in the container, which is called the Unit Value First (UVF) strategy. For\nsmall-scale instances (N < 100), we employ the \u03b1\u03b2-random strategy. It randomly selects\n\u03b1% and \u03b2% of the polygons and reassigns their UVF-based priority to the highest and the\nlowest, respectively. These instances are run for multiple times to ensure comprehensive\noptimization, with \u03b1 and \u03b2 set to 10 in our implementation.\n3.2 Lower-Level Packing Optimization\nThe position of a polygon can be represented by the coordinates l = (x, y) of a reference point,\nsuch as the bottom-left corner of the boundary. Then, the translation of a polygon can be\nrepresented by a vector pointing from its original position to its new position. Given a feasible\npacking S and a polygon p to be placed, it is impossible to find a non-overlapping position\nfor p without moving other polygons in most cases. This section introduces the algorithm for\neliminating overlaps for an invalid packing, which involves solving an unconstrained nonlinear\nproblem and heuristic polygon movement.\nS o C G 2 0 2 4\n86:4 A General Heuristic Approach for Maximum Polygon Packing\n3.2.1 Overlap Minimization\nTo determine the appropriate translation for the polygons, we utilized the no-fit polygon\n(NFP) and inner-fit polygon (IFP), which are fundamental in algorithmic approaches to\ngeometric design and optimization challenges. For a fixed polygon pi and a movable polygon\npj , NFP(pi, pj ) describes their non-overlapping positions with boundaries in contact precisely,\nwhich can be utilized to determine the minimum translation for pj to avoid overlap. Similarly,\nIFP(pi, pj ) is employed to determine the minimum translation to place pj inside pi. Figure 3\nillustrates the polygon translations determined using NFP (left) and IFP (right). The readers\nmay refer to Burke et al. [2] for a more detailed description.\nFor a packing S, based on NFP and IFP, we define the overlap between polygons pi\nand pj as fij (S), representing the minimum translation to separate them, and f0i(S) as the\nminimum translation for moving pi to fit into the container. Subsequently, we employ the\nseparation algorithm proposed by Imamichi et al. [7] to minimize the overlap, which involves\nsolving an unconstrained nonlinear programming problem as follows:\nmin\nS\nF(S) = X\n0\u2264i<j\u2264N\nf\n2\nij (S) (1)\nThe model relaxes the non-overlapping constraint but introduces repulsion forces between\nany two overlapped polygons. We use the classic L-BFGS (limited memory BFGS) method\nto solve this problem. It makes the packing S converge to a local optimum but strongly\ndepends on the initial layout. ...",
      "url": "https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.86/LIPIcs.SoCG.2024.86.pdf"
    },
    {
      "title": "Kaggle Santa 2025: Why \u201cReinforcement Learning\u201d is Failing",
      "text": "Kaggle Santa 2025: Why \u201cReinforcement Learning\u201d is Failing | by Himanshu Dhiman | Dec, 2025 | Medium\n[Sitemap](https://hmnshudhmn24.medium.com/sitemap/sitemap.xml)\n[Open in app](https://play.google.com/store/apps/details?id=com.medium.reader&amp;referrer=utm_source=mobileNavBar&amp;source=post_page---top_nav_layout_nav-----------------------------------------)\nSign up\n[Sign in](https://medium.com/m/signin?operation=login&amp;redirect=https://hmnshudhmn24.medium.com/kaggle-santa-2025-why-reinforcement-learning-is-failing-087f3f04fa97&amp;source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\n[Medium Logo](https://medium.com/?source=post_page---top_nav_layout_nav-----------------------------------------)\n[\nWrite\n](https://medium.com/m/signin?operation=register&amp;redirect=https://medium.com/new-story&amp;source=---top_nav_layout_nav-----------------------new_post_topnav------------------)\n[\nSearch\n](https://medium.com/search?source=post_page---top_nav_layout_nav-----------------------------------------)\nSign up\n[Sign in](https://medium.com/m/signin?operation=login&amp;redirect=https://hmnshudhmn24.medium.com/kaggle-santa-2025-why-reinforcement-learning-is-failing-087f3f04fa97&amp;source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\n![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)\n# Kaggle Santa 2025: Why \u201cReinforcement Learning\u201d is Failing\n[\n![Himanshu Dhiman](https://miro.medium.com/v2/resize:fill:64:64/1*3jyWFYIYAox5D7cqT7gIRA.jpeg)\n](https://hmnshudhmn24.medium.com/?source=post_page---byline--087f3f04fa97---------------------------------------)\n[Himanshu Dhiman](https://hmnshudhmn24.medium.com/?source=post_page---byline--087f3f04fa97---------------------------------------)\n3 min read\n\u00b7Dec 21, 2025\n[\n](https://medium.com/m/signin?actionUrl=https://medium.com/_/vote/p/087f3f04fa97&amp;operation=register&amp;redirect=https://hmnshudhmn24.medium.com/kaggle-santa-2025-why-reinforcement-learning-is-failing-087f3f04fa97&amp;user=Himanshu+Dhiman&amp;userId=288bb1baa8d2&amp;source=---header_actions--087f3f04fa97---------------------clap_footer------------------)\n--\n[](https://medium.com/m/signin?actionUrl=https://medium.com/_/bookmark/p/087f3f04fa97&amp;operation=register&amp;redirect=https://hmnshudhmn24.medium.com/kaggle-santa-2025-why-reinforcement-learning-is-failing-087f3f04fa97&amp;source=---header_actions--087f3f04fa97---------------------bookmark_footer------------------)\nListen\nShare\nPress enter or click to view image in full size\n![]()\nEvery December, Kaggle drops a \u201cSanta\u201d competition that ruins the holidays for thousands of data scientists. We expect a fun puzzle. We get a nightmare of Combinatorial Optimization.\nThis year\u2019s edition,**\u201cSanta 2025: The Christmas Tree Packing Challenge,\u201d**is no exception. The goal? Pack $N$ irregular \u201cTree Polygons\u201d into the smallest possible square bounding box for $N=1$ to $200$.\nIf you checked the leaderboard today (Dec 21), you noticed a trend:**Reinforcement Learning (RL) is getting crushed.**\nDespite the massive hype around \u201cReasoning Models\u201d and PPO agents this year, the top 100 teams aren\u2019t using neural networks. They are using 1980s physics simulations. Here is why the \u201cOld School\u201d is winning, and how the pros are using LLMs to cheat the system.\n## The Problem: Why RL Hates \u201cPacking\u201d\nOn paper, this looks like a game.*Place a tree, check for overlap, repeat.*Perfect for a DQN agent, right?\nWrong. The geometry kills the gradient.\n1. **Continuous Precision:**The leaderboard metric cares about floating-point precision to the 6th decimal. RL agents (which output discrete actions or probability distributions) struggle to make the \u201cmicro-adjustments\u201d needed to squeeze a tree into a 0.001mm gap.\n2. **The \u201cCollision\u201d Cliff:**In packing, a move is either valid (reward = 1) or it overlaps by a pixel (reward = -100). This sparse, binary feedback loop makes it nearly impossible for an agent to \u201clearn\u201d a gradient. It doesn\u2019t know*how*to fix the overlap, just that it failed.## The Solution: Simulated Annealing (on Steroids)\nThe \u201cSecret Sauce\u201d currently dominating the leaderboard is**Simulated Annealing (SA)**combined with**Lattice Generation**.\nInstead of training a model to*predict*the position, teams are writing physics engines that*shake*the box.\n* **High Temperature:**Randomly spin and throw trees into the box (Explorer Phase).\n* **Low Temperature:**Jiggle the trees by microscopic amounts to resolve collisions (Exploiter Phase).\nThe best solutions right now use a \u201cHybrid\u201d strategy:\n* **N &lt; 58:**Use Simulated Annealing to find unstructured, chaotic packings.\n* **N &gt; 58:**Switch to \u201cCrystalline Packing\u201d (regular geometric lattices) which is mathematically superior for large numbers.## The Twist: How LLMs are Actually Helping\nIf RL is dead, where is the AI?\nTop competitors aren\u2019t using LLMs to*solve*the puzzle; they are using LLMs to**write the solver**.\nPython is too slow for 10 billion annealing steps. The meta this year is to prompt Gemini 3 or Claude to:\n\u201cRewrite this Python overlap-check function in Rust/C++ with AVX2 vectorization.\u201d\nWe are seeing \u201cHybrid\u201d workflows where the**Human**defines the heuristics, the**LLM**writes the highly optimized C++ kernels, and**Simulated Annealing**does the heavy lifting.\n## The Starter Code: A Simple Annealer\nIf you want to jump in before the January deadline, don\u2019t start with PyTorch. Start here.\nHere is a conceptual snippet for a \u201cPerturbation\u201d mover \u2014the heart of any good annealing solution.\n```\nimport numpy as np\nimport math\ndef anneal(layout, max\\_temps=10000):\n# layout: Array of [x, y, rotation] for N trees\ncurrent\\_score = calculate\\_area(layout)\ntemperature = 1.0\ncooling\\_rate = 0.9995\nfor i in range(max\\_temps):\n# 1. Propose a Move (The &quot;Shake&quot;)\n# We only move ONE tree slightly to save compute\nidx = np.random.randint(0, len(layout))\noriginal\\_pos = layout[idx].copy()\n# Perturb: Move x/y by small amount, rotate slightly\nlayout[idx][0] += np.random.normal(0, temperature)\nlayout[idx][1] += np.random.normal(0, temperature)\nlayout[idx][2] += np.random.normal(0, temperature \\* 10) # Rotate\n# 2. Check Constraints (The &quot;Wall&quot;)\nif check\\_overlap(layout):\n# Revert immediately if invalid\nlayout[idx] = original\\_pos\ncontinue\n# 3. Acceptance Criteria (Metropolis-Hastings)\nnew\\_score = calculate\\_area(layout)\ndelta = new\\_score - current\\_score\n# If better, accept. If worse, accept with prob based on Temp.\nif delta &lt; 0 or math.exp(-delta / temperature) &gt; np.random.rand():\ncurrent\\_score = new\\_score\nelse:\nlayout[idx] = original\\_pos # Revert\n# Cool down\ntemperature \\*= cooling\\_rate\nreturn layout, current\\_score\n# Pro Tip: Ask an LLM to convert &#x27;&#x27;check\\_overlap&#x27;&#x27; to Cython for 100x speed.\n```\nThe competition ends**January 30, 2026**. You have 40 days. Put down the Neural Network and pick up a physics textbook.\n*(****Discussion:****Are you using a Lattice approach or pure Annealing for N=200? Let\u2019s discuss strategy in the comments!)*\n[\n![Himanshu Dhiman](https://miro.medium.com/v2/resize:fill:96:96/1*3jyWFYIYAox5D7cqT7gIRA.jpeg)\n](https://hmnshudhmn24.medium.com/?source=post_page---post_author_info--087f3f04fa97---------------------------------------)\n[\n![Himanshu Dhiman](https://miro.medium.com/v2/resize:fill:128:128/1*3jyWFYIYAox5D7cqT7gIRA.jpeg)\n](https://hmnshudhmn24.medium.com/?source=post_page---post_author_info--087f3f04fa97---------------------------------------)\n[## Written byHimanshu Dhiman\n](https://hmnshudhmn24.medium.com/?source=post_page---post_author_info--087f3f04fa97---------------------------------------)\n[20 followers](https://hmnshudhmn24.medium.com/followers?source=post_page---post_author_info--087f3f04fa97---------------------------------------)\n\u00b7[0 following](https://hmnshudhmn24.medium.com/following?source=post_page---post_author_info--087f3f04fa97---------------------------------------)\nJust another human t...",
      "url": "https://hmnshudhmn24.medium.com/kaggle-santa-2025-why-reinforcement-learning-is-failing-087f3f04fa97"
    },
    {
      "title": "",
      "text": "Shadoks Approach to Knapsack Polygonal Packing\nGuilherme D. da Fonseca #\nLIS, Aix-Marseille Universit\u00e9, France\nYan Gerard #\nLIMOS, University Clermont Auvergne, Aubi\u00e8re, France\nAbstract\nWe describe the heuristics used by the Shadoks team in the CG:SHOP 2024 Challenge. Each instance\nconsists of a convex polygon called container and a multiset of items, where each item is a simple\npolygon and has an associated value. The goal is to pack some of the items inside the container\nusing translations, in order to maximize the sum of their values. Our strategy consists of obtaining\ngood initial solutions and improving them with local search. To obtain the initial solutions we used\ninteger programming and a carefully designed greedy approach.\n2012 ACM Subject Classification Theory of computation \u2192 Computational geometry\nKeywords and phrases Packing, polygons, heuristics, integer programming, computational geometry\nDigital Object Identifier 10.4230/LIPIcs.SoCG.2024.84\nCategory CG Challenge\nRelated Version Full Version: https://arxiv.org/abs/2403.20123\nSupplementary Material\nSoftware (Source Code): https://github.com/gfonsecabr/shadoks-CGSHOP2024\narchived at swh:1:dir:96fb9ad50c0c1307c7aef78560655cfcfabb24a6\nFunding Work supported by the French ANR PRC grant ADDS (ANR-19-CE48-0005).\nAcknowledgements We would like to thank the Challenge organizers and other competitors for their\ntime, feedback, and making this whole event possible. We would like to thank H\u00e9l\u00e8ne Toussaint,\nRapha\u00ebl Amato, Boris Lonjon, and William Guyot-L\u00e9nat from LIMOS, as well as the Qarma and\nTALEP teams and Manuel Bertrand from LIS, who continue to make the computational resources of\nthe LIMOS and LIS clusters available to our research. We would also like to thank Aldo Gonzalez\u0002Lorenzo and the undergraduate students Aymeric Beck, Houssam Boufarachan, Marine Izoulet, and\nCarla Scardigli for coding viewers for the solutions.\nFigure 1 Our best solutions to jigsaw_cf2_5db5d75a_34, random_rcf4_6e323d40_100,\natris1240, and satris1786 instances.\n\u00a9 Guilherme D. da Fonseca and Yan Gerard;\nlicensed under Creative Commons License CC-BY 4.0\n40th International Symposium on Computational Geometry (SoCG 2024).\nEditors: Wolfgang Mulzer and Jeff M. Phillips; Article No. 84; pp. 84:1\u201384:9\nLeibniz International Proceedings in Informatics\nSchloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik, Dagstuhl Publishing, Germany\n84:2 Shadoks Approach to Knapsack Polygonal Packing\n1 Introduction\nCG:SHOP Challenge is an annual geometric optimization challenge. The sixth edition in\n2024 considers a 2-dimensional knapsack packing problem. The team Shadoks won first place\nwith the best solution (among the 14 participating teams) to 75 instances out of 180. In this\npaper, we describe the heuristics we used. We start by briefly describing the problem.\nAn input instance consists of a convex polygon called container and a multiset of items.\nEach item is a simple polygon with an associated integer value. The goal is to pack some of\nthe instance items inside the container using integer translations in order to maximize the\nsum of their values. In total, 180 instances have been given, ranging from 28 to 50,000 items.\nThe instances are of several different types according to the shape and values of the items.\nSome instances have mostly convex items, while other instances have many non-convex items\nsuch as polyominoes. In terms of item values, some items have only unit value, some have\nvalues proportional to the area, and other have random values, for example. Some solutions\nare presented in Figure 1 and more details about the challenge are available in the organizers\u2019\nsurvey paper [3].\nOur general strategy consists of finding a good initial solution (using integer programming\nor a greedy heuristic) and subsequently optimizing them with local search. Our strategy\nshares many common elements with the second place [5], but they did not use integer\nprogramming to obtain initial solutions and their optimization phase is more sophisticated\nthan ours. The third place [4] uses an hierarchical grid approach. The fourth place [1] used\na completely different integer programming model and a genetic algorithm.\nWe describe the algorithms in Section 2 and experimentally analyze their performance\nusing different parameters in Section 3. Our solvers were coded in Python and C++ and\nexecuted on several desktop laptop computers, as well as the LIMOS and LIS clusters.\n2 Algorithms\nWe used two different algorithms to compute initial solutions, a preprocessing phase that\ncan be executed beforehand, and a local search phase to improve the solutions.\n2.1 Integer Programming Approach\nA simple idea to solve the challenge problem is to produce a set V of random translations of\neach item inside the container and then reduce the problem to a kind of maximum weight\nindependent set problem in a graph G = (V, E). Each translated item is a vertex and there\nare two types of edges: (1) an edge between two translations that overlap and (2) translations\nof the same item i form a clique Ci. If all item have quantity one, then this is a traditional\nmaximum weight independent set problem. However, if items have non-unit quantities, then\neach clique Ciis associated with the quantity qi of item i and at most qi vertices of the\nclique are allowed in the solution.\nThis combinatorial problem can easily be modeled as integer programming with one\nbinary variable per vertex. A type-1 edge uv is modeled as u + v \u2264 1 and each clique Ci\nis modeled as P\nv\u2208Ci\nv \u2264 qi. The CPLEX solver [2] can optimally solve graphs with a few\nthousand vertices obtained from the challenge instances, which is not enough to obtain good\nsolutions using uniformly random placements.\nTo obtain better solutions, we start from a solutions S obtained with the aforementioned\nmethod and build a new graph G = (V, E) as follows. Let \u03c3 > 0 be a parameter and N be a\nset of the zero vector and random vectors where each random vector has x and y coordinates\nG. D. da Fonseca and Y. Gerard 84:3\nas Gaussian random variables of average 0 and standard deviation \u03c3. We create a translation\nin V for each item that is placed in S and for each translation vector in N if the translation\nis inside the container. We also create vertices in V using uniform random translations for\nall items. Edges and cliques are created as before, and the new combinatorial problem is\nsolved with CPLEX. We repeat this procedure multiple times using the previous solution S\nand reducing the value of \u03c3 at each step.\nThis method works well for instances with up to 200 items. To handle larger instances,\nwe partition the container using a square grid and partition the items equally among the\ncells. The partition is such that items are grouped by the slope of the longest edge, breaking\nties by the slope of the diameter. Each cell is then solved independently. The intuition to\ngroup items of similar slope together is that they can often be placed in a way that minimizes\nthe wasted space. Since the values of the items do not seem to be related to the slopes, this\napproach works well for the challenge instances.\n2.2 Greedy Heuristic\nThe greedy heuristic starts by creating an initial list L of n grid points inside the container\n(typically n = 1000). The list L is shuffled and we compute its centroid c rounded to integer\ncoordinates. The point c is inserted in the beginning of L. The input items are placed into a\nlist I ordered by decreasing utility, where the utility function is described next. Different\nutility functions may be used (more details in Section 3). The goal is that items of small\narea and high value have high utility while large items with small value have low utility.\nWe then build the packing by considering the items of the list I one by one in order. At\neach step, we have a current packing and a new item i to pack. We first try to pack i at\nthe first grid position g \u2208 L and at a number of random positions around g. If one of these\npositions is availa...",
      "url": "https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.84/LIPIcs.SoCG.2024.84.pdf"
    },
    {
      "title": "Search code, repositories, users, issues, pull requests...",
      "text": "GitHub - adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-: In this re-defined optimization problem, help Santa fit Christmas tree toys into the smallest (2-dimension) parcel size possible so that he can efficiently mail these stocking stuffers around the globe. Santa needs the dimensions of the smallest possible square box that fits shipments of between 1-200 trees.\n[Skip to content](#start-of-content)\n## Navigation Menu\nToggle navigation\n[](https://github.com/)\n[Sign in](https://github.com/login?return_to=https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\nAppearance settings\nSearch or jump to...\n# Search code, repositories, users, issues, pull requests...\n</option></form>\nSearch\nClear\n[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)\n# Provide feedback\n</option></form>\nWe read every piece of feedback, and take your input very seriously.\nInclude my email address so I can be contacted\nCancelSubmit feedback\n# Saved searches\n## Use saved searches to filter your results more quickly\n</option></form>\nName\nQuery\nTo see all available qualifiers, see our[documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).\nCancelCreate saved search\n[Sign in](https://github.com/login?return_to=https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\n[Sign up](https://github.com/signup?ref_cta=Sign+up&amp;ref_loc=header+logged+out&amp;ref_page=/%3Cuser-name%3E/%3Crepo-name%3E&amp;source=header-repo&amp;source_repo=adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\nAppearance settings\nResetting focus\nYou signed in with another tab or window.[Reload]()to refresh your session.You signed out in another tab or window.[Reload]()to refresh your session.You switched accounts on another tab or window.[Reload]()to refresh your session.Dismiss alert\n{{ message }}\n[adityapawar327](https://github.com/adityapawar327)/**[Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)**Public\n* [Notifications](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)You must be signed in to change notification settings\n* [Fork1](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\n* [Star2](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\nIn this re-defined optimization problem, help Santa fit Christmas tree toys into the smallest (2-dimension) parcel size possible so that he can efficiently mail these stocking stuffers around the globe. Santa needs the dimensions of the smallest possible square box that fits shipments of between 1-200 trees.\n[www.kaggle.com/code/adityapawar327/santa-2025-christmas-tree-packing-challenge-v1](https://www.kaggle.com/code/adityapawar327/santa-2025-christmas-tree-packing-challenge-v1)\n[2stars](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/stargazers)[1fork](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/forks)[Branches](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/branches)[Tags](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/tags)[Activity](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/activity)\n[Star](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)\n[Notifications](https://github.com/login?return_to=/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-)You must be signed in to change notification settings\n# adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-\nmain\n[Branches](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/branches)[Tags](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/tags)\n[](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/branches)[](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/tags)\nGo to file\nCode\nOpen more actions menu\n## Folders and files\n|Name|Name|\nLast commit message\n|\nLast commit date\n|\n## Latest commit\n## History\n[2 Commits](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/commits/main/)\n[](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/commits/main/)\n|\n[README.md](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/blob/main/README.md)\n|\n[README.md](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/blob/main/README.md)\n|\n|\n|\n[santa-2025-christmas-tree-packing-challenge-v1.ipynb](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/blob/main/santa-2025-christmas-tree-packing-challenge-v1.ipynb)\n|\n[santa-2025-christmas-tree-packing-challenge-v1.ipynb](https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-/blob/main/santa-2025-christmas-tree-packing-challenge-v1.ipynb)\n|\n|\n|\nView all files\n|\n## Repository files navigation\n# Santa 2025 - Christmas Tree Packing Challenge V1\n[](#santa-2025---christmas-tree-packing-challenge-v1)\nThis repository contains my approach for the[Santa 2025 - Christmas Tree Packing Challenge](https://www.kaggle.com/competitions/santa-2025)on Kaggle.\n## Overview\n[](#overview)\nThe objective of this challenge is to optimally pack rotatable Christmas trees (polygonal shapes) into the smallest possible square, minimizing the bounding box area for each value of N (number of trees from 1 to 200). The final solution is evaluated by an ensemble score that combines all cases.\n**Notebook Link**:[Santa 2025 - Christmas Tree Packing Challenge V1](https://www.kaggle.com/code/adityapawar327/santa-2025-christmas-tree-packing-challenge-v1)\n**Public Score**: 85.92\n## Table of Contents\n[](#table-of-contents)\n* Library Imports and Environment Setup\n* Global Configuration and Precision Settings\n* ChristmasTree Class Definition\n* Utility Functions (Scoring/Collision)\n* Simulated Annealing Algorithm (N &lt; 20)\n* Grid Search Algorithm (N &gt;= 20)\n* Hybrid &amp; Ensemble Solvers\n* Main Computation Loop (N = 1 to 200)\n* Submission Formatting and Export\n## Methodology\n[](#methodology)\n* **Small N (&lt; 20):**Uses Simulated Annealing for efficient search in small configuration spaces.\n* **Large N (&gt;= 20):**Uses a tailored Grid Search for tractable solution space exploration.\n* **Hybrid/Ensemble:**Runs multiple seeds and chooses the best solution for each N.\n* **Collision Detection:**Employs Shapely geometry operations to prevent tree overlap.\n* **Performance:**Code leverages parallelization (`ProcessPoolExecutor`) and high-precision (Decimal) arithmetic.\n## Usage\n[](#usage)\n1. Install dependencies:\n* `shapely`,`numpy`,`pandas`,`matplotlib`,`tqdm`\n* Run the notebook or script sequentially to output results and save a`submission.csv`.\n* Check the score on important N cases (e.g., 1, 10, 25, 50, 100, 150, 200).\n## Output\n[](#output)\n* The notebook prints key logs during computation.\n* A`submission.csv`is generated with columns:`id`,`x`,`y`,`deg`(example row:`001\\_0, s-9.146226, s-0.12832, s-224.999647`).\n## License\n[](#license)\nThis project is released under the[Apache 2.0 License](http://www.apache.org/licenses/LICENSE-2.0).\n## Author\n[](#author)\nAditya Pawar ([Kaggle Profile](https://www.kaggle.com/adityapawar327))\nFor questions or collaboration, feel free to reach out via Kaggle discussions or connect on[LinkedIn](https://www.linkedin.com/in/adityapawar327).\n## About\nIn this re-defined optimization problem, help Santa fit Christmas tree toys into the smallest (2-dimension) parcel size possible so that ...",
      "url": "https://github.com/adityapawar327/Christmas-Tree-Packing-Kaggle-Challenge-Santa-25-"
    },
    {
      "title": "Search code, repositories, users, issues, pull requests...",
      "text": "GitHub - gfonsecabr/shadoks-CGSHOP2024: Translational Knapsack Packing\n[Skip to content](#start-of-content)\n## Navigation Menu\nToggle navigation\n[](/)\n[Sign in](/login?return_to=https://github.com/gfonsecabr/shadoks-CGSHOP2024)\nAppearance settings\nSearch or jump to...\n# Search code, repositories, users, issues, pull requests...\n</option></form>\nSearch\nClear\n[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)\n# Provide feedback\n</option></form>\nWe read every piece of feedback, and take your input very seriously.\nInclude my email address so I can be contacted\nCancelSubmit feedback\n# Saved searches\n## Use saved searches to filter your results more quickly\n</option></form>\nName\nQuery\nTo see all available qualifiers, see our[documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).\nCancelCreate saved search\n[Sign in](/login?return_to=https://github.com/gfonsecabr/shadoks-CGSHOP2024)\n[Sign up](/signup?ref_cta=Sign+up&amp;ref_loc=header+logged+out&amp;ref_page=/<user-name>/<repo-name>&amp;source=header-repo&amp;source_repo=gfonsecabr/shadoks-CGSHOP2024)\nAppearance settings\nResetting focus\nYou signed in with another tab or window.[Reload]()to refresh your session.You signed out in another tab or window.[Reload]()to refresh your session.You switched accounts on another tab or window.[Reload]()to refresh your session.Dismiss alert\n{{ message }}\n[gfonsecabr](/gfonsecabr)/**[shadoks-CGSHOP2024](/gfonsecabr/shadoks-CGSHOP2024)**Public\n* [Notifications](/login?return_to=/gfonsecabr/shadoks-CGSHOP2024)You must be signed in to change notification settings\n* [Fork1](/login?return_to=/gfonsecabr/shadoks-CGSHOP2024)\n* [Star3](/login?return_to=/gfonsecabr/shadoks-CGSHOP2024)\nTranslational Knapsack Packing\n### License\n[MIT license](/gfonsecabr/shadoks-CGSHOP2024/blob/main/LICENSE)\n[3stars](/gfonsecabr/shadoks-CGSHOP2024/stargazers)[1fork](/gfonsecabr/shadoks-CGSHOP2024/forks)[Branches](/gfonsecabr/shadoks-CGSHOP2024/branches)[Tags](/gfonsecabr/shadoks-CGSHOP2024/tags)[Activity](/gfonsecabr/shadoks-CGSHOP2024/activity)\n[Star](/login?return_to=/gfonsecabr/shadoks-CGSHOP2024)\n[Notifications](/login?return_to=/gfonsecabr/shadoks-CGSHOP2024)You must be signed in to change notification settings\n# gfonsecabr/shadoks-CGSHOP2024\nmain\n[Branches](/gfonsecabr/shadoks-CGSHOP2024/branches)[Tags](/gfonsecabr/shadoks-CGSHOP2024/tags)\n[](/gfonsecabr/shadoks-CGSHOP2024/branches)[](/gfonsecabr/shadoks-CGSHOP2024/tags)\nGo to file\nCode\nOpen more actions menu\n## Folders and files\n|Name|Name|\nLast commit message\n|\nLast commit date\n|\n## Latest commit\n## History\n[4 Commits](/gfonsecabr/shadoks-CGSHOP2024/commits/main/)\n[](/gfonsecabr/shadoks-CGSHOP2024/commits/main/)\n|\n[cpp](/gfonsecabr/shadoks-CGSHOP2024/tree/main/cpp)\n|\n[cpp](/gfonsecabr/shadoks-CGSHOP2024/tree/main/cpp)\n|\n|\n|\n[python](/gfonsecabr/shadoks-CGSHOP2024/tree/main/python)\n|\n[python](/gfonsecabr/shadoks-CGSHOP2024/tree/main/python)\n|\n|\n|\n[LICENSE](/gfonsecabr/shadoks-CGSHOP2024/blob/main/LICENSE)\n|\n[LICENSE](/gfonsecabr/shadoks-CGSHOP2024/blob/main/LICENSE)\n|\n|\n|\n[README.md](/gfonsecabr/shadoks-CGSHOP2024/blob/main/README.md)\n|\n[README.md](/gfonsecabr/shadoks-CGSHOP2024/blob/main/README.md)\n|\n|\n|\nView all files\n|\n## Repository files navigation\nThis repository contains the source code used by the`Shadoks`team to win first place at the[CG:SHOP 2024 challenge](https://cgshop.ibr.cs.tu-bs.de/competition/cg-shop-2024/#problem-description)about a knapsack polygonal packing problem. More information about the algorithms used is available at the following paper.\n```\n`@inproceedings{Challenge24\\_1,\nauthor = {da Fonseca, Guilherme D. and Gerard, Yan},\ntitle = {Shadoks Approach to Knapsack Polygonal Packing},\nbooktitle = {Symposium on Computational Geometry (SoCG)},\nseries = {LIPIcs},\nvolume = {293},\npages = {83:1--83:9},\nyear = {2024},\n}`\n```\nThe code has been used only to obtain solutions to the challenge, and some bugs have been detected and not fixed. The main purpose of the code is a source of ideas, rather than a ready-to-use solver.\n## About\nTranslational Knapsack Packing\n### Resources\n[Readme](#readme-ov-file)\n### License\n[MIT license](#MIT-1-ov-file)\n### Uh oh!\nThere was an error while loading.[Please reload this page]().\n[Activity](/gfonsecabr/shadoks-CGSHOP2024/activity)\n### Stars\n[**3**stars](/gfonsecabr/shadoks-CGSHOP2024/stargazers)\n### Watchers\n[**1**watching](/gfonsecabr/shadoks-CGSHOP2024/watchers)\n### Forks\n[**1**fork](/gfonsecabr/shadoks-CGSHOP2024/forks)\n[Report repository](/contact/report-content?content_url=https://github.com/gfonsecabr/shadoks-CGSHOP2024&amp;report=gfonsecabr+(user))\n## [Releases](/gfonsecabr/shadoks-CGSHOP2024/releases)\nNo releases published\n## [Packages0](/users/gfonsecabr/packages?repo_name=shadoks-CGSHOP2024)\nNo packages published\n## Languages\n* [Python80.2%](/gfonsecabr/shadoks-CGSHOP2024/search?l=python)\n* [C++19.7%](/gfonsecabr/shadoks-CGSHOP2024/search?l=c++)\n* [Shell0.1%](/gfonsecabr/shadoks-CGSHOP2024/search?l=shell)\nYou can\u2019t perform that action at this time.",
      "url": "https://github.com/gfonsecabr/shadoks-CGSHOP2024"
    },
    {
      "title": "Computer Science > Computational Geometry",
      "text": "[2403.16203] Maximum Polygon Packing: The CG:SHOP Challenge 2024[![close this message](https://arxiv.org/static/browse/0.3.4/images/icons/close-slider.png)](#)\n![arXiv smileybones](https://arxiv.org/static/browse/0.3.4/images/icons/smileybones-pixel.png)\n## Happy Open Access Week from arXiv!\nYOU make open access possible! Tell us why you support #openaccess and give to arXiv this week to help keep science open for all.\n[**Donate!**](https://arxiv.salsalabs.org/arXivOAWeek2025)\n[Skip to main content](#content)\n[![Cornell University](https://arxiv.org/static/browse/0.3.4/images/icons/cu/cornell-reduced-white-SMALL.svg)](https://www.cornell.edu/)\nWe gratefully acknowledge support from the Simons Foundation,[member institutions](https://info.arxiv.org/about/ourmembers.html), and all contributors.[Donate](https://info.arxiv.org/about/donate.html)\n[](https://arxiv.org/IgnoreMe)\n[![arxiv logo](https://arxiv.org/static/browse/0.3.4/images/arxiv-logo-one-color-white.svg)](https://arxiv.org/)&gt;[cs](https://arxiv.org/list/cs/recent)&gt;arXiv:2403.16203\n[Help](https://info.arxiv.org/help)|[Advanced Search](https://arxiv.org/search/advanced)\nAll fieldsTitleAuthorAbstractCommentsJournal referenceACM classificationMSC classificationReport numberarXiv identifierDOIORCIDarXiv author IDHelp pagesFull text\nSearch\n[![arXiv logo](https://arxiv.org/static/browse/0.3.4/images/arxiv-logomark-small-white.svg)](https://arxiv.org/)\n[![Cornell University Logo](https://arxiv.org/static/browse/0.3.4/images/icons/cu/cornell-reduced-white-SMALL.svg)](https://www.cornell.edu/)\nopen search\nGO\nopen navigation menu\n# Computer Science \\> Computational Geometry\n**arXiv:2403.16203**(cs)\n[Submitted on 24 Mar 2024]\n# Title:Maximum Polygon Packing: The CG:SHOP Challenge 2024\nAuthors:[S\u00e1ndor P. Fekete](https://arxiv.org/search/cs?searchtype=author&amp;query=Fekete,+S+P),[Phillip Keldenich](https://arxiv.org/search/cs?searchtype=author&amp;query=Keldenich,+P),[Dominik Krupke](https://arxiv.org/search/cs?searchtype=author&amp;query=Krupke,+D),[Stefan Schirra](https://arxiv.org/search/cs?searchtype=author&amp;query=Schirra,+S)\nView a PDF of the paper titled Maximum Polygon Packing: The CG:SHOP Challenge 2024, by S\\\\&#39;&#39;andor P. Fekete and 2 other authors\n[View PDF](https://arxiv.org/pdf/2403.16203)[HTML (experimental)](https://arxiv.org/html/2403.16203v1)> > Abstract:\n> We give an overview of the 2024 Computational Geometry Challenge targeting the problem \\textsc{Maximum Polygon Packing}: Given a convex region $P$ in the plane, and a collection of simple polygons $Q_1, \\ldots, Q_n$, each $Q_i$ with a respective value $c_i$, find a subset $S \\subseteq \\{1, \\ldots,n\\}$ and a feasible packing within $P$ of the polygons $Q_i$ (without rotation) for $i \\in S$, maximizing $\\sum_{i \\in S} c_i$. Geometric packing problems, such as this, present significant computational challenges and are of substantial practical importance. Comments:|16 pages, 10 figures|\nSubjects:|Computational Geometry (cs.CG); Data Structures and Algorithms (cs.DS)|\nACMclasses:|F.2.2|\nCite as:|[arXiv:2403.16203](https://arxiv.org/abs/2403.16203)[cs.CG]|\n|(or[arXiv:2403.16203v1](https://arxiv.org/abs/2403.16203v1)[cs.CG]for this version)|\n|[https://doi.org/10.48550/arXiv.2403.16203](https://doi.org/10.48550/arXiv.2403.16203)\nFocus to learn more\narXiv-issued DOI via DataCite\n|\n## Submission history\nFrom: Sandor P. Fekete [[view email](https://arxiv.org/show-email/361b714e/2403.16203)]\n**[v1]**Sun, 24 Mar 2024 15:56:03 UTC (2,118 KB)\nFull-text links:## Access Paper:\nView a PDF of the paper titled Maximum Polygon Packing: The CG:SHOP Challenge 2024, by S\\\\&#39;&#39;andor P. Fekete and 2 other authors\n* [View PDF](https://arxiv.org/pdf/2403.16203)\n* [HTML (experimental)](https://arxiv.org/html/2403.16203v1)\n* [TeX Source](https://arxiv.org/src/2403.16203)\n[view license](http://arxiv.org/licenses/nonexclusive-distrib/1.0/)\nCurrent browse context:\ncs.CG\n[&lt;&lt;prev](https://arxiv.org/prevnext?id=2403.16203&amp;function=prev&amp;context=cs.CG) | [next&gt;&gt;](https://arxiv.org/prevnext?id=2403.16203&amp;function=next&amp;context=cs.CG)\n[new](https://arxiv.org/list/cs.CG/new)|[recent](https://arxiv.org/list/cs.CG/recent)|[2024-03](https://arxiv.org/list/cs.CG/2024-03)\nChange to browse by:\n[cs](https://arxiv.org/abs/2403.16203?context=cs)\n[cs.DS](https://arxiv.org/abs/2403.16203?context=cs.DS)\n### References &amp; Citations\n* [NASA ADS](https://ui.adsabs.harvard.edu/abs/arXiv:2403.16203)\n* [Google Scholar](https://scholar.google.com/scholar_lookup?arxiv_id=2403.16203)\n* [Semantic Scholar](https://api.semanticscholar.org/arXiv:2403.16203)\nexport BibTeX citationLoading...\n## BibTeX formatted citation\n&times;\nloading...\nData provided by:\n### Bookmark\n[![BibSonomy logo](https://arxiv.org/static/browse/0.3.4/images/icons/social/bibsonomy.png)](<http://www.bibsonomy.org/BibtexHandler?requTask=upload&amp;url=https://arxiv.org/abs/2403.16203&amp;description=Maximum Polygon Packing: The CG:SHOP Challenge 2024>)[![Reddit logo](https://arxiv.org/static/browse/0.3.4/images/icons/social/reddit.png)](<https://reddit.com/submit?url=https://arxiv.org/abs/2403.16203&amp;title=Maximum Polygon Packing: The CG:SHOP Challenge 2024>)\nBibliographic Tools\n# Bibliographic and Citation Tools\nBibliographic Explorer Toggle\nBibliographic Explorer*([What is the Explorer?](https://info.arxiv.org/labs/showcase.html#arxiv-bibliographic-explorer))*\nConnected Papers Toggle\nConnected Papers*([What is Connected Papers?](https://www.connectedpapers.com/about))*\nLitmaps Toggle\nLitmaps*([What is Litmaps?](https://www.litmaps.co/))*\nscite.ai Toggle\nscite Smart Citations*([What are Smart Citations?](https://www.scite.ai/))*\nCode, Data, Media\n# Code, Data and Media Associated with this Article\nalphaXiv Toggle\nalphaXiv*([What is alphaXiv?](https://alphaxiv.org/))*\nLinks to Code Toggle\nCatalyzeX Code Finder for Papers*([What is CatalyzeX?](https://www.catalyzex.com))*\nDagsHub Toggle\nDagsHub*([What is DagsHub?](https://dagshub.com/))*\nGotitPub Toggle\nGotit.pub*([What is GotitPub?](http://gotit.pub/faq))*\nHuggingface Toggle\nHugging Face*([What is Huggingface?](https://huggingface.co/huggingface))*\nLinks to Code Toggle\nPapers with Code*([What is Papers with Code?](https://paperswithcode.com/))*\nScienceCast Toggle\nScienceCast*([What is ScienceCast?](https://sciencecast.org/welcome))*\nDemos\n# Demos\nReplicate Toggle\nReplicate*([What is Replicate?](https://replicate.com/docs/arxiv/about))*\nSpaces Toggle\nHugging Face Spaces*([What is Spaces?](https://huggingface.co/docs/hub/spaces))*\nSpaces Toggle\nTXYZ.AI*([What is TXYZ.AI?](https://txyz.ai))*\nRelated Papers\n# Recommenders and Search Tools\nLink to Influence Flower\nInfluence Flower*([What are Influence Flowers?](https://influencemap.cmlab.dev/))*\nCore recommender toggle\nCORE Recommender*([What is CORE?](https://core.ac.uk/services/recommender))*\n* Author\n* Venue\n* Institution\n* Topic\nAbout arXivLabs\n# arXivLabs: experimental projects with community collaborators\narXivLabs is a framework that allows collaborators to develop and share new arXiv features directly on our website.\nBoth individuals and organizations that work with arXivLabs have embraced and accepted our values of openness, community, excellence, and user data privacy. arXiv is committed to these values and only works with partners that adhere to them.\nHave an idea for a project that will add value for arXiv's community?[**Learn more about arXivLabs**](https://info.arxiv.org/labs/index.html).\n[Which authors of this paper are endorsers?](https://arxiv.org/auth/show-endorsers/2403.16203)|[Disable MathJax](javascript:setMathjaxCookie())([What is MathJax?](https://info.arxiv.org/help/mathjax.html))",
      "url": "https://arxiv.org/abs/2403.16203"
    },
    {
      "title": "Santa 2025 - Christmas Tree Packing Challenge",
      "text": "[AI\u8d5b\u4e8b\u901a](https://www.competehub.dev/en)Open menu\n[AI Compete Hub](https://www.competehub.dev/en)\nSanta 2025 - Christmas Tree Packing Challenge - CompeteHub\nK\nKAGGLE\u2022DATA ALGORITHM\u20222 MONTHS LEFT\nJoin CompetitionMore options\n# Santa 2025 - Christmas Tree Packing Challenge\n## How many Christmas trees can fit in a box? Help solve a classic optimization problem with a festive twist.\n![AI Competition: Santa 2025 - Christmas Tree Packing Challenge - Detailed competition information, rules, and participation guidelines](https://ai77-pub.oss-ap-southeast-1.aliyuncs.com/competitions/images/logo_kagglesanta-2025.png)\nStart Date\n11/17/2025\nEnd Date\n1/30/2026\nOverview\n## \ud83c\udf84Santa 2025 - Christmas Tree Packing Challenge \ud83c\udf84## Overview\nThis competition, hosted by Kaggle, presents a festive twist on a classic optimization problem. Participants are tasked with determining the optimal way to pack Christmas tree toys into the smallest possible square box, allowing Santa Claus to mail them efficiently around the globe. The challenge is to find the dimensions of the smallest square box that can fit between 1 to 200 trees.\nThe competition is designed to encourage innovation and problem-solving skills, with a focus on packing efficiency. Participants are encouraged to submit their solutions, which will be evaluated based on the normalized area of the square bounding box for each puzzle configuration.\n### Description\nThe challenge is inspired by Santa&#x27;s need for the smallest box to fit all the tiny trees for his Christmas deliveries. Participants are required to find the best packing solution to help Santa Claus and win the competition&#x27;s prize.\n### Evaluation\nSubmissions are evaluated on the sum of the normalized area of the square bounding box for each puzzle. The formula for the score is:\n```\n`score = \u2211(sn^2/n)`\n```\nwhere`sn`is the side of the square box bounding the trees and`n`is the total number of trees in the configuration.\n### Submission File\nEach submission must include the tree position (`x`,`y`) and rotation (`deg`) for each`id`in the submission. The values must be converted to a string and prepended with an`s`before submission. Submissions with overlapping trees will result in an error. Location values must be constrained to -100 \u2264x, y \u2264100.\nThe file should have the following format:\n```\n`id,x,y,deg\n001\\_0,s0.0,s0.0,s20.411299\n002\\_0,s0.0,s0.0,s20.411299\n002\\_1,s-0.541068,s0.259317,s51.66348\netc.`\n```\n### Timeline\n* **November 17, 2025**: Start Date\n* **January 23, 2026**: Entry Deadline\n* **January 23, 2026**: Team Merger Deadline\n* **January 30, 2026**: Final Submission Deadline\nAll deadlines are at 11:59 PM UTC unless otherwise noted.\n### Prizes\n* **First Prize**: $12,000\n* **Second Prize**: $10,000\n* **Third Prize**: $10,000\n* **Fourth Prize**: $8,000\nAdditionally, a**Rudolph Prize**of $10,000 is awarded to the team holding 1st place on the leaderboard for the longest period of time between November 17, 2025, and January 30, 2026.\n### Citation\nWalter Reade and Ashley Oldacre. Santa 2025 - Christmas Tree Packing Challenge.[https://kaggle.com/competitions/santa-2025](https://kaggle.com/competitions/santa-2025), 2025. Kaggle.\n## Key Points\n* \ud83d\ude80Hosted by Kaggle\n* \ud83c\udfafOptimize packing of Christmas tree toys into the smallest square box\n* \u2705Find the optimal packing solution for Santa Claus\n* \ud83d\udcc8Score based on normalized area of the square bounding box\n* \ud83d\udcb3Total prize pool of $50,000## Objectives\n* To solve a classic optimization problem with a festive twist\n* To encourage innovation and problem-solving skills\n* To find the most efficient packing solution for Christmas tree toys## Requirements\n* Participants must submit a file with tree positions and rotations\n* Submissions must avoid overlapping trees\n* Location values must be constrained to -100 \u2264x, y \u2264100## Important Details\n* The competition runs for 2 months\n* Prizes are awarded for the best solutions\n* A special Rudolph Prize is awarded for the longest period of 1st place on the leaderboard\nThis overview is a content summary. For detailed competition information, please visit the[official competition page](https://www.competehub.dev/click?id=kagglesanta-2025&amp;type=competition&amp;redirect_url=https://www.kaggle.com/competitions/santa-2025).\nCompetition Source\nK\nKAGGLE\nPrize\n$50,000\nParticipants\nTeams1,720\nOrganizer\nKAGGLE\nTags\nOptimizationHolidays and Cultural Events",
      "url": "https://www.competehub.dev/en/competitions/kagglesanta-2025"
    },
    {
      "title": "Kaggle Santa 2024 and what do the puzzles have to do with it?",
      "text": "Kaggle Santa 2024 and what do the puzzles have to do with it?\nAgree & Join LinkedIn\nBy clicking Continue to join or sign in, you agree to LinkedIn\u2019s[User Agreement](https://www.linkedin.com/legal/user-agreement?trk=linkedin-tc_auth-button_user-agreement),[Privacy Policy](https://www.linkedin.com/legal/privacy-policy?trk=linkedin-tc_auth-button_privacy-policy), and[Cookie Policy](https://www.linkedin.com/legal/cookie-policy?trk=linkedin-tc_auth-button_cookie-policy).\n``````````````\n![]()## Sign in to view more content\nCreate your free account or sign in to continue your search\nSign in\n## Welcome back\n````````````````````\nEmail or phone\nPassword\nShow\n[Forgot password?](https://www.linkedin.com/uas/request-password-reset?trk=pulse-article_contextual-sign-in-modal_sign-in-modal_forgot_password)Sign in\nor\nBy clicking Continue to join or sign in, you agree to LinkedIn\u2019s[User Agreement](https://www.linkedin.com/legal/user-agreement?trk=pulse-article_contextual-sign-in-modal_sign-in-modal_auth-button_user-agreement),[Privacy Policy](https://www.linkedin.com/legal/privacy-policy?trk=pulse-article_contextual-sign-in-modal_sign-in-modal_auth-button_privacy-policy), and[Cookie Policy](https://www.linkedin.com/legal/cookie-policy?trk=pulse-article_contextual-sign-in-modal_sign-in-modal_auth-button_cookie-policy).\nNew to LinkedIn?[Join now](https://www.linkedin.com/signup/cold-join?session_redirect=/pulse/kaggle-santa-2024-what-do-puzzles-have-ivan-isaev--tl2ze&trk=pulse-article_contextual-sign-in-modal_sign-in-modal_join-link)\nor\nNew to LinkedIn?[Join now](https://www.linkedin.com/signup/cold-join?session_redirect=/pulse/kaggle-santa-2024-what-do-puzzles-have-ivan-isaev--tl2ze&trk=pulse-article_contextual-sign-in-modal_join-link)\nBy clicking Continue to join or sign in, you agree to LinkedIn\u2019s[User Agreement](https://www.linkedin.com/legal/user-agreement?trk=linkedin-tc_auth-button_user-agreement),[Privacy Policy](https://www.linkedin.com/legal/privacy-policy?trk=linkedin-tc_auth-button_privacy-policy), and[Cookie Policy](https://www.linkedin.com/legal/cookie-policy?trk=linkedin-tc_auth-button_cookie-policy).\nLinkedIn\nLinkedIn is better on the app\nDon\u2019t have the app? Get it in the Microsoft Store.\n[Open the app](ms-windows-store://pdp/?ProductId=9WZDNCRFJ4Q7&amp;mode=mini&amp;cid=guest_desktop_upsell)\n``````````````[Skip to main content](#main-content)\n````````\n![Kaggle Santa 2024 and what do the puzzles have to do with it?](https://media.licdn.com/dms/image/v2/D4E12AQERTkpb43B4nw/article-cover_image-shrink_720_1280/article-cover_image-shrink_720_1280/0/1739047298220?e=2147483647&amp;v=beta&amp;t=4vs2GFxEHk5kXGFycvuWrpejbJ95ZxzwQAEsa5tHMAk)\n# Kaggle Santa 2024 and what do the puzzles have to do with it?\n* [Report this article](https://www.linkedin.com/uas/login?session_redirect=https://www.linkedin.com/pulse/kaggle-santa-2024-what-do-puzzles-have-ivan-isaev--tl2ze&amp;trk=article-ssr-frontend-pulse_ellipsis-menu-semaphore-sign-in-redirect&amp;guestReportContentType=PONCHO_ARTICLE&amp;_f=guest-reporting)\n[Ivan Isaev](https://www.linkedin.com/in/ivanisaev)![Ivan Isaev]()\n### Ivan Isaev\nPublished Feb 8, 2025\n[+ Follow](https://www.linkedin.com/signup/cold-join?session_redirect=/pulse/kaggle-santa-2024-what-do-puzzles-have-ivan-isaev--tl2ze&amp;trk=article-ssr-frontend-pulse_publisher-author-card)\n[Our team got 23-rd place in Santa 2024 with a silver medal](https://www.linkedin.com/redir/redirect?url=https://www.kaggle.com/competitions/santa-2024/leaderboard&amp;urlhash=lwEr&amp;trk=article-ssr-frontend-pulse_little-text-block). We were close to gold but not this time.\nBelow is the summary of the competition task and our approach. It is mostly taken from my teammate[Telegram channel](https://www.linkedin.com/redir/redirect?url=https://t.me/pseudolabeling&amp;urlhash=4Jmr&amp;trk=article-ssr-frontend-pulse_little-text-block)(in Russian).\nAlso there a few my thoughts about application of similar approach to RAG with chunking.\n### Problem statement\nParticipants were asked to solve a fairly simple problem: permute a fixed set of words so that the resulting sequence minimizes the perplexity of the Gemma-2-9b model.\nIn this case, only permutations of the given words could be used.\n### Real life applicability\nBeam search will not be able to turn around in this particular competition because it is designed to avoid negative cycles. This does not prevent them from looking for good solutions in LLMs, because the set of words there is not limited and you can use them as many times as you like.\nIn real life for example in tasks related to \u201cchunking\u201d the popular approach to create text descriptions using chunks from vector databases using RAG.\n![Article content]()\nI.e. for example you have to create description using some similarity metric for example for video or summarize long article and you should somehow extract subset of chunks from vector database such a way that joint embedding of this sequence of chunks (or unordered subset itself) must be as close as it possible to embedding of video or article you creating the description. And in this case beam search could work very well to find right \u201cpuzzles subset\u201d from a vector database joint embedding of which (i.e. embedding of summary (description)) would be very close to embedding of input (article, video, etc.) you are searching summary (description) for. You wouldn\u2019t be able to find global optima with beam search but would be able to find a very good local optima (and this is enough).\n![Article content]()\nA few pictures\n![Article content]()\n![Article content]()\nSome interesting sources for more details:\n* [Chunking Strategies (Medium Post)](https://www.linkedin.com/redir/redirect?url=https://medium.com/@danushidk507/chunking-strategies-f93dbdec7634&amp;urlhash=x_uC&amp;trk=article-ssr-frontend-pulse_little-text-block)\n* [Chunking Strategies for LLM Applications (from Pinecone site)](https://www.linkedin.com/redir/redirect?url=https://www.pinecone.io/learn/chunking-strategies/&amp;urlhash=ABtR&amp;trk=article-ssr-frontend-pulse_little-text-block)\nBack to the competition and solution.\n### General picture\nAlmost all participants used some simulated annealing algorithms or their modifications, so the public solutions were quite similar. Even the guy from 2nd place simply used SA. There was no private LB in the competition - only a public one was used, which means there was no shakeup.\n### Details\nDistilled Gemma-2-9b\nSince the domain is limited to a hundred words, it was possible to compress the model to 1/5000 of the original.\nThe main winning algorithm is Iterated Local Search (ILS)\nWe'll describe the principle as follows:\n1. Initialization:\nWe select a starting solution - the initial sequence of words. Let's say, the best public from the open ones.\n2. Perturbation:\nFrom the current solution, we select a block of several consecutive words, which we then randomly rearrange. This allows us to \"push off\" from the current state and explore new options.\n3. Local search:\nAfter brute force perturbation, we try to rearrange each word. We record the obtained result, and remember its assessment with a small margin (10%), in order to cut off unpromising options.\n4. Depth-first search:\nThen we iterate over all permutations with depth N+1 (we permute two words, then three words with all possible options). If none of the new solutions is better than the set threshold, the current local optimum is considered final, and the algorithm returns to perturbation.\nThe winners found the global optimum and all the gold teams finished with the same score.\n``````````\n``\n[\nLike\n](https://www.linkedin.com/signup/cold-join?session_redirect=/pulse/kaggle-santa-2024-what-do-puzzles-have-ivan-isaev--tl2ze&amp;trk=article-ssr-frontend-pulse_x-social-details_like-toggle_like-cta)\n![Like]()Like\n![Celebrate]()Celebrate\n![Support]()Support\n![Love]()Love\n![Insightful]()Insightful\n![Funny]()Funny\n[Comment](https://www.linkedin.com/signup/cold-join?session_redirec...",
      "url": "https://www.linkedin.com/pulse/kaggle-santa-2024-what-do-puzzles-have-ivan-isaev--tl2ze"
    }
  ]
}