# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 71.812779 from exp_001 (valid ensemble)
- Best LB score: 71.812779 (confirmed - perfect CV-LB calibration)
- Target: 68.919154 | Gap to target: 2.89 points (4.2%)

## CRITICAL DIAGNOSIS: WE ARE STUCK AT A LOCAL OPTIMUM

**All 5 experiments have converged to the same score (71.81):**
- exp_000: 70.68 (touching trees - REJECTED by Kaggle)
- exp_001: 71.81 (valid ensemble - ACCEPTED)
- exp_002: 71.81 (micro-separation - used_baseline_fallback=true)
- exp_003: 71.81 (scale approach - used_baseline_fallback=true)
- exp_004: 71.81 (gap-constrained SA - used_baseline_fallback=true)

**The "convert existing solutions" approach family is EXHAUSTED.**
- All public optimizers (bbox3, tree_packer, SA) allow touching trees
- Existing solutions are optimized for touching (distance=0)
- Converting touching to non-touching loses ~1.2 points
- Simple SA/optimization cannot improve the valid ensemble

## Response to Evaluator

The evaluator correctly identified that:
1. The experiment didn't actually implement gap constraints in the C++ optimizer
2. 5 experiments with same approach = STUCK at local optimum
3. Need to PIVOT to fundamentally different approach

**I agree with the evaluator's assessment.** The key insight is that we need to:
1. Generate solutions FROM SCRATCH with gap constraints built in
2. NOT start from existing touching solutions
3. Use a proper optimizer that maintains gaps throughout

## THE FUNDAMENTAL PROBLEM

**Why all public solutions have touching trees:**
- All public kernels use collision detection that ALLOWS touching:
  ```python
  # This allows touching (distance=0)
  if tree1.polygon.intersects(tree2.polygon) and not tree1.polygon.touches(tree2.polygon):
      return True  # collision
  ```
- Optimizers push trees together until they touch (distance=0)
- Kaggle requires distance > 0, rejecting all touching solutions

**Why converting touching to non-touching fails:**
- Touching solutions are at tight local optima
- Any movement to create gaps causes new overlaps
- The ~1.2 point penalty is unavoidable with this approach

## RECOMMENDED APPROACHES (Priority Order)

### 1. **[HIGHEST PRIORITY] Implement True Gap-Constrained C++ Optimizer**

Modify the C++ optimizer to maintain MIN_GAP from the start:

```cpp
// In overlap check function:
const double MIN_GAP = 0.001;

// Option A: Inflate polygons before checking
Poly getInflatedPoly(double cx, double cy, double deg, double inflate) {
    // Scale tree vertices outward by inflate amount
    Poly q;
    double r = deg * PI / 180, c = cos(r), s = sin(r);
    for (int i = 0; i < NV; i++) {
        // Inflate by moving vertices outward from centroid
        double dx = TX[i], dy = TY[i];
        double len = sqrt(dx*dx + dy*dy);
        if (len > 0) {
            dx += inflate * dx / len;
            dy += inflate * dy / len;
        }
        q.p[i].x = dx * c - dy * s + cx;
        q.p[i].y = dx * s + dy * c + cy;
    }
    q.bbox();
    return q;
}

// Option B: Add distance check after overlap check
double minDistance(const Poly& a, const Poly& b) {
    // Compute minimum distance between two polygons
    // Use Shapely-like algorithm
}

bool hasGapViolation(const Poly& a, const Poly& b) {
    if (overlap(a, b)) return true;
    if (minDistance(a, b) < MIN_GAP) return true;
    return false;
}
```

**Key changes:**
1. Start from RANDOM initialization, not existing solutions
2. Use hasGapViolation() instead of overlap() in SA
3. Run for small N (1-20) first to verify it works
4. Then scale to full N=1-200

### 2. **[HIGH PRIORITY] Tessellation with Gap Constraints**

The egortrushin kernel uses tessellation (grid pattern) for large N:
- Start with 2 base trees
- Translate in x/y directions to create grid
- Parameters: nt = [nx, ny] where nx*ny >= N

**Modify for gap constraints:**
1. Add MIN_GAP to translation distances
2. Optimize base tree positions with gap constraints
3. This naturally maintains gaps in the grid pattern

```python
# Tessellation with gaps
def create_tessellation(n, base_trees, tx, ty, min_gap=0.001):
    # tx, ty are translation distances
    # Add min_gap to ensure gaps between translated trees
    tx_with_gap = tx + min_gap
    ty_with_gap = ty + min_gap
    
    trees = []
    for i in range(nx):
        for j in range(ny):
            if len(trees) >= n:
                break
            for base in base_trees:
                new_tree = translate(base, i * tx_with_gap, j * ty_with_gap)
                trees.append(new_tree)
    return trees[:n]
```

### 3. **[MEDIUM PRIORITY] No-Fit Polygon (NFP) Approach**

From web research, top competitors use NFP for efficient packing:
1. Compute NFP for each tree pair (with gap buffer)
2. NFP defines all positions where trees would violate gap
3. Use NFP for fast collision/gap checking in SA

### 4. **[LOWER PRIORITY] Backward Propagation with Gap Constraints**

The crodoc kernel uses backward propagation:
- Start from N=200, work backward to N=1
- For each N, try removing each tree from N+1 config
- Keep best configuration

**Modify for gap constraints:**
- Only accept configurations where all trees have distance > MIN_GAP
- This propagates gap-valid patterns from larger to smaller N

## What NOT to Try

- ❌ More variations of micro-separation or scaling
- ❌ Running existing C++ optimizers (they optimize for touching)
- ❌ Searching for more valid configs in existing CSVs (exhausted)
- ❌ Simple Python SA without proper gap constraints (too slow)

## SUBMISSION STRATEGY

- Remaining submissions: 90+
- **SUBMIT after EVERY experiment** - we have abundant submissions
- LB feedback is free information - USE IT
- Even if score is worse, we learn what doesn't work

## Validation Notes

- CV = LB exactly (perfect calibration confirmed)
- Scoring: score = Σ(s_n² / n) for n=1 to 200
- Kaggle requires distance > 0 between all tree pairs
- Use shapely.distance() to verify: all pairs must have distance > 1e-9

## Key Files

- Valid ensemble: `/home/code/experiments/002_valid_submission/submission.csv` (71.81)
- Touching ensemble: `/home/code/experiments/002_valid_ensemble/submission.csv` (70.65 - rejected)
- C++ optimizer template: `/home/nonroot/snapshots/santa-2025/21116303805/code/experiments/004_sa_v1_parallel/sa_v1_parallel.cpp`
- Egortrushin tessellation: `/home/code/research/kernels/egortrushin_santa25-simulated-annealing-with-translations/`

## Expected Outcomes

If gap-constrained optimization works:
- Should achieve scores between 70.65 (touching) and 71.81 (current valid)
- Target: ~70.5-71.0 would close 0.8-1.3 points of the 2.89 gap
- Combined with other improvements, could reach target

The key is to generate NEW solutions with gaps from the start, not convert existing touching solutions.