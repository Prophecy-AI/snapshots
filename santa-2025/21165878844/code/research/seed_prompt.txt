# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 71.81106 from exp_002 (micro_separation)
- Best LB score: 71.8128 (exp_001 - valid submission)
- Target: 68.919154 | Gap to target: 2.89 points (4.2%)

## CRITICAL PROBLEM IDENTIFIED
**Kaggle requires distance > 0 between all trees.** The pre-optimized solutions have trees TOUCHING (distance = 0), which Kaggle rejects as "overlapping". 

The gap breakdown:
- Touching ensemble: 70.65 (rejected by Kaggle)
- Valid ensemble: 71.81 (accepted)
- Gap: 1.17 points lost due to non-touching requirement
- Target: 68.92 (still 1.73 points below touching ensemble)

## Response to Evaluator
The evaluator correctly identified that:
1. Micro-separation approach has limited effectiveness (only 5/200 N values separated)
2. The touching configurations are too tightly packed - any movement causes new overlaps
3. **The key insight**: We need to GENERATE valid solutions from scratch with gap constraints, not convert touching solutions

I fully agree with the evaluator's recommendation to modify the C++ optimizer to maintain a minimum gap during optimization. This is the highest-leverage change.

## STRATEGY PIVOT: Generate Valid Solutions with Gap Constraints

### APPROACH 1: Modify C++ Optimizer (HIGHEST PRIORITY)
Modify `sa_v1_parallel.cpp` to maintain minimum gap:

The key change is in the overlap detection - add a MIN_GAP buffer so that trees must maintain distance > MIN_GAP, not just distance > 0.

This would enable the optimizer to find solutions that are:
1. Valid for Kaggle (distance > 0)
2. Near-optimal (only slightly worse than touching solutions)

### APPROACH 2: Tessellation/Translation-Based Approach (HIGH PRIORITY)
From egortrushin kernel - for large N (>50):
1. Start with 2 base trees in optimal configuration
2. Translate them in x and y directions to create a grid pattern
3. Parameters: nt = [nx, ny] where nx*ny >= N
4. Optimize the base configuration and translation distances

This is fundamentally different from random SA and could achieve tighter bounds.

### APPROACH 3: Python-Based Gap-Constrained Optimization (MEDIUM PRIORITY)
If C++ modification is too complex, implement in Python:
1. Use shapely's `distance()` function to check gaps
2. Reject moves that bring trees closer than MIN_GAP
3. Slower but easier to implement and debug

### APPROACH 4: Hybrid Approach - Scale and Re-optimize (MEDIUM PRIORITY)
1. Take touching solutions and scale all positions by 1.001 from centroid
2. This creates small gaps between all trees
3. Re-optimize with gap constraints to recover some efficiency
4. This might recover some of the 1.17 point gap

## Recommended Experiments (Priority Order)

1. **[HIGHEST]** Implement gap-constrained C++ optimizer
   - Modify sa_v1_parallel.cpp to add MIN_GAP buffer in overlap detection
   - Run optimization from scratch for all N
   - Expected: Score between 70.65 (touching) and 71.81 (valid)

2. **[HIGH]** Implement tessellation approach for large N
   - Use egortrushin's approach for N >= 50
   - Optimize base configuration and translation distances
   - Expected: Better scores for large N configurations

3. **[MEDIUM]** Python gap-constrained SA
   - Implement simpler SA in Python with gap constraints
   - Focus on small N (1-20) where search space is manageable
   - Expected: Modest improvements for small N

4. **[MEDIUM]** Scale-and-reoptimize approach
   - Scale touching solutions by 1.001 to create gaps
   - Re-optimize to recover efficiency
   - Faster to implement than full C++ modification

## What NOT to Try
- ❌ More micro-separation attempts (proven ineffective - only 5/200 succeeded)
- ❌ Finding better valid configs from existing CSVs (already exhausted 1020 CSVs)
- ❌ Running existing optimizers longer (they optimize for touching, not gaps)
- ❌ Force-directed separation (tested, doesn't converge)

## Validation Notes
- CV = LB exactly (perfect calibration confirmed)
- Scoring: score = Σ(s_n² / n) for n=1 to 200
- Lower is better

## SUBMISSION STRATEGY
- Remaining submissions: 90
- Submit after EVERY experiment - LB feedback is free!
- Even if worse than baseline, we learn what doesn't work

## Key Files
- C++ optimizer: /home/nonroot/snapshots/santa-2025/21116303805/code/experiments/004_sa_v1_parallel/sa_v1_parallel.cpp
- Valid ensemble: /home/code/experiments/002_valid_submission/submission.csv
- Touching ensemble: /home/code/experiments/002_valid_ensemble/submission.csv