# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 71.812779 from exp_001 (valid ensemble)
- Best LB score: 71.812779 (confirmed from submission)
- Target: 68.919154 | Gap to target: 2.89 points (4.2%)

## CRITICAL SITUATION ANALYSIS

**We are STUCK.** Four experiments have explored "convert existing solutions" with ZERO improvement:
- exp_000: Baseline with touching trees (70.68) - REJECTED by Kaggle
- exp_001: Valid ensemble from CSVs (71.81) - ACCEPTED
- exp_002: Micro-separation (71.81) - negligible improvement (+0.0017)
- exp_003: Scale approach (77.66 raw, fell back to 71.81) - FAILED

**ROOT CAUSE IDENTIFIED:**
All public C++ optimizers (bbox3, sa_v1_parallel, tree_packer) use `hasOvl()` or `overlap()` functions that allow touching (distance = 0). This is why ALL pre-optimized solutions have touching trees. Kaggle requires distance > 0.

**The 1.17 point gap between touching (70.65) and valid (71.81) is NOT fundamental** - it's an artifact of optimizing for touching trees. If we optimize with gap constraints from the start, we should get much closer to 70.65 while remaining valid.

## Response to Evaluator

**I AGREE with the evaluator's assessment.** The evaluator correctly identified:
1. Four experiments on "convert existing solutions" = exhausted approach
2. The C++ optimizer's `overlap()` function is the ROOT CAUSE
3. Need to PIVOT to generating new solutions with gap constraints

**Specific actions based on evaluator feedback:**
1. ✅ STOP trying to convert existing solutions
2. ✅ Modify C++ optimizer to maintain MIN_GAP
3. ✅ Try tessellation approach for large N
4. ✅ Focus on small N (1-20) where exhaustive search is feasible

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Modify C++ Optimizer for Gap Constraints

**Modify sa_v1_parallel.cpp:**

```cpp
// Add at top of file
const double MIN_GAP = 0.001;  // Minimum distance between trees

// Modify the overlap() function to require minimum gap
bool overlap(const Poly& a, const Poly& b) {
    // Add MIN_GAP buffer to bounding box check
    if (a.x1 + MIN_GAP < b.x0 || b.x1 + MIN_GAP < a.x0 || 
        a.y1 + MIN_GAP < b.y0 || b.y1 + MIN_GAP < a.y0) return false;
    
    // For detailed polygon check, need to compute actual distance
    // If bounding boxes overlap (with gap), check polygon distance
    // ... existing point-in-polygon and segment intersection checks
    // But return true if distance < MIN_GAP
}
```

**Alternative: Python-based gap-constrained SA:**
```python
from shapely.geometry import Polygon
from shapely import distance

def has_gap_violation(trees, min_gap=0.001):
    for i in range(len(trees)):
        for j in range(i+1, len(trees)):
            if trees[i].polygon.distance(trees[j].polygon) < min_gap:
                return True
    return False
```

### 2. **[HIGH PRIORITY]** Tessellation Approach for Large N

From egortrushin kernel - for N >= 50, use grid-based placement:
- Start with 2 base trees in optimal configuration
- Translate in x and y directions: nt = [nx, ny] where nx*ny >= N
- Grid patterns: N=72 → [6,6], N=100 → [5,10], N=144 → [6,12], N=200 → [7,15]

This creates regular patterns that may be more efficient than random SA.

### 3. **[MEDIUM PRIORITY]** Small N Exhaustive Search (N=1-10)

For small N, exhaustive search is computationally feasible:
- N=1: Already optimal at 45° (score contribution 0.66)
- N=2-10: Try all angle combinations with gap constraints
- These contribute ~4.3 points to total score

### 4. **[MEDIUM PRIORITY]** Fractional Translation with Gap Constraints

From jonathanchan kernel - micro-movements [0.001, 0.0005, 0.0002, 0.0001]:
- Apply to valid ensemble
- Only accept moves that maintain min_gap > 0
- May find small improvements

## What NOT to Try
- ❌ More variations of micro-separation
- ❌ More geometric transformations on existing solutions
- ❌ Running existing optimizers longer (they optimize for touching)
- ❌ Searching for more valid configs in existing CSVs (exhausted)

## Implementation Strategy

**Experiment 005: Gap-Constrained Optimization**

1. **Option A (Preferred):** Modify C++ optimizer
   - Copy sa_v1_parallel.cpp
   - Add MIN_GAP constant
   - Modify overlap() to check distance
   - Compile and run on all N values
   - Expected: Score between 70.65 and 71.81

2. **Option B (Fallback):** Python gap-constrained SA
   - Implement simple SA with shapely distance checks
   - Focus on small N (1-20) first
   - Slower but easier to implement correctly

3. **Option C:** Tessellation for large N
   - Implement egortrushin approach
   - Generate grid-based solutions for N >= 50
   - Combine with valid ensemble for small N

## Validation Notes
- CV = LB (perfect calibration confirmed)
- Use shapely.distance() to verify gaps > 0
- Test on small N first before full run

## SUBMISSION STRATEGY
- Remaining submissions: 90
- **SUBMIT after every experiment** - LB feedback is free information
- Even if score is worse, we learn what doesn't work
