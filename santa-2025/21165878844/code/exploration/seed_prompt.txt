# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.646824 from 002_valid_ensemble
- Best LB score: N/A (first valid submission pending)
- Target: 68.919154 | Gap to target: 1.73 points (2.51%)

## CRITICAL: Submission Validation Issue RESOLVED
The original baseline failed with "Overlapping trees in group 004" because Kaggle's validation is STRICTER than shapely's `intersects()` check. Trees that share even a single point or edge (intersection area ~1e-20) are rejected as "overlapping".

**Solution Applied:** Built a valid ensemble from 959 snapshot CSVs, selecting for each N the configuration with the smallest bounding box that has ZERO intersections (not even point/edge touching). This achieved score 70.647 with guaranteed valid submission.

## Response to Evaluator
The evaluator correctly identified:
1. ✅ Need to submit baseline to verify LB score - DOING THIS NOW with valid submission
2. ✅ Ensemble snapshot submissions - DONE, improved from 70.676 to 70.647
3. ⚠️ N=1 optimality analysis - N=1 is already at optimal (45 deg rotation, side=0.813)
4. ⚠️ fix_direction post-processing - Not yet applied, should try next

The evaluator's concern about per-N efficiency gaps is valid. The gap to target (1.73 points) requires fundamentally different approaches, not just micro-optimization.

## Recommended Approaches (Priority Order)

### 1. **[IMMEDIATE]** Submit valid ensemble to verify LB score
- Submission file: /home/submission/submission.csv
- Expected score: ~70.65
- This establishes our CV-LB baseline

### 2. **[HIGH PRIORITY]** Apply fix_direction post-processing
The fix_direction technique rotates the entire configuration to minimize bounding box:
- Source: `research/kernels/saspav_santa-submission/santa-submission.ipynb`
- Uses ConvexHull + minimize_scalar to find optimal rotation (0-90 degrees)
- Can improve score without changing tree positions relative to each other
- Apply to all 200 configurations

### 3. **[HIGH PRIORITY]** Run bbox3 optimizer on valid configurations
The current ensemble is from pre-optimized snapshots. Running bbox3 with longer iterations might find improvements:
- Source: `research/kernels/jazivxt_why-not/why-not.ipynb`
- Compile: `g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp`
- Run: `./bbox3 -n 50000 -r 128` (longer than typical)
- IMPORTANT: Validate output has NO intersections before using

### 4. **[MEDIUM PRIORITY]** Focus on worst-performing N values
Analyze which N values have the worst efficiency (highest s²/n contribution relative to theoretical minimum):
- Small N (1-10): Already well-optimized, contribute ~4.3 to score
- Medium N (11-50): Contribute ~14.7, may have room for improvement
- Large N (100-200): Lattice/grid patterns might help

### 5. **[MEDIUM PRIORITY]** Implement lattice packing for large N
For N >= 58, crystalline/grid-based placement may achieve tighter bounds:
- Start with 2 base trees in optimal configuration
- Translate in x and y to create grid pattern
- Parameters: nx, ny where nx*ny >= N

## What NOT to Try
- ❌ Using configurations with ANY intersection (even point/edge touching)
- ❌ Micro-optimization of existing solutions (they're at local optima)
- ❌ Simple SA runs on pre-optimized solutions (previous experiments found 0 improvements)

## Validation Notes
- ALWAYS check `has_any_intersection()` before using a configuration
- Kaggle rejects trees that share even a single point
- Use the ensemble-building approach to find valid configurations

## SUBMISSION STRATEGY
- Remaining submissions: 91
- Submit after this experiment? **YES** - need to verify LB score matches CV
- We have abundant submissions, use them for feedback
