# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D polygon packing optimization problem. Pack Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding box for each configuration of N trees (N=1 to 200).

**Scoring:** score = Σ(s_n² / n) for n=1 to 200, where s_n is the side length of the bounding square for n trees. **Lower is better.**

**Target Score:** Beat 68.919154
**Current Best:** 70.676102 (from pre-optimized submissions)
**Gap:** 1.75 points (2.5%)

## CRITICAL INSIGHT
The pre-optimized submissions are at a **tight local optimum**. Standard SA/optimization runs find NO improvements. Previous experiments ran bbox3, tree_packer_v21, backward propagation - all found 0 improvements. **Micro-optimization of existing solutions will NOT close the 1.75 point gap.**

## Tree Geometry
Each Christmas tree is a 15-vertex polygon:
- Trunk: width 0.15, height 0.2
- Base tier: width 0.7
- Middle tier: width 0.4
- Top tier: width 0.25
- Tip at y=0.8, Total height: 1.0 (from trunk bottom at -0.2 to tip at 0.8)
- Can be positioned (x, y) and rotated by angle (deg)

## Pre-Optimized Submissions Available
Best pre-optimized CSV files are in `/home/nonroot/snapshots/santa-2025/`:
- `submission.csv` files scoring ~70.676
- Use these as starting points, NOT the sample_submission.csv

## Top Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (Primary)
**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`

Core engine used by top solutions:
- Complex Number Vector Coordination for position calculations
- Fluid Dynamics simulation for tree movement
- Hinge Pivot mechanism for rotation optimization
- Density Gradient Flow for compaction
- Global Boundary Tension for edge optimization
- OpenMP parallelization

**Compilation & Usage:**
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp
./bbox3 -n 10000 -r 64  # -n iterations, -r rounds
```

### 2. tree_packer_v21 (Alternative Optimizer)
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Features:
- Swap moves between trees
- Multi-angle restarts
- Higher temperature simulated annealing
- Squeeze, compaction, and local search phases
- Uses long double precision for accuracy

### 3. fix_direction Post-Processing (CRITICAL)
**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

Rotates entire configuration to minimize bounding box:
```python
def optimize_rotation(trees):
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points_np = np.array(all_points)
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    res = minimize_scalar(
        lambda a: calculate_bbox_side_at_angle(a, hull_points),
        bounds=(0.001, 89.999), method='bounded'
    )
    return res.x, res.fun
```

### 4. Backward Propagation
Improves smaller N configurations by removing trees from larger ones:
- Start from N=200, work down to N=2
- For each config, try removing each tree
- If resulting (N-1) config is better than stored, save it

## STRATEGIES TO BEAT TARGET (Priority Order)

### 1. **[HIGHEST PRIORITY]** Lattice/Grid-Based Approach for Large N
For N >= 58, use crystalline/grid-based placement:
- Start with 2 base trees in optimal configuration
- Translate them in x and y directions to create a grid pattern
- Parameters: nt = [nx, ny] where nx*ny >= N
- This can achieve tighter bounds than random optimization

### 2. **[HIGH PRIORITY]** Focus on Small N Values (1-10)
These have the lowest efficiency and highest score contribution:
- N=1: side=0.813, contributes 0.66 to score (highest single contribution!)
- N=2: side=0.950, contributes 0.45 to score
- Try exhaustive search for optimal rotation angles
- For N=1, optimal angle is 45 degrees (minimizes bounding box)

### 3. **[HIGH PRIORITY]** Much Longer Optimization Runs
Top solutions run for HOURS, not minutes:
- Higher iterations: -n 100000 or more
- More restarts: -r 100 or more
- Different random seeds
- Multiple generations with perturbation to escape local optima

### 4. **[MEDIUM PRIORITY]** Asymmetric Solutions
Discussion insight: "Why the winning solutions will be Asymmetric"
- Symmetric solutions may be optimal for small N but asymmetric for large N
- Try breaking symmetry in configurations

### 5. **[MEDIUM PRIORITY]** Per-N Specialization
- Calculate score contribution for each N: s_n² / n
- Identify N values with worst efficiency
- Focus optimization time on those specific configurations
- Different strategy for N<50 vs N>100

### 6. **[MEDIUM PRIORITY]** Multi-Start Strategy
- Run optimizer multiple times with different random seeds
- Keep best result for each N
- Combine best configurations from different runs

## Implementation Details

### ChristmasTree Class
```python
from decimal import Decimal, getcontext
from shapely import affinity
from shapely.geometry import Polygon

getcontext().prec = 30

class ChristmasTree:
    def __init__(self, center_x='0', center_y='0', angle='0'):
        self.center_x = Decimal(str(center_x))
        self.center_y = Decimal(str(center_y))
        self.angle = Decimal(str(angle))
        
        initial_polygon = Polygon([
            (0.0, 0.8),      # Tip
            (0.125, 0.5),    # Right top tier
            (0.0625, 0.5),
            (0.2, 0.25),     # Right mid tier
            (0.1, 0.25),
            (0.35, 0.0),     # Right base
            (0.075, 0.0),    # Right trunk
            (0.075, -0.2),
            (-0.075, -0.2),  # Left trunk
            (-0.075, 0.0),
            (-0.35, 0.0),    # Left base
            (-0.1, 0.25),    # Left mid tier
            (-0.2, 0.25),
            (-0.0625, 0.5),  # Left top tier
            (-0.125, 0.5),
        ])
        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))
        self.polygon = affinity.translate(rotated, xoff=float(self.center_x), yoff=float(self.center_y))
```

### Overlap Detection
```python
from shapely.strtree import STRtree

def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

### Scoring Function
```python
def get_total_score(submission_df):
    total = 0
    for n in range(1, 201):
        trees = load_trees_for_n(submission_df, n)
        xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])
        side = max(xys.max(axis=0) - xys.min(axis=0))
        total += side**2 / n
    return total
```

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- id: `{n:03d}_{tree_index}` (e.g., 001_0, 002_0, 002_1)
- x, y, deg: prefixed with 's' to preserve precision
- Total rows: 20100 (1+2+3+...+200)

## Validation Checklist
1. No overlapping trees (use has_overlap function)
2. All coordinates within [-100, 100]
3. All 200 configurations present (20100 rows)
4. Values prefixed with 's' in submission

## External Datasets
Top kernels use pre-optimized submissions as starting points:
- "santa-2025-csv" - contains bbox3 binary and optimized CSV
- "bucket-of-chump" - another optimized starting point
- Download these to use as baseline

## Recommended Experiment Pipeline

### Phase 1: Establish Baseline (~70.68)
1. Copy best pre-optimized submission from snapshots
2. Run fix_direction on it
3. Validate no overlaps
4. Submit to verify baseline score

### Phase 2: Try Novel Approaches
1. **Lattice packing for large N** - Implement grid-based placement
2. **Optimize small N exhaustively** - Focus on N=1-10
3. **Run much longer optimization** - Hours, not minutes
4. **Try asymmetric configurations**

### Phase 3: Ensemble Best Results
1. For each N, keep whichever approach gives smallest bounding box
2. Apply fix_direction to final combined result
3. Validate thoroughly before submission

## What NOT to Try (Already Failed)
- Short optimization runs on pre-optimized submissions (no improvements)
- Simple ensemble of existing CSVs (one source dominates all N values)
- Backward propagation alone (no improvements found)
- Standard SA with default parameters

## Key Insight for Beating Target
The gap of 1.75 points requires **fundamentally different approaches**, not micro-optimization:
1. Lattice/tessellation patterns for large N
2. Exhaustive search for small N
3. Breaking symmetry
4. Much longer compute time with restarts

Start with pre-optimized baseline, then focus on novel approaches that can escape the local optimum.
