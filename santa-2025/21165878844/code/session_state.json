{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-20T09:20:06.831729",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [
    {
      "strategy": "# Santa 2025 - Christmas Tree Packing Optimization\n\n## Problem Overview\nThis is a 2D polygon packing optimization problem. Pack Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding box for each configuration of N trees (N=1 to 200).\n\n**Scoring:** score = \u03a3(s_n\u00b2 / n) for n=1 to 200, where s_n is the side length of the bounding square for n trees. **Lower is better.**\n\n**Target Score:** Beat 68.919154\n**Current Best:** 70.676102 (from pre-optimized submissions)\n**Gap:** 1.75 points (2.5%)\n\n## CRITICAL INSIGHT\nThe pre-optimized submissions are at a **tight local optimum**. Standard SA/optimization runs find NO improvements. Previous experiments ran bbox3, tree_packer_v21, backward propagation - all found 0 improvements. **Micro-optimization of existing solutions will NOT close the 1.75 point gap.**\n\n## Tree Geometry\nEach Christmas tree is a 15-vertex polygon:\n- Trunk: width 0.15, height 0.2\n- Base tier: width 0.7\n- Middle tier: width 0.4\n- Top tier: width 0.25\n- Tip at y=0.8, Total height: 1.0 (from trunk bottom at -0.2 to tip at 0.8)\n- Can be positioned (x, y) and rotated by angle (deg)\n\n## Pre-Optimized Submissions Available\nBest pre-optimized CSV files are in `/home/nonroot/snapshots/santa-2025/`:\n- `submission.csv` files scoring ~70.676\n- Use these as starting points, NOT the sample_submission.csv\n\n## Top Approaches from Public Kernels\n\n### 1. bbox3 C++ Optimizer (Primary)\n**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`\n\nCore engine used by top solutions:\n- Complex Number Vector Coordination for position calculations\n- Fluid Dynamics simulation for tree movement\n- Hinge Pivot mechanism for rotation optimization\n- Density Gradient Flow for compaction\n- Global Boundary Tension for edge optimization\n- OpenMP parallelization\n\n**Compilation & Usage:**\n```bash\ng++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp\n./bbox3 -n 10000 -r 64  # -n iterations, -r rounds\n```\n\n### 2. tree_packer_v21 (Alternative Optimizer)\n**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n\nFeatures:\n- Swap moves between trees\n- Multi-angle restarts\n- Higher temperature simulated annealing\n- Squeeze, compaction, and local search phases\n- Uses long double precision for accuracy\n\n### 3. fix_direction Post-Processing (CRITICAL)\n**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`\n\nRotates entire configuration to minimize bounding box:\n```python\ndef optimize_rotation(trees):\n    all_points = []\n    for tree in trees:\n        all_points.extend(list(tree.polygon.exterior.coords))\n    points_np = np.array(all_points)\n    hull_points = points_np[ConvexHull(points_np).vertices]\n    \n    res = minimize_scalar(\n        lambda a: calculate_bbox_side_at_angle(a, hull_points),\n        bounds=(0.001, 89.999), method='bounded'\n    )\n    return res.x, res.fun\n```\n\n### 4. Backward Propagation\nImproves smaller N configurations by removing trees from larger ones:\n- Start from N=200, work down to N=2\n- For each config, try removing each tree\n- If resulting (N-1) config is better than stored, save it\n\n## STRATEGIES TO BEAT TARGET (Priority Order)\n\n### 1. **[HIGHEST PRIORITY]** Lattice/Grid-Based Approach for Large N\nFor N >= 58, use crystalline/grid-based placement:\n- Start with 2 base trees in optimal configuration\n- Translate them in x and y directions to create a grid pattern\n- Parameters: nt = [nx, ny] where nx*ny >= N\n- This can achieve tighter bounds than random optimization\n\n### 2. **[HIGH PRIORITY]** No-Fit Polygon (NFP) Based Optimization\nFrom 2D packing literature - NFP is the gold standard for collision detection:\n- NFP describes the region where two polygons would overlap\n- Enables efficient placement search\n- Combined with local search or genetic algorithms\n- Can find tighter packings than simple overlap checks\n\n### 3. **[HIGH PRIORITY]** Focus on Small N Values (1-10)\nThese have the lowest efficiency and highest score contribution:\n- N=1: side=0.813, contributes 0.66 to score (highest single contribution!)\n- N=2: side=0.950, contributes 0.45 to score\n- Try exhaustive search for optimal rotation angles\n- For N=1, optimal angle is 45 degrees (minimizes bounding box)\n\n### 4. **[HIGH PRIORITY]** Much Longer Optimization Runs\nTop solutions run for HOURS, not minutes:\n- Higher iterations: -n 100000 or more\n- More restarts: -r 100 or more\n- Different random seeds\n- Multiple generations with perturbation to escape local optima\n\n### 5. **[MEDIUM PRIORITY]** Extended Local Search with Nonlinear Programming\nFrom research literature:\n- Treat placement coordinates as continuous variables\n- Iteratively solve nonlinear program to reduce overlap\n- Followed by discrete moves to escape local minima\n- Hybrid approach outperforms pure greedy heuristics\n\n### 6. **[MEDIUM PRIORITY]** Asymmetric Solutions\nDiscussion insight: \"Why the winning solutions will be Asymmetric\"\n- Symmetric solutions may be optimal for small N but asymmetric for large N\n- Try breaking symmetry in configurations\n\n### 7. **[MEDIUM PRIORITY]** Per-N Specialization\n- Calculate score contribution for each N: s_n\u00b2 / n\n- Identify N values with worst efficiency\n- Focus optimization time on those specific configurations\n- Different strategy for N<50 vs N>100\n\n### 8. **[MEDIUM PRIORITY]** Two-Level Algorithm\nFrom research: Two-level algorithms with collision-free regions:\n- First level: coarse placement using global heuristic\n- Second level: fine-grained search respecting collision-free zones\n- Useful when bounding box must be tightly minimized\n\n## Implementation Details\n\n### ChristmasTree Class\n```python\nfrom decimal import Decimal, getcontext\nfrom shapely import affinity\nfrom shapely.geometry import Polygon\n\ngetcontext().prec = 30\n\nclass ChristmasTree:\n    def __init__(self, center_x='0', center_y='0', angle='0'):\n        self.center_x = Decimal(str(center_x))\n        self.center_y = Decimal(str(center_y))\n        self.angle = Decimal(str(angle))\n        \n        initial_polygon = Polygon([\n            (0.0, 0.8),      # Tip\n            (0.125, 0.5),    # Right top tier\n            (0.0625, 0.5),\n            (0.2, 0.25),     # Right mid tier\n            (0.1, 0.25),\n            (0.35, 0.0),     # Right base\n            (0.075, 0.0),    # Right trunk\n            (0.075, -0.2),\n            (-0.075, -0.2),  # Left trunk\n            (-0.075, 0.0),\n            (-0.35, 0.0),    # Left base\n            (-0.1, 0.25),    # Left mid tier\n            (-0.2, 0.25),\n            (-0.0625, 0.5),  # Left top tier\n            (-0.125, 0.5),\n        ])\n        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))\n        self.polygon = affinity.translate(rotated, xoff=float(self.center_x), yoff=float(self.center_y))\n```\n\n### Overlap Detection\n```python\nfrom shapely.strtree import STRtree\n\ndef has_overlap(trees):\n    polygons = [t.polygon for t in trees]\n    tree_index = STRtree(polygons)\n    \n    for i, poly in enumerate(polygons):\n        indices = tree_index.query(poly)\n        for idx in indices:\n            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):\n                return True\n    return False\n```\n\n### Scoring Function\n```python\ndef get_total_score(submission_df):\n    total = 0\n    for n in range(1, 201):\n        trees = load_trees_for_n(submission_df, n)\n        xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])\n        side = max(xys.max(axis=0) - xys.min(axis=0))\n        total += side**2 / n\n    return total\n```\n\n## Submission Format\n```csv\nid,x,y,deg\n001_0,s0.0,s0.0,s90.0\n002_0,s0.0,s0.0,s90.0\n002_1,s0.202736,s-0.511271,s90.0\n...\n```\n- id: `{n:03d}_{tree_index}` (e.g., 001_0, 002_0, 002_1)\n- x, y, deg: prefixed with 's' to preserve precision\n- Total rows: 20100 (1+2+3+...+200)\n\n## Validation Checklist\n1. No overlapping trees (use has_overlap function)\n2. All coordinates within [-100, 100]\n3. All 200 configurations present (20100 rows)\n4. Values prefixed with 's' in submission\n\n## External Datasets\nTop kernels use pre-optimized submissions as starting points:\n- \"santa-2025-csv\" - contains bbox3 binary and optimized CSV\n- \"bucket-of-chump\" - another optimized starting point\n- Download these to use as baseline\n\n## Recommended Experiment Pipeline\n\n### Phase 1: Establish Baseline (~70.68)\n1. Copy best pre-optimized submission from snapshots\n2. Run fix_direction on it\n3. Validate no overlaps\n4. Submit to verify baseline score\n\n### Phase 2: Try Novel Approaches\n1. **Lattice packing for large N** - Implement grid-based placement\n2. **Optimize small N exhaustively** - Focus on N=1-10\n3. **Run much longer optimization** - Hours, not minutes\n4. **Try asymmetric configurations**\n5. **Implement NFP-based placement** - More efficient collision detection\n\n### Phase 3: Ensemble Best Results\n1. For each N, keep whichever approach gives smallest bounding box\n2. Apply fix_direction to final combined result\n3. Validate thoroughly before submission\n\n## What NOT to Try (Already Failed)\n- Short optimization runs on pre-optimized submissions (no improvements)\n- Simple ensemble of existing CSVs (one source dominates all N values)\n- Backward propagation alone (no improvements found)\n- Standard SA with default parameters\n\n## Key Insight for Beating Target\nThe gap of 1.75 points requires **fundamentally different approaches**, not micro-optimization:\n1. Lattice/tessellation patterns for large N\n2. Exhaustive search for small N\n3. Breaking symmetry\n4. Much longer compute time with restarts\n5. NFP-based optimization from 2D packing literature\n\n## Research References\n- No-Fit Polygon (NFP) for collision detection: Improved sliding algorithm (MDPI 2022)\n- Extended local search with nonlinear programming (Computers & Operations Research 2012)\n- Two-level algorithms with collision-free regions (ICINCO 2011)\n- Shelf-based approximation algorithms (ESA 2023)\n\nStart with pre-optimized baseline, then focus on novel approaches that can escape the local optimum.\n",
      "agent": "explorer",
      "timestamp": "2026-01-20T09:26:23.680520"
    }
  ],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "Best pre-optimized score is 70.676102. Target is 68.919154. Gap is 1.75 points (2.5%). The pre-optimized submissions are at a tight local optimum - standard SA/optimization runs find NO improvements.",
      "source": "snapshots metrics.json",
      "agent": "explorer"
    },
    {
      "finding": "bbox3.cpp is the core optimizer: Uses Complex Number Vector Coordination, Fluid Dynamics simulation, Hinge Pivot mechanism, Density Gradient Flow, Global Boundary Tension. Key params: -n iterations (5000-20000), -r rounds (16-256). Compile: g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "tree_packer_v21.cpp: Alternative optimizer with swap moves, multi-angle restarts, higher temperature SA, squeeze/compaction/local search phases. Uses long double precision.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "fix_direction post-processing: Rotates entire configuration to minimize bounding box. Uses ConvexHull + minimize_scalar to find optimal rotation angle (0-90 degrees). Can improve score without changing tree positions relative to each other.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Key 2D packing techniques: 1) No-Fit Polygon (NFP) for efficient collision detection, 2) Shelf-based approximation algorithms, 3) Extended local search with nonlinear programming, 4) Genetic algorithms + local search hybrid, 5) Two-level algorithms with collision-free regions. Meta-heuristics (SA, tabu search, PSO) are widely used with NFP-based collision detection.",
      "source": "WebSearch: 2D irregular polygon packing",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization to minimize bounding box?",
      "finding": "2\u2011D irregular polygon packing \u2013 where each piece may have an arbitrary shape and can be rotated \u2013 is usually tackled as a strip\u2011packing or bounding\u2011box\u2011minimisation problem.  The goal is to place all polygons inside the smallest possible axis\u2011aligned rectangle (or strip) while avoiding overlap.  Because the problem is NP\u2011hard, most state\u2011of\u2011the\u2011art approaches fall into two families: **exact/branch\u2011and\u2011bound formulations** that guarantee optimality for modest instance sizes, and **high\u2011performance heuristics** that give near\u2011optimal solutions on industrial\u2011scale data.\n\n**Exact and mixed\u2011integer models.**  A recent mixed\u2011integer programming (MIP) model slices the strip into vertical columns and encodes non\u2011overlap with binary variables; this formulation yields provably optimal layouts for small to medium sets of irregular pieces but quickly becomes computationally expensive as the number of polygons grows\u202f([arxiv.org](https://arxiv.org/pdf/2206.00032)).  Complementary to MIP, the **no\u2011fi",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 91
}