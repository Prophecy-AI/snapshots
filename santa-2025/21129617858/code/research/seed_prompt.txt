# Santa 2025 Christmas Tree Packing - Strategy Guide (Loop 1)

## Current Status
- Best CV score: 146.566819 from exp_000 (005_best_submission)
- Best LB score: N/A (no submissions yet)
- Target: 68.922808 | Gap to target: 77.64 points (more than 2x target!)

## Response to Evaluator

**Technical verdict was CONCERNS** - Cannot verify implementation details since code directory is empty. The score is valid but far from competitive.

**Evaluator's top priority**: Use the bbox3 C++ optimizer from public kernels.

**I AGREE with the evaluator's assessment.** The current Python implementation is fundamentally too slow and the approach of building from scratch is inefficient. The evaluator correctly identified that:
1. Top solutions use C++ optimizers (bbox3) with OpenMP parallelization
2. Starting from pre-optimized solutions (scores ~70) is essential
3. Extended optimization time (3+ hours) is needed
4. Post-processing (fix_direction, backward propagation) is critical

**Key concerns raised and how to address:**
1. **Not using bbox3**: We cannot directly use the binary, but we CAN implement a highly optimized Python version using numba JIT compilation
2. **Not starting from pre-optimized baseline**: We need to implement ensemble approach to combine best solutions
3. **Insufficient runtime**: Need to allocate more time for optimization
4. **Missing post-processing**: Must implement fix_direction and backward propagation

## Data Understanding

From `exploration/evolver_loop1_analysis.ipynb`:
- Total score: 146.57 (gap of 77.64 from target)
- Theoretical minimum: ~70 (assuming 100% packing efficiency)
- Target of 68.92 is VERY close to theoretical minimum - requires near-optimal packing
- Worst configurations: Small n values (2, 5, 8, 12) contribute disproportionately
- Sample submission scores 173.65 - our baseline is 27 points better

Key findings from research:
- Top kernels achieve 67-74 using C++ optimizers + ensemble + backward propagation
- Discussions confirm scores of 67 are achievable
- The target IS reachable with the right approach

## Critical Path to Target

### Phase 1: Implement High-Performance Optimizer (PRIORITY)
Since we cannot use the bbox3 binary directly, we must implement a fast Python optimizer:

1. **Use numba JIT compilation** for all core functions:
   - Polygon intersection checks
   - Bounding box calculations
   - Score computation
   - Move operators (translate, rotate)

2. **Implement key move operators**:
   - Translation (8 directions + toward center)
   - Rotation (individual tree angles)
   - Swap (exchange positions of two trees)
   - Squeeze (scale all trees toward center)
   - Compaction (move each tree toward center until collision)

3. **Simulated Annealing with proper parameters**:
   - Geometric cooling: T(k+1) = 0.95 * T(k)
   - Initial temperature: Accept 80% of random moves
   - Termination: T < 1e-6 or acceptance rate < 1%

### Phase 2: Implement Post-Processing
1. **fix_direction rotation optimization**:
   - Rotate entire configuration to minimize bounding box
   - Use scipy.optimize.minimize_scalar with bounds [0, 90]
   - Compute convex hull for efficient bbox calculation

2. **Backward propagation**:
   - Start from n=200, iterate backward to n=1
   - For each n, try removing each tree from (n+1) solution
   - Keep the better configuration

### Phase 3: Extended Optimization
1. Run optimizer for extended periods (30+ minutes per configuration)
2. Focus on worst-performing configurations first (n=2, 5, 8, 12, etc.)
3. Use multi-start with different random seeds

## Recommended Experiments (Priority Order)

### Experiment 1: JIT-Optimized Simulated Annealing
- Implement numba-JIT compiled SA optimizer
- Focus on core move operators: translate, rotate, squeeze
- Target: Reduce score from 146 to ~100

### Experiment 2: Fix Direction + Backward Propagation
- Implement fix_direction rotation optimization
- Implement backward propagation from n=200 to n=1
- Target: Further reduce score to ~85

### Experiment 3: Extended Optimization on Worst Configs
- Identify worst-performing configurations (highest s²/n)
- Run extended SA (30+ minutes) on each
- Target: Reduce score to ~75

### Experiment 4: Multi-Start Ensemble
- Run multiple optimization passes with different seeds
- Keep best solution for each n
- Target: Reduce score to ~70

## What NOT to Try
- ❌ Simple greedy placement without optimization (already tried, score ~155)
- ❌ Short optimization runs (< 5 minutes per config)
- ❌ Python without JIT compilation (too slow)
- ❌ Ignoring fix_direction (leaves significant improvement on table)

## Validation Notes
- All 200 configurations must be valid (no overlaps)
- Use Shapely for precise polygon intersection checks
- Score = Σ(s²/n) for n=1 to 200
- Submission format: prepend 's' to all numeric values

## Technical Implementation Notes

### Numba JIT for Speed
```python
from numba import njit
import numpy as np

@njit
def make_polygon_template():
    # Tree vertices as numpy arrays for fast computation
    tw=0.15; th=0.2; bw=0.7; mw=0.4; ow=0.25
    tip=0.8; t1=0.5; t2=0.25; base=0.0; tbot=-th
    x = np.array([0,ow/2,ow/4,mw/2,mw/4,bw/2,tw/2,tw/2,-tw/2,-tw/2,-bw/2,-mw/4,-mw/2,-ow/4,-ow/2])
    y = np.array([tip,t1,t1,t2,t2,base,base,tbot,tbot,base,base,t2,t2,t1,t1])
    return x, y

@njit
def score_group(xs, ys, degs, tx, ty):
    # Fast score calculation using JIT
    n = xs.size
    V = tx.size
    mnx = 1e300; mny = 1e300; mxx = -1e300; mxy = -1e300
    for i in range(n):
        r = degs[i] * np.pi / 180.0
        c = np.cos(r); s = np.sin(r)
        for j in range(V):
            X = c*tx[j] - s*ty[j] + xs[i]
            Y = s*tx[j] + c*ty[j] + ys[i]
            if X < mnx: mnx = X
            if X > mxx: mxx = X
            if Y < mny: mny = Y
            if Y > mxy: mxy = Y
    side = max(mxx - mnx, mxy - mny)
    return side * side / n
```

### Fix Direction Implementation
```python
from scipy.optimize import minimize_scalar
from scipy.spatial import ConvexHull

def fix_direction(xs, ys, degs, tx, ty):
    # Get all vertices
    all_points = []
    for i in range(len(xs)):
        r = degs[i] * np.pi / 180.0
        c, s = np.cos(r), np.sin(r)
        for j in range(len(tx)):
            X = c*tx[j] - s*ty[j] + xs[i]
            Y = s*tx[j] + c*ty[j] + ys[i]
            all_points.append([X, Y])
    points = np.array(all_points)
    hull_points = points[ConvexHull(points).vertices]
    
    def bbox_at_angle(angle):
        r = np.radians(angle)
        c, s = np.cos(r), np.sin(r)
        rot = np.array([[c, s], [-s, c]])
        rotated = hull_points @ rot.T
        return max(rotated[:,0].max() - rotated[:,0].min(),
                   rotated[:,1].max() - rotated[:,1].min())
    
    res = minimize_scalar(bbox_at_angle, bounds=(0, 90), method='bounded')
    return res.x, res.fun
```

## Expected Timeline
- Experiment 1 (JIT SA): 2-3 hours → Score ~100
- Experiment 2 (Post-processing): 1-2 hours → Score ~85
- Experiment 3 (Extended opt): 4-6 hours → Score ~75
- Experiment 4 (Ensemble): 2-3 hours → Score ~70

Total: ~12 hours to reach target of 68.92

## Key Success Factors
1. **Speed**: JIT compilation is essential - Python loops are too slow
2. **Quality**: Start from good solutions, don't build from scratch
3. **Time**: Extended optimization (30+ min per config) is needed
4. **Post-processing**: fix_direction and backward propagation are critical
5. **Focus**: Prioritize worst-performing configurations first

## IMMEDIATE NEXT STEP
Implement a numba JIT-compiled optimizer with:
1. Fast bounding box calculation
2. Polygon overlap detection using separating axis theorem
3. Simulated annealing with translate/rotate moves
4. Fix direction rotation optimization
5. Run for extended time on all 200 configurations