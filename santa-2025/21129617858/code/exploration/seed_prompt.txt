# Santa 2025 Christmas Tree Packing - Optimization Techniques Guide

## Problem Overview
This is a 2D geometric packing optimization problem. The goal is to pack Christmas tree-shaped polygons (15-vertex irregular shapes) into the smallest possible square bounding boxes for configurations of 1-200 trees.

**Metric:** Score = Σ(s²/n) for n=1 to 200, where s is the side length of the bounding square for each n-tree configuration. Lower is better.

**Target Score:** Beat 68.922808

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Tip at (0, 0.8)
- Three tiers of branches (widths: 0.25, 0.4, 0.7)
- Trunk (width: 0.15, height: 0.2)
- Total height: 1.0 (from trunk bottom at -0.2 to tip at 0.8)
- Maximum width: 0.7 at base

## Top Approaches from Public Kernels

### 1. Getting Started Baseline (../research/kernels/inversion_santa-2025-getting-started/)
- Greedy placement algorithm with collision detection using Shapely
- Weighted angle generation (favors diagonal orientations for better corner packing)
- Incremental building: use n-tree solution as starting point for (n+1)-tree
- STRtree for efficient spatial queries

### 2. bbox3 C++ Optimizer (../research/kernels/jazivxt_why-not/, ../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/)
- High-performance C++ implementation with OpenMP parallelization
- Key features:
  - Complex number vector coordination for tree movements
  - Fluid dynamics simulation for natural packing
  - Hinge pivot moves
  - Density gradient flow
  - Global boundary tension
  - Simulated annealing with temperature scheduling
  - Swap moves between trees
  - Multi-start with different angle initializations

### 3. Multi-Phase Optimization Strategy
- **Phase A (short runs, 2 min):** Explore many (n, r) parameter combinations
- **Phase B (medium runs, 10 min):** Focus on top candidates
- **Phase C (long runs, 20 min):** Deep optimization on best few
- Only validate/repair promising solutions to save time

### 4. fix_direction Rotation Optimization (../research/kernels/saspav_santa-submission/)
- Rotates entire configuration to minimize bounding box
- Uses scipy.optimize.minimize_scalar with bounded search [0, 90°]
- Computes convex hull of all tree vertices for efficient bbox calculation
- Can improve score without changing relative tree positions

### 5. Backward Propagation
- Improve smaller configurations by removing trees from larger ones
- For each n from 200 down to 2:
  - Try removing each boundary-touching tree
  - If resulting (n-1) config is better than stored, update it

## Key Optimization Techniques

### Collision Detection
- Use Shapely library with STRtree for efficient spatial indexing
- Point-in-polygon test + segment intersection for precise overlap detection
- Bounding box pre-filtering for speed

### Move Operators
1. **Translation:** Move tree toward center or in 8 directions
2. **Rotation:** Adjust individual tree angles
3. **Swap:** Exchange positions of two trees
4. **Squeeze:** Scale all trees toward center uniformly
5. **Compaction:** Move each tree toward center until collision

### Local Search Strategies
- Multi-scale step sizes: [0.01, 0.004, 0.0015, 0.0006, 0.00025, 0.0001]
- Rotation deltas: [5°, 2°, 0.8°, 0.3°, 0.1°]
- Focus on boundary trees (those defining the bounding box)
- Accept moves that reduce bounding box side length

### Simulated Annealing
- Higher initial temperature for exploration
- Geometric cooling schedule
- Accept worse solutions with probability exp(-delta/T)
- Multiple restarts with different initial configurations

### Overlap Repair
- If optimization creates overlaps, replace invalid configurations with known-good ones
- Keep backup of best valid solution
- Validate all 200 configurations before submission

## Implementation Recommendations

### Priority 1: Implement Core Optimizer
1. Start with greedy placement (bottom-left or center-out)
2. Add local search with translation/rotation moves
3. Implement squeeze and compaction
4. Add simulated annealing wrapper

### Priority 2: Rotation Optimization
- Implement fix_direction to rotate entire configurations
- Use convex hull for efficient bounding box computation
- Apply after each improvement phase

### Priority 3: Advanced Moves
- Swap moves between trees
- Boundary-focused optimization
- Multi-start with different initial angles

### Priority 4: Backward Propagation
- Use larger configs to improve smaller ones
- Focus on boundary-touching trees for removal candidates

## Validation Strategy
- Check for overlaps using precise polygon intersection
- Verify all 200 configurations are valid
- Score locally before submission
- Keep best valid solution as fallback

## Technical Notes
- Use high precision (Decimal with 25+ digits) for coordinates
- Submission format: prepend 's' to all numeric values
- Coordinates constrained to [-100, 100]
- Use OpenMP for parallelization in C++ implementations

## Reference Implementations
- Python baseline: `../research/kernels/inversion_santa-2025-getting-started/`
- C++ optimizer (bbox3): `../research/kernels/jazivxt_why-not/`
- Multi-phase runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- Fix direction + validation: `../research/kernels/saspav_santa-submission/`

## Expected Approach
1. Start from a good baseline submission (from kernels or greedy)
2. Apply fix_direction rotation optimization
3. Run local search with multiple move types
4. Use simulated annealing for global exploration
5. Apply backward propagation for smaller configs
6. Validate and repair any overlaps
7. Iterate until convergence or time limit
