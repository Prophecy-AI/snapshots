{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T08:02:05.830952",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D geometric packing optimization problem: Pack 1-200 Christmas tree shapes into minimum square bounding boxes. Score = sum of (side\u00b2/n) for each configuration. Trees are 15-vertex polygons with specific shape (trunk + 3-tier branches). Key approaches: 1) Greedy placement with collision detection using Shapely, 2) bbox3 C++ optimizer with simulated annealing, 3) Rotation optimization to minimize bounding box, 4) Squeeze/compaction moves, 5) Local search with position/angle perturbations.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Key optimization techniques from kernels: 1) fix_direction - rotates entire configuration to minimize bounding box using scipy.optimize.minimize_scalar, 2) bbox3 binary - C++ optimizer with phases (short/medium/long runs), 3) Overlap repair - replace invalid configurations with known-good ones, 4) Multi-phase optimization: Phase A (2min runs), Phase B (10min), Phase C (20min), 5) Backward propagation - improve smaller configs by removing trees from larger ones.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Advanced C++ optimizer features from bbox3.cpp: 1) Complex number vector coordination, 2) Fluid dynamics simulation for tree movement, 3) Hinge pivot moves, 4) Density gradient flow, 5) Global boundary tension, 6) Simulated annealing with temperature scheduling, 7) Swap moves between trees, 8) Multi-start with different angle initializations, 9) Squeeze operation (scale towards center), 10) Compaction (move trees toward center), 11) Local search with 8-directional moves.",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Key 2D irregular polygon packing techniques from research: 1) Bottom-left (BL) placement strategy - place pieces at lowest-leftmost valid position, 2) No-fit polygon (NFP) - precompute collision-free regions, 3) Simulated annealing (SA) with temperature scheduling, 4) Genetic algorithms with problem-specific operators, 5) Tabu search for diversification, 6) Local search with swap/translate/rotate moves, 7) Nonlinear programming for overlap minimization, 8) Two-level algorithms (fixed dimension + variable dimension), 9) Collision-free region (CFR) computation, 10) Compaction algorithms to tighten layouts.",
      "source": "Web search: 2D irregular polygon packing optimization",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization problems?",
      "finding": "Two\u2011dimensional irregular polygon packing \u2013 where arbitrary\u2011shaped pieces must be placed inside a rectangular sheet or a set of bins with minimal waste \u2013 is a classic combinatorial optimisation problem that appears in shipbuilding, metal\u2011working, textile and furniture manufacturing. Because the search space grows exponentially with the number of pieces and their possible orientations, exact methods are rarely practical for realistic instances; instead a variety of specialised heuristics and meta\u2011heuristics have become the de\u2011facto \u201cbest\u201d approaches\u202f([frontiersin](https://www.frontiersin.org/articles/10.3389/fmech.2022.966691/full)).\n\nThe most widely used families of algorithms are:  \n\n* **Constructive heuristics** that order the pieces and then place each one by a simple geometric rule. The classic *bottom\u2011left* (BL) strategy and its variants are still popular for irregular shapes, often combined with a preprocessing step that generates a placement order\u202f([taylorfrancis](https://www.ta",
      "agent": "explorer"
    },
    {
      "query": "What are optimal simulated annealing cooling schedules and temperature parameters for geometric packing problems?",
      "finding": "Simulated\u2011annealing (SA) for geometric\u2011packing (e.g., polygon, bin\u2011 or rotational\u2011packing) almost always relies on a **geometric (exponential) cooling schedule**  \n\n\\[\nT_{k+1}= \\alpha\\,T_{k},\n\\]\n\nwhere the factor\u202f\u03b1\u202f\u2208\u202f(0,1) is kept constant throughout the run.  Empirical studies on packing problems have shown that values of\u202f\u03b1\u202fbetween **0.90 and 0.99** give a good trade\u2011off between solution quality and run\u2011time; a slower decay (\u03b1\u22480.99) is preferred for larger instances because it allows more uphill moves early on, while a faster decay (\u03b1\u22480.90) can be used for smaller or easier instances\u202f([Result\u202f7](https://pdfs.semanticscholar.org/6509/3a9d2d6b9b38ac2c9a2da79c3905b76ef008.pdf);\u202f[Result\u202f8](https://link.springer.com/content/pdf/10.1007/BF02283751.pdf)).  \n\nThe **initial temperature** is usually chosen so that a random move that increases the objective by a typical \u0394E is accepted with a high probability (\u22480.8\u20130.9).  Practically this means setting  \n\n\\[\nT_{0}= -\\frac{\\Delta E}{\\ln(p_{0})},\n\\",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 95
}