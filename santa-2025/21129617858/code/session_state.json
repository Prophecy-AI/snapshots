{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T08:02:05.830952",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D geometric packing optimization problem: Pack 1-200 Christmas tree shapes into minimum square bounding boxes. Score = sum of (side\u00b2/n) for each configuration. Trees are 15-vertex polygons with specific shape (trunk + 3-tier branches). Key approaches: 1) Greedy placement with collision detection using Shapely, 2) bbox3 C++ optimizer with simulated annealing, 3) Rotation optimization to minimize bounding box, 4) Squeeze/compaction moves, 5) Local search with position/angle perturbations.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Key optimization techniques from kernels: 1) fix_direction - rotates entire configuration to minimize bounding box using scipy.optimize.minimize_scalar, 2) bbox3 binary - C++ optimizer with phases (short/medium/long runs), 3) Overlap repair - replace invalid configurations with known-good ones, 4) Multi-phase optimization: Phase A (2min runs), Phase B (10min), Phase C (20min), 5) Backward propagation - improve smaller configs by removing trees from larger ones.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Advanced C++ optimizer features from bbox3.cpp: 1) Complex number vector coordination, 2) Fluid dynamics simulation for tree movement, 3) Hinge pivot moves, 4) Density gradient flow, 5) Global boundary tension, 6) Simulated annealing with temperature scheduling, 7) Swap moves between trees, 8) Multi-start with different angle initializations, 9) Squeeze operation (scale towards center), 10) Compaction (move trees toward center), 11) Local search with 8-directional moves.",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization problems?",
      "finding": "Two\u2011dimensional irregular polygon packing \u2013 where arbitrary\u2011shaped pieces must be placed inside a rectangular sheet or a set of bins with minimal waste \u2013 is a classic combinatorial optimisation problem that appears in shipbuilding, metal\u2011working, textile and furniture manufacturing. Because the search space grows exponentially with the number of pieces and their possible orientations, exact methods are rarely practical for realistic instances; instead a variety of specialised heuristics and meta\u2011heuristics have become the de\u2011facto \u201cbest\u201d approaches\u202f([frontiersin](https://www.frontiersin.org/articles/10.3389/fmech.2022.966691/full)).\n\nThe most widely used families of algorithms are:  \n\n* **Constructive heuristics** that order the pieces and then place each one by a simple geometric rule. The classic *bottom\u2011left* (BL) strategy and its variants are still popular for irregular shapes, often combined with a preprocessing step that generates a placement order\u202f([taylorfrancis](https://www.ta",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 95
}