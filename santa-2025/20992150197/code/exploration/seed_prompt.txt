# Santa 2025 - Christmas Tree Packing Challenge: Seed Prompt

## Problem Understanding
This is a 2D irregular packing problem. You must pack $n$ identical (but rotatable) Christmas tree polygons into the smallest possible square container for each $n \in [1, 200]$.
**Objective:** Minimize $\sum_{n=1}^{200} \frac{s_n^2}{n}$, where $s_n$ is the side length of the square for $n$ trees.
**Constraints:** No overlap between trees. Trees can be rotated.
**Tree Shape:** Defined in `santa-2025-getting-started.ipynb`. It is a non-convex polygon.

## Core Techniques & Strategy

### 1. Geometry Handling (CRITICAL)
- **No-Fit Polygon (NFP):** This is the standard and most efficient technique for irregular packing. The NFP of two polygons $A$ and $B$ represents the set of all translation vectors for $B$ such that it touches but does not overlap $A$.
    - *Action:* Pre-calculate NFPs for the tree shape at various discrete rotations (e.g., every 1-5 degrees). This makes collision detection $O(1)$ lookup or simple point-in-polygon checks.
- **Decomposition:** Decompose the non-convex tree polygon into a set of convex polygons (e.g., rectangles or triangles). This allows using fast collision detection algorithms like the Separating Axis Theorem (SAT) or GJK if you don't use NFPs.
- **Rasterization:** For a quick approximate solution or initialization, rasterize the tree into a binary grid/matrix. Use 2D convolution (FFT-based) to find valid placement positions.

### 2. Initialization (Constructive Heuristics)
Do not start with random placement. Use a structured approach:
- **Bottom-Left Fill (BLF):** Place the next tree at the lowest, then leftmost valid position.
- **Constructive Lookahead:** When placing tree $i$, consider how it affects the "skyline" or available space for tree $i+1$.
- **Grid/Pattern Initialization:** For large $n$, optimal packings often exhibit lattice-like structures. Initialize with a hexagonal or square grid pattern (alternating 0° and 180° rotations) and then compress. (See `zaburo` kernel).

### 3. Optimization (The "Squeeze")
Once you have a valid configuration, you must shrink the container.
- **Physics-Based Simulation (Highly Recommended):** Treat trees as rigid bodies in a 2D physics engine (e.g., Box2D, Pymunk).
    - Apply centripetal forces (gravity towards the center) to all trees.
    - Add "shaking" (random small impulses) to break jams.
    - Slowly shrink the bounding box walls until internal pressure becomes too high.
- **Simulated Annealing (SA):**
    - *State:* Order of trees, orientations, and approximate positions.
    - *Moves:* Rotate a tree, swap two trees, remove and re-insert a tree using BLF.
    - *Energy:* Size of the bounding square.
- **Guided Local Search (GLS):** Penalize specific overlaps or "bad" placements to force the solver to explore new configurations.

### 4. Refinement & Post-Processing
- **Linear Programming (LP) / Separation:** Once a layout is "tight", fix the rotations and relative topology. Formulate an LP to minimize the bounding box size subject to non-overlap constraints (separation hyperplanes). This can squeeze out the final floating-point precision.
- **Iterative Compaction:** "Jiggle" trees: move a tree slightly; if valid and improves compactness, keep it. Repeat for all trees.

## Recommended Workflow
1.  **Baseline:** Implement a robust NFP generator or use a geometry library (Shapely/PyClipper) to handle overlaps accurately.
2.  **Pattern Search:** For each $n$, try initializing with regular patterns (rows, hex grid) with alternating orientations.
3.  **Physics Compress:** Load these patterns into a physics simulation. Apply forces to compress them into a square.
4.  **Global Optimization:** Wrap the physics simulation in a meta-heuristic (SA or GA) to explore different initial configurations and rotation sets.

## Key Resources
- **Tree Definition:** See `santa-2025-getting-started.ipynb` for the exact polygon coordinates.
- **Baseline Code:** `zaburo_88-32999-a-well-aligned-initial-solution` demonstrates a structured grid approach.
- **Literature:** Search for "Irregular Packing", "Nesting Problem", "No-Fit Polygon", "CMA-ES for Packing".

## Metric Specifics
The score is $\sum (s_n^2 / n)$. This means optimizing small $n$ contributes differently than large $n$. However, since it's a sum, you need good solutions for ALL $n$. Focus on a general solver that scales from $n=1$ to $n=200$.
