# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- **Best VALID CV score**: 70.676102 (baseline, exp_000)
- **Best LB score**: 70.676102 (1 submission made)
- **Target**: 68.919154
- **Gap to target**: 1.76 points (2.5%)
- **Submissions remaining**: 90/100

## ⚠️ CRITICAL: exp_002 (C++ optimizer) is INVALID!

The evaluator correctly identified that the C++ optimizer has a **buggy overlap detection**:
- The `hasOvl()` function only checks edge-edge intersections
- It MISSES polygon containment (one tree inside another)
- Verified with Shapely: N=2-7 and N=10 have SEVERE overlaps
- N=2: 0.18 intersection area (73% of tree area!)
- N=4: 1.02 intersection area
- **The reported score of 69.653351 is INVALID**
- Kaggle will REJECT this submission

## Response to Evaluator

The evaluator was **100% correct**. I verified the overlap issue with Shapely:
- Baseline (candidate_000.csv) has NO overlaps
- Optimized (optimized20.csv) has overlaps in N=2-7 and N=10
- The "improvement" was achieved by allowing illegal overlaps

The evaluator's recommendations are spot-on:
1. ✅ Use bbox3 (but it's GLIBC incompatible - system has 2.31, needs 2.34)
2. ✅ Add Shapely validation as post-processing
3. ✅ Fix the C++ overlap detection

## Technical Constraints

- **bbox3 binary is incompatible** - Requires GLIBC 2.34, system has 2.31
- **Must use Python-based optimization or fix C++ code**
- **All solutions must be validated with Shapely before submission**

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Fix C++ Overlap Detection and Re-run

The C++ optimizer structure is sound (SA + local search + fractional translation). Just fix the overlap detection by adding point-in-polygon check:

```cpp
// Add to hasOvl() after edge-edge check:
// Check if any vertex of polygon i is inside polygon j (or vice versa)
bool pointInPolygon(double px, double py, int j) {
    int cnt = 0;
    for (int k = 0; k < NV; k++) {
        int k2 = (k + 1) % NV;
        double x1 = this->px[j][k], y1 = this->py[j][k];
        double x2 = this->px[j][k2], y2 = this->py[j][k2];
        if ((y1 <= py && py < y2) || (y2 <= py && py < y1)) {
            double xint = x1 + (py - y1) / (y2 - y1) * (x2 - x1);
            if (px < xint) cnt++;
        }
    }
    return cnt % 2 == 1;
}
```

### 2. **[HIGH PRIORITY]** Python-based SA with Shapely Validation

If C++ fix is complex, implement SA in Python with proper Shapely overlap detection using STRtree for efficiency.

### 3. **[MEDIUM PRIORITY]** Backward Propagation (chistyakov approach)

Start with N trees, remove trees one by one that touch the bounding box, keep the configuration that minimizes the bounding box for N-1.

### 4. **[MEDIUM PRIORITY]** Validate and Repair Approach (saspav kernel)

Run optimization, validate with Shapely, revert any N with overlaps to baseline.

## What NOT to Try

- ❌ Running the buggy C++ optimizer without fixing overlap detection
- ❌ Submitting without Shapely validation
- ❌ Using bbox3 binary (GLIBC incompatible)
- ❌ Trusting any "improvement" without overlap verification

## Validation Requirements

**EVERY submission must be validated with Shapely before submitting.**

## Submission Strategy

- **90 submissions remaining** - ABUNDANT!
- **Submit after EVERY valid experiment** to get LB feedback
- **Always validate with Shapely before submission**
- **If overlap detected, revert that N to baseline before submitting**

## Key Insight

The C++ optimizer DID find better configurations for small N - the problem was just the overlap detection. Once fixed, we should see real improvements for N=2-10.