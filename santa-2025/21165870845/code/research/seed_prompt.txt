# Santa 2025 - Evolved Strategy (Loop 2)

## Current Status
- Best CV score: 70.676102 from exp_000 (baseline)
- Best LB score: 70.676102398091 (1 submission)
- Target: 68.919154 | Gap to target: 1.76 points (2.49%)

## Key Findings from Analysis

### 1. Ensemble is USELESS
All 30 pre-optimized CSVs produce the SAME best score (70.676102). santa-2025.csv dominates all N values. **No improvement possible from ensembling existing sources.**

### 2. Packing Efficiency Analysis
- N=1: 37.1% efficiency (lowest - already optimal at 45°)
- N=2: 54.5% efficiency
- N=10: 65.2% efficiency
- N=50: 68.1% efficiency
- N=100: 71.1% efficiency
- N=200: 72.7% efficiency

Small N values have the LOWEST efficiency and HIGHEST improvement potential.

### 3. Previous Experiments Failed
- exp_001 (small N SA): NO improvement - baseline is at tight local optimum
- exp_002 (lattice): INCOMPLETE - ImprovedLatticeAnnealing was defined but never tested
- bbox3 C++ optimizer: GLIBC incompatibility - cannot run pre-compiled binary

## Response to Evaluator

The evaluator correctly identified that:
1. The lattice experiment was incomplete - the ImprovedLatticeAnnealing class was never tested
2. The bbox3 optimizer wasn't used (due to GLIBC incompatibility)
3. Two experiments with no progress is concerning

**My response:**
- The lattice approach got stuck with collisions because the initial configuration was too tight
- We need to either: (a) Fix the lattice approach with better initial spacing, OR (b) Compile our own C++ optimizer
- The jonathanchan kernel shows the key technique: SA + local search + fractional translation
- Since bbox3 won't run, we should compile the jonathanchan C++ code ourselves

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Compile and Run C++ Optimizer
The jonathanchan kernel has a complete C++ optimizer with:
- Simulated annealing (sa_v3)
- Local search (ls_v3)
- Fractional translation (micro-steps 0.001 to 0.00001)
- Multi-generation optimization

**Implementation:**
```bash
# Extract C++ code from jonathanchan kernel
# Compile with: g++ -O3 -march=native -std=c++17 -fopenmp -o optimizer optimizer.cpp
# Run with: ./optimizer -i baseline.csv -n 15000 -r 80
```

This is the ONLY approach that has shown to produce scores better than 70.676102 in public kernels.

### 2. **[HIGH PRIORITY]** Fix Lattice Approach
The ImprovedLatticeAnnealing class needs:
- Wider initial spacing (dx=1.5, dy=1.2) to guarantee no collisions
- Better angle initialization (try 0°/180° instead of 90°/270°)
- More SA iterations (50000+)

Key N values for lattice: 72, 100, 144, 156, 196, 200

### 3. **[MEDIUM PRIORITY]** Fractional Translation Post-Processing
Even without full C++ optimizer, implement fractional translation in Python:
- After SA converges, try micro-steps (0.001, 0.0005, 0.0001, 0.00001)
- Move each tree in 8 directions (N, S, E, W, NE, NW, SE, SW)
- Accept if bounding box shrinks without collision

### 4. **[MEDIUM PRIORITY]** Different Starting Configurations
Instead of optimizing pre-optimized submission:
- Generate random configurations
- Use lattice-based initial placement
- Try different angle distributions (all 0°, all 45°, alternating 0°/180°)

## What NOT to Try
- ❌ Ensemble from existing CSVs (all produce same score)
- ❌ Short SA runs on pre-optimized submission (already at local optimum)
- ❌ Small N optimization with basic SA (already tried, no improvement)
- ❌ Running pre-compiled bbox3 (GLIBC incompatibility)

## SUBMISSION STRATEGY
- Remaining submissions: 90
- **Submit after EVERY experiment** - LB feedback is free
- Even if score doesn't improve, submit to verify CV-LB correlation

## Validation Notes
- CV matches LB exactly (70.676102 vs 70.676102398091)
- This is a deterministic optimization problem - no train/test split
- Use Shapely polygon intersection for collision detection
- Use high-precision Decimal arithmetic for submission format

## Technical Details

### Tree Geometry (15 vertices)
```cpp
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

### Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s45.0
002_0,s0.154097,s-0.038541,s203.629378
...
```

## Score Breakdown
- N=1-10: 4.33 points (highest per-tree contribution)
- N=11-50: 14.71 points
- N=51-100: 17.64 points
- N=101-150: 17.14 points
- N=151-200: 16.85 points

Total: 70.676102 | Target: 68.919154 | Gap: 1.76 points