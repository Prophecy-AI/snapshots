# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- **Best VALID CV score**: 70.676102 (baseline, exp_000)
- **Best LB score**: 70.676102 (1 submission made)
- **Target**: 68.919154
- **Gap to target**: 1.76 points (2.5%)
- **Submissions remaining**: 90/100

## ⚠️ CRITICAL: exp_002 (C++ optimizer) is INVALID!

The evaluator correctly identified that the C++ optimizer has a **buggy overlap detection**:
- The `hasOvl()` function only checks edge-edge intersections
- It MISSES polygon containment (one tree inside another)
- Verified with Shapely: N=2-7 and N=10 have SEVERE overlaps
- N=2: 0.18 intersection area (73% of tree area!)
- N=4: 1.02 intersection area
- **The reported score of 69.653351 is INVALID**
- Kaggle will REJECT this submission

## Response to Evaluator

The evaluator was **100% correct**. I verified the overlap issue with Shapely:
- Baseline (candidate_000.csv) has NO overlaps
- Optimized (optimized20.csv) has overlaps in N=2-7 and N=10
- The "improvement" was achieved by allowing illegal overlaps

The evaluator's recommendations are spot-on:
1. ✅ Use bbox3 (but it's GLIBC incompatible - system has 2.31, needs 2.34)
2. ✅ Add Shapely validation as post-processing
3. ✅ Fix the C++ overlap detection

## Technical Constraints

- **bbox3 binary is incompatible** - Requires GLIBC 2.34, system has 2.31
- **Must use Python-based optimization or fix C++ code**
- **All solutions must be validated with Shapely before submission**

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Fix C++ Overlap Detection and Re-run

The C++ optimizer structure is sound (SA + local search + fractional translation). Just fix the overlap detection:

```cpp
// Add point-in-polygon check to hasOvl()
bool pointInPolygon(double px, double py, int j) {
    int cnt = 0;
    for (int k = 0; k < NV; k++) {
        int k2 = (k + 1) % NV;
        double x1 = this->px[j][k], y1 = this->py[j][k];
        double x2 = this->px[j][k2], y2 = this->py[j][k2];
        if ((y1 <= py && py < y2) || (y2 <= py && py < y1)) {
            double xint = x1 + (py - y1) / (y2 - y1) * (x2 - x1);
            if (px < xint) cnt++;
        }
    }
    return cnt % 2 == 1;
}

// In hasOvl(), after edge-edge check:
for (int v = 0; v < NV; v++) {
    if (pointInPolygon(px[i][v], py[i][v], j)) return true;
    if (pointInPolygon(px[j][v], py[j][v], i)) return true;
}
```

### 2. **[HIGH PRIORITY]** Python-based SA with Shapely Validation

If C++ fix is complex, implement SA in Python with proper Shapely overlap detection:

```python
from shapely.geometry import Polygon
from shapely.strtree import STRtree

def has_overlap(trees):
    """Check if any two trees overlap using Shapely."""
    polygons = [get_tree_polygon(t.x, t.y, t.deg) for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        for idx in tree_index.query(poly):
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

### 3. **[MEDIUM PRIORITY]** Backward Propagation (chistyakov approach)

The chistyakov kernel uses backward propagation:
- Start with N trees
- Remove trees one by one that touch the bounding box
- Keep the configuration that minimizes the bounding box for N-1
- This can find better configurations for smaller N values

### 4. **[MEDIUM PRIORITY]** Validate and Repair Approach (saspav kernel)

The saspav kernel approach:
1. Run bbox3 optimization (if available)
2. Validate with Shapely for overlaps
3. For any N with overlaps, revert to baseline
4. This ensures valid submissions while keeping improvements

## What NOT to Try

- ❌ Running the buggy C++ optimizer without fixing overlap detection
- ❌ Submitting without Shapely validation
- ❌ Using bbox3 binary (GLIBC incompatible)
- ❌ Trusting any "improvement" without overlap verification

## Validation Requirements

**EVERY submission must be validated with Shapely:**

```python
def validate_submission(csv_path):
    """Validate that no trees overlap in any N configuration."""
    df = load_submission(csv_path)
    for n in range(1, 201):
        trees = df[df['n'] == n]
        if has_overlap(trees):
            print(f"OVERLAP in N={n}!")
            return False
    return True
```

## Submission Strategy

- **90 submissions remaining** - ABUNDANT!
- **Submit after EVERY valid experiment** to get LB feedback
- **Always validate with Shapely before submission**
- **If overlap detected, revert that N to baseline before submitting**

## Score Breakdown (from baseline)

- N=1-10: ~3.5 points (highest per-tree contribution)
- N=11-50: ~15 points
- N=51-100: ~18 points
- N=101-150: ~16 points
- N=151-200: ~18 points

Focus on small N values (N=2-10) which have the highest improvement potential.

## Key Insight from Experiments

The C++ optimizer DID find better configurations for small N - the problem was just the overlap detection. Once fixed, we should see real improvements for N=2-10.

## Immediate Actions

1. Fix the C++ overlap detection (add point-in-polygon check)
2. Re-run optimization on baseline
3. Validate output with Shapely
4. Submit to verify on LB
