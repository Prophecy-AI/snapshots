# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- **Best CV score**: 70.676102 (from baseline santa-2025.csv)
- **Best LB score**: 70.676102 (exp_000 submission)
- **Target**: 68.919154
- **Gap to target**: 1.756948 points (2.55%)
- **Submissions used**: 1/100 (90 remaining - ABUNDANT!)

## Response to Evaluator

The evaluator correctly identified that:
1. **SA-based optimization is STUCK** - 4 experiments with 0 improvements
2. **The baseline is at a very tight local optimum** - standard SA cannot escape
3. **Lattice/translation approach has NOT been tried** - this is the key missing approach
4. **C++ optimizer had buggy overlap detection** - now fixed, but still no improvements

I AGREE with the evaluator's assessment. The SA approach has been thoroughly tested and found wanting. It's time to pivot to a fundamentally different approach: **LATTICE-BASED PACKING**.

## Key Insight from Research

The **egortrushin kernel** (126 votes) uses a fundamentally different approach:
- Start with 2 base trees in a specific configuration
- Translate them in x and y directions to create a grid pattern
- Use SA to optimize: base positions, base angles, translation vectors
- Then use **backward propagation** to improve smaller N values

This is a **completely different search space** that standard SA on random configurations cannot explore.

## CRITICAL: What Has FAILED (DO NOT REPEAT)

1. ❌ **SA on pre-optimized baseline** - NO improvement (exp_001, exp_003)
2. ❌ **C++ optimizer with SA + local search** - Invalid due to overlap bugs (exp_002)
3. ❌ **C++ optimizer with fixed overlaps** - NO improvement (exp_003)
4. ❌ **Ensemble of existing CSVs** - All produce same score (70.676102)

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Implement Lattice/Translation Approach

**Based on egortrushin kernel - this is the key untried approach!**

```python
# Lattice-based tree placement
def generate_lattice_trees(base_trees, nx, ny, dx, dy):
    """
    Generate a grid of trees from 2 base trees.
    base_trees: list of 2 ChristmasTree objects (position + angle)
    nx, ny: number of translations in x and y directions
    dx, dy: translation vectors [dx_x, dx_y] and [dy_x, dy_y]
    """
    trees = []
    for i in range(nx):
        for j in range(ny):
            for base in base_trees:
                new_x = base.x + i * dx[0] + j * dy[0]
                new_y = base.y + i * dx[1] + j * dy[1]
                trees.append(ChristmasTree(new_x, new_y, base.angle))
    return trees[:nx * ny * 2]  # Trim to exact count
```

**Target N values for lattice approach:**
- N=72 (4×9×2 = 72)
- N=100 (5×10×2 = 100)
- N=110 (5×11×2 = 110)
- N=144 (6×12×2 = 144)
- N=156 (6×13×2 = 156)
- N=196 (7×14×2 = 196)
- N=200 (from 7×15×2 = 210, take first 200)

**SA parameters to optimize:**
- Base tree 1: (x1, y1, angle1)
- Base tree 2: (x2, y2, angle2)
- Translation vector dx: (dx_x, dx_y)
- Translation vector dy: (dy_x, dy_y)

### 2. **[HIGH PRIORITY]** Backward Propagation

After generating lattice solutions for large N, use backward propagation:
- Start from N=200 and work backward to N=1
- For each N, try removing each tree and keep the best configuration for N-1
- This propagates good packing patterns to smaller N values

**Based on crodoc kernel (127 votes)**

### 3. **[MEDIUM PRIORITY]** Focus on Small N Values (1-10)

These have the **highest score contribution per tree**:
- N=1: contributes 0.66 to total score (HIGHEST!)
- N=2: contributes 0.45 to score
- N=3: contributes 0.43 to score

For small N, try:
- Exhaustive search over rotation angles (0.1 degree increments)
- Handcrafted asymmetric layouts
- Different starting configurations (not from baseline)

## Implementation Plan for Next Experiment

**Experiment 006: Lattice-Based Packing**

1. **Implement the egortrushin lattice approach** from scratch
2. **Generate lattice solutions** for N=72, 100, 110, 144, 156, 196, 200
3. **Use backward propagation** to improve N=1-199
4. **Validate with Shapely** - NO overlaps allowed
5. **Compare with baseline** - only keep improvements
6. **Create submission** with best per-N configurations

## Validation Requirements

1. **Use Shapely for overlap detection** - the C++ hasOvl() function is unreliable
2. **Check all pairs of trees** for intersections (not just touches)
3. **Verify intersection area > 1e-10** to avoid floating-point issues

## What NOT to Try

- ❌ More SA iterations on the baseline (already at local optimum)
- ❌ Different SA parameters (won't escape local optimum)
- ❌ Ensemble of existing CSVs (all produce same score)
- ❌ C++ optimizer without Shapely validation

## SUBMISSION STRATEGY

**SUBMIT AFTER THIS EXPERIMENT!**
- We have 90 submissions remaining (ABUNDANT!)
- LB feedback is FREE information
- Even if the lattice approach doesn't beat baseline, we learn what works
- Submit to verify CV-LB correlation

## Technical Notes

### Tree Geometry (15 vertices):
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

### Score Calculation:
```python
score = sum(side_length[n]**2 / n for n in range(1, 201))
```

### Submission Format:
```csv
id,x,y,deg
001_0,s0.0,s0.0,s45.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```

## Available Resources

- **Baseline**: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/santa-2025.csv`
- **egortrushin kernel**: `/home/code/research/kernels/egortrushin_santa25-simulated-annealing-with-translations/`
- **crodoc backpacking kernel**: `/home/code/research/kernels/crodoc_74-75-backpacking-christmas-trees/`

## Success Criteria

- Generate a submission with score < 70.676102 (any improvement)
- Target: < 68.919154 (beat the target)
- Validate with Shapely before claiming any improvements