# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
Pack N Christmas trees (N=1 to 200) into the smallest possible square bounding box.
- Score = Σ(s²/n) for n=1 to 200, where s is the side length of the bounding square
- Lower score is better
- Trees are 15-vertex polygons that can be rotated and translated
- No overlapping trees allowed

## Current Status
- **Best Score**: 70.676102 (from pre-optimized santa-2025.csv)
- **Target Score**: 68.919154
- **Gap**: 1.76 points (2.5%)

## CRITICAL INSIGHTS FROM PREVIOUS EXPERIMENTS

### What Has Been Tried (NO IMPROVEMENTS FOUND):
1. **Standard SA optimization** on pre-optimized submission - NO improvement
2. **Backward propagation** (removing trees from N to get N-1 configs) - NO improvement
3. **Ensemble of 30 CSV files** - santa-2025.csv dominates all N values
4. **Short optimization runs** (minutes) - NO improvement

### Why Standard Approaches Fail:
The pre-optimized santa-2025.csv is at a **very tight local optimum**. Running more iterations of the same optimizer will NOT close the 1.76 point gap. A fundamentally different approach is needed.

## RECOMMENDED APPROACHES (Priority Order)

### 1. **[HIGHEST PRIORITY]** Lattice/Grid-Based Approach for Large N (N >= 58)
**NOT YET TRIED - This is the key missing approach!**

The egortrushin kernel uses a fundamentally different approach:
- Start with 2 base trees in a specific configuration
- Translate them in x and y directions to create a grid pattern
- Use simulated annealing to optimize the base configuration
- For N = rows × cols, this creates crystalline/lattice packings

**Implementation:**
```python
# For large N, try grid-based placement
# nt = [nx, ny] where nx * ny >= N
# Optimize: base tree positions, translation vectors, rotation angles
# This generates tighter packings than random optimization
```

Key N values for lattice: 72, 100, 110, 144, 156, 196, 200

### 2. **[HIGH PRIORITY]** Asymmetric Solutions
**Discussion insight**: Asymmetric solutions outperform symmetric ones!
- New N=22 asymmetric config achieves <0.36 normalized area
- Break the usual symmetric grid patterns
- Try handcrafted asymmetric layouts for specific N values

### 3. **[HIGH PRIORITY]** Focus on Small N Values (1-10)
These have the **highest score contribution per tree**:
- N=1: side=0.813, contributes 0.66 to total score (HIGHEST!)
- N=2: side=0.950, contributes 0.45 to score
- Small N values have lowest packing efficiency (1.5-2.6 trees/unit area)

**For N=1**: The optimal angle is 45 degrees (minimizes bounding box of single tree)
**For N=2-10**: Try exhaustive search over rotation angles (0.001 degree increments)

### 4. **[MEDIUM PRIORITY]** Much Longer Optimization Runs (Hours, Not Minutes)
Top solutions run bbox3 optimizer for HOURS with:
- `-n 15000+` iterations (vs. short runs tried)
- `-r 80+` rounds
- Multiple generations with perturbation to escape local optima

### 5. **[MEDIUM PRIORITY]** Different Starting Configurations
Instead of optimizing the pre-optimized submission:
- Generate new random configurations
- Use lattice-based initial placement
- Try different angle distributions

## Technical Details

### Tree Geometry (15 vertices):
```cpp
const double TX[15] = {0,0.125,0.0625,0.2,0.1,0.35,0.075,0.075,-0.075,-0.075,-0.35,-0.1,-0.2,-0.0625,-0.125};
const double TY[15] = {0.8,0.5,0.5,0.25,0.25,0,0,-0.2,-0.2,0,0,0.25,0.25,0.5,0.5};
```
- Trunk: width 0.15, height 0.2
- Base tier: width 0.7
- Middle tier: width 0.4
- Top tier: width 0.25
- Tip at y=0.8

### bbox3 Optimizer (C++):
The main optimizer uses:
- Complex number vector coordination
- Fluid dynamics simulation
- Hinge pivot mechanics
- Density gradient flow
- Global boundary tension
- Simulated annealing with aggressive overlap repair

Key parameters: `-n` (iterations), `-r` (rounds)

### Submission Format:
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- Values prefixed with 's' to preserve precision
- Coordinates must be in range [-100, 100]

## Available Pre-optimized Files
Located in `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`:
- `santa-2025.csv` - Best current solution (score 70.676102)
- `bucket-of-chump/submission.csv` - Alternative solution
- `santa25-public/` - Multiple versions (v61-v76)
- `bbox3` - Compiled C++ optimizer

## Validation Requirements
1. No overlapping trees (Kaggle rejects overlapping submissions)
2. Use high-precision Decimal arithmetic to avoid floating-point errors
3. Validate with Shapely polygon intersection checks

## What NOT to Try
- ❌ Simple ensemble (santa-2025.csv dominates all N values)
- ❌ Short optimization runs on pre-optimized submission
- ❌ Backward propagation (already tried, no improvement)
- ❌ fix_direction post-processing (causes precision loss and overlaps)

## Experiment Strategy
1. **First**: Implement lattice-based approach for large N (N >= 58)
2. **Second**: Optimize small N values (1-10) with exhaustive angle search
3. **Third**: Try asymmetric configurations for specific N values
4. **Fourth**: Run very long optimization (hours) with different random seeds

## Score Breakdown by N Range
- N=1-10: ~3.5 points (highest per-tree contribution)
- N=11-50: ~15 points
- N=51-100: ~18 points
- N=101-150: ~16 points
- N=151-200: ~18 points

Focus improvements on N ranges with highest potential impact.
