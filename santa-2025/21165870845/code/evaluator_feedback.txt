# Evaluator Feedback - Experiment 004_cpp_optimizer

## What I Understood

The junior researcher implemented a C++ optimizer based on the jonathanchan kernel, combining Simulated Annealing (SA), local search, and fractional translation. The goal was to improve upon the baseline score of 70.676102 by optimizing tree placements, particularly for small N values (N=2-10) which have the highest per-tree score contribution. The experiment ran 21 optimization rounds over ~5 hours and reported a score improvement from 70.676102 to 69.653351 (1.02 points, 1.45% reduction).

## Technical Execution Assessment

**Validation**: ⚠️ **CRITICAL ISSUE DETECTED**

**Leakage Risk**: N/A - this is a pure optimization problem.

**Score Integrity**: ❌ **INVALID RESULTS**

I verified the submission candidate and found **SEVERE OVERLAPPING TREES** in exactly the N values that showed "improvements":
- N=2: Intersection area = 0.180 (73% of tree area!)
- N=3: OVERLAP DETECTED
- N=4: OVERLAP DETECTED
- N=5: OVERLAP DETECTED
- N=6: OVERLAP DETECTED
- N=7: OVERLAP DETECTED
- N=10: OVERLAP DETECTED

The baseline (candidate_000.csv) has NO overlaps for these N values, confirming the C++ optimizer introduced invalid configurations.

**Root Cause**: The `hasOvl()` function in optimizer.cpp only checks for edge-edge intersections (line segment crossings). It does NOT detect:
1. One polygon completely inside another
2. Overlapping polygons where edges don't cross

This is a classic bug in polygon intersection detection. The correct approach must also check if any vertex of one polygon is inside the other.

**Code Quality**: The C++ code is well-structured but has a fundamental bug in the overlap detection that invalidates all results.

Verdict: **UNRELIABLE** - The reported improvements are INVALID. If submitted to Kaggle, this would be rejected due to overlapping trees.

## Strategic Assessment

**Approach Fit**: The approach (SA + local search + fractional translation) is sound and matches what top kernels use. The implementation just has a critical bug.

**Effort Allocation**: 
- ✅ Good: Focused on small N values which have highest impact
- ✅ Good: Implemented multiple optimization techniques (SA, local search, fractional translation)
- ❌ Bad: Did not validate the output for overlaps before claiming success

**Assumptions**: 
- The assumption that the C++ overlap detection was correct was WRONG
- Always validate outputs with Shapely or similar robust geometry library

**Blind Spots**:
1. **No overlap validation**: The experiment should have validated the final submission with Shapely before claiming success
2. **Missing `fix_direction`**: Top kernels use rotation tightening (`fix_direction`) to further minimize bounding boxes
3. **Missing `repair_overlaps`**: Top kernels have overlap repair mechanisms

**Trajectory**: The approach direction is correct, but the implementation needs fixing. Once the overlap detection bug is fixed, this approach could yield real improvements.

## What's Working

1. **C++ optimizer structure**: The overall architecture (SA + local search + fractional translation) is correct
2. **Focus on small N**: Correctly identified that N=2-10 have highest improvement potential
3. **Multiple optimization rounds**: Running 21 rounds with different seeds is good practice
4. **Iterative improvement**: The approach of saving intermediate results (optimized1.csv, optimized2.csv, etc.) is good

## Key Concerns

### 1. CRITICAL: Buggy Overlap Detection (MUST FIX)
- **Observation**: The `hasOvl()` function only checks edge-edge intersections, missing polygon containment and non-crossing overlaps
- **Why it matters**: ALL reported improvements are invalid. Kaggle will reject the submission.
- **Suggestion**: Either:
  a) Fix the C++ overlap detection to include point-in-polygon checks, OR
  b) Use Shapely for overlap validation after C++ optimization, OR
  c) Use the existing bbox3 optimizer which has correct overlap detection

### 2. Missing Post-Processing Steps
- **Observation**: Top kernels use `fix_direction` (rotation tightening) and `repair_overlaps` after optimization
- **Why it matters**: These can provide additional score improvements and ensure validity
- **Suggestion**: Add Shapely-based validation and rotation tightening as post-processing

### 3. No Submission Made
- **Observation**: Despite claiming a 1.02 point improvement, no submission was made to verify on LB
- **Why it matters**: Would have caught the overlap issue immediately (Kaggle rejects overlapping submissions)
- **Suggestion**: Always submit to verify results, especially when seeing large improvements

## Top Priority for Next Experiment

**FIX THE OVERLAP DETECTION BUG AND RE-RUN**

The approach is sound but the implementation is broken. Here are the options in order of preference:

### Option 1: Use the existing bbox3 optimizer (FASTEST)
The bbox3 binary at `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/bbox3` has correct overlap detection. Use it instead of the custom C++ optimizer:
```bash
./bbox3 -i baseline.csv -o output.csv -n 15000 -r 80
```

### Option 2: Add Shapely validation as post-processing
After C++ optimization, validate with Shapely and revert any N values with overlaps to baseline:
```python
from shapely.geometry import Polygon
from shapely import affinity

def validate_and_repair(optimized_csv, baseline_csv):
    # For each N, check for overlaps
    # If overlaps found, use baseline configuration for that N
    pass
```

### Option 3: Fix the C++ overlap detection
Add point-in-polygon check to `hasOvl()`:
```cpp
// After edge-edge check, add:
// Check if any vertex of polygon i is inside polygon j (or vice versa)
for (int v = 0; v < NV; v++) {
    if (pointInPolygon(px[i][v], py[i][v], j)) return true;
    if (pointInPolygon(px[j][v], py[j][v], i)) return true;
}
```

**The gap to target is still 1.76 points (from baseline 70.676102 to target 68.919154).** The current "improvement" to 69.653351 is INVALID due to overlaps. We need to start fresh with correct overlap detection.

**Immediate actions:**
1. Revert to baseline (candidate_000.csv) as the current best valid submission
2. Use bbox3 or fix the overlap detection
3. Re-run optimization with correct overlap handling
4. Validate output with Shapely before claiming success
5. Submit to Kaggle to verify

The target IS achievable - we just need correct implementation.
