## Current Status
- Best CV score: 70.315653 from exp_028 (deep_data_mining)
- Best LB score: 70.3157 (EXACTLY matches CV - deterministic problem)
- Target: 68.873342 | Gap to target: 1.44 points (2.09%)

## Submission Log
| Exp | Approach | CV | LB | Notes |
|-----|----------|----|----|-------|
| 001 | valid_baseline | 70.615 | 70.615 | Starting point |
| 010 | safe_ensemble | 70.365 | 70.365 | Major gain from ensemble |
| 016 | mega_ensemble | 70.354 | 70.354 | External data helped |
| 019 | comprehensive | 70.343 | 70.343 | More external sources |
| 022 | extended_cpp | 70.316 | 70.316 | SA hit ceiling |
| 028 | deep_mining | 70.316 | 70.316 | Found 1 improvement |

## Response to Evaluator

The evaluator correctly identified the KEY INSIGHT: **2,542 potential improvements were REJECTED due to overlaps**. This is a goldmine that hasn't been exploited!

The evaluator recommends:
1. Extended bbox3 runs (3-6 hours)
2. Investigate the 2,542 rejected improvements

I AGREE with the evaluator's analysis. The current approach (data mining, short optimization runs) has hit its ceiling. The path forward is:

1. **OVERLAP REPAIR** - The 2,542 rejected improvements are CLOSE to valid. Small perturbations might fix them.
2. **Extended bbox3** - Top competitors run for hours, not minutes.

## ⛔ FORBIDDEN (WILL BE REJECTED)
- Running bbox3/sa_fast with "more iterations" without a NEW strategy
- More data mining without overlap repair
- Any approach that gave < 0.01 improvement in the last 5 experiments

## ✅ NEXT EXPERIMENT: OVERLAP REPAIR STRATEGY

### The Problem
exp_028 found 2,542 configurations that WOULD improve the score but were rejected due to overlaps. These are CLOSE to valid solutions!

### The Solution
Implement an OVERLAP REPAIR algorithm:

```python
def repair_overlapping_solution(xs, ys, angles, n):
    """
    Try to fix overlapping trees by small perturbations.
    Returns repaired solution if successful, None otherwise.
    """
    MAX_REPAIR_ATTEMPTS = 100
    PERTURBATION_SIZE = 0.001
    
    for attempt in range(MAX_REPAIR_ATTEMPTS):
        # Find overlapping pairs
        overlaps = find_overlapping_pairs(xs, ys, angles)
        if not overlaps:
            return xs, ys, angles  # Fixed!
        
        # For each overlapping pair, push them apart
        for i, j in overlaps:
            # Calculate push direction (away from each other)
            dx = xs[j] - xs[i]
            dy = ys[j] - ys[i]
            dist = math.sqrt(dx*dx + dy*dy)
            if dist > 0:
                # Push both trees apart
                xs[i] -= PERTURBATION_SIZE * dx / dist
                ys[i] -= PERTURBATION_SIZE * dy / dist
                xs[j] += PERTURBATION_SIZE * dx / dist
                ys[j] += PERTURBATION_SIZE * dy / dist
    
    return None  # Could not repair

# Main loop
for each rejected_improvement in rejected_improvements:
    repaired = repair_overlapping_solution(...)
    if repaired:
        new_score = compute_score(repaired)
        if new_score < best_per_n[n]['score']:
            best_per_n[n] = repaired  # Keep it!
```

### Expected Outcome
- If even 10% of the 2,542 rejected improvements can be repaired, that's 254 improvements!
- Each improvement contributes to the total score
- This is the ONLY unexploited source of improvements

### Implementation Steps
1. Re-run the deep scan but SAVE rejected improvements instead of discarding
2. For each rejected improvement, try the repair algorithm
3. Validate repaired solutions with strict overlap checking
4. Keep only improvements that pass validation

## Alternative: Extended bbox3 Runs (if repair fails)

If overlap repair doesn't work, try extended bbox3 optimization:

```bash
# Phase A: Short runs to find promising (n, r) combinations
for n in 1000 2000 3000; do
    for r in 30 60 90; do
        timeout 120 ./bbox3 -n $n -r $r
    done
done

# Phase B: Medium runs on top candidates
timeout 600 ./bbox3 -n 2000 -r 60

# Phase C: Long runs on best candidates
timeout 1800 ./bbox3 -n 2000 -r 60
```

Run for 3-6 hours total, not 10-30 minutes.

## Per-N Tracking (MANDATORY)

After each experiment:
1. Compare per-N scores to baseline
2. For any N where you improved, save that solution
3. Update best_per_n.json with improvements
4. Even if total score is worse, individual N improvements are valuable

## Success Criteria
- ✅ SUCCESS: Score improved by > 0.01 from previous best
- ⚠️ MARGINAL: Score improved by 0.001 - 0.01
- ❌ FAILURE: Score same or worse

## SUBMIT AFTER EVERY EXPERIMENT
We have 94 submissions remaining. LB feedback is FREE information - USE IT!