{
  "query": "How do top teams break through local optima in polygon packing optimization competitions?",
  "results": [
    {
      "title": "ANSWER",
      "text": "Top teams in polygon packing optimization competitions address the challenge of breaking through local optima by employing a combination of heuristic strategies, local search techniques, and initial solution generation methods. According to recent research and competition reports, effective approaches include partitioning the problem into smaller subproblems, using greedy algorithms to obtain good initial solutions, and then applying local search to improve these solutions ([Result 1](https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.86/LIPIcs.SoCG.2024.86.pdf), [Result 2](https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.84/LIPIcs.SoCG.2024.84.pdf)). \n\nAdditionally, some teams utilize advanced metaheuristics such as simulated annealing with specialized cooling schedules, L\u00e9vy flights, or hybrid algorithms that combine multiple techniques to enhance exploration and avoid premature convergence ([Result 7](https://openreview.net/pdf?id=3O31o6AKpG)). These methods help escape local optima by enabling the search process to explore diverse regions of the solution space, often through perturbations or probabilistic acceptance criteria.\n\nIn summary, successful strategies involve starting with high-quality initial solutions via greedy or integer programming methods, then applying local search and stochastic perturbations to navigate out of local optima and find better packings ([Result 2](https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.84/LIPIcs.SoCG.2024.84.pdf), [Result 7](https://openreview.net/pdf?id=3O31o6AKpG)).",
      "url": ""
    },
    {
      "title": "A General Heuristic Approach for Maximum Polygon Packing",
      "text": "A General Heuristic Approach for Maximum\nPolygon Packing\nCanhui Luo #\nHuazhong University of Science and Technology, Wuhan, China\nZhouxing Su1 #\nHuazhong University of Science and Technology, Wuhan, China\nZhipeng L\u00fc #\nHuazhong University of Science and Technology, Wuhan, China\nAbstract\nThis work proposes a general heuristic packing approach to address the Maximum Polygon Packing\nProblem introduced by the CG:SHOP 2024 Challenge. Our solver primarily consists of two steps:\n(1) Partitioning the container and polygons to form a series of small-scale subproblems; (2) For each\nsubproblem, sequentially placing polygons into the container and attempting to eliminate overlaps.\n2012 ACM Subject Classification Theory of computation \u2192 Computational geometry; Computing\nmethodologies \u2192 Search methodologies\nKeywords and phrases packing, polygon, heuristic, differential evolution, local search, tabu search\nDigital Object Identifier 10.4230/LIPIcs.SoCG.2024.86\nCategory CG Challenge\nFunding This work was supported in part by the National Natural Science Foundation of China\n(NSFC) under Grant 72101094 and the Special Project for Knowledge Innovation of Hubei Province\nunder Grant 2022013301015175.\nAcknowledgements We want to thank the organizers of CG:SHOP 2024 and all other participants\nfor creating such an engaging challenge. We also want to thank Dominik Krupke for providing a\nhelpful official validator for solutions.\n1 Introduction\nThe recent CG:SHOP 2024 Challenge introduced a variant of irregular packing problems\nknown as the Maximum Polygon Packing (MPP) problem. The MPP problem involves a\nconvex polygonal container C and a polygon set P = {p1, p2, ..., pN }, where polygon piis\nassociated with a value vi. It seeks for a non-overlapping packing with the maximum total\nvalue. The challenge presents a total of 180 instances whose number of polygons ranges from\n28 to 50,000. The official document [4] gives a detailed description of the challenge.\nOur proposed algorithm employs a general process to solve these instances indiscriminately,\nand the overall framework is presented in Figure 1. We first partition a large-scale problem\ninto multiple small-scale subproblems (Section 2) and then solve each subproblem using\nupper-level polygon ordering (Section 3.1) and lower-level packing optimization techniques\n(Section 3.2). Section 4 presents our experimental results, followed by conclusions.\n1 Corresponding author: Zhouxing Su\n\u00a9 Canhui Luo, Zhouxing Su, and Zhipeng L\u00fc;\nlicensed under Creative Commons License CC-BY 4.0\n40th International Symposium on Computational Geometry (SoCG 2024).\nEditors: Wolfgang Mulzer and Jeff M. Phillips; Article No. 86; pp. 86:1\u201386:9\nLeibniz International Proceedings in Informatics\nSchloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik, Dagstuhl Publishing, Germany\n86:2 A General Heuristic Approach for Maximum Polygon Packing\nInput polygon set P and container C\nUpper-level polygon ordering\nLower-level packing optimization\nFinished?\n \nPacking\nAssemble and return the complete solution\nMPP1 MPP2 MPPm\n( ) 0? Overlap Scurr== ( ) Update Sbest best\nReturn S\nPartitioning\nYes\nNo\nYes\nNo\nSelect next one\nFigure 1 The framework of our proposed algorithm.\n2 Partitioning\nIn this section, we present the decomposition of the original large-scale problem into a series\nof smaller MPP subproblems. It involves two components: partitioning the container C into\nmultiple regions and assigning polygons to each region.\n2.1 Container Partitioning\nThe container partitioning process consists of two steps, as shown in Figure 2. Initially, we\narrange two-dimensional square grids starting from the bottom-left corner of the bounding\nbox until the entire container is covered. The subregions formed by the intersection of the\ncontainer with all the grids constitute its partition C = C1 \u222a C2 \u222a ... \u222a Cm. Subsequently,\nwe merge the small subregions with adjacent grids, which are difficult to be used effectively.\nThe grid is dimensioned to keep the scale of each subproblem at approximately 300 polygons,\nmaking a trade-off between effectiveness and efficiency of lower-level packing optimization.\n2.2 Polygon Assignment\nWe adopt a simple approach of randomly assigning polygons to each subregion. Specifically, for\neach subregion Ci, we randomly select a polygon pj from P until\nP\nj\narea(pj )\narea(Ci) \u2265\nPN\ni=0\narea(pi)\narea(C)\n.\nThe advantage of random assignment lies in ensuring that the overall characteristics of each\nsubproblem align with the original problem.\nC. Luo, Z. Su, and Z. L\u00fc 86:3\nFigure 2 The partitioning process for the instance jigsaw_cf1_4fd4c46e. Step 1 (left): Cover the\ncontainer with squares; Step 2: Intersect and merge small regions (from the middle to the right).\nminimum translation\nminimum translation\nIFP\nContainer\nFigure 3 Examples of NFP between two polygons and IFP between container and polygon.\n3 Packing\n3.1 Upper-Level Polygon Ordering\nWe define a priority for each polygon. We repeatedly select one remaining polygon with the\nhighest priority (ties are broken by value) and try to insert it into the current solution. If the\ninsertion with lower-level packing optimization fails, we skip the current polygon and turn to\nthe next one. For the majority of instances, the priority is defined as the value-to-area ratio\nof a polygon (we also call it unit value). Polygons with higher unit values are prioritized\nfor putting in the container, which is called the Unit Value First (UVF) strategy. For\nsmall-scale instances (N < 100), we employ the \u03b1\u03b2-random strategy. It randomly selects\n\u03b1% and \u03b2% of the polygons and reassigns their UVF-based priority to the highest and the\nlowest, respectively. These instances are run for multiple times to ensure comprehensive\noptimization, with \u03b1 and \u03b2 set to 10 in our implementation.\n3.2 Lower-Level Packing Optimization\nThe position of a polygon can be represented by the coordinates l = (x, y) of a reference point,\nsuch as the bottom-left corner of the boundary. Then, the translation of a polygon can be\nrepresented by a vector pointing from its original position to its new position. Given a feasible\npacking S and a polygon p to be placed, it is impossible to find a non-overlapping position\nfor p without moving other polygons in most cases. This section introduces the algorithm for\neliminating overlaps for an invalid packing, which involves solving an unconstrained nonlinear\nproblem and heuristic polygon movement.\nS o C G 2 0 2 4\n86:4 A General Heuristic Approach for Maximum Polygon Packing\n3.2.1 Overlap Minimization\nTo determine the appropriate translation for the polygons, we utilized the no-fit polygon\n(NFP) and inner-fit polygon (IFP), which are fundamental in algorithmic approaches to\ngeometric design and optimization challenges. For a fixed polygon pi and a movable polygon\npj , NFP(pi, pj ) describes their non-overlapping positions with boundaries in contact precisely,\nwhich can be utilized to determine the minimum translation for pj to avoid overlap. Similarly,\nIFP(pi, pj ) is employed to determine the minimum translation to place pj inside pi. Figure 3\nillustrates the polygon translations determined using NFP (left) and IFP (right). The readers\nmay refer to Burke et al. [2] for a more detailed description.\nFor a packing S, based on NFP and IFP, we define the overlap between polygons pi\nand pj as fij (S), representing the minimum translation to separate them, and f0i(S) as the\nminimum translation for moving pi to fit into the container. Subsequently, we employ the\nseparation algorithm proposed by Imamichi et al. [7] to minimize the overlap, which involves\nsolving an unconstrained nonlinear programming problem as follows:\nmin\nS\nF(S) = X\n0\u2264i<j\u2264N\nf\n2\nij (S) (1)\nThe model relaxes the non-overlapping constraint but introduces repulsion forces between\nany two overlapped polygons. We use the classic L-BFGS (limited memory BFGS) method\nto solve this problem. It makes the packing S converge to a local optimum but strongly\ndepends on the initial layout. ...",
      "url": "https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.86/LIPIcs.SoCG.2024.86.pdf"
    },
    {
      "title": "",
      "text": "Shadoks Approach to Knapsack Polygonal Packing\nGuilherme D. da Fonseca #\nLIS, Aix-Marseille Universit\u00e9, France\nYan Gerard #\nLIMOS, University Clermont Auvergne, Aubi\u00e8re, France\nAbstract\nWe describe the heuristics used by the Shadoks team in the CG:SHOP 2024 Challenge. Each instance\nconsists of a convex polygon called container and a multiset of items, where each item is a simple\npolygon and has an associated value. The goal is to pack some of the items inside the container\nusing translations, in order to maximize the sum of their values. Our strategy consists of obtaining\ngood initial solutions and improving them with local search. To obtain the initial solutions we used\ninteger programming and a carefully designed greedy approach.\n2012 ACM Subject Classification Theory of computation \u2192 Computational geometry\nKeywords and phrases Packing, polygons, heuristics, integer programming, computational geometry\nDigital Object Identifier 10.4230/LIPIcs.SoCG.2024.84\nCategory CG Challenge\nRelated Version Full Version: https://arxiv.org/abs/2403.20123\nSupplementary Material\nSoftware (Source Code): https://github.com/gfonsecabr/shadoks-CGSHOP2024\narchived at swh:1:dir:96fb9ad50c0c1307c7aef78560655cfcfabb24a6\nFunding Work supported by the French ANR PRC grant ADDS (ANR-19-CE48-0005).\nAcknowledgements We would like to thank the Challenge organizers and other competitors for their\ntime, feedback, and making this whole event possible. We would like to thank H\u00e9l\u00e8ne Toussaint,\nRapha\u00ebl Amato, Boris Lonjon, and William Guyot-L\u00e9nat from LIMOS, as well as the Qarma and\nTALEP teams and Manuel Bertrand from LIS, who continue to make the computational resources of\nthe LIMOS and LIS clusters available to our research. We would also like to thank Aldo Gonzalez\u0002Lorenzo and the undergraduate students Aymeric Beck, Houssam Boufarachan, Marine Izoulet, and\nCarla Scardigli for coding viewers for the solutions.\nFigure 1 Our best solutions to jigsaw_cf2_5db5d75a_34, random_rcf4_6e323d40_100,\natris1240, and satris1786 instances.\n\u00a9 Guilherme D. da Fonseca and Yan Gerard;\nlicensed under Creative Commons License CC-BY 4.0\n40th International Symposium on Computational Geometry (SoCG 2024).\nEditors: Wolfgang Mulzer and Jeff M. Phillips; Article No. 84; pp. 84:1\u201384:9\nLeibniz International Proceedings in Informatics\nSchloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik, Dagstuhl Publishing, Germany\n84:2 Shadoks Approach to Knapsack Polygonal Packing\n1 Introduction\nCG:SHOP Challenge is an annual geometric optimization challenge. The sixth edition in\n2024 considers a 2-dimensional knapsack packing problem. The team Shadoks won first place\nwith the best solution (among the 14 participating teams) to 75 instances out of 180. In this\npaper, we describe the heuristics we used. We start by briefly describing the problem.\nAn input instance consists of a convex polygon called container and a multiset of items.\nEach item is a simple polygon with an associated integer value. The goal is to pack some of\nthe instance items inside the container using integer translations in order to maximize the\nsum of their values. In total, 180 instances have been given, ranging from 28 to 50,000 items.\nThe instances are of several different types according to the shape and values of the items.\nSome instances have mostly convex items, while other instances have many non-convex items\nsuch as polyominoes. In terms of item values, some items have only unit value, some have\nvalues proportional to the area, and other have random values, for example. Some solutions\nare presented in Figure 1 and more details about the challenge are available in the organizers\u2019\nsurvey paper [3].\nOur general strategy consists of finding a good initial solution (using integer programming\nor a greedy heuristic) and subsequently optimizing them with local search. Our strategy\nshares many common elements with the second place [5], but they did not use integer\nprogramming to obtain initial solutions and their optimization phase is more sophisticated\nthan ours. The third place [4] uses an hierarchical grid approach. The fourth place [1] used\na completely different integer programming model and a genetic algorithm.\nWe describe the algorithms in Section 2 and experimentally analyze their performance\nusing different parameters in Section 3. Our solvers were coded in Python and C++ and\nexecuted on several desktop laptop computers, as well as the LIMOS and LIS clusters.\n2 Algorithms\nWe used two different algorithms to compute initial solutions, a preprocessing phase that\ncan be executed beforehand, and a local search phase to improve the solutions.\n2.1 Integer Programming Approach\nA simple idea to solve the challenge problem is to produce a set V of random translations of\neach item inside the container and then reduce the problem to a kind of maximum weight\nindependent set problem in a graph G = (V, E). Each translated item is a vertex and there\nare two types of edges: (1) an edge between two translations that overlap and (2) translations\nof the same item i form a clique Ci. If all item have quantity one, then this is a traditional\nmaximum weight independent set problem. However, if items have non-unit quantities, then\neach clique Ciis associated with the quantity qi of item i and at most qi vertices of the\nclique are allowed in the solution.\nThis combinatorial problem can easily be modeled as integer programming with one\nbinary variable per vertex. A type-1 edge uv is modeled as u + v \u2264 1 and each clique Ci\nis modeled as P\nv\u2208Ci\nv \u2264 qi. The CPLEX solver [2] can optimally solve graphs with a few\nthousand vertices obtained from the challenge instances, which is not enough to obtain good\nsolutions using uniformly random placements.\nTo obtain better solutions, we start from a solutions S obtained with the aforementioned\nmethod and build a new graph G = (V, E) as follows. Let \u03c3 > 0 be a parameter and N be a\nset of the zero vector and random vectors where each random vector has x and y coordinates\nG. D. da Fonseca and Y. Gerard 84:3\nas Gaussian random variables of average 0 and standard deviation \u03c3. We create a translation\nin V for each item that is placed in S and for each translation vector in N if the translation\nis inside the container. We also create vertices in V using uniform random translations for\nall items. Edges and cliques are created as before, and the new combinatorial problem is\nsolved with CPLEX. We repeat this procedure multiple times using the previous solution S\nand reducing the value of \u03c3 at each step.\nThis method works well for instances with up to 200 items. To handle larger instances,\nwe partition the container using a square grid and partition the items equally among the\ncells. The partition is such that items are grouped by the slope of the longest edge, breaking\nties by the slope of the diameter. Each cell is then solved independently. The intuition to\ngroup items of similar slope together is that they can often be placed in a way that minimizes\nthe wasted space. Since the values of the items do not seem to be related to the slopes, this\napproach works well for the challenge instances.\n2.2 Greedy Heuristic\nThe greedy heuristic starts by creating an initial list L of n grid points inside the container\n(typically n = 1000). The list L is shuffled and we compute its centroid c rounded to integer\ncoordinates. The point c is inserted in the beginning of L. The input items are placed into a\nlist I ordered by decreasing utility, where the utility function is described next. Different\nutility functions may be used (more details in Section 3). The goal is that items of small\narea and high value have high utility while large items with small value have low utility.\nWe then build the packing by considering the items of the list I one by one in order. At\neach step, we have a current packing and a new item i to pack. We first try to pack i at\nthe first grid position g \u2208 L and at a number of random positions around g. If one of these\npositions is availa...",
      "url": "https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.84/LIPIcs.SoCG.2024.84.pdf"
    },
    {
      "title": "",
      "text": "Hybrid Simulated Annealing with Cosine Cooling and\nL\u00e9vy Flights for Circle Packing\nAnonymous Author(s)\nAffiliation\nAddress\nemail\nAbstract\n1 The circle packing problem\u2014arranging non-overlapping circles within a bounded\n2 domain to maximize a chosen metric\u2014arises in computational geometry, material\n3 science, and visual design. In the specific case of maximizing the sum of radii in\n4 a unit square, existing methods such as greedy placement, grid-based heuristics,\n5 gradient optimization, and particle swarm optimization often suffer from premature\n6 convergence, poor scalability, or suboptimal exploration of the solution space. We\n7 present a novel hybrid algorithm that combines latin hypercube sampling with a\n8 modified simulated annealing procedure incorporating cosine-annealing tempera\u00029 ture decay, occasional L\u00e9vy-flight-inspired perturbations to escape local optima,\n10 and a dynamically shrinking local search radius. This design strategically balances\n11 exploration and exploitation while maintaining feasibility through geometric and\n12 boundary constraints. Our algorithm generates a new world record score of\n2.6359372 on 26 circles 113 , exceeding the best-known hand-crafted algorithms and\n14 recent Google AlphaEvolve solution (2.634 and 2.6358627, respectively). The\n15 algorithm\u2019s modular design allows easy integration of spatial partitioning to ac\u000216 celerate neighbor checks. The algorithm has potential applications in geometric\n17 layout optimization, materials engineering, and automated packing-pattern design.\n18 The source code is publicly available at: https://anonymous.4open.science/r/AI\u000219 AlgorithmResearcher-161C.\n20 1 Introduction\n21 The circle packing problem, a canonical challenge in computational geometry and discrete optimiza\u000222 tion, concerns the arrangement of disjoint circles within a bounded domain subject to non-overlap\n23 constraints, with the aim of optimizing a given objective function. This problem intersects with\n24 multiple disciplines, including material science, industrial manufacturing, and graphic design, where\n25 efficient spatial arrangements are paramount [1\u20133]. In particular, the variant considered here in\u000226 volves positioning a fixed number of non-overlapping circles inside a unit square to maximize the\n27 sum of their radii. This objective emphasizes maximizing the total usable material space or visual\n28 prominence, rather than the more commonly studied problem of maximizing the uniform radius in\n29 congruent circle packing.\n30 The significance of this problem extends to several practical domains. In materials engineering,\n31 optimal packing configurations can minimize waste when cutting circular components from square\n32 sheets. In visual design, deliberate packing arrangements influence balance and aesthetic perception,\n33 while in manufacturing, space-efficient layouts contribute to reduced costs and improved machining\n34 efficiency [4, 5]. Beyond engineering, circle packing techniques underpin layout generation in printed\n1Both the record-breaking algorithm and this manuscript are automatically generated by AI Agent Systems.\nThe source code is publicly available at: https://anonymous.4open.science/r/AI-AlgorithmResearcher-161C.\nSubmitted to 1st Open Conference on AI Agents for Science (agents4science 2025). Do not distribute.\n0 5000 10000150002000025000300003500040000\nIterations\n2.1\n2.2\n2.3\n2.4\n2.5\n2.6\nScore\nConvergence Curve: Score vs. Iterations\nGrid: 2.39815401\nGradient: 2.13538824\nPSO: 2.04966947\nBest-known (until April 2025): 2.634\nOurs (1000 iter): 2.427008\nOurs (10000 iter): 2.501017\nOurs (40000 iter): 2.635937\nOur Algorithm\n3900039250395003975040000\n2.634\n2.636\n0.0 0.2 0.4 0.6 0.8 1.0\n0.0\n0.2\n0.4\n0.6\n0.8\n1.0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nFinal Circle Packing Solution (Score: 2.635937)\nFigure 1: Performance Comparison of Circle Packing Algorithms. (Left) Convergence curve showing\nour algorithm surpassing previous state-of-the-art after 40,000 iterations. (Right) Optimal solution of\n26 circles in a unit square achieving a record score of 2.635937.\n35 circuit boards, UAV deployment for area coverage [6], and even data visualization in computational\n36 art.\n37 Despite its simplicity in formulation, the circle packing problem is NP-hard [1], with a highly\n38 nonconvex search space riddled with local optima [2]. Classical greedy placement and incremental\n39 addition approaches often suffer from severe sensitivity to initialization, limiting their ability to find\n40 global optima. Grid-based heuristics, while computationally fast, impose artificial discretization that\n41 prevents exploiting fine-grained adjustments in high-quality solutions [4]. Continuous optimization\n42 strategies, including gradient-based methods, require careful handling of geometric constraints and\n43 tend to stagnate when encountering flat objective landscapes [7]. Population-based metaheuristics\n44 such as genetic algorithms, particle swarm optimization, and simulated annealing have been applied\n45 in related contexts [1, 8] but may exhibit premature convergence and inefficient traversal of vast\n46 feasible spaces.\n47 Recent research on circle packing has pursued several methodological directions. Geometry-driven\n48 algorithms have produced efficient configurations in specific domains, such as arbitrary shapes [3]\n49 and regular polygons [9]. Discretization-based optimization has allowed mixed-integer programming\n50 formulations, though often at the cost of reduced flexibility [4]. Analytical approaches, including\n51 convexification and semidefinite relaxations [2], have clarified the theoretical limits of exact formula\u000252 tions but are generally impractical for large instances. Nature-inspired metaheuristics such as bat\n53 algorithms, firefly algorithms, and swarm intelligence [1] continue to improve practical outcomes\n54 for mid-scale problems but inherit issues of parameter sensitivity and slow convergence. Hybrid\n55 strategies have also been explored for related packing problems\u2014combining global search heuristics\n56 with local improvement [8, 10]\u2014yet often remain problem-specific or focused on congruent rather\n57 than unequal circles.\n58 These observations reveal a clear research gap: existing algorithms either emphasize computational\n59 speed at the expense of fine-grained optimization, or they achieve high-quality solutions without\n60 providing a principled balance between exploration and exploitation. Moreover, transparent, hybrid\n61 designs capable of exceeding state-of-the-art performance in unequal circle packing within a unit\n62 square remain underexplored\u2014particularly those that integrate statistically robust initialization,\n63 adaptive stochastic search, and occasional long-range perturbations.\n2\n64 In this paper, we address this gap with a novel Hybrid Simulated Annealing algorithm incorporating\n65 cosine temperature cooling, L\u00e9vy-flight-inspired jumps, and adaptive local search shrinkage. The\n66 contributions of this work are as follows:\n67 \u2022 Algorithmic Innovation: We propose a hybrid heuristic algorithm that couples well\u000268 distributed Latin Hypercube Sampling initialization with a cosine-annealed simulated an\u000269 nealing loop enhanced by L\u00e9vy flight perturbations and a dynamically shrinking local search\n70 radius for strategic balancing of exploration and exploitation.\n71 \u2022 Record-breaking Performance: As illustrated in Figure 1, our method surpasses both\nthe best-known human-designed packing score (2.634) 272 and the AlphaEvolve results\n73 (2.6358627) [11], achieving a new record of 2.6359372 on 26 circles.\n74 \u2022 Transparency and Extensibility: The approach maintains methodological clarity, facilitat\u000275 ing adaptations to related geometric optimization problems and enabling integration with\n76 acceleration techniques such as spatial partitioning.\n77 2 Problem Formulation\n78 2.1 Problem Description\n79 We consider a classical problem in computational geometry and geometric opti...",
      "url": "https://openreview.net/pdf?id=3O31o6AKpG"
    },
    {
      "title": "Priority-Driven Nesting of Irregular Polygonal Shapes Within a Convex Polygonal Container Based on a Hierarchical Integer Grid (CG Challenge)",
      "text": "Document\n\n`https://doi.org/10.4230/LIPIcs.SoCG.2024.85`\n\n- [Export XML](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SoCG.2024.85/metadata/xml)\n- [Export ACM-XML](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SoCG.2024.85/metadata/acm-xml)\n- [Export DOAJ-XML](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SoCG.2024.85/metadata/doaj-xml)\n- [Export Schema.org](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SoCG.2024.85/metadata/schema-org)\n- [Export BibTeX](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SoCG.2024.85/metadata/bibtex)\n\n# Priority-Driven Nesting of Irregular Polygonal Shapes Within a Convex Polygonal Container Based on a Hierarchical Integer Grid (CG Challenge)\n\n### Author [Martin Held](https://drops.dagstuhl.de/search/documents?author=Held, Martin)\n\n- Part of:Volume:\n[40th International Symposium on Computational Geometry (SoCG 2024)](https://drops.dagstuhl.de/entities/volume/LIPIcs-volume-293) Part of:Series:\n[Leibniz International Proceedings in Informatics (LIPIcs)](https://drops.dagstuhl.de/entities/series/LIPIcs) Part of:Conference:\n[Symposium on Computational Geometry (SoCG)](https://drops.dagstuhl.de/entities/conference/SoCG)\n- License: \u00a0 [Creative Commons Attribution 4.0 International license](https://creativecommons.org/licenses/by/4.0/legalcode)\n- Publication Date: 2024-06-06\n\n[PDF](https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.85/LIPIcs.SoCG.2024.85.pdf)\n\n## File\n\n[PDF\\\nLIPIcs.SoCG.2024.85.pdf](https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.85/LIPIcs.SoCG.2024.85.pdf)\n\n- Filesize: 0.59 MB\n- 6 pages\n\n## Document Identifiers\n\n- **DOI:** [10.4230/LIPIcs.SoCG.2024.85](https://doi.org/10.4230/LIPIcs.SoCG.2024.85)\n- **URN:** [urn:nbn:de:0030-drops-200306](https://nbn-resolving.org/urn:nbn:de:0030-drops-200306)\n\n## Subject Classification\n\n##### ACM Subject Classification\n\n- Theory of computation \u2192 Computational geometry\n\n##### Keywords\n\n- Computational Geometry\n- geometric optimization\n- nesting\n- packing\n- algorithm engineering\n\n## Metrics\n\n- [Access Statistics](https://drops.dagstuhl.de/drops.dagstuhl.de)\n- Total Accesses (updated on a weekly basis)\n\n\n\n\n0\n\n\n\nPDF Downloads\n\n\n\n\n\n\n\n0\n\n\n\nMetadata Views\n\n\n## Abstract\n\n```\nOur work on nesting polygons is based on two key components: (1) a hierarchy of uniform integer grids for maintaining free space within the container during the nesting such that placement queries can be answered reasonably efficiently, and (2) priority heuristics for choosing the order in which the polygons are tested for placement. We discuss our approach and shed a light on the results obtained.\n```\n\n## Cite As Get BibTex\n\nMartin Held. Priority-Driven Nesting of Irregular Polygonal Shapes Within a Convex Polygonal Container Based on a Hierarchical Integer Grid (CG Challenge). In 40th International Symposium on Computational Geometry (SoCG 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 293, pp. 85:1-85:6, Schloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik (2024)\n[https://doi.org/10.4230/LIPIcs.SoCG.2024.85](https://doi.org/10.4230/LIPIcs.SoCG.2024.85)\n\n## Author Details\n\n**Martin Held**\n\n- FB Informatik, Universit\u00e4t Salzburg, Austria\n\n## References\n\n1. Alkan Atak, Kevin Buchin, Mart Hagedoorn, Jona Heinrichs, Karsten Hogreve, Guangping Li, and Patrick Pawelczyk. Computing maximum polygonal packings in convex polygons using best-fit, genetic algorithms and ILPs. In Symposium on Computational Geometry (SoCG), volume 293 of LIPIcs, pages 83:1-83:9, 2024. URL: [https://doi.org/10.4230/LIPIcs.SoCG.2024.83](https://doi.org/10.4230/LIPIcs.SoCG.2024.83).\n2. Guilherme Dias da Fonseca and Yan Gerard. Shadoks approach to knapsack polygonal packing. In Symposium on Computational Geometry (SoCG), volume 293 of LIPIcs, pages 84:1-84:9, 2024. URL: [https://doi.org/10.4230/LIPIcs.SoCG.2024.84](https://doi.org/10.4230/LIPIcs.SoCG.2024.84).\n3. Canhui Luo, Zhouxing Su, and Zhipeng L\u00fc. A general heuristic approach for maximum polygon packing. In Symposium on Computational Geometry (SoCG), volume 293 of LIPIcs, pages 86:1-86:9, 2024. URL: [https://doi.org/10.4230/LIPIcs.SoCG.2024.86](https://doi.org/10.4230/LIPIcs.SoCG.2024.86).\n4. S\u00e1ndor P. Fekete, Phillip Keldenich, Dominik Krupke, and Stefan Schirra. Maximum polygon packing: The CG:SHOP Challenge 2024, 2024. URL: [https://arxiv.org/abs/2403.16203](https://arxiv.org/abs/2403.16203).\n\n[Any Issues?](https://drops.dagstuhl.de/drops.dagstuhl.de)\n\n[X](https://drops.dagstuhl.de/drops.dagstuhl.de)\n\nFeedback on the Current Page\n\nSend\n\nSubmit\n\n### Thanks for your feedback!\n\nFeedback submitted to Dagstuhl Publishing\n\nOK\n\n### Could not send message\n\nPlease try again later or send an [E-mail](mailto:publishing@dagstuhl.de)\n\nOK\n\n\u00a9 2023-2025 [Schloss Dagstuhl \u2013 LZI GmbH](https://www.dagstuhl.de) [About\u00a0DROPS](https://drops.dagstuhl.de/docs/about) [Imprint](https://drops.dagstuhl.de/docs/imprint) [Privacy](https://drops.dagstuhl.de/docs/privacy) [Contact](https://www.dagstuhl.de/en/publishing/team)",
      "url": "https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SoCG.2024.85"
    },
    {
      "title": "Greedy and Local Search Heuristics to Build Area-Optimal Polygons",
      "text": "# Computer Science > Computational Geometry\n\n**arXiv:2106.14728** (cs)\n\n\\[Submitted on 28 Jun 2021\\]\n\n# Title:Greedy and Local Search Heuristics to Build Area-Optimal Polygons\n\nAuthors: [Lo\u00efc Crombez](https://arxiv.org/search/cs?searchtype=author&query=Crombez,+L), [Guilherme D. da Fonseca](https://arxiv.org/search/cs?searchtype=author&query=da+Fonseca,+G+D), [Yan Gerard](https://arxiv.org/search/cs?searchtype=author&query=Gerard,+Y)\n\nView a PDF of the paper titled Greedy and Local Search Heuristics to Build Area-Optimal Polygons, by Lo\\\\\"ic Crombez and 2 other authors\n\n[View PDF](https://arxiv.org/pdf/2106.14728)\n\n> Abstract:In this paper, we present our heuristic solutions to the problems of finding the maximum and minimum area polygons with a given set of vertices. Our solutions are based mostly on two simple algorithmic paradigms: greedy method and local search. The greedy heuristic starts with a simple polygon and adds vertices one by one, according to a weight function. A crucial ingredient to obtain good solutions is the choice of an appropriate weight function that avoids long edges. The local search part consists of moving consecutive vertices to another location in the polygonal chain. We also discuss the different implementation techniques that are necessary to reduce the running time.\n\n|     |     |\n| --- | --- |\n| Comments: | Second place at CG:SHOP 2019 challenge |\n| Subjects: | Computational Geometry (cs.CG) |\n| Cite as: | [arXiv:2106.14728](https://arxiv.org/abs/2106.14728) \\[cs.CG\\] |\n|  | (or [arXiv:2106.14728v1](https://arxiv.org/abs/2106.14728v1) \\[cs.CG\\] for this version) |\n|  | [https://doi.org/10.48550/arXiv.2106.14728](https://doi.org/10.48550/arXiv.2106.14728)<br>Focus to learn more<br>arXiv-issued DOI via DataCite |\n| Journal\u00a0reference: | ACM Journal of Experimental Algorithmics, 27, 2.2, 1-11, 2022 |\n| Related DOI: | [https://doi.org/10.1145/3503999](https://doi.org/10.1145/3503999)<br>Focus to learn more<br>DOI(s) linking to related resources |\n\n## Submission history\n\nFrom: Guilherme D. da Fonseca \\[ [view email](https://arxiv.org/show-email/f7681dab/2106.14728)\\]\n\n**\\[v1\\]**\nMon, 28 Jun 2021 13:58:55 UTC (696 KB)\n\nFull-text links:\n\n## Access Paper:\n\nView a PDF of the paper titled Greedy and Local Search Heuristics to Build Area-Optimal Polygons, by Lo\\\\\"ic Crombez and 2 other authors\n\n- [View PDF](https://arxiv.org/pdf/2106.14728)\n- [TeX Source](https://arxiv.org/src/2106.14728)\n- [Other Formats](https://arxiv.org/format/2106.14728)\n\n[view license](http://arxiv.org/licenses/nonexclusive-distrib/1.0/)\n\nCurrent browse context:\n\ncs.CG\n\n[<\u00a0prev](https://arxiv.org/prevnext?id=2106.14728&function=prev&context=cs.CG)\u00a0 \\| \u00a0[next\u00a0>](https://arxiv.org/prevnext?id=2106.14728&function=next&context=cs.CG)\n\n[new](https://arxiv.org/list/cs.CG/new) \\| [recent](https://arxiv.org/list/cs.CG/recent) \\| [2021-06](https://arxiv.org/list/cs.CG/2021-06)\n\nChange to browse by:\n\n[cs](https://arxiv.org/abs/2106.14728?context=cs)\n\n### References & Citations\n\n- [NASA ADS](https://ui.adsabs.harvard.edu/abs/arXiv:2106.14728)\n- [Google Scholar](https://scholar.google.com/scholar_lookup?arxiv_id=2106.14728)\n- [Semantic Scholar](https://api.semanticscholar.org/arXiv:2106.14728)\n\n### [DBLP](https://dblp.uni-trier.de) \\- CS Bibliography\n\n[listing](https://dblp.uni-trier.de/db/journals/corr/corr2106.html#abs-2106-14728) \\| [bibtex](https://dblp.uni-trier.de/rec/bibtex/journals/corr/abs-2106-14728)\n\n[Lo\u00efc Crombez](https://dblp.uni-trier.de/search/author?author=Lo%C3%AFc%20Crombez)\n\n[Guilherme Dias da Fonseca](https://dblp.uni-trier.de/search/author?author=Guilherme%20Dias%20da%20Fonseca)\n\n[a](https://arxiv.org/static/browse/0.3.4/css/cite.css) export BibTeX citationLoading...\n\n## BibTeX formatted citation\n\n\u00d7\n\nData provided by:\n\n### Bookmark\n\n[![BibSonomy logo](https://arxiv.org/static/browse/0.3.4/images/icons/social/bibsonomy.png)](http://www.bibsonomy.org/BibtexHandler?requTask=upload&url=https://arxiv.org/abs/2106.14728&description=Greedy and Local Search Heuristics to Build Area-Optimal Polygons) [![Reddit logo](https://arxiv.org/static/browse/0.3.4/images/icons/social/reddit.png)](https://reddit.com/submit?url=https://arxiv.org/abs/2106.14728&title=Greedy and Local Search Heuristics to Build Area-Optimal Polygons)\n\nBibliographic Tools\n\n# Bibliographic and Citation Tools\n\nBibliographic Explorer Toggle\n\nBibliographic Explorer _( [What is the Explorer?](https://info.arxiv.org/labs/showcase.html#arxiv-bibliographic-explorer))_\n\nConnected Papers Toggle\n\nConnected Papers _( [What is Connected Papers?](https://www.connectedpapers.com/about))_\n\nLitmaps Toggle\n\nLitmaps _( [What is Litmaps?](https://www.litmaps.co/))_\n\nscite.ai Toggle\n\nscite Smart Citations _( [What are Smart Citations?](https://www.scite.ai/))_\n\nCode, Data, Media\n\n# Code, Data and Media Associated with this Article\n\nalphaXiv Toggle\n\nalphaXiv _( [What is alphaXiv?](https://alphaxiv.org/))_\n\nLinks to Code Toggle\n\nCatalyzeX Code Finder for Papers _( [What is CatalyzeX?](https://www.catalyzex.com))_\n\nDagsHub Toggle\n\nDagsHub _( [What is DagsHub?](https://dagshub.com/))_\n\nGotitPub Toggle\n\nGotit.pub _( [What is GotitPub?](http://gotit.pub/faq))_\n\nHuggingface Toggle\n\nHugging Face _( [What is Huggingface?](https://huggingface.co/huggingface))_\n\nLinks to Code Toggle\n\nPapers with Code _( [What is Papers with Code?](https://paperswithcode.com/))_\n\nScienceCast Toggle\n\nScienceCast _( [What is ScienceCast?](https://sciencecast.org/welcome))_\n\nDemos\n\n# Demos\n\nReplicate Toggle\n\nReplicate _( [What is Replicate?](https://replicate.com/docs/arxiv/about))_\n\nSpaces Toggle\n\nHugging Face Spaces _( [What is Spaces?](https://huggingface.co/docs/hub/spaces))_\n\nSpaces Toggle\n\nTXYZ.AI _( [What is TXYZ.AI?](https://txyz.ai))_\n\nRelated Papers\n\n# Recommenders and Search Tools\n\nLink to Influence Flower\n\nInfluence Flower _( [What are Influence Flowers?](https://influencemap.cmlab.dev/))_\n\nCore recommender toggle\n\nCORE Recommender _( [What is CORE?](https://core.ac.uk/services/recommender))_\n\n- Author\n- Venue\n- Institution\n- Topic\n\nAbout arXivLabs\n\n# arXivLabs: experimental projects with community collaborators\n\narXivLabs is a framework that allows collaborators to develop and share new arXiv features directly on our website.\n\nBoth individuals and organizations that work with arXivLabs have embraced and accepted our values of openness, community, excellence, and user data privacy. arXiv is committed to these values and only works with partners that adhere to them.\n\nHave an idea for a project that will add value for arXiv's community? [**Learn more about arXivLabs**](https://info.arxiv.org/labs/index.html).\n\n[Which authors of this paper are endorsers?](https://arxiv.org/auth/show-endorsers/2106.14728) \\|\n[Disable MathJax](javascript:setMathjaxCookie()) ( [What is MathJax?](https://info.arxiv.org/help/mathjax.html))",
      "url": "https://arxiv.org/abs/2106.14728"
    },
    {
      "title": "Maximum Polygon Packing:\n The CG:SHOP Challenge 2024",
      "text": "HTML conversions [sometimes display errors](https://info.dev.arxiv.org/about/accessibility_html_error_messages.html) due to content that did not convert correctly from the source. This paper uses the following packages that are not yet supported by the HTML conversion tool. Feedback on these issues are not necessary; they are known and are being worked on.\n\n- failed: nth\n- failed: complexity\n\nAuthors: achieve the best HTML results from your LaTeX submissions by following these [best practices](https://info.arxiv.org/help/submit_latex_best_practices.html).\n\nLicense: arXiv.org perpetual non-exclusive license\n\narXiv:2403.16203v1 \\[cs.CG\\] 24 Mar 2024\n\n\\\\hideLIPIcs\n\nDepartment of Computer Science, TU Braunschweig, Germanys.fekete@tu-bs.dehttps://orcid.org/0000-0002-9062-4241\nDepartment of Computer Science, TU Braunschweig, Germanyp.keldenich@tu-bs.dehttps://orcid.org/0000-0002-6677-5090\nDepartment of Computer Science, TU Braunschweig, Germanyd.krupke@tu-bs.dehttps://orcid.org/0000-0003-1573-3496\nDepartment for Simulation and Graphics, OvGU Magdeburg, Germanystschirr@isg.cs.uni-magdeburg.dehttps://orcid.org/0009-0006-5928-1494\n\\\\CopyrightS.\u00a0P.\u00a0Fekete, P.\u00a0Keldenich, D.\u00a0Krupke, S.\u00a0Schirra\n\\\\ccsdescTheory of computation \u2192\u2192\\\\rightarrow\u2192 Computational geometry\n\\\\ccsdescTheory of computation \u2192\u2192\\\\rightarrow\u2192 Design and analysis of algorithms\n\\\\supplement\\\\fundingWork at TU Braunschweig has been partially supported by the German Research Foundation (DFG),\nproject \u201cComputational Geometry: Solving Hard Optimization Problems\u201d (CG:SHOP), grant FE407/21-1.\n\n###### Acknowledgements.\n\nWe thank the members of the CG:SHOP Challenge Advisory Board for their valuable input:\nWilliam J.\u00a0Cook, Andreas Fabri, Dan Halperin, Michael Kerber, Philipp Kindermann, Joe Mitchell, Kevin Verbeek.\n\\\\EventAcronymCG:SHOP 2024\n\n# Maximum Polygon Packing: The CG:SHOP Challenge 2024\n\nS\u00e1ndor P.\u00a0Fekete\nPhillip Keldenich\nDominik Krupke\nStefan Schirra\n\n###### Abstract\n\nWe give an overview of the 2024 Computational Geometry Challenge\ntargeting the problem Maximum Polygon Packing:\nGiven a convex region P\ud835\udc43Pitalic\\_P in the plane, and a collection of simple polygons Q1,\u2026,Qnsubscript\ud835\udc441\u2026subscript\ud835\udc44\ud835\udc5bQ\\_{1},\\\\ldots,Q\\_{n}italic\\_Q start\\_POSTSUBSCRIPT 1 end\\_POSTSUBSCRIPT , \u2026 , italic\\_Q start\\_POSTSUBSCRIPT italic\\_n end\\_POSTSUBSCRIPT, each Qisubscript\ud835\udc44\ud835\udc56Q\\_{i}italic\\_Q start\\_POSTSUBSCRIPT italic\\_i end\\_POSTSUBSCRIPT\nwith a respective value cisubscript\ud835\udc50\ud835\udc56c\\_{i}italic\\_c start\\_POSTSUBSCRIPT italic\\_i end\\_POSTSUBSCRIPT,\nfind a subset S\u2286{1,\u2026,n}\ud835\udc461\u2026\ud835\udc5bS\\\\subseteq\\\\{1,\\\\ldots,n\\\\}italic\\_S \u2286 { 1 , \u2026 , italic\\_n }\nand a feasible packing within P\ud835\udc43Pitalic\\_P of the polygons Qisubscript\ud835\udc44\ud835\udc56Q\\_{i}italic\\_Q start\\_POSTSUBSCRIPT italic\\_i end\\_POSTSUBSCRIPT (without rotation) for i\u2208S\ud835\udc56\ud835\udc46i\\\\in Sitalic\\_i \u2208 italic\\_S,\nmaximizing \u2211i\u2208Scisubscript\ud835\udc56\ud835\udc46subscript\ud835\udc50\ud835\udc56\\\\sum\\_{i\\\\in S}c\\_{i}\u2211 start\\_POSTSUBSCRIPT italic\\_i \u2208 italic\\_S end\\_POSTSUBSCRIPT italic\\_c start\\_POSTSUBSCRIPT italic\\_i end\\_POSTSUBSCRIPT.\nGeometric packing problems, such as this, present significant computational challenges and are of substantial practical importance.\n\n###### keywords:\n\nComputational Geometry, geometric optimization, packing, Algorithm Engineering, contest\n\n## 1 Introduction\n\nThe \u201cCG:SHOP Challenge\u201d (Computational Geometry: Solving Hard\nOptimization Problems) originated as a workshop at the 2019\nComputational Geometry Week (CG Week) in Portland, Oregon in June,\n2019\\. The goal was to conduct a computational challenge competition\nthat focused attention on a specific hard geometric optimization\nproblem, encouraging researchers to devise and implement solution\nmethods that could be compared scientifically based on how well they\nperformed on a database of carefully selected and varied instances.\nWhile much of computational\ngeometry research is theoretical, often seeking provable approximation\nalgorithms for \\\\NP-hard optimization problems,\nthe goal of the Challenge was to set the metric of success based on\ncomputational results on a specific set of benchmark geometric\ninstances. The 2019 Challenge\u00a0\\[ [26](https://arxiv.org/html/2403.16203v1#bib.bib26)\\] focused on the problem of computing\nsimple polygons of minimum and maximum area for given sets of vertices in the\nplane. It generated a strong response from many research\ngroups\u00a0\\[ [11](https://arxiv.org/html/2403.16203v1#bib.bib11), [38](https://arxiv.org/html/2403.16203v1#bib.bib38), [22](https://arxiv.org/html/2403.16203v1#bib.bib22), [25](https://arxiv.org/html/2403.16203v1#bib.bib25), [58](https://arxiv.org/html/2403.16203v1#bib.bib58), [45](https://arxiv.org/html/2403.16203v1#bib.bib45)\\] from both the computational geometry and the combinatorial\noptimization communities, and resulted in a lively exchange of\nsolution ideas.\n\nSubsequently, the CG:SHOP Challenge became an event within the CG Week\nprogram, with top performing solutions reported in the Symposium on\nComputational Geometry (SoCG) proceedings.\nThe schedule for the Challenge was\nadvanced earlier, to give an opportunity for more participation, particularly\namong students, e.g., as part of course projects.\nFor CG Weeks 2020, 2021, 2022, and 2023, the Challenge problems were Minimum Convex Partition\\[ [19](https://arxiv.org/html/2403.16203v1#bib.bib19), [67](https://arxiv.org/html/2403.16203v1#bib.bib67), [56](https://arxiv.org/html/2403.16203v1#bib.bib56), [21](https://arxiv.org/html/2403.16203v1#bib.bib21)\\],\nCoordinated Motion Planning\\[ [27](https://arxiv.org/html/2403.16203v1#bib.bib27), [14](https://arxiv.org/html/2403.16203v1#bib.bib14), [15](https://arxiv.org/html/2403.16203v1#bib.bib15), [66](https://arxiv.org/html/2403.16203v1#bib.bib66), [13](https://arxiv.org/html/2403.16203v1#bib.bib13), [47](https://arxiv.org/html/2403.16203v1#bib.bib47), [65](https://arxiv.org/html/2403.16203v1#bib.bib65)\\],\nMinimum Partition into Plane Subgraphs\\[ [28](https://arxiv.org/html/2403.16203v1#bib.bib28), [10](https://arxiv.org/html/2403.16203v1#bib.bib10), [60](https://arxiv.org/html/2403.16203v1#bib.bib60), [12](https://arxiv.org/html/2403.16203v1#bib.bib12), [61](https://arxiv.org/html/2403.16203v1#bib.bib61), [36](https://arxiv.org/html/2403.16203v1#bib.bib36), [59](https://arxiv.org/html/2403.16203v1#bib.bib59)\\],\nand Minimum Convex Covering\\[ [29](https://arxiv.org/html/2403.16203v1#bib.bib29), [16](https://arxiv.org/html/2403.16203v1#bib.bib16), [1](https://arxiv.org/html/2403.16203v1#bib.bib1)\\],\nrespectively.\n\nThe sixth edition of the Challenge in 2024 continued\nthis format, leading to contributions in the SoCG proceedings.\n\n## 2 The Challenge: Maximum Polygon Packing\n\nA suitable contest problem has a number of desirable properties.\n\n- \u2022\n\n\nThe problem is of geometric nature.\n\n- \u2022\n\n\nThe problem is of general scientific interest and has received previous attention.\n\n- \u2022\n\n\nOptimization problems tend to be more suitable than feasibility problems; in principle,\nfeasibility problems are also possible, but they need to be suitable for sufficiently\nfine-grained scoring to produce an interesting contest.\n\n- \u2022\n\n\nComputing optimal solutions is difficult for instances of reasonable size.\n\n- \u2022\n\n\nThis difficulty is of a fundamental algorithmic nature, and not only due to\nissues of encoding or access to sophisticated software or hardware.\n\n- \u2022\n\n\nVerifying feasibility of provided solutions is relatively easy.\n\n\nIn this sixth year, a call for suitable problems was communicated in March\n2023\\. In response, a number of interesting problems were proposed for the 2024\nChallenge. These were evaluated with respect to difficulty, distinctiveness\nfrom previous years, and existing literature and related work. In the end, the\nAdvisory Board selected the chosen problem. Special thanks go to Mikkel Abrahamsen\n(University of Copenhagen) who suggested this problem, motivated by a rich history\nin geometry and optimization, including\u00a0\\[ [46](https://arxiv.org/html/2403.16203v1#bib.bib46)\\] and a wide range of\nprevious work described further down.\n\n### 2.1 The Proble...",
      "url": "https://arxiv.org/html/2403.16203v1"
    },
    {
      "title": "",
      "text": "Lo\u00efc Crombez \nGuilherme D Da Fonseca \nYan Gerard \nGreedy and Local Search Heuristics to Build Area-Optimal Polygons\n\nIn this paper, we present our heuristic solutions to the problems of finding the maximum and minimum area polygons with a given set of vertices. Our solutions are based mostly on two simple algorithmic paradigms: greedy method and local search. The greedy heuristic starts with a simple polygon and adds vertices one by one, according to a weight function. A crucial ingredient to obtain good solutions is the choice of an appropriate weight function that avoids long edges. The local search part consists of moving consecutive vertices to another location in the polygonal chain. We also discuss the different implementation techniques that are necessary to reduce the running time.\n\nIntroduction\n\nIn this paper, we consider the optimal area polygonalization problem, i.e. the problem of finding large and small area simple polygons with a given vertex set. Optimal area polygonalization resembles to the well-known travelling salesman problem, the difference being that the objective function of the former is the area of the computed polygon instead of its perimeter. This problem has been the subject of the 2019 Geometric Optimization Challenge and is known to be NP-hard for both minimization and maximization [2]. Exact algorithms are discussed in [3] and a recent state of the art is given in [1].\n\nIn this paper, we describe the algorithm that we developed during the 2019 Geometric Optimization Challenge. Our results gave us the second place, both for the minimization and maximization contests. Throughout, we refer to the score of a solution as the area of the polygon divided by the area of the convex hull. The score is a real number between 0 and 1, and a lower score is better for the minimization version while a higher score is better for the maximization version. The scores obtained on the instances of the challenge are in the range [0.025, 0.352] for the minimization problem and in the range [0.835, 0.976] for the maximization problem. These two intervals become [0.110, 0.135] and [0.871, 0.924] if we only consider the uniform instances of at least 100 points where the inputs sets have been randomly generated in a square with a uniform density function. More results are presented in Section 4.\n\nOur results have been obtained with a relatively simple and fast heuristic coded in Python and executed with pypy3. The heuristic consists of two phases: a greedy heuristic and a subsequent local search optimization. It is surprising that our results are very competitive when compared to the more complex approaches used by the other teams [1]. The whole source code is available at github.com/gfonsecabr/poLYG and is less than 500 lines long, requiring no external library. While during the challenge we used several different machines, all the running times presented herein have been obtained on a Dell XPS 13-9380 laptop with an Intel i7-10510U CPU and 16GB of RAM running Fedora 32 Linux. The implementation only uses one CPU thread and the other CPU threads were kept mostly idle during the benchmarks.\n\nThe paper is organized as follows. Section 2 describes the algorithmic approach we used. In Section 3, we present different techniques implemented to make the code run faster and find better solutions. Section 4 presents our results. In Section 5, we discuss some possible improvements.\n\n\nMethods\n\nIn the next two sections, we describe the two phases of our solution. For simplicity, we focus only on the maximum area polygon. The few changes necessary to solve the minimization version are described in Section 2.3.\n\n2.1. Greedy Heuristic. Let S be the input set with n points. Throughout the execution of the algorithm, we work with a simple polygon P whose set of vertices is a subset of S. The set of points in S which are not yet vertices of P is denotedP . The current polygon P is initialized with the convex hull of S.\n\nEach greedy step consists of choosing a point q \u2208 P and inserting q in the current polygon P . We insert q as the intermediary point of an edge p 1 , p 2 \u2208 P so that our current polygon P has two new edges p 1 , q and q, p 2 replacing p 1 , p 2 . We preserve at each step the simplicity of P by verifying that the new edges p 1 , q and q, p 2 do not cross the existing edges of P .\n\nWe repeat our greedy steps until either the set P becomes empty or until no point of P can possibly be inserted anywhere in P (see Figure 2). In the former case the algorithm successfully finds a solution, and in the latter case it fails. Our experiments showed that if the triple q, p 1 , p 2 is chosen carefully at each step, as we explain in the next paragraphs, then the heuristic hardly ever fails. Hence, we simply ignored the extremely rare failures and when it happened we used a different value of the parameter \u03b1 described later on to guide the heuristic.\n\nThe choice of the triple q, p 1 , p 2 at each step is essential to the quality of the solution. A strategy investigated in [5] is to randomly choose the point q in P and then choose the best edge p 1 , p 2 where to insert q. We employ a more exhaustive search. At each step we choose the triple minimizing weight(p 1 , p 2 , q), for a weight function to be described next. Perhaps, the most natural greedy choice is to minimize the area of the triangle p 1 p 2 q (denoted area(p 1 p 2 q)), since the area of P will decrease by exactly area(p 1 p 2 q) when q is inserted between p 1 and p 2 . In this case, we say that the weight function is weight(p 1 , p 2 , q) = area(p 1 p 2 q). This weight function has the property that all points of P lie in the interior of P . However, this function leads to very long edges as shown in    Table 1. Scores before and after local search for different values of \u03b1 and instances with 500 points. The scores above use the formula weight(p 1 , p 2 , q) = area(p 1 p 2 q) + \u03b1( qp 1 + qp 2 \u2212 p 1 p 2 ) while the ones below use weight(p 1 , p 2 , q) = area(p 1 p 2 q) + \u03b1( qp 1 + qp 2 + p 1 p 2 ). Figure 1(a). While long edges may seem like a good choice at short term, they dramatically reduce the search space of potential new triangles, which will hence deteriorate the solution at long term and often make the algorithm fail. We experimented with several different weight functions in order to obtain better solutions. The best function that we found by penalizing long edges is\nweight(p 1 , p 2 , q) = area(p 1 p 2 q) + \u03b1( qp 1 + qp 2 \u2212 p 1 p 2 ),\nwhere \u00b7 denotes the Euclidean distance and \u03b1 is a small parameter. The term qp 1 + qp 2 penalizes the creation of long edges, while the term \u2212 p 1 p 2 favors breaking existing long edges. Another weight function that gives good results is obtained by replacing the minus sign by a plus sign, and numerous other variations exist. Notice that these functions do not guarantee that all points of P lie in the interior of P .\n\nThe value of area(p 1 p 2 q) is a positive number if q is inside P and a negative number otherwise. Using signed areas (negative for clockwise triangles) is important, since some input points in P may possibly lie outside P . We determined that the best values of \u03b1 are generally in the range 1/150 \u2264 \u03b1 \u2264 1/50. Unless otherwise specified, the examples in this paper use \u03b1 = 1/90. Figure 1(b) shows the improvement obtained by penalizing long edges, while Table 1 shows some scores achieved through different weight functions (the local search algorithm is discussed in the next section).\n\n\nLocal Search.\n\nAfter obtaining the greedy solution, we perform a second phase to improve the score of the solution, by making local changes to the polygon. The simplest optimization we perform consists of moving one vertex v to another position in the polygonal chain, between the endpoints of an edge u 1 u 2 (Figure 3(a)), adding the edges u 1 v and vu 2 , while removing the edge u 1 u 2 . A more general version of this procedure consists of moving a path V = v 1 ,...",
      "url": "https://export.arxiv.org/pdf/2106.14728v1.pdf"
    }
  ]
}