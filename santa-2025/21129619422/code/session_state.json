{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T08:02:55.944513",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D geometric packing optimization problem: pack Christmas tree-shaped polygons (15 vertices) into the smallest square bounding box for configurations of 1-200 trees. Score = sum of (side_length^2 / n) for all n. Lower is better.",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "Key techniques from kernels: 1) bbox3 binary optimizer with parameters -n (iterations) and -r (restarts), 2) fix_direction rotation optimization using ConvexHull and minimize_scalar to find optimal rotation angle, 3) Simulated Annealing with squeeze/compaction/local search, 4) Backward propagation (removing trees from n-tree config to improve (n-1)-tree config), 5) Overlap repair using donor submissions",
      "source": "../research/kernels/",
      "agent": "explorer"
    },
    {
      "finding": "Tree geometry: 15-vertex polygon with trunk (0.15w x 0.2h), base tier (0.7w), mid tier (0.4w), top tier (0.25w), tip at y=0.8. Center point is at top of trunk (0,0). Collision detection uses Shapely with STRtree for efficiency.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/",
      "agent": "explorer"
    },
    {
      "finding": "C++ optimizers are critical: tree_packer_v21.exe uses OpenMP parallelization, complex number geometry, swap moves, multi-start SA. bbox3 uses global dynamics, fluid dynamics, hinge pivot, density gradient flow, and global boundary tension. Both use long double precision.",
      "source": "../research/kernels/smartmanoj_santa-claude/",
      "agent": "explorer"
    },
    {
      "finding": "Sample submission uses only 4 discrete angles (0, 90, 180, 270 degrees). Optimized solutions use continuous angles for better packing. The sample has approximate score ~157, target is 68.9 - significant optimization needed.",
      "source": "exploration/eda.ipynb",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization problems?",
      "finding": "Two\u2011dimensional irregular polygon packing is a classic combinatorial optimisation problem that appears in shipbuilding, metal\u2011working, automotive and furniture manufacturing, where the goal is to maximise material utilisation while respecting geometric constraints.  Because the search space grows exponentially with the number of pieces and their possible orientations, exact methods are only feasible for very small instances; most practical solvers rely on sophisticated heuristics and meta\u2011heuristics that construct a feasible layout and then improve it iteratively\u202f([frontiersin.org](https://www.frontiersin.org/articles/10.3389/fmech.2022.966691/full)).  \n\nThe most effective approaches combine a **selection heuristic** (which orders the polygons) with a **placement heuristic** (which decides where each selected piece is placed).  A widely cited example is the adaptation of the Djang\u2011Finch (DJD) heuristic to irregular shapes, which pairs DJD\u2019s piece\u2011ordering rule with a bottom\u2011left placem",
      "agent": "explorer"
    },
    {
      "query": "What is the best way to pack identical irregular polygons into a square with minimum area?",
      "finding": "Packing identical irregular polygons into the smallest possible square is a classic two\u2011dimensional bin\u2011packing problem that is NP\u2011hard, so exact solutions are only feasible for very small instances.  In practice the most successful approaches combine a geometric preprocessing step (e.g., computing the **no\u2011fit polygon** to test overlaps) with either a provable approximation algorithm or a powerful mixed\u2011integer programming (MIP) model.  For convex polygons that are not allowed to rotate, recent work provides polynomial\u2011time **area\u2011minimisation** algorithms that sort the pieces by height and apply a refined shelf\u2011packing scheme, yielding the best known constant\u2011factor guarantees for translational packing\u202f([arXiv\u202f2023](https://export.arxiv.org/pdf/2308.08523v1.pdf)).  When rotations are permitted or the shapes are non\u2011convex, the state\u2011of\u2011the\u2011art relies on exact MIP formulations such as the **dotted\u2011board model** or the **polygonal enclosure model**, which encode each piece as a set of ",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 95
}