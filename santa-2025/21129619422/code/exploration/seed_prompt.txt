# Christmas Tree Packing Optimization - Seed Prompt

## Problem Overview
This is a 2D geometric packing optimization problem: pack Christmas tree-shaped polygons (15 vertices) into the smallest square bounding box for configurations of 1-200 trees. 

**Objective:** Minimize score = Σ(side_length² / n) for n=1 to 200. Lower is better.
**Target Score:** Beat 68.922808
**Sample Submission Score:** ~157 (uses only 4 discrete angles - significant room for improvement)

**Tree Geometry:**
- 15-vertex polygon with trunk (0.15w x 0.2h), base tier (0.7w), mid tier (0.4w), top tier (0.25w), tip at y=0.8
- Center point is at top of trunk (0,0)
- Trees can be rotated to any angle (0-360 degrees) - continuous angles are key!
- No overlapping allowed (touching is OK)

**Submission Format:**
- CSV with columns: id, x, y, deg (all values prefixed with 's')
- id format: NNN_T where NNN is tree count (001-200), T is tree index
- Total rows: 20100 (1+2+3+...+200)

## Top Approaches from Public Kernels

### 1. bbox3 Binary Optimizer (Primary Tool)
See `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- C++ optimizer with parameters: -n (iterations) and -r (restarts)
- Uses global dynamics, fluid dynamics, hinge pivot, density gradient flow
- Typical parameters: n=1000-2000, r=30-90 for quick runs; n=5000-10000, r=256 for longer runs
- Multi-phase approach: Phase A (short runs), Phase B (medium), Phase C (long)

### 2. tree_packer C++ Optimizer
See `../research/kernels/smartmanoj_santa-claude/`
- Uses OpenMP parallelization for all n values (1-200) in parallel
- Complex number geometry for efficient rotation calculations
- Key operations: squeeze, compaction, local search, swap moves
- Multi-start simulated annealing with higher temperature
- Backward propagation: remove trees from n-tree config to improve (n-1)-tree config

### 3. fix_direction Rotation Optimization
See `../research/kernels/saspav_santa-submission/`
- Uses ConvexHull of all tree vertices
- scipy.optimize.minimize_scalar to find optimal rotation angle (0-90 degrees)
- Rotates entire configuration to minimize bounding box side length
- Critical post-processing step after any optimizer

### 4. Greedy Baseline with Weighted Angles
See `../research/kernels/inversion_santa-2025-getting-started/`
- Place trees using weighted random angles (prefer diagonal orientations via sin(2*angle))
- Move from far away toward center until collision
- Back up until no overlap
- Use previous n-tree solution as starting point for (n+1)-tree

## Key Optimization Techniques

### Collision Detection
- Use Shapely library with STRtree for efficient spatial queries
- Point-in-polygon test + segment intersection for precise overlap detection
- Bounding box pre-filter for speed

### Local Search Operations
1. **Squeeze:** Scale all trees toward center until overlap
2. **Compaction:** Move individual trees toward center in small steps
3. **Translation:** Move trees in 8 directions (cardinal + diagonal)
4. **Rotation:** Rotate individual trees by small angles (±0.1° to ±5°)
5. **Swap:** Exchange positions of two trees

### Meta-heuristics
- **Simulated Annealing:** Accept worse solutions with decreasing probability
- **Tabu Search:** Avoid recently visited configurations
- **Genetic Algorithm:** Evolve population of solutions
- **Iterated Local Search:** Perturb + local search cycles

### Overlap Repair
- If optimizer produces overlaps, replace affected configurations from donor submission
- Use separation vectors (MTV approximation) to push overlapping trees apart

## Recommended Implementation Strategy

### Approach 1: Use Existing C++ Optimizers (RECOMMENDED)
1. Start with best available submission as baseline
2. Run bbox3 with various (n, r) parameter combinations
3. Apply fix_direction rotation optimization
4. Validate and repair any overlaps
5. Keep best score, revert on regressions

### Approach 2: Python-based Optimization
1. Implement ChristmasTree class with Shapely polygons
2. Use greedy initialization with weighted angles (continuous, not discrete!)
3. Apply local search (translation + rotation)
4. Use scipy.optimize for continuous refinement
5. Apply fix_direction as post-processing

### Approach 3: Hybrid Approach
1. Use C++ optimizer for heavy computation
2. Python for orchestration, validation, and post-processing
3. Ensemble multiple optimizer runs with different seeds
4. Cherry-pick best configurations per n

## Critical Implementation Details

### Precision
- Use Decimal type or long double for coordinates
- Scale factor of 1e15 used in some implementations
- Round to 6 decimal places for submission

### Validation
- Check for overlaps using intersects() and not touches()
- Verify all 200 configurations are present
- Ensure coordinates within bounds (-100 ≤ x, y ≤ 100)

### Scoring
```python
def calculate_score(submission):
    total = 0
    for n in range(1, 201):
        trees = get_trees_for_n(submission, n)
        side = get_bounding_box_side(trees)
        total += side**2 / n
    return total
```

## Research Insights (2D Irregular Packing)

From academic literature:
- **Bottom-left (BL) strategy:** Simple, fast placement heuristic
- **No-fit polygon (NFP):** Efficient collision detection for fixed orientations
- **Nonlinear programming:** Continuous optimization for fine-tuning positions
- **Jostle algorithm:** Local search that "jostles" pieces to find better arrangements
- **Hybrid approaches:** Combine GA global search with local refinement

## Key Insights from EDA
- Sample submission uses only 4 discrete angles (0, 90, 180, 270) - this is suboptimal
- Optimized solutions use continuous angles for better interlocking
- Trees can interlock better when rotated to complementary angles
- Diagonal orientations (45°, 135°, etc.) can help fill corners of square bounding box

## Validation Checklist
1. No overlapping trees (intersects but not touches = overlap)
2. All 200 configurations present
3. Correct number of trees per configuration (n trees for config n)
4. Coordinates within bounds
5. Score calculation matches expected formula

## Files Reference
- Sample submission: `/home/data/sample_submission.csv`
- Getting started kernel: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- tree_packer: `../research/kernels/smartmanoj_santa-claude/`
- Combined approach: `../research/kernels/saspav_santa-submission/`
- Why-not kernel: `../research/kernels/jazivxt_why-not/`

## Priority Actions
1. **Compile and run C++ optimizers** - These are the most effective tools
2. **Apply fix_direction** - Critical post-processing for any solution
3. **Validate overlaps** - Submissions with overlaps are rejected
4. **Iterate with different parameters** - Try various (n, r) combinations
5. **Cherry-pick best configs** - Combine best n-tree solutions from multiple runs
