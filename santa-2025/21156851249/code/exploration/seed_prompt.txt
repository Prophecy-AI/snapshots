# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D packing optimization problem where we need to pack Christmas tree-shaped polygons (15-vertex shapes) into the smallest square bounding box for N=1 to N=200 trees.

**Scoring:** score = Σ(s_n² / n) for n=1 to 200, where s_n is the side length of the bounding box for n trees.
**Target:** 68.919154 (lower is better)
**Best known baseline:** ~70.66 (from pre-optimized CSVs)
**Gap to target:** ~1.74 points (2.5% improvement needed)

## FIRST EXPERIMENT STRATEGY
1. **Submit the best pre-optimized CSV immediately** to establish baseline LB score
2. Copy the best CSV to submission directory:
```bash
cp /home/code/exploration/datasets/santa-2025.csv /home/submission/submission.csv
```
3. Expected LB score: ~70.66 (should match CV)

## CRITICAL INSIGHT FROM PREVIOUS EXPERIMENTS
Previous experiments (12+ attempts across multiple runs) tried:
- Simulated Annealing (SA) optimizers (sa_v1_parallel, tree_packer_v18, tree_packer_v21)
- Lattice construction for large N
- Backward propagation (removing trees from N+1 to get N)
- Ensemble of 30+ CSV sources
- Genetic algorithms
- bbox3 C++ optimizer with various parameters
- Rotation optimization (fix_direction)
- Multi-seed optimization with overlap repair

**ALL FOUND NO IMPROVEMENTS beyond 70.659944!**

The pre-optimized CSVs are at a VERY TIGHT LOCAL OPTIMUM. Local search methods cannot escape this basin.

## Pre-optimized Files Available
Copy these to your working directory:
```bash
# Best baseline CSV (score: 70.659958)
cp /home/code/exploration/datasets/santa-2025.csv /home/code/submission.csv

# bbox3 C++ optimizer binary
cp /home/code/exploration/datasets/bbox3 /home/code/
chmod +x /home/code/bbox3
```

Alternative sources in snapshots:
- `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`

## Tree Geometry (15 vertices)
```python
# Tree shape coordinates (center at origin, pointing up)
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
# Tree dimensions: height=1.0 (from -0.2 to 0.8), max width=0.7 at base
```

## RECOMMENDED APPROACHES (Priority Order)

### 1. **[HIGHEST PRIORITY]** Search for Better Pre-optimized Solutions
The target score of 68.919154 suggests solutions exist that are ~1.74 points better than our baseline.
- Search Kaggle datasets for newer/better pre-optimized CSVs
- Look for solutions from top leaderboard teams
- Check discussion forums for shared solutions

**Commands:**
```bash
# Search for Santa 2025 datasets
kaggle datasets list -s "santa 2025" --sort-by updated
# Download promising datasets
kaggle datasets download -d <dataset-name>
```

### 2. **[HIGH PRIORITY]** Greedy Backtracking with Beam Search
Build solutions from scratch instead of optimizing pre-optimized CSVs:
- Start with N=1 (optimal at 45 degrees)
- For each N, try multiple tree placements with beam search
- Keep top K configurations (beam width)
- This explores different basins of attraction

**Implementation:**
```python
def greedy_beam_search(max_n=200, beam_width=10, max_depth=10):
    configs = {1: [optimal_single_tree()]}  # Start with N=1
    
    for n in range(2, max_n + 1):
        candidates = []
        for config in configs[n-1]:
            # Try adding tree at multiple positions/angles
            for angle in range(0, 360, 15):
                for attempt in range(max_depth):
                    new_config = try_add_tree(config, angle, attempt)
                    if new_config and not has_overlap(new_config):
                        candidates.append((score(new_config), new_config))
        
        # Keep top beam_width configurations
        candidates.sort(key=lambda x: x[0])
        configs[n] = [c[1] for c in candidates[:beam_width]]
    
    return configs
```

### 3. **[HIGH PRIORITY]** Random Initialization + Long Optimization
Generate completely NEW starting configurations instead of optimizing pre-optimized CSVs:
```python
def random_initialization(n):
    trees = []
    for i in range(n):
        # Random position in a reasonable area
        x = random.uniform(-5, 5)
        y = random.uniform(-5, 5)
        angle = random.uniform(0, 360)
        trees.append((x, y, angle))
    return trees

# Then apply SA optimization to the random starting point
```

### 4. **[MEDIUM PRIORITY]** Lattice-Based Construction for Large N
For N >= 58, try crystalline packing patterns:
- Start with 2 base trees in optimal configuration
- Translate in x and y to create grid pattern
- Grid configurations: N=72 (4x9), N=100 (5x10), N=144 (6x12), N=196 (7x14), N=200 (7x15)

### 5. **[MEDIUM PRIORITY]** Asymmetric Solutions
From discussion "Why the winning solutions will be Asymmetric":
- Symmetric solutions have been explored extensively
- Asymmetric configurations may have lower scores
- Try breaking symmetry in existing solutions

### 6. **[MEDIUM PRIORITY]** Extended bbox3 Optimization
If you have the bbox3 binary, try very long runs:
```bash
chmod +x bbox3
./bbox3 -n 100000 -r 256  # Much longer than previous attempts
```

### 7. **[LOWER PRIORITY]** Branch-and-Bound with Lower Bounds
From academic literature on 2D polygon packing:
- Use 1D bin packing relaxation for lower bounds
- Apply dominance conditions to prune search space
- Use rotating calipers for optimal bounding box orientation

## C++ Optimizer Template (from kernels)
The key techniques from top kernels:
1. **Fractional translation** with micro-steps (0.001 to 0.00001)
2. **Population-based optimization** keeping top 3 candidates
3. **Perturbation** to escape local optima
4. **OpenMP parallelization** for speed

```cpp
// Key parameters for SA optimizer
double frac_steps[] = {0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001};
int iterations = 100000;  // Much longer than default
int rounds = 256;
```

## Validation Requirements
- No overlapping trees (Kaggle rejects overlapping submissions)
- All coordinates in [-100, 100]
- Values must be prefixed with 's' in submission CSV
- Use Shapely STRtree for efficient overlap checking

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s45.0
002_0,s-0.0255,s0.0442,s0.0
002_1,s0.3688,s0.738,s180.0
...
```

## Scoring Function (Python)
```python
from decimal import Decimal, getcontext
from shapely import affinity
from shapely.geometry import Polygon
from shapely.ops import unary_union

getcontext().prec = 30

class ChristmasTree:
    def __init__(self, center_x='0', center_y='0', angle='0'):
        self.center_x = Decimal(center_x)
        self.center_y = Decimal(center_y)
        self.angle = Decimal(angle)
        
        trunk_w = Decimal('0.15')
        trunk_h = Decimal('0.2')
        base_w = Decimal('0.7')
        mid_w = Decimal('0.4')
        top_w = Decimal('0.25')
        tip_y = Decimal('0.8')
        tier_1_y = Decimal('0.5')
        tier_2_y = Decimal('0.25')
        base_y = Decimal('0.0')
        trunk_bottom_y = -trunk_h

        initial_polygon = Polygon([
            (float(Decimal('0.0')), float(tip_y)),
            (float(top_w / Decimal('2')), float(tier_1_y)),
            (float(top_w / Decimal('4')), float(tier_1_y)),
            (float(mid_w / Decimal('2')), float(tier_2_y)),
            (float(mid_w / Decimal('4')), float(tier_2_y)),
            (float(base_w / Decimal('2')), float(base_y)),
            (float(trunk_w / Decimal('2')), float(base_y)),
            (float(trunk_w / Decimal('2')), float(trunk_bottom_y)),
            (float(-(trunk_w / Decimal('2'))), float(trunk_bottom_y)),
            (float(-(trunk_w / Decimal('2'))), float(base_y)),
            (float(-(base_w / Decimal('2'))), float(base_y)),
            (float(-(mid_w / Decimal('4'))), float(tier_2_y)),
            (float(-(mid_w / Decimal('2'))), float(tier_2_y)),
            (float(-(top_w / Decimal('4'))), float(tier_1_y)),
            (float(-(top_w / Decimal('2'))), float(tier_1_y)),
        ])
        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))
        self.polygon = affinity.translate(rotated, xoff=float(self.center_x), yoff=float(self.center_y))

def score_submission(df):
    total_score = Decimal('0')
    for n in range(1, 201):
        group = df[df['id'].str.startswith(f'{n:03d}_')]
        trees = [ChristmasTree(row['x'], row['y'], row['deg']) for _, row in group.iterrows()]
        polygons = [t.polygon for t in trees]
        bounds = unary_union(polygons).bounds
        side = Decimal(str(max(bounds[2] - bounds[0], bounds[3] - bounds[1])))
        total_score += side ** 2 / Decimal(str(n))
    return float(total_score)
```

## What NOT to Try
- Simple SA on pre-optimized CSV (already at local optimum)
- Short optimization runs (need hours, not minutes)
- Backward propagation alone (already tried, no improvements)
- Ensemble without new sources (santa-2025.csv dominates all N values)

## Key Insight
The gap of 1.74 points suggests the target is achievable, but requires either:
1. Finding better pre-optimized solutions from external sources (most likely path)
2. Using constructive approaches (beam search, random restart) to explore different basins
3. Very long optimization runs with perturbation to escape local optima

**DO NOT waste experiments on local search of pre-optimized CSVs - they are already at local optimum!**

## Kernel References
- Getting Started: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 Runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- Santa Claude (C++ optimizer): `../research/kernels/smartmanoj_santa-claude/`
- Why Not (bbox3): `../research/kernels/jazivxt_why-not/`
- Santa Tree High Score: `../research/kernels/hossam82_santa-tree-high-score-v1/`

## Downloaded Datasets
Located in `/home/code/exploration/datasets/`:
- `santa-2025.csv` (score: 70.659958) - BEST
- `submission.csv` (score: 70.659982)
- `bbox3` - C++ optimizer binary
