# Christmas Tree Packing Optimization - Seed Prompt

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (1-200 trees per configuration) into the smallest possible square bounding box. 

**Metric:** Sum of (s²/n) for each n-tree configuration, where s = side length of bounding square, n = number of trees.
**Target Score:** Beat 68.931058 (lower is better)
**Best Known Scores:** ~67 is achievable with good optimization (from discussions)

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Trunk: width=0.15, height=0.2
- Base tier: width=0.7
- Middle tier: width=0.4
- Top tier: width=0.25
- Tip at y=0.8
- Position defined by (x, y) center of trunk top and rotation angle (deg)

## Top Approaches from Public Kernels

### 1. bbox3 Binary Optimizer (Most Common Approach)
- External C/C++ binary that performs iterative optimization
- Parameters: `-n` (iterations) and `-r` (restarts)
- Used in most top kernels: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- Typical usage: `./bbox3 -n 1000 -r 96` or higher for better results

### 2. Fix Direction / Rotation Optimization
- After packing, rotate entire configuration to minimize bounding box
- Uses scipy.optimize.minimize_scalar to find optimal rotation angle (0-90°)
- Calculates convex hull of all tree vertices, then finds rotation that minimizes max(width, height)
- Implementation in: `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

### 3. C++ Tree Packer with OpenMP (High Performance)
- Full C++ implementation with parallel processing
- Key operators:
  - **Squeeze**: Scale configuration toward center until collision
  - **Compaction**: Move trees toward center in small steps
  - **Local search**: 8-directional moves + rotation adjustments
  - **Simulated annealing**: Accept worse solutions with decreasing probability
  - **Swap moves**: Exchange positions of two trees
  - **Multi-start**: Try different initial angles
- Implementation: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

### 4. Backward Propagation
- Use n-tree solution to derive (n-1)-tree solution
- Remove trees that touch the bounding box boundary
- Can improve smaller configurations using larger ones

### 5. Overlap Repair Strategy
- After optimization, check for overlapping trees
- Replace invalid configurations with known-good solutions from baseline
- Critical for valid submissions

## Key Implementation Details

### Collision Detection
- Use Shapely library with STRtree for efficient spatial queries
- Check `polygon.intersects()` but exclude `polygon.touches()` (touching is allowed)
- High precision using Decimal with scale_factor (1e15 or 1e18)

### Submission Format
- Values prefixed with 's' to preserve precision: `s0.123456`
- ID format: `{n:03d}_{tree_index}` (e.g., "001_0", "002_1")
- Columns: id, x, y, deg
- Total rows: 20100 (sum of 1+2+...+200)

### Scoring Function
```python
def get_score(trees, n):
    # Get all polygon vertices
    xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])
    min_x, min_y = xys.min(axis=0)
    max_x, max_y = xys.max(axis=0)
    side_length = max(max_x - min_x, max_y - min_y)
    return side_length**2 / n
```

## Recommended Experiments (Priority Order)

### Experiment 1: Baseline with bbox3 + Fix Direction
1. Start with sample_submission.csv or best known solution
2. Run bbox3 optimizer with moderate parameters (n=1000-2000, r=30-96)
3. Apply fix_direction rotation optimization
4. Validate and repair overlaps
- Expected: Should beat baseline significantly

### Experiment 2: Extended bbox3 Optimization
1. Use multi-phase approach from best-keeping-bbox3-runner:
   - Phase A: Short runs (2 min) to find promising (n, r) combinations
   - Phase B: Medium runs (10 min) on top candidates
   - Phase C: Long runs (20 min) on best few
2. Apply fix_direction after each phase
- See: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`

### Experiment 3: C++ Implementation
1. Compile tree_packer with OpenMP: `g++ -O3 -march=native -std=c++17 -fopenmp`
2. Run with high iterations: `-n 5000-10000 -r 16-256`
3. Apply backward propagation post-processing
- See: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

### Experiment 4: Hybrid Approach
1. Combine multiple optimizers:
   - bbox3 for initial optimization
   - C++ local search for refinement
   - Fix direction for rotation
   - Backward propagation for small n
2. Keep best solution across all methods

### Experiment 5: Custom Local Search Improvements
1. Implement additional move operators:
   - Jostle algorithm (shift trees to create gaps, then compact)
   - Gradient-based moves toward center
   - Rotation-only optimization per tree
2. Fine-grained step sizes for final polish

## Validation Strategy
1. Always validate for overlaps before submission
2. Use STRtree for efficient collision detection
3. Replace invalid configurations with known-good baseline
4. Score locally before submitting

## Key Insights from Kernels and Discussions

1. **Lattice patterns emerge**: Trees tend to form crystalline arrangements with alternating orientations (blue/pink phases at ~90° apart)

2. **Boundary trees matter most**: Trees touching the bounding box boundary determine the score - focus optimization on these

3. **Rotation is critical**: The fix_direction step can significantly reduce bounding box by rotating entire configuration

4. **Incremental improvement**: Small improvements compound - even 1e-10 improvement per configuration adds up

5. **Precision matters**: Use high-precision Decimal arithmetic to avoid floating-point errors

6. **Symmetric vs Asymmetric**: Symmetric solutions appear optimal for some n values, but asymmetric solutions may win for larger n (from discussions)

7. **Simulated Annealing Energy Function**: Design of the SA energy function is important - consider using bounding box side length directly

## Algorithm Design Recommendations

### For Simulated Annealing
- Energy function: Use side_length (not side_length²/n) for individual configurations
- Temperature schedule: Start high, decrease exponentially
- Move operators: Combine translation, rotation, and swap moves
- Accept criterion: exp(-delta_E / T) for worse solutions

### For Local Search
- Step sizes: Start with 0.01-0.05, decrease to 0.0001 for fine-tuning
- Rotation steps: 5°, 2°, 0.8°, 0.3°, 0.1° (progressively finer)
- Directions: 8-directional (N, S, E, W, NE, NW, SE, SW)
- Center-seeking: Move trees toward centroid of configuration

### For Greedy Construction
- Use weighted random angles (favor diagonal orientations for corner packing)
- Place trees from outside-in, moving toward center until collision
- Try multiple random starting positions, keep best

## Files Reference
- Sample submission: `/home/data/sample_submission.csv`
- Getting started kernel: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- C++ implementation: `../research/kernels/smartmanoj_santa-claude/`
- Validation/repair: `../research/kernels/jazivxt_why-not/`
- Combined approach: `../research/kernels/saspav_santa-submission/`

## Quick Start Code Template

```python
import pandas as pd
import numpy as np
from decimal import Decimal, getcontext
from shapely import affinity
from shapely.geometry import Polygon
from shapely.ops import unary_union
from shapely.strtree import STRtree
from scipy.optimize import minimize_scalar
from scipy.spatial import ConvexHull

getcontext().prec = 25

# Tree polygon vertices (relative to center at origin, 0° rotation)
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def make_tree_polygon(x, y, deg):
    """Create a tree polygon at position (x,y) with rotation deg."""
    base = Polygon(zip(TX, TY))
    rotated = affinity.rotate(base, deg, origin=(0, 0))
    return affinity.translate(rotated, x, y)

def check_overlap(poly1, poly2):
    """Check if two polygons overlap (touching is OK)."""
    return poly1.intersects(poly2) and not poly1.touches(poly2)

def calculate_score(trees_df, n):
    """Calculate score for n-tree configuration."""
    group = trees_df[trees_df['id'].str.startswith(f'{n:03d}_')]
    polygons = []
    for _, row in group.iterrows():
        x = float(str(row['x'])[1:])
        y = float(str(row['y'])[1:])
        deg = float(str(row['deg'])[1:])
        polygons.append(make_tree_polygon(x, y, deg))
    
    bounds = unary_union(polygons).bounds
    side = max(bounds[2] - bounds[0], bounds[3] - bounds[1])
    return side**2 / n

def total_score(trees_df):
    """Calculate total score for all configurations."""
    return sum(calculate_score(trees_df, n) for n in range(1, 201))
```
