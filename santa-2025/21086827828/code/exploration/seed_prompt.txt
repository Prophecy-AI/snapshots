# Christmas Tree Packing Optimization - Seed Prompt

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (1-200 trees per configuration) into the smallest possible square bounding box. 

**Metric:** Sum of (s²/n) for each n-tree configuration, where s = side length of bounding square, n = number of trees.
**Target Score:** Beat 68.931058 (lower is better)

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Trunk: width=0.15, height=0.2
- Base tier: width=0.7
- Middle tier: width=0.4
- Top tier: width=0.25
- Tip at y=0.8
- Position defined by (x, y) center of trunk top and rotation angle (deg)

## Top Approaches from Public Kernels

### 1. bbox3 Binary Optimizer (Most Common Approach)
- External C/C++ binary that performs iterative optimization
- Parameters: `-n` (iterations) and `-r` (restarts)
- Used in most top kernels: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- Typical usage: `./bbox3 -n 1000 -r 96` or higher for better results

### 2. Fix Direction / Rotation Optimization
- After packing, rotate entire configuration to minimize bounding box
- Uses scipy.optimize.minimize_scalar to find optimal rotation angle (0-90°)
- Calculates convex hull of all tree vertices, then finds rotation that minimizes max(width, height)
- Implementation in: `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

### 3. C++ Tree Packer with OpenMP (High Performance)
- Full C++ implementation with parallel processing
- Key operators:
  - **Squeeze**: Scale configuration toward center until collision
  - **Compaction**: Move trees toward center in small steps
  - **Local search**: 8-directional moves + rotation adjustments
  - **Simulated annealing**: Accept worse solutions with decreasing probability
  - **Swap moves**: Exchange positions of two trees
  - **Multi-start**: Try different initial angles
- Implementation: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

### 4. Backward Propagation
- Use n-tree solution to derive (n-1)-tree solution
- Remove trees that touch the bounding box boundary
- Can improve smaller configurations using larger ones

### 5. Overlap Repair Strategy
- After optimization, check for overlapping trees
- Replace invalid configurations with known-good solutions from baseline
- Critical for valid submissions

## Key Implementation Details

### Collision Detection
- Use Shapely library with STRtree for efficient spatial queries
- Check `polygon.intersects()` but exclude `polygon.touches()` (touching is allowed)
- High precision using Decimal with scale_factor (1e15 or 1e18)

### Submission Format
- Values prefixed with 's' to preserve precision: `s0.123456`
- ID format: `{n:03d}_{tree_index}` (e.g., "001_0", "002_1")
- Columns: id, x, y, deg

### Scoring Function
```python
def get_score(trees, n):
    # Get all polygon vertices
    xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])
    min_x, min_y = xys.min(axis=0)
    max_x, max_y = xys.max(axis=0)
    side_length = max(max_x - min_x, max_y - min_y)
    return side_length**2 / n
```

## Recommended Experiments (Priority Order)

### Experiment 1: Baseline with bbox3 + Fix Direction
1. Start with sample_submission.csv or best known solution
2. Run bbox3 optimizer with moderate parameters (n=1000-2000, r=30-96)
3. Apply fix_direction rotation optimization
4. Validate and repair overlaps
- Expected: Should beat baseline significantly

### Experiment 2: Extended bbox3 Optimization
1. Use multi-phase approach from best-keeping-bbox3-runner:
   - Phase A: Short runs (2 min) to find promising (n, r) combinations
   - Phase B: Medium runs (10 min) on top candidates
   - Phase C: Long runs (20 min) on best few
2. Apply fix_direction after each phase
- See: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`

### Experiment 3: C++ Implementation
1. Compile tree_packer with OpenMP: `g++ -O3 -march=native -std=c++17 -fopenmp`
2. Run with high iterations: `-n 5000-10000 -r 16-256`
3. Apply backward propagation post-processing
- See: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

### Experiment 4: Hybrid Approach
1. Combine multiple optimizers:
   - bbox3 for initial optimization
   - C++ local search for refinement
   - Fix direction for rotation
   - Backward propagation for small n
2. Keep best solution across all methods

### Experiment 5: Custom Local Search Improvements
1. Implement additional move operators:
   - Jostle algorithm (shift trees to create gaps, then compact)
   - Gradient-based moves toward center
   - Rotation-only optimization per tree
2. Fine-grained step sizes for final polish

## Validation Strategy
1. Always validate for overlaps before submission
2. Use STRtree for efficient collision detection
3. Replace invalid configurations with known-good baseline
4. Score locally before submitting

## Key Insights from Kernels

1. **Lattice patterns emerge**: Trees tend to form crystalline arrangements with alternating orientations (blue/pink phases at ~90° apart)

2. **Boundary trees matter most**: Trees touching the bounding box boundary determine the score - focus optimization on these

3. **Rotation is critical**: The fix_direction step can significantly reduce bounding box by rotating entire configuration

4. **Incremental improvement**: Small improvements compound - even 1e-10 improvement per configuration adds up

5. **Precision matters**: Use high-precision Decimal arithmetic to avoid floating-point errors

## Files Reference
- Sample submission: `/home/data/sample_submission.csv`
- Getting started kernel: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- C++ implementation: `../research/kernels/smartmanoj_santa-claude/`
- Validation/repair: `../research/kernels/jazivxt_why-not/`
