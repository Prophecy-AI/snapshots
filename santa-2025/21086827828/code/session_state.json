{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-17T02:30:35.578439",
  "time_limit_minutes": 2100,
  "experiments": [
    {
      "id": "exp_000",
      "name": "Baseline: Sample Submission + Fix Direction + Local Search",
      "model_type": "optimization",
      "score": 149.294025,
      "cv_score": 149.294025,
      "lb_score": null,
      "notes": "Started with sample_submission.csv (score 173.65). Applied fix_direction rotation optimization (score 151.17). Applied local search for n<=30 configurations (score 149.29). Still far from target 68.93. The sample submission is a very basic greedy solution - need more sophisticated optimization like bbox3 binary or C++ implementation from kernels.",
      "experiment_folder": "/home/code/experiments/001_baseline",
      "timestamp": "2026-01-17T02:43:43.239116"
    }
  ],
  "candidates": [
    {
      "file_path": "/home/code/submission_candidates/candidate_000.csv",
      "score": 149.294025,
      "cv_score": 149.294025,
      "model_name": "Baseline: Sample Submission + Fix Direction + Local Search",
      "experiment_id": "exp_000",
      "timestamp": "2026-01-17T02:43:43.241246"
    }
  ],
  "submissions": [],
  "strategy_history": [
    {
      "strategy": "# Christmas Tree Packing Optimization - Seed Prompt\n\n## Problem Overview\nThis is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (1-200 trees per configuration) into the smallest possible square bounding box. \n\n**Metric:** Sum of (s\u00b2/n) for each n-tree configuration, where s = side length of bounding square, n = number of trees.\n**Target Score:** Beat 68.931058 (lower is better)\n**Best Known Scores:** ~67 is achievable with good optimization (from discussions)\n\n## Tree Geometry\nEach tree is a 15-vertex polygon with:\n- Trunk: width=0.15, height=0.2\n- Base tier: width=0.7\n- Middle tier: width=0.4\n- Top tier: width=0.25\n- Tip at y=0.8\n- Position defined by (x, y) center of trunk top and rotation angle (deg)\n\n## Top Approaches from Public Kernels\n\n### 1. bbox3 Binary Optimizer (Most Common Approach)\n- External C/C++ binary that performs iterative optimization\n- Parameters: `-n` (iterations) and `-r` (restarts)\n- Used in most top kernels: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`\n- Typical usage: `./bbox3 -n 1000 -r 96` or higher for better results\n\n### 2. Fix Direction / Rotation Optimization\n- After packing, rotate entire configuration to minimize bounding box\n- Uses scipy.optimize.minimize_scalar to find optimal rotation angle (0-90\u00b0)\n- Calculates convex hull of all tree vertices, then finds rotation that minimizes max(width, height)\n- Implementation in: `../research/kernels/saspav_santa-submission/santa-submission.ipynb`\n\n### 3. C++ Tree Packer with OpenMP (High Performance)\n- Full C++ implementation with parallel processing\n- Key operators:\n  - **Squeeze**: Scale configuration toward center until collision\n  - **Compaction**: Move trees toward center in small steps\n  - **Local search**: 8-directional moves + rotation adjustments\n  - **Simulated annealing**: Accept worse solutions with decreasing probability\n  - **Swap moves**: Exchange positions of two trees\n  - **Multi-start**: Try different initial angles\n- Implementation: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n\n### 4. Backward Propagation\n- Use n-tree solution to derive (n-1)-tree solution\n- Remove trees that touch the bounding box boundary\n- Can improve smaller configurations using larger ones\n\n### 5. Overlap Repair Strategy\n- After optimization, check for overlapping trees\n- Replace invalid configurations with known-good solutions from baseline\n- Critical for valid submissions\n\n## Key Implementation Details\n\n### Collision Detection\n- Use Shapely library with STRtree for efficient spatial queries\n- Check `polygon.intersects()` but exclude `polygon.touches()` (touching is allowed)\n- High precision using Decimal with scale_factor (1e15 or 1e18)\n\n### Submission Format\n- Values prefixed with 's' to preserve precision: `s0.123456`\n- ID format: `{n:03d}_{tree_index}` (e.g., \"001_0\", \"002_1\")\n- Columns: id, x, y, deg\n- Total rows: 20100 (sum of 1+2+...+200)\n\n### Scoring Function\n```python\ndef get_score(trees, n):\n    # Get all polygon vertices\n    xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])\n    min_x, min_y = xys.min(axis=0)\n    max_x, max_y = xys.max(axis=0)\n    side_length = max(max_x - min_x, max_y - min_y)\n    return side_length**2 / n\n```\n\n## Recommended Experiments (Priority Order)\n\n### Experiment 1: Baseline with bbox3 + Fix Direction\n1. Start with sample_submission.csv or best known solution\n2. Run bbox3 optimizer with moderate parameters (n=1000-2000, r=30-96)\n3. Apply fix_direction rotation optimization\n4. Validate and repair overlaps\n- Expected: Should beat baseline significantly\n\n### Experiment 2: Extended bbox3 Optimization\n1. Use multi-phase approach from best-keeping-bbox3-runner:\n   - Phase A: Short runs (2 min) to find promising (n, r) combinations\n   - Phase B: Medium runs (10 min) on top candidates\n   - Phase C: Long runs (20 min) on best few\n2. Apply fix_direction after each phase\n- See: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`\n\n### Experiment 3: C++ Implementation\n1. Compile tree_packer with OpenMP: `g++ -O3 -march=native -std=c++17 -fopenmp`\n2. Run with high iterations: `-n 5000-10000 -r 16-256`\n3. Apply backward propagation post-processing\n- See: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n\n### Experiment 4: Hybrid Approach\n1. Combine multiple optimizers:\n   - bbox3 for initial optimization\n   - C++ local search for refinement\n   - Fix direction for rotation\n   - Backward propagation for small n\n2. Keep best solution across all methods\n\n### Experiment 5: Custom Local Search Improvements\n1. Implement additional move operators:\n   - Jostle algorithm (shift trees to create gaps, then compact)\n   - Gradient-based moves toward center\n   - Rotation-only optimization per tree\n2. Fine-grained step sizes for final polish\n\n## Validation Strategy\n1. Always validate for overlaps before submission\n2. Use STRtree for efficient collision detection\n3. Replace invalid configurations with known-good baseline\n4. Score locally before submitting\n\n## Key Insights from Kernels and Discussions\n\n1. **Lattice patterns emerge**: Trees tend to form crystalline arrangements with alternating orientations (blue/pink phases at ~90\u00b0 apart)\n\n2. **Boundary trees matter most**: Trees touching the bounding box boundary determine the score - focus optimization on these\n\n3. **Rotation is critical**: The fix_direction step can significantly reduce bounding box by rotating entire configuration\n\n4. **Incremental improvement**: Small improvements compound - even 1e-10 improvement per configuration adds up\n\n5. **Precision matters**: Use high-precision Decimal arithmetic to avoid floating-point errors\n\n6. **Symmetric vs Asymmetric**: Symmetric solutions appear optimal for some n values, but asymmetric solutions may win for larger n (from discussions)\n\n7. **Simulated Annealing Energy Function**: Design of the SA energy function is important - consider using bounding box side length directly\n\n## Algorithm Design Recommendations\n\n### For Simulated Annealing\n- Energy function: Use side_length (not side_length\u00b2/n) for individual configurations\n- Temperature schedule: Start high, decrease exponentially\n- Move operators: Combine translation, rotation, and swap moves\n- Accept criterion: exp(-delta_E / T) for worse solutions\n\n### For Local Search\n- Step sizes: Start with 0.01-0.05, decrease to 0.0001 for fine-tuning\n- Rotation steps: 5\u00b0, 2\u00b0, 0.8\u00b0, 0.3\u00b0, 0.1\u00b0 (progressively finer)\n- Directions: 8-directional (N, S, E, W, NE, NW, SE, SW)\n- Center-seeking: Move trees toward centroid of configuration\n\n### For Greedy Construction\n- Use weighted random angles (favor diagonal orientations for corner packing)\n- Place trees from outside-in, moving toward center until collision\n- Try multiple random starting positions, keep best\n\n## Files Reference\n- Sample submission: `/home/data/sample_submission.csv`\n- Getting started kernel: `../research/kernels/inversion_santa-2025-getting-started/`\n- bbox3 runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`\n- C++ implementation: `../research/kernels/smartmanoj_santa-claude/`\n- Validation/repair: `../research/kernels/jazivxt_why-not/`\n- Combined approach: `../research/kernels/saspav_santa-submission/`\n\n## Quick Start Code Template\n\n```python\nimport pandas as pd\nimport numpy as np\nfrom decimal import Decimal, getcontext\nfrom shapely import affinity\nfrom shapely.geometry import Polygon\nfrom shapely.ops import unary_union\nfrom shapely.strtree import STRtree\nfrom scipy.optimize import minimize_scalar\nfrom scipy.spatial import ConvexHull\n\ngetcontext().prec = 25\n\n# Tree polygon vertices (relative to center at origin, 0\u00b0 rotation)\nTX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]\nTY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]\n\ndef make_tree_polygon(x, y, deg):\n    \"\"\"Create a tree polygon at position (x,y) with rotation deg.\"\"\"\n    base = Polygon(zip(TX, TY))\n    rotated = affinity.rotate(base, deg, origin=(0, 0))\n    return affinity.translate(rotated, x, y)\n\ndef check_overlap(poly1, poly2):\n    \"\"\"Check if two polygons overlap (touching is OK).\"\"\"\n    return poly1.intersects(poly2) and not poly1.touches(poly2)\n\ndef calculate_score(trees_df, n):\n    \"\"\"Calculate score for n-tree configuration.\"\"\"\n    group = trees_df[trees_df['id'].str.startswith(f'{n:03d}_')]\n    polygons = []\n    for _, row in group.iterrows():\n        x = float(str(row['x'])[1:])\n        y = float(str(row['y'])[1:])\n        deg = float(str(row['deg'])[1:])\n        polygons.append(make_tree_polygon(x, y, deg))\n    \n    bounds = unary_union(polygons).bounds\n    side = max(bounds[2] - bounds[0], bounds[3] - bounds[1])\n    return side**2 / n\n\ndef total_score(trees_df):\n    \"\"\"Calculate total score for all configurations.\"\"\"\n    return sum(calculate_score(trees_df, n) for n in range(1, 201))\n```\n",
      "agent": "explorer",
      "timestamp": "2026-01-17T02:35:23.467208"
    },
    {
      "strategy": "# Christmas Tree Packing Optimization - Evolved Seed Prompt (Loop 2)\n\n## Current Status\n- Best CV score: 116.98 from tree_packer.exe optimization\n- Best LB score: N/A (no submissions yet)\n- Target: 68.931058 | Gap to target: ~48 points (still ~70% away)\n\n## Response to Evaluator\nThe evaluator correctly identified that:\n1. **The baseline approach (Python local search) was too weak** - Agreed. We've now switched to the C++ tree_packer.exe which is orders of magnitude faster.\n2. **bbox3 or C++ tree packer should be prioritized** - Implemented. We're now using tree_packer.exe with good results.\n3. **Backward propagation is important** - Implemented. We're running bp.exe after each optimization pass.\n\nThe evaluator's top priority was to get the high-performance tools working. This has been done successfully.\n\n## Progress Summary\nStarting from baseline 149.29, we've achieved:\n- After tree_packer.exe (n=10000, r=32): 127.03\n- After backward propagation: 125.15\n- After tree_packer.exe (n=15000, r=64): 119.32\n- After backward propagation: 119.28\n- After tree_packer.exe (n=20000, r=128): 116.98\n- After backward propagation: 116.98\n\n**Key insight**: The tree_packer.exe is effective but we're still far from the target of 68.93. The score is improving but at a decreasing rate. We need more aggressive optimization strategies.\n\n## Available Tools\n1. **tree_packer.exe** - C++ optimizer with OpenMP (26 threads)\n   - Parameters: -n (iterations), -r (restarts)\n   - Includes: squeeze, compaction, local search, simulated annealing, swap moves\n   - Location: /home/code/tree_packer.exe\n\n2. **bp.exe** - Backward propagation optimizer\n   - Removes trees from larger configurations to improve smaller ones\n   - Location: /home/code/bp.exe\n\n## Recommended Approaches (Priority Order)\n\n### 1. Extended Optimization Runs (CRITICAL)\nThe tree_packer.exe is showing diminishing returns. We need to:\n- Run with much higher iterations: -n 50000 or higher\n- Run with more restarts: -r 512 or higher\n- Run multiple passes, alternating with bp.exe\n\n### 2. Multi-Phase Optimization Strategy\nBased on the bbox3 runner kernel approach:\n- Phase A: Short runs (5 min) to find promising configurations\n- Phase B: Medium runs (15 min) on top candidates\n- Phase C: Long runs (30+ min) on best few\n- Apply fix_direction rotation optimization between phases\n\n### 3. Fix Direction Optimization\nThe kernels show that rotating the entire configuration can significantly reduce bounding box:\n- Use scipy.optimize.minimize_scalar to find optimal rotation angle\n- Apply to all configurations after each optimization pass\n- This is NOT currently being done by tree_packer.exe\n\n### 4. Overlap Validation and Repair\nBefore submission, validate all configurations for overlaps:\n- Use Shapely STRtree for efficient collision detection\n- Replace invalid configurations with known-good baseline\n\n### 5. Ensemble Best Solutions\nKeep track of best solution for each n-tree configuration across all runs:\n- Merge best solutions from different optimization runs\n- This can capture improvements that might be lost in later passes\n\n## What NOT to Try\n- Simple Python-based local search (too slow)\n- Single-pass optimization (need multiple passes)\n- Low iteration counts (need high iterations for convergence)\n\n## Validation Notes\n- Score is computed directly on solution quality (no train/test split)\n- Submission format: CSV with 's' prefix for precision\n- Total rows: 20100 (sum of 1+2+...+200)\n\n## Key Insights from Kernels\n1. **Lattice patterns emerge**: Trees tend to form crystalline arrangements\n2. **Boundary trees matter most**: Trees touching the bounding box determine the score\n3. **Rotation is critical**: fix_direction can significantly reduce bounding box\n4. **Incremental improvement**: Small improvements compound\n5. **Precision matters**: Use high-precision Decimal arithmetic\n\n## Next Steps\n1. Run tree_packer.exe with higher parameters (-n 50000 -r 512)\n2. Implement fix_direction rotation optimization\n3. Run multiple optimization passes\n4. Validate and submit to get LB feedback\n\n## Files Reference\n- Current submission: /home/submission/submission.csv (score ~116.98)\n- Tree packer: /home/code/tree_packer.exe\n- Backward propagation: /home/code/bp.exe\n- Research kernels: /home/code/research/kernels/",
      "agent": "evolver",
      "timestamp": "2026-01-17T09:33:41.712821"
    }
  ],
  "feedback_history": [
    {
      "feedback": "## What I Understood\n\nThe junior researcher is working on a 2D polygon packing optimization problem (Santa 2025 competition). They started with the sample submission (score 173.65), applied fix_direction rotation optimization (score 151.17), and then applied local search for small configurations (n<=30), achieving a score of 149.29. The target is 68.93, so they're still about 80 points away - roughly 2x the target score.\n\nThis is the first experiment, establishing a baseline. The researcher correctly identified that more sophisticated optimization is needed (bbox3 binary or C++ implementation from kernels).\n\n## Technical Execution Assessment\n\n**Validation**: N/A for this optimization problem - there's no train/test split. The score is computed directly on the solution quality.\n\n**Leakage Risk**: None - this is a pure optimization problem, not a prediction task.\n\n**Score Integrity**: The metrics.json shows a clear progression:\n- Baseline: 173.65\n- After fix_direction: 151.17\n- After local search: 149.29\n\nThese scores are reasonable and show incremental improvement. The scoring function appears correctly implemented based on the EDA notebook.\n\n**Code Quality**: The experiment folder only contains metrics.json - the actual code that was run is not preserved in the experiment folder. This is a minor issue for reproducibility, but the session_state.json captures the key results.\n\nVerdict: **TRUSTWORTHY** - The results are valid, though code preservation could be improved.\n\n## Strategic Assessment\n\n**Approach Fit**: The researcher correctly identified this as an optimization problem requiring sophisticated algorithms. The initial approach (fix_direction + simple local search) is a reasonable starting point but is far too weak to reach the target.\n\n**Effort Allocation**: This is where the critical issue lies. The researcher has:\n1. \u2705 Correctly identified the problem type\n2. \u2705 Established a baseline\n3. \u274c NOT leveraged the powerful tools available in the kernels\n\nThe research folder contains **ready-to-use implementations** that achieve scores near the target:\n- `bbox3` binary optimizer (used by top kernels)\n- C++ tree packer with OpenMP parallelization\n- Multi-phase optimization strategies\n- Backward propagation for small n\n\n**Assumptions**: The researcher's local search implementation is likely too simple. The kernels show that effective optimization requires:\n- Simulated annealing with proper temperature schedules\n- Squeeze and compaction operators\n- Swap moves between trees\n- Multi-start with different initial angles\n- Backward propagation (using n-tree solution to derive n-1 solution)\n\n**Blind Spots**: \n1. **The bbox3 binary is the key tool** - Most top solutions use this external optimizer. The researcher should prioritize getting this working.\n2. **The C++ implementation in smartmanoj_santa-claude** provides a complete solution with all the advanced operators.\n3. **Multi-phase optimization** (from yongsukprasertsuk kernel) shows how to efficiently allocate compute time.\n\n**Trajectory**: This is experiment 1, so trajectory assessment is premature. However, the gap between current score (149.29) and target (68.93) is substantial - the current approach won't close this gap through incremental improvements.\n\n## What's Working\n\n1. **Problem understanding is correct** - The researcher correctly identified this as a 2D polygon packing problem\n2. **Scoring function is implemented correctly** - The progression of scores makes sense\n3. **Research phase was thorough** - The seed_prompt.txt shows excellent research on available approaches\n4. **Fix_direction optimization is valuable** - This is a key component used by all top solutions\n\n## Key Concerns\n\n### 1. Not Using Available High-Performance Tools\n- **Observation**: The kernels contain bbox3 binary and C++ implementations that achieve near-target scores\n- **Why it matters**: The current Python-based local search is orders of magnitude slower and less effective than these tools\n- **Suggestion**: Priority #1 should be getting bbox3 or the C++ tree packer running. These are proven to work.\n\n### 2. Local Search is Too Simple\n- **Observation**: Only applied to n<=30 configurations, using basic moves\n- **Why it matters**: The score is dominated by larger n values (the metric is s\u00b2/n, so larger n contributes more)\n- **Suggestion**: Need to optimize ALL configurations, especially n=100-200 which contribute most to the score\n\n### 3. Missing Key Optimization Operators\n- **Observation**: The current approach lacks squeeze, compaction, swap moves, simulated annealing\n- **Why it matters**: These operators are essential for escaping local minima and achieving tight packings\n- **Suggestion**: Either use the C++ implementation which has all these, or implement them in Python\n\n### 4. No Multi-Start Strategy\n- **Observation**: Single starting point optimization\n- **Why it matters**: Polygon packing has many local minima - multiple restarts are essential\n- **Suggestion**: The bbox3 runner uses `-r` parameter for restarts, C++ uses multi-angle starts\n\n## Top Priority for Next Experiment\n\n**CRITICAL: Get bbox3 or C++ tree packer working immediately.**\n\nThe gap from 149.29 to 68.93 is too large to close with incremental Python improvements. The kernels provide proven solutions:\n\n1. **Option A (Recommended)**: Adapt the bbox3 runner from `research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`\n   - This is the most commonly used approach in top solutions\n   - Multi-phase optimization (short runs \u2192 medium runs \u2192 long runs)\n   - Already includes fix_direction and overlap repair\n\n2. **Option B**: Compile and run the C++ tree packer from `research/kernels/smartmanoj_santa-claude/`\n   - Full implementation with all operators (squeeze, compaction, SA, swap, local search)\n   - Includes backward propagation for small n\n   - Uses OpenMP for parallelization\n\n3. **After getting one of these working**: Apply backward propagation to improve small n configurations\n\nThe target of 68.93 is achievable - discussions mention scores around 67 are possible. But this requires using the sophisticated optimization tools, not basic local search.\n\n**Do not spend more time on Python-based local search improvements.** The ROI is too low. Get the proven tools working first.\n",
      "experiment_id": "exp_000",
      "agent": "evaluator",
      "timestamp": "2026-01-17T02:45:25.292006"
    }
  ],
  "data_findings": [
    {
      "finding": "This is a 2D polygon packing optimization problem. Goal: pack Christmas tree-shaped polygons (1-200 trees) into smallest square bounding box. Metric: sum of s\u00b2/n for each n-tree configuration. Lower is better. Target score: 68.931058",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "Key techniques from kernels: 1) bbox3 binary optimizer for packing, 2) fix_direction rotation optimization using scipy.optimize.minimize_scalar to find best rotation angle, 3) Simulated annealing with local search, 4) Squeeze/compaction to reduce bounding box, 5) Overlap detection using Shapely STRtree, 6) Multi-phase optimization (short runs to find promising params, then longer runs)",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "C++ implementation with OpenMP parallelization is used for speed. Key operators: squeeze, compaction, local search (8-directional moves + rotation), simulated annealing, swap moves, multi-start with different angles. Backward propagation: use n-tree solution to derive (n-1)-tree solution by removing boundary-touching trees.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Key optimization techniques for 2D irregular polygon packing: 1) Bottom-left placement heuristic, 2) Jostle algorithm for local search, 3) Simulated annealing, 4) Genetic algorithms for sequence optimization, 5) Particle swarm optimization, 6) Hyper-heuristics combining multiple low-level heuristics, 7) Squeeze/compaction moves, 8) Rotation optimization, 9) No-fit polygon for collision detection",
      "source": "Web search: 2D irregular polygon packing optimization",
      "agent": "explorer"
    },
    {
      "finding": "From discussions: 1) Symmetric solutions appear optimal for some n values, 2) Asymmetric solutions may win for larger n, 3) Simulated annealing energy function design is important, 4) Backward propagation (generating n-1 from n) is a valid strategy, 5) Score around 67 is achievable with good optimization",
      "source": "../research/discussions.json",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best optimization algorithms for 2D irregular polygon packing problems?",
      "finding": "Two\u2011dimensional irregular polygon packing is a combinatorial optimisation problem that appears in sheet\u2011metal nesting, textile cutting, furniture layout and many other manufacturing processes.  Because the feasible region is highly non\u2011convex and the search space grows exponentially with the number of pieces, exact methods are limited to very small instances and most practical solvers rely on sophisticated heuristics and meta\u2011heuristics\u202f([Frontiers](https://www.frontiersin.org/articles/10.3389/fmech.2022.966691/full)).\n\nThe most successful approaches reported in the recent literature combine a constructive placement rule (e.g., bottom\u2011left, shelf or strip\u2011packing heuristics) with a powerful improvement phase.  Bottom\u2011left and shelf\u2011based algorithms are often used as a fast initialiser, after which local\u2011search moves such as \u201cjostle\u201d, rotation, and piece\u2011swap are applied\u202f([Taylor\u202f&\u202fFrancis](https://www.taylorfrancis.com/chapters/edit/10.1201/9781351236423-33/practical-algorithms-two-dim",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 100
}