# Santa 2025 - Christmas Tree Packing Challenge: Seed Prompt

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to fit Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding boxes for configurations of n=1 to n=200 trees.

**Scoring Metric:** score = Σ(side_length²/n) for n=1 to 200. Lower is better.
**Target Score:** Beat 68.901319

## Tree Shape Specification
Each tree is a 15-vertex polygon with:
- Trunk: 0.15 wide, 0.2 tall (bottom at y=-0.2)
- Base tier: 0.7 wide at y=0
- Middle tier: 0.4 wide at y=0.25
- Top tier: 0.25 wide at y=0.5
- Tip: at y=0.8
- Position defined by center of trunk top (0,0)
- Trees can be rotated by any angle (continuous rotation allowed)

## Key Techniques from Public Kernels

### 1. External Binary Optimizers (Most Effective)
From `../research/kernels/saspav_santa-submission/` and `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`:
- **bbox3**: Binary optimizer that runs with parameters -n (iterations) and -r (restarts)
- **shake_public**: Local optimization binary for fine-tuning placements
- These are pre-compiled C++ tools that significantly outperform pure Python approaches

### 2. Rotation Tightening (fix_direction)
After placing trees, optimize the global rotation angle of the entire configuration:
```python
from scipy.optimize import minimize_scalar
from scipy.spatial import ConvexHull

def optimize_rotation(trees):
    # Get all polygon vertices
    all_points = [list(tree.polygon.exterior.coords) for tree in trees]
    points_np = np.array(all_points).reshape(-1, 2)
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    # Find optimal rotation angle
    res = minimize_scalar(
        lambda a: calculate_bbox_side_at_angle(a, hull_points),
        bounds=(0.001, 89.999), method='bounded'
    )
    return res.x, res.fun
```

### 3. C++ Implementation for Speed
From `../research/kernels/smartmanoj_santa-claude/`:
- **Simulated Annealing** with swap moves and multi-start
- **Local Search**: 8-directional moves + rotation adjustments
- **Compaction**: Move trees toward center iteratively
- **Squeeze**: Scale entire configuration uniformly
- **Backward Propagation**: Remove boundary-touching trees from n-config to improve (n-1)-config

### 4. Greedy Initial Placement
From `../research/kernels/inversion_santa-2025-getting-started/`:
- Start trees far from center at weighted random angles
- Move toward center until collision
- Back up until no overlap
- Weight angles by |sin(2*angle)| to favor diagonal placements (fills corners better)

## Collision Detection
- Use Shapely library for Python implementation
- STRtree for spatial indexing (fast neighbor queries)
- Point-in-polygon test + segment intersection for precise overlap detection
- Bounding box pre-filtering for efficiency

## Advanced Simulated Annealing Techniques (from research)

### Cooling Schedules
- **Geometric cooling**: T_new = alpha * T_old, where alpha ∈ [0.9995, 0.99999]
- **Adaptive cooling**: Adjust cooling rate based on acceptance ratio
- **Hierarchical SA**: Inner level optimizes placement, outer level adjusts container size

### Move Operators
1. **Translation moves**: Small random displacements in x, y
2. **Rotation moves**: Small angle changes (±0.1° to ±5°)
3. **Swap moves**: Exchange positions of two trees
4. **Collision-free region moves**: Place items on vertices of collision-free zones
5. **Adaptive neighborhood**: Modify step size based on acceptance rate
   - If acceptance < 40%: decrease step size
   - If acceptance > 60%: increase step size

### Anisotropic Search
- Use different step sizes for different directions
- Adjust step sizes based on partial derivatives of objective function

## Recommended Approach Strategy

### Approach 1: Leverage Existing Optimizers (Fastest to Implement)
1. Start with a good baseline submission (from public kernels or sample)
2. Run bbox3 with various -n and -r parameters
3. Apply shake_public for local refinement
4. Apply rotation tightening (fix_direction)
5. Validate for overlaps and repair if needed

### Approach 2: Custom C++ Optimizer
Implement in C++ for speed:
1. **Initialization**: Greedy placement with weighted random angles
2. **Simulated Annealing**: 
   - Moves: translate, rotate, swap positions
   - Temperature schedule: start high, decay exponentially
   - Accept worse solutions probabilistically
3. **Local Search**: Fine-tune with small moves
4. **Compaction**: Pull trees toward center
5. **Backward Propagation**: Use n-config to improve (n-1)-config

### Approach 3: Hybrid Python/C++ Pipeline
1. Python for orchestration and validation
2. C++ for compute-intensive optimization
3. Iterate: optimize → validate → repair → optimize

## Implementation Notes

### Decimal Precision
Use high precision for coordinates to avoid floating-point errors:
```python
from decimal import Decimal, getcontext
getcontext().prec = 25  # or higher
```

### Submission Format
- Coordinates must be strings prefixed with 's': `s0.123456`
- Format: `id,x,y,deg` where id is `NNN_T` (N=tree count, T=tree index)
- Coordinates constrained to -100 ≤ x, y ≤ 100

### Validation
Always check for overlaps before submission:
```python
def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

## Optimization Parameters (from kernels)

### bbox3 Parameters
- Short runs: timeout=120s, n=1000-2000, r=30-90
- Medium runs: timeout=600s, n values from best short runs
- Long runs: timeout=1200s, top candidates only

### Simulated Annealing Parameters
- Initial temperature: high enough to accept 50-80% of moves initially
- Cooling rate: 0.9995-0.99999 per iteration
- Move sizes: start large (0.1), decrease over time
- Iterations per temperature: 100-1000 depending on n

## Key Insights from Discussions

1. **Asymmetric solutions often win**: Don't constrain to symmetric patterns
2. **Boundary trees matter most**: Focus optimization on trees touching the bounding box
3. **Small n values are easier**: Larger n requires more sophisticated optimization
4. **Rotation is crucial**: Global rotation tightening can significantly reduce bounding box
5. **No-fit polygon**: Determines collision-free area for each polygon before placement

## Files to Reference
- `../research/kernels/inversion_santa-2025-getting-started/` - Basic greedy algorithm
- `../research/kernels/saspav_santa-submission/` - Pipeline with bbox3 + shake
- `../research/kernels/smartmanoj_santa-claude/` - C++ SA implementation
- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - bbox3 runner with phases

## Priority Order for Experiments

1. **Use existing optimized submission** from public kernels as baseline
2. **Run bbox3 optimizer** with various parameters (most impactful)
3. **Apply rotation tightening** to all configurations
4. **Implement backward propagation** to improve smaller n from larger n
5. **Custom SA optimizer** if time permits

## Expected Score Progression
- Sample submission: ~100+
- Basic greedy: ~80-90
- With bbox3: ~70-75
- With full optimization pipeline: ~68-69 (target range)

## Critical Success Factors
1. **Speed**: Use C++ or compiled binaries for optimization loops
2. **Precision**: Use high-precision arithmetic to avoid floating-point errors
3. **Validation**: Always check for overlaps before submission
4. **Iteration**: Run multiple optimization passes with different parameters
5. **Focus on boundary**: Trees touching the bounding box determine the score
