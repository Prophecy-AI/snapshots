{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-24T22:30:00.897815",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D bin packing optimization problem: fit Christmas tree shapes (15-vertex polygons) into smallest square boxes for n=1 to 200 trees. Score = sum of (side_length^2 / n) for all n. Lower is better.",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "Key optimization tools used: bbox3 binary optimizer, shake_public binary for local optimization, fix_direction for rotation tightening. These are external compiled binaries that optimize tree placements.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Rotation tightening technique: After placing trees, optimize the global rotation angle of the entire configuration to minimize bounding box. Uses scipy.optimize.minimize_scalar on convex hull points.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Tree shape: 15-vertex polygon with trunk (0.15 wide, 0.2 tall), base tier (0.7 wide), middle tier (0.4 wide), top tier (0.25 wide), tip at y=0.8. Position defined by center of trunk top.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "C++ optimization techniques: Simulated Annealing with swap moves, multi-start with different angles, local search (8-directional moves + rotation), compaction (move trees toward center), squeeze (scale configuration), backward propagation (remove trees from larger configs to improve smaller ones).",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Collision detection: Uses point-in-polygon test, segment intersection, and bounding box pre-filtering for efficiency. Shapely library used in Python; custom C++ implementation for speed.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Backward propagation: Start from n=200, remove boundary-touching trees one at a time, check if resulting (n-1) config is better than current best for that n. Propagates improvements downward.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization problems?",
      "finding": "The best algorithms for 2D irregular polygon packing optimization problems encompass a variety of approaches, with many focusing on metaheuristic techniques due to the complexity and combinatorial nature of these problems. Metaheuristics such as genetic algorithms, simulated annealing, and tabu search are frequently employed to explore large solution spaces effectively ([Springer](https://link.springer.com/article/10.1023/A:1012590107280), [Frontiers](https://www.frontiersin.org/articles/10.3389/fmech.2022.966691/full)). For instance, a hybrid approach combining genetic algorithms with linear programming has shown promising results in optimizing packing of convex polygons without rotation, improving approximation guarantees ([arXiv](https://export.arxiv.org/pdf/2308.08523v1.pdf)). \n\nAdditionally, heuristic methods such as the Djang and Finch heuristic, adapted for irregular shapes, have been successfully applied, especially when paired with efficient placement routines to reduce comput",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 100
}