{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-24T22:30:00.897815",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D bin packing optimization problem: fit Christmas tree shapes (15-vertex polygons) into smallest square boxes for n=1 to 200 trees. Score = sum of (side_length^2 / n) for all n. Lower is better.",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "Key optimization tools used: bbox3 binary optimizer, shake_public binary for local optimization, fix_direction for rotation tightening. These are external compiled binaries that optimize tree placements.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Rotation tightening technique: After placing trees, optimize the global rotation angle of the entire configuration to minimize bounding box. Uses scipy.optimize.minimize_scalar on convex hull points.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Tree shape: 15-vertex polygon with trunk (0.15 wide, 0.2 tall), base tier (0.7 wide), middle tier (0.4 wide), top tier (0.25 wide), tip at y=0.8. Position defined by center of trunk top.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "C++ optimization techniques: Simulated Annealing with swap moves, multi-start with different angles, local search (8-directional moves + rotation), compaction (move trees toward center), squeeze (scale configuration), backward propagation (remove trees from larger configs to improve smaller ones).",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Collision detection: Uses point-in-polygon test, segment intersection, and bounding box pre-filtering for efficiency. Shapely library used in Python; custom C++ implementation for speed.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Backward propagation: Start from n=200, remove boundary-touching trees one at a time, check if resulting (n-1) config is better than current best for that n. Propagates improvements downward.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "SA cooling schedules: Geometric/exponential cooling (T_new = alpha * T_old, alpha ~0.9995-0.99999) is most common. Adaptive cooling adjusts based on acceptance rate. Hierarchical SA: inner level optimizes placement, outer level adjusts container size.",
      "source": "Web search: simulated annealing cooling schedules",
      "agent": "explorer"
    },
    {
      "finding": "SA move operators for packing: (1) Collision-free region moves - place items on vertices of collision-free zones, (2) Adaptive neighborhood - modify step size based on acceptance rate, (3) Anisotropic search - different step sizes for different directions.",
      "source": "Web search: simulated annealing move operators",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization problems?",
      "finding": "The best algorithms for 2D irregular polygon packing optimization problems encompass a variety of approaches, with many focusing on metaheuristic techniques due to the complexity and combinatorial nature of these problems. Metaheuristics such as genetic algorithms, simulated annealing, and tabu search are frequently employed to explore large solution spaces effectively ([Springer](https://link.springer.com/article/10.1023/A:1012590107280), [Frontiers](https://www.frontiersin.org/articles/10.3389/fmech.2022.966691/full)). For instance, a hybrid approach combining genetic algorithms with linear programming has shown promising results in optimizing packing of convex polygons without rotation, improving approximation guarantees ([arXiv](https://export.arxiv.org/pdf/2308.08523v1.pdf)). \n\nAdditionally, heuristic methods such as the Djang and Finch heuristic, adapted for irregular shapes, have been successfully applied, especially when paired with efficient placement routines to reduce comput",
      "agent": "explorer"
    },
    {
      "query": "What are the best simulated annealing cooling schedules and move operators for 2D polygon packing?",
      "finding": "Simulated annealing (SA) is a widely used metaheuristic for solving 2D polygon packing problems, including irregular and non-convex shapes. The effectiveness of SA largely depends on the choice of cooling schedules and move operators. For cooling schedules, polynomial-time schedules have been explored, with some studies demonstrating their ability to achieve optimal packing by gradually lowering the temperature in a controlled manner ([INFERRED](https://pubsonline.informs.org/doi/10.1287/moor.13.2.311)). Adaptive cooling schedules, such as geometrical or geometrical-like schedules, are also common, as they allow for a balance between exploration and exploitation during the search process ([INFERRED](https://doi.org/10.3182/20081205-2-CL-4009.00020); [INFERRED](https://s100.copyright.com/AppDispatchServlet?publisherName=ELS&contentID=S147466701535549X)).\n\nRegarding move operators, several strategies have been proposed to improve packing efficiency. These include collision-free region-ba",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 100
}