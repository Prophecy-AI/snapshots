# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D packing optimization problem where we need to fit Christmas tree-shaped polygons (15 vertices each) into the smallest possible square bounding box for N=1 to 200 trees.

**Scoring:** score = Σ(side_n² / n) for n=1 to 200 (lower is better)
**Target Score:** 68.919154
**Current Best:** ~70.676102 (from pre-optimized santa-2025.csv)
**Gap:** ~1.757 points (2.49%)

## Tree Geometry
The Christmas tree has 15 vertices defining its shape:
- TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
- TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
- Each tree can be positioned (x, y) and rotated (deg)

## Pre-Optimized Resources
**CRITICAL:** Use pre-optimized solutions as starting points:
- `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/santa-2025.csv` - Best known solution (~70.676)
- `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/bbox3` - C++ optimizer binary
- Multiple ensemble files available in the preoptimized folder

## Top Kernel Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** tree_packer_v21.cpp (from smartmanoj/santa-claude)
The most advanced optimizer combining multiple techniques:
- **Simulated Annealing** with high temperature for exploration
- **Squeeze** - scale all trees toward center until overlap
- **Compaction** - move individual trees toward center
- **Local Search** - 8-directional moves + rotation optimization
- **Swap Moves** - exchange positions of two trees
- **Multi-start** - multiple random angle restarts
- **Backward Propagation** - use N config to improve N-1

**Compilation:**
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer_v21 tree_packer_v21.cpp
```

**Usage:**
```bash
OMP_NUM_THREADS=26 ./tree_packer_v21 -n 100000 -r 64
```

### 2. **[HIGH PRIORITY]** bbox3.cpp (from jazivxt/why-not)
C++ optimizer with advanced features:
- Complex number vector coordination
- Fluid dynamics-based movement
- Hinge pivot for rotation
- Density gradient flow
- Global boundary tension
- Aggressive overlap repair

**Key Parameters:**
- `-n` iterations (try 15000+)
- `-r` restarts (try 80+)

### 3. **[HIGH PRIORITY]** Backward Propagation (bp.cpp)
Transfers solutions from larger N to smaller N:
- For each N from 200 down to 2
- Try removing each tree that touches the bounding box
- If resulting (N-1) config is better than stored, save it

**Implementation:**
```cpp
for (int n = 200; n >= 2; n--) {
    for each tree touching boundary:
        candidate = remove_tree(config[n], tree_idx)
        if (candidate.side() < best_sides[n-1]):
            config[n-1] = candidate
}
```

### 4. **[MEDIUM PRIORITY]** fix_direction / Rotation Optimization
Optimize the global rotation angle to minimize bounding box:
- Use scipy.optimize.minimize_scalar on convex hull
- Try angles from 0 to 90 degrees
- Apply rotation to all trees in configuration

### 5. **[MEDIUM PRIORITY]** Lattice/Grid-Based Approach for Large N
For N >= 58, consider crystalline packing:
- Start with 2 base trees in optimal configuration
- Translate in x and y directions to create grid
- Parameters: nt = [rows, cols] where rows*cols >= N

## Optimization Loop Strategy

**Recommended Pipeline:**
1. Start from pre-optimized santa-2025.csv
2. Run tree_packer_v21 with high iterations (n=100000, r=64)
3. Run backward propagation
4. Run fix_direction for rotation optimization
5. Repeat loop until convergence

**Time Budget:**
- Run optimizers for HOURS, not minutes
- The pre-optimized solution is at a tight local optimum
- Need aggressive exploration to escape

## Key Technical Notes

### Precision
- Use `long double` in C++ for maximum precision
- Use `Decimal` with prec=25+ in Python
- Avoid floating-point errors in collision detection

### Collision Detection
- Bounding box pre-check for speed
- Point-in-polygon test
- Segment intersection test
- Trees can touch but not overlap

### Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
```
- Values prefixed with 's' to preserve precision
- Coordinates must be in range [-100, 100]

## What NOT to Try
- Short optimization runs (< 1 hour) - won't escape local optima
- Simple ensemble without optimization - santa-2025.csv dominates all N values
- Python-based optimization - too slow, use C++
- fix_direction without validation - can cause precision loss and overlaps

## Validation
- Always check for overlaps before submission
- CV = LB for this optimization problem (no distribution shift)
- Use the scoring function: Σ(side² / n)

## Small N Focus (High Impact)
N=1 to N=10 have lowest efficiency and highest score contribution:
- N=1: side=0.813, contributes 0.66 to score
- N=2: side=0.950, contributes 0.45 to score
- Try exhaustive angle search for small N (0.001 degree increments)

## Advanced Techniques from Research

### No-Fit Polygon (NFP) Methods
- Compute all feasible relative placements between pairs of polygons
- Use Minkowski sum or decomposition algorithm
- Feed to placement heuristic for efficient packing

### Genetic Algorithm + Pixel-Based Overlap Detection
- Use GA for global search
- Pixel counting for fast overlap detection
- Expanded-area-based placement strategy

### Shelf Packing Algorithms
- Sort objects by height and orientation
- Stack shelves to build final solution
- Effective for convex polygons

## Expected Improvements
- tree_packer_v21 with long runs: potential 1-2 point improvement
- Backward propagation: helps propagate improvements to smaller N
- Lattice approach for large N: potential for tighter packing
- Combined approach needed to close the 1.757 point gap

## Kernel References
- `../research/kernels/smartmanoj_santa-claude/` - tree_packer_v21.cpp, bp.cpp
- `../research/kernels/jazivxt_why-not/` - bbox3.cpp
- `../research/kernels/saspav_santa-submission/` - Combined approach
- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - bbox3 runner
- `../research/kernels/inversion_santa-2025-getting-started/` - Basic greedy algorithm

## Critical Insight
The pre-optimized santa-2025.csv is at a very tight local optimum. Standard optimization approaches (SA, local search) have been tried extensively with NO improvements. To beat the target:

1. **Run MUCH longer** - hours, not minutes
2. **Use multiple restarts** with different random seeds
3. **Try fundamentally different approaches** - lattice packing, constructive methods
4. **Focus on small N** - highest score contribution per improvement
5. **Combine techniques** - tree_packer + backward_prop + fix_direction in loop
