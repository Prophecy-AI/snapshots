# Santa 2025 - Christmas Tree Packing Optimization

## Problem Summary
Pack N Christmas trees (N=1 to 200) into the smallest possible square bounding box. Each tree is a fixed-shape polygon that can be positioned (x, y) and rotated (deg). Score = sum of (side_length² / N) for all N values. Lower is better.

## Current Status
- **Best achieved score**: ~70.625-70.676 (from pre-optimized CSVs)
- **Target score**: 68.894234
- **Gap**: ~1.73-1.78 points (2.5% improvement needed)
- **CV-LB relationship**: EXACT match (local scoring = leaderboard scoring)

## CRITICAL INSIGHT: Local Optimum Problem
All standard optimization approaches (SA, bbox3, tree_packer, tessellation) converge to the SAME local optimum (~70.6). After 29+ experiments in previous runs:
- SA with different parameters: NO improvement
- bbox3 optimizer: NO improvement  
- Tessellation approaches: NO improvement
- Ensemble of symmetric solutions: NO improvement
- Random restarts: NO improvement

**The pre-optimized baseline is at an EXTREMELY STRONG local optimum.**

## Efficiency Analysis by N Range
From previous analysis:
- **N=1-10**: 37-65% efficiency (WORST - most room for improvement!)
- **N=11-50**: 65-66% efficiency
- **N=51-100**: 68-72% efficiency
- **N=101-200**: 72-73% efficiency (BEST)

Score contribution by range:
- N=1-10: 4.33 points (6.1%)
- N=11-50: 14.70 points (20.8%)
- N=51-100: 17.61 points (24.9%)
- N=101-150: 17.14 points (24.3%)
- N=151-200: 16.84 points (23.8%)

## Key Techniques from Public Kernels

### 1. bbox3 C++ Optimizer (SA-based)
- Binary optimizer using simulated annealing
- Parameters: -n (iterations), -r (radius)
- Used by top kernels (saspav, yongsukprasertsuk)
- **Limitation**: Converges to same local optimum

### 2. tree_packer_v21.cpp (smartmanoj)
- Multi-start SA with different angle restarts
- Swap move operator
- Boundary tree identification for targeted moves
- Tree removal cascade (N→N-1)
- OpenMP parallelization
- **Limitation**: Also converges to same local optimum

### 3. fix_direction Rotation Optimization
- Optimizes global rotation angle of entire configuration
- Uses scipy.optimize.minimize_scalar
- Finds angle that minimizes bounding box
- Quick improvement pass after SA

### 4. Ensemble Approach (jonathanchan)
- Collect solutions from 19+ sources (datasets, notebooks, GitHub)
- Take best score for each N value independently
- Sources: bucket-of-chump, SmartManoj GitHub, telegram shared, etc.
- **Key insight**: N=1 optimal is exactly 45 degrees rotation

### 5. Fractional Translation
- Construct large-N solutions from small-N by translations
- Identify translations shorter than box length
- Can find non-obvious packing arrangements

## Tree Geometry
```
trunk_w = 0.15, trunk_h = 0.2
base_w = 0.7, mid_w = 0.4, top_w = 0.25
tip_y = 0.8, tier_1_y = 0.5, tier_2_y = 0.25
base_y = 0.0, trunk_bottom_y = -0.2
```
15-vertex polygon with 3-tier Christmas tree shape.

## Pre-optimized Baselines Available
Check `/home/nonroot/snapshots/santa-2025/` for pre-optimized submissions:
- Latest snapshot: 21198893057 (score ~70.625)
- Contains submission.csv ready to use

## RECOMMENDED APPROACHES (Priority Order)

### 1. [HIGHEST PRIORITY] Focus on Small N (1-10)
Small N values have WORST efficiency and contribute 4.33 points.
- N=1: Verify optimal is 45° (score ~0.661)
- N=2-10: Try exhaustive search with fine angle steps (0.1°)
- These are small enough for brute-force optimization

### 2. [HIGH PRIORITY] Asymmetric Layouts for N < 60
Web search confirms "asymmetry yields better scores for N < 60".
- Generate completely NEW layouts from scratch with NO symmetry
- Try spiral placement, random placement with local optimization
- Different initial configurations (not grid-based)

### 3. [MEDIUM PRIORITY] External Solution Mining
- Check for newer public kernels with better scores
- Look for datasets containing optimized solutions
- The target of 68.89 suggests someone has achieved this

### 4. [MEDIUM PRIORITY] Constructive Approaches
Since all local search converges to same optimum, try:
- Greedy backtracking with beam search
- Build solutions tree-by-tree from scratch
- Random initialization + optimization (not from pre-optimized CSV)

### 5. [LOW PRIORITY] Crystalline Packing for Large N
- Regular geometric lattices for N > 58
- Hexagonal packing patterns
- Tessellation-based approaches

## What NOT to Try (Proven Ineffective)
- ❌ More SA/bbox3 optimization (converges to same optimum)
- ❌ Parameter tuning on existing optimizers
- ❌ Ensemble of symmetric solutions (all at same local optimum)
- ❌ Random restarts with same algorithm
- ❌ Running optimizers longer (diminishing returns)

## Validation Notes
- CV = LB exactly for this deterministic optimization problem
- Use Shapely for overlap detection (STRtree for efficiency)
- Decimal precision (30 digits) for coordinates
- Submission format: x, y, deg with 's' prefix (e.g., "s0.123")

## Code Resources
- Kernels: `../research/kernels/`
  - `saspav_santa-submission/` - bbox3 + fix_direction
  - `smartmanoj_santa-claude/` - tree_packer_v21.cpp
  - `jonathanchan_santa25-ensemble-sa-fractional-translation/` - ensemble approach
  - `yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - bbox3 runner

## Submission Strategy
- 100 submissions available
- Submit after EVERY experiment that produces valid submission
- CV = LB, so local validation is reliable
- Focus on experiments that try FUNDAMENTALLY DIFFERENT approaches

## Key Questions to Answer
1. Can we beat baseline for just N=10? N=20? (Test small N first)
2. What patterns emerge in optimal small-N solutions?
3. Are there better public solutions we haven't found?
4. Can constructive approaches escape the local optimum?
