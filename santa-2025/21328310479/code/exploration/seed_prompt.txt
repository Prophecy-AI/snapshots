# Santa 2025 - Christmas Tree Packing Optimization

## Problem Summary
Pack N Christmas trees (N=1 to 200) into the smallest possible square bounding box. Each tree is a fixed-shape polygon that can be positioned (x, y) and rotated (deg). Score = sum of (side_length² / N) for all N values. Lower is better.

## Current Status
- **Best achieved score**: 70.625918 (from pre-optimized snapshot)
- **Target score**: 68.894234
- **Gap**: 1.73 points (2.45% improvement needed)
- **CV-LB relationship**: EXACT match (local scoring = leaderboard scoring)

## CRITICAL INSIGHT: Local Optimum Problem
All standard optimization approaches (SA, bbox3, tree_packer, tessellation) converge to the SAME local optimum (~70.6). After 29+ experiments in previous runs:
- SA with different parameters: NO improvement
- bbox3 optimizer: NO improvement  
- Tessellation approaches: NO improvement
- Ensemble of symmetric solutions: NO improvement
- Random restarts: NO improvement

**The pre-optimized baseline is at an EXTREMELY STRONG local optimum.**

## Score Analysis by N Range
Current best submission breakdown:
- **N=1-50**: 19.03 points (27.0%)
- **N=51-100**: 17.61 points (24.9%)
- **N=101-150**: 17.14 points (24.3%)
- **N=151-200**: 16.84 points (23.8%)

Worst N values (highest per-N scores):
- N=1: 0.661250 (OPTIMAL - cannot improve, 45° is theoretical minimum)
- N=2: 0.450779
- N=3: 0.434745
- N=4: 0.416545
- N=5: 0.416850

**Key insight**: N=1 is already at theoretical optimum. Focus on N=2-10 for improvements.

## Key Techniques from Public Kernels

### 1. bbox3 C++ Optimizer (SA-based)
- Binary optimizer using simulated annealing
- Parameters: -n (iterations), -r (radius)
- Used by top kernels (saspav, yongsukprasertsuk)
- **Limitation**: Converges to same local optimum

### 2. tree_packer_v21.cpp (smartmanoj)
- Multi-start SA with different angle restarts
- Swap move operator
- Boundary tree identification for targeted moves
- Tree removal cascade (N→N-1)
- OpenMP parallelization
- **Limitation**: Also converges to same local optimum

### 3. fix_direction Rotation Optimization
- Optimizes global rotation angle of entire configuration
- Uses scipy.optimize.minimize_scalar
- Finds angle that minimizes bounding box
- Quick improvement pass after SA

### 4. Ensemble Approach (jonathanchan)
- Collect solutions from 19+ sources (datasets, notebooks, GitHub)
- Take best score for each N value independently
- Sources: bucket-of-chump, SmartManoj GitHub, telegram shared, etc.
- **Key insight**: N=1 optimal is exactly 45 degrees rotation

### 5. Backward Propagation (bp.cpp)
- Start from N=200, cascade improvements down to N=2
- For each N, try removing boundary-touching trees
- If removal improves N-1 configuration, save it
- Run after tree_packer for additional gains

### 6. Fractional Translation
- Construct large-N solutions from small-N by translations
- Identify translations shorter than box length
- Can find non-obvious packing arrangements

## Tree Geometry
```
trunk_w = 0.15, trunk_h = 0.2
base_w = 0.7, mid_w = 0.4, top_w = 0.25
tip_y = 0.8, tier_1_y = 0.5, tier_2_y = 0.25
base_y = 0.0, trunk_bottom_y = -0.2
```
15-vertex polygon with 3-tier Christmas tree shape.
At 0°: width=0.7, height=1.0
At 45°: bounding box side = 0.813173 (minimum for single tree)

## Pre-optimized Baselines Available
Check `/home/nonroot/snapshots/santa-2025/` for pre-optimized submissions:
- Latest snapshot: 21198893057 (score 70.625918)
- Contains submission.csv ready to use
- Copy this as starting point: `cp /home/nonroot/snapshots/santa-2025/21198893057/submission/submission.csv .`

## External Data Sources for Ensemble
1. **bucket-of-chump** dataset on Kaggle
2. **SmartManoj GitHub**: `https://raw.githubusercontent.com/SmartManoj/Santa-Scoreboard/main/submission.csv`
3. **telegram shared solutions** (71.97, 72.49 scores)
4. **santa25-public** dataset
5. Various kernel outputs (saspav, jazivxt, chistyakov, etc.)

## RECOMMENDED APPROACHES (Priority Order)

### 1. [HIGHEST PRIORITY] Focus on Small N (2-20)
N=1 is already optimal. Focus on N=2-20 which have worst efficiency.
- N=2-5: Try exhaustive search with fine angle steps (0.1°)
- N=6-10: Use aggressive local search from multiple random starts
- N=11-20: Try different packing patterns (not just grid)
- These are small enough for brute-force or exhaustive optimization

### 2. [HIGH PRIORITY] Asymmetric Layouts for N < 60
Web search confirms "asymmetry yields better scores for N < 60".
- Generate completely NEW layouts from scratch with NO symmetry
- Try spiral placement, random placement with local optimization
- Different initial configurations (not grid-based)

### 3. [MEDIUM PRIORITY] External Solution Mining
- Check for newer public kernels with better scores
- Look for datasets containing optimized solutions
- The target of 68.89 suggests someone has achieved this
- Key datasets: bucket-of-chump, SmartManoj GitHub, telegram shared

### 4. [MEDIUM PRIORITY] Constructive Approaches
Since all local search converges to same optimum, try:
- Greedy backtracking with beam search
- Build solutions tree-by-tree from scratch
- Random initialization + optimization (not from pre-optimized CSV)

### 5. [LOW PRIORITY] Crystalline Packing for Large N
- Regular geometric lattices for N > 58
- Hexagonal packing patterns
- Tessellation-based approaches

## What NOT to Try (Proven Ineffective)
- ❌ More SA/bbox3 optimization (converges to same optimum)
- ❌ Parameter tuning on existing optimizers
- ❌ Ensemble of symmetric solutions (all at same local optimum)
- ❌ Random restarts with same algorithm
- ❌ Running optimizers longer (diminishing returns)
- ❌ Trying to improve N=1 (already at theoretical optimum)

## Validation Notes
- CV = LB exactly for this deterministic optimization problem
- Use Shapely for overlap detection (STRtree for efficiency)
- Decimal precision (30 digits) for coordinates
- Submission format: x, y, deg with 's' prefix (e.g., "s0.123")

## Code Resources
- Kernels: `../research/kernels/`
  - `saspav_santa-submission/` - bbox3 + fix_direction
  - `smartmanoj_santa-claude/` - tree_packer_v21.cpp
  - `jonathanchan_santa25-ensemble-sa-fractional-translation/` - ensemble approach + backward propagation
  - `yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - bbox3 runner

## Submission Strategy
- 100 submissions available
- Submit after EVERY experiment that produces valid submission
- CV = LB, so local validation is reliable
- Focus on experiments that try FUNDAMENTALLY DIFFERENT approaches

## Scoring Function (for validation)
```python
import numpy as np

# Tree vertices
TX = np.array([0,0.125,0.0625,0.2,0.1,0.35,0.075,0.075,-0.075,-0.075,-0.35,-0.1,-0.2,-0.0625,-0.125])
TY = np.array([0.8,0.5,0.5,0.25,0.25,0,0,-0.2,-0.2,0,0,0.25,0.25,0.5,0.5])

def score_group(xs, ys, degs):
    """Calculate score for a single N-tree configuration"""
    n = len(xs)
    all_x, all_y = [], []
    for i in range(n):
        rad = np.radians(degs[i])
        c, s = np.cos(rad), np.sin(rad)
        for j in range(len(TX)):
            x = TX[j] * c - TY[j] * s + xs[i]
            y = TX[j] * s + TY[j] * c + ys[i]
            all_x.append(x)
            all_y.append(y)
    side = max(max(all_x) - min(all_x), max(all_y) - min(all_y))
    return side * side / n
```

## Key Questions to Answer
1. Can we beat baseline for just N=2? N=5? N=10? (Test small N first)
2. What patterns emerge in optimal small-N solutions?
3. Are there better public solutions we haven't found?
4. Can constructive approaches escape the local optimum?
5. What makes the target score (68.89) achievable? What technique are we missing?

## First Experiment Recommendation
1. Copy best baseline: `cp /home/nonroot/snapshots/santa-2025/21198893057/submission/submission.csv .`
2. Submit to verify score matches (~70.63)
3. Analyze small N (2-10) configurations in detail
4. Try exhaustive optimization on N=2-5 with fine angle grid
5. If any improvement found, cascade to larger N via backward propagation
