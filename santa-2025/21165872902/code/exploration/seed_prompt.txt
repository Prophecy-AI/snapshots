# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D packing optimization problem where we need to pack Christmas tree toys (15-vertex polygons) into the smallest square bounding box for N=1 to 200 trees. 

**Scoring Formula:** score = Σ(s_n²/n) for n=1 to 200, where s_n is the side length of the bounding box for n trees.
**Lower is better.**

## Current Status
- **Target Score:** 68.919154 (must beat this)
- **Best Known Public Score:** ~70.676 from pre-optimized submissions
- **Gap to Target:** ~1.75 points (2.54%)

## Pre-Optimized Resources Available
- Pre-optimized submission at `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/santa-2025.csv`
- bbox3 binary optimizer at `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/bbox3`
- Multiple CSV files from various sources in `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`

## Tree Geometry (CRITICAL)
The Christmas tree is a 15-vertex polygon:
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```
- Tip at (0, 0.8)
- Trunk from y=0 to y=-0.2, width 0.15
- Base width 0.7, mid width 0.4, top width 0.25
- Total height: 1.0 (from -0.2 to 0.8)

## Top Approaches from Public Kernels

### 1. bbox3.cpp Optimizer (jazivxt "Why Not" kernel)
**Key Features:**
- Complex Number Vector Coordination
- Fluid Dynamics simulation
- Hinge Pivot mechanism
- Density Gradient Flow
- Global Boundary Tension
- Aggressive overlap repair using separation vectors

**Usage:** `./bbox3 -n <iterations> -r <rounds> input.csv output.csv`

### 2. tree_packer_v21.cpp (smartmanoj "Santa Claude" kernel)
**Key Features:**
- Swap moves between trees
- Multi-angle restarts
- Higher temperature simulated annealing
- Squeeze, compaction, and local search
- Backward propagation (bp.cpp) - removes trees from larger configs to improve smaller ones

**Usage:** `./tree_packer_v21.exe -n <iterations> -r <rounds>`

### 3. Backward Propagation (bp.cpp)
For each N from 200 down to 2:
- Try removing each boundary-touching tree
- If resulting (N-1) config is better than stored, save it
- This can find better configurations for smaller N values

## CRITICAL INSIGHTS FROM PREVIOUS EXPERIMENTS

### What Has Been Tried (and didn't work):
1. **Short optimization runs** - The pre-optimized submission is at a tight local optimum
2. **Simple ensemble** - santa-2025.csv dominates all N values
3. **Backward propagation** - Found no improvements on pre-optimized submission
4. **Standard SA parameters** - Local optimum is too tight

### What MUST Be Tried:

#### 1. **MUCH LONGER OPTIMIZATION RUNS (CRITICAL)**
Top solutions run for HOURS, not minutes:
- `-n 15000+` iterations
- `-r 80+` rounds
- Multiple generations with perturbation to escape local optima

#### 2. **LATTICE/TESSELLATION APPROACH FOR LARGE N (N >= 58)**
The egortrushin kernel uses a fundamentally different approach:
- Start with 2 trees in a specific configuration
- Translate them in x and y directions to create a grid pattern
- Use simulated annealing to optimize the base configuration
- Parameters: `nt = [nx, ny]` where nx*ny >= N
- This generates crystalline/lattice packings that can be tighter than random optimization

#### 3. **FOCUS ON SMALL N VALUES (1-10)**
These have the highest score contribution:
- N=1: side=0.813, contributes 0.66 to score (highest single contribution!)
- N=2: side=0.950, contributes 0.45 to score
- Try exhaustive search for optimal rotation angles
- For N=1, optimal angle is 45 degrees (minimizes bounding box)

#### 4. **ASYMMETRIC SOLUTIONS**
Discussion "Why the winning solutions will be Asymmetric" suggests:
- Symmetric solutions may be optimal for small N
- Asymmetric solutions outperform for larger N
- Try breaking symmetry in optimization

#### 5. **DIFFERENT STARTING CONFIGURATIONS**
Instead of optimizing the pre-optimized submission:
- Generate new random configurations
- Use lattice-based initial placement
- Try different angle distributions

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- id: `{n:03d}_{tree_index}` (e.g., 001_0, 002_0, 002_1)
- x, y, deg: prefixed with 's' to preserve precision
- Total rows: 20100 (1+2+3+...+200)
- Coordinates must be within [-100, 100]

## Overlap Detection (CRITICAL)
```python
from shapely.geometry import Polygon
from shapely import affinity
from shapely.strtree import STRtree

def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

## Scoring Function
```python
def get_total_score(submission_df):
    total = 0
    for n in range(1, 201):
        trees = load_trees_for_n(submission_df, n)
        xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])
        side = max(xys.max(axis=0) - xys.min(axis=0))
        total += side**2 / n
    return total
```

## Recommended Experiment Strategy

### Experiment 1: Establish Baseline
1. Copy best pre-optimized submission
2. Calculate score to verify ~70.676
3. Identify which N values contribute most to score

### Experiment 2: Long Optimization Run
1. Run bbox3 or tree_packer_v21 with MUCH longer parameters:
   - `-n 20000 -r 256` or higher
   - Run for 2-4 hours
2. Apply backward propagation after

### Experiment 3: Lattice Approach for Large N
1. Implement tessellation/lattice packing for N >= 58
2. Start with 2 base trees, translate to create grid
3. Optimize base configuration and translation vectors

### Experiment 4: Small N Optimization
1. Focus on N=1 to N=10 specifically
2. Try exhaustive angle search for N=1 (should be 45 degrees)
3. Try all combinations of angles for N=2, N=3

### Experiment 5: Fresh Start with Different Initialization
1. Generate completely new configurations from scratch
2. Use lattice-based initial placement
3. Run long optimization on fresh configs

## What NOT to Try
- Simple ensemble (already tried - one source dominates)
- Short optimization runs (local optimum is too tight)
- fix_direction post-processing (causes precision loss and overlaps)
- Micro-optimizations on pre-optimized submission

## Technical Notes
- Use high-precision Decimal arithmetic to avoid floating-point errors
- Validate for overlaps before submitting (Kaggle rejects overlapping trees)
- C++ optimizers use OpenMP for parallelization (check available threads with `nproc`)
- Pre-optimized files available in `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`

## Key Insight
The gap of 1.75 points requires fundamentally different approaches, not micro-optimization. The pre-optimized submission is already at a very tight local optimum. To beat the target, we need:
1. Much longer optimization runs (hours, not minutes)
2. Lattice/tessellation approach for large N
3. Focus on high-contribution small N values
4. Fresh starting configurations to escape local optima
