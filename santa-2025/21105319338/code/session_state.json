{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-18T03:34:07.734231",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "bbox3 is a compiled C++ binary optimizer that takes -n (iterations) and -r (restarts) parameters. Used by top kernels with settings like -n 1000 -r 96, -n 2000 -r 96, -n 5000 -r 16, -n 10000 -r 256",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "fix_direction technique: Rotates entire configuration to minimize bounding box using scipy.optimize.minimize_scalar with bounds (0.001, 89.999). Calculates convex hull of all tree polygons and finds optimal rotation angle.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Backward propagation: Start from N=200 and work down to N=2. For each N, try removing boundary-touching trees and check if the resulting (N-1) configuration improves the stored best for that size.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Tree shape: 15-vertex polygon with trunk (0.15 wide, 0.2 tall), base tier (0.7 wide), middle tier (0.4 wide), top tier (0.25 wide), tip at y=0.8. Origin at center of trunk top.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "C++ tree_packer_v21 uses: squeeze (scale towards center), compaction (move trees towards center), local search (8-directional moves + rotations), simulated annealing with swap moves, multi-start optimization",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization to minimize bounding box?",
      "finding": "Two\u2011dimensional irregular\u2011polygon packing that seeks the smallest axis\u2011aligned bounding box is typically tackled with a combination of exact, approximation and meta\u2011heuristic methods.  Recent work on **approximation algorithms** for translational (no\u2011rotation) packing of convex polygons shows that sorting pieces by height and applying shelf\u2011style packing yields provably\u2011good bounds on the container area, perimeter or strip length, improving earlier\u202fO(1)\u2011approximation results\u202f([export.arxiv.org](https://export.arxiv.org/pdf/2308.08523v1.pdf)).  When rotations are allowed, the **no\u2011fit polygon (NFP)** is a central geometric tool; an improved sliding\u2011window algorithm for constructing NFPs speeds up collision checks and enables tighter placements of highly irregular shapes\u202f([mdpi.com](https://www.mdpi.com/2227-7390/10/16/2941)).\n\nFor practical, large\u2011scale instances the most effective approaches are **local\u2011search and evolutionary meta\u2011heuristics**.  An extended local\u2011search scheme that em",
      "agent": "explorer"
    },
    {
      "query": "What techniques do Kaggle winners use for Santa optimization competitions with geometric packing problems?",
      "finding": "Kaggle\u2019s \u201cSanta\u201d contests (e.g.,\u202fPacking\u202fSanta\u2019s\u202fSleigh\u202fand the 2025 Christmas\u2011Tree Packing Challenge) are essentially two\u2011dimensional bin\u2011packing problems with extra constraints such as delivery order or a fixed\u2011size square envelope.  Winners therefore treat the task as a geometric packing problem and apply a mix of classic heuristic packers, problem\u2011specific refinements, and meta\u2011heuristic search.\n\nThe most common baseline is a **shelf\u2011or Guillotine\u2011based algorithm**: items are placed in rows (shelves) and each new rectangle splits the remaining free space with a guillotine cut, after which a simple **height\u2011compaction step** slides rows downward to reduce wasted vertical space.  This approach mirrors the method described by a 2014 Kaggle participant, who linked the technique to the Jyl\u00e4nki rectangle\u2011bin\u2011packing paper and achieved a mid\u2011leaderboard score\u202f([dsgeek.com](http://dsgeek.com/2014/02/26/KagglePackingSantaSleighChallenge.html)).  Many top solutions extend this core with **lo",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 99
}