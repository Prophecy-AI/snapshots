{
  "phase": "executor",
  "loop_count": 1,
  "last_submission": null,
  "competition_id": "santa-2025",
  "seed_prompt": "# Santa 2025 Christmas Tree Packing - Seed Prompt\n\n## Problem Overview\nThis is a 2D irregular polygon packing optimization problem. The goal is to pack N Christmas trees (N=1 to 200) into the smallest possible square bounding box for each N value.\n\n**Scoring:** score = \u03a3(s_n\u00b2 / n) for n=1 to 200, where s_n is the side length of the bounding square for n trees.\n\n**Tree Shape:** 15-vertex polygon with:\n- Trunk: 0.15 wide, 0.2 tall\n- Base tier: 0.7 wide\n- Middle tier: 0.4 wide  \n- Top tier: 0.25 wide\n- Tip at y=0.8\n- Origin at center of trunk top\n\n**Target Score:** Beat 68.931058 (lower is better)\n\n## Critical Insight: Different Strategies for Different N\nBased on competition analysis:\n- **N < 58:** Use simulated annealing for unstructured, chaotic packings\n- **N \u2265 58:** Consider \"crystalline packing\" (regular geometric lattices) which is mathematically superior for large numbers\n\n## REQUIRED EXTERNAL DATASETS\n**CRITICAL:** Download these datasets before running experiments:\n```bash\nkaggle datasets download -d jazivxt/bucket-of-chump\nkaggle datasets download -d saspav/santa-2025-csv\n```\nThese contain:\n- `bbox3` binary optimizer (compiled C++)\n- Pre-optimized submission.csv files as starting points\n\n## Top Approaches from Public Kernels\n\n### 1. bbox3 Binary Optimizer (CRITICAL - Most Effective)\nThe `bbox3` compiled C++ binary is the core optimizer used by top solutions.\n- **Usage:** `./bbox3 -n <iterations> -r <restarts>`\n- **Recommended settings:**\n  - Quick runs: `-n 1000 -r 30` to `-n 2000 -r 96`\n  - Medium runs: `-n 5000 -r 16`\n  - Long runs: `-n 10000 -r 256`\n- **Source:** Available in kernel datasets (e.g., `bucket-of-chump/bbox3` or `santa-2025-csv/bbox3`)\n- See `../research/kernels/jazivxt_why-not/why-not.ipynb` for usage\n\n### 2. fix_direction - Rotation Optimization (ESSENTIAL)\nAfter bbox3 optimization, rotate the entire configuration to minimize bounding box:\n```python\nfrom scipy.optimize import minimize_scalar\nfrom scipy.spatial import ConvexHull\nimport numpy as np\n\ndef calculate_bbox_side_at_angle(angle_deg, points):\n    angle_rad = np.radians(angle_deg)\n    c, s = np.cos(angle_rad), np.sin(angle_rad)\n    rot_matrix_T = np.array([[c, s], [-s, c]])\n    rotated_points = points.dot(rot_matrix_T)\n    min_xy = np.min(rotated_points, axis=0)\n    max_xy = np.max(rotated_points, axis=0)\n    return max(max_xy[0] - min_xy[0], max_xy[1] - min_xy[1])\n\ndef optimize_rotation(trees):\n    # Get convex hull of all tree polygon points\n    all_points = []\n    for tree in trees:\n        all_points.extend(list(tree.polygon.exterior.coords))\n    points_np = np.array(all_points)\n    hull_points = points_np[ConvexHull(points_np).vertices]\n    \n    # Find optimal rotation angle (0 to 90 degrees)\n    res = minimize_scalar(\n        lambda a: calculate_bbox_side_at_angle(a, hull_points),\n        bounds=(0.001, 89.999), method='bounded'\n    )\n    return res.x, res.fun\n```\n- Apply multiple passes (1-3) for better results\n- See `../research/kernels/saspav_santa-submission/santa-submission.ipynb`\n\n### 3. Backward Propagation (NOVEL TECHNIQUE)\nUse larger N configurations to improve smaller N:\n```\nFor N from 200 down to 2:\n    For each tree touching the bounding box boundary:\n        Try removing that tree\n        If resulting (N-1) config is better than stored best for (N-1):\n            Update the stored best\n```\n- See `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb` for bp.cpp implementation\n\n### 4. C++ Tree Packer v21 (Alternative Optimizer)\nFull C++ implementation with:\n- **Squeeze:** Scale all trees towards center\n- **Compaction:** Move trees towards center in small steps\n- **Local search:** 8-directional moves + rotations\n- **Simulated annealing:** With swap moves\n- **Multi-start:** Different random seeds\n- Compile: `g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer.cpp`\n\n### 5. Overlap Detection and Repair\nAfter optimization, validate and repair overlapping configurations:\n```python\nfrom shapely.strtree import STRtree\n\ndef has_overlap(trees):\n    polygons = [t.polygon for t in trees]\n    tree_index = STRtree(polygons)\n    for i, poly in enumerate(polygons):\n        indices = tree_index.query(poly)\n        for idx in indices:\n            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):\n                return True\n    return False\n```\n- If overlap detected, replace with known-good configuration from donor file\n\n## Recommended Experiment Pipeline\n\n### Phase 1: Baseline (Match Best Kernel ~69-70)\n1. Download datasets: `kaggle datasets download -d jazivxt/bucket-of-chump`\n2. Copy bbox3 and submission.csv to working directory\n3. Make bbox3 executable: `chmod +x ./bbox3`\n4. Run bbox3 with moderate settings: `./bbox3 -n 2000 -r 60`\n5. Apply fix_direction with 1-2 passes\n6. Validate and repair overlaps\n7. Expected score: ~69-70\n\n### Phase 2: Extended Optimization (Beat 68.931)\n1. Run bbox3 with MUCH longer settings: `-n 10000 -r 200`\n2. Apply fix_direction with 3+ passes\n3. Run backward propagation\n4. Identify worst-performing N values and focus optimization there\n5. Try multiple random seeds and keep best\n\n### Phase 3: Advanced Techniques\n1. **Per-tree rotation optimization:** Optimize each tree's angle individually\n2. **Greedy backtracking:** Beam search to remove/reposition trees\n3. **Fractional translation:** Very fine position adjustments (0.001 units)\n4. **Multi-start optimization:** Run from 10+ different initial configurations\n5. **Ensemble:** Combine best configurations from different approaches\n6. **Crystalline lattice patterns:** For large N, try regular geometric arrangements\n\n## Key Implementation Details\n\n### Submission Format\n```csv\nid,x,y,deg\n001_0,s0.0,s0.0,s20.411299\n002_0,s0.0,s0.0,s20.411299\n002_1,s-0.541068,s0.259317,s51.66348\n```\n- Values prefixed with 's' to preserve precision\n- Coordinates constrained to -100 \u2264 x, y \u2264 100\n\n### ChristmasTree Class\n```python\nfrom decimal import Decimal, getcontext\nfrom shapely import affinity\nfrom shapely.geometry import Polygon\n\ngetcontext().prec = 25\nscale_factor = Decimal('1e15')  # For precision\n\nclass ChristmasTree:\n    def __init__(self, center_x='0', center_y='0', angle='0'):\n        self.center_x = Decimal(center_x)\n        self.center_y = Decimal(center_y)\n        self.angle = Decimal(angle)\n        \n        trunk_w = Decimal('0.15')\n        trunk_h = Decimal('0.2')\n        base_w = Decimal('0.7')\n        mid_w = Decimal('0.4')\n        top_w = Decimal('0.25')\n        tip_y = Decimal('0.8')\n        tier_1_y = Decimal('0.5')\n        tier_2_y = Decimal('0.25')\n        base_y = Decimal('0.0')\n        trunk_bottom_y = -trunk_h\n        \n        # Build 15-vertex polygon\n        initial_polygon = Polygon([\n            (Decimal('0.0') * scale_factor, tip_y * scale_factor),\n            (top_w / Decimal('2') * scale_factor, tier_1_y * scale_factor),\n            (top_w / Decimal('4') * scale_factor, tier_1_y * scale_factor),\n            (mid_w / Decimal('2') * scale_factor, tier_2_y * scale_factor),\n            (mid_w / Decimal('4') * scale_factor, tier_2_y * scale_factor),\n            (base_w / Decimal('2') * scale_factor, base_y * scale_factor),\n            (trunk_w / Decimal('2') * scale_factor, base_y * scale_factor),\n            (trunk_w / Decimal('2') * scale_factor, trunk_bottom_y * scale_factor),\n            (-(trunk_w / Decimal('2')) * scale_factor, trunk_bottom_y * scale_factor),\n            (-(trunk_w / Decimal('2')) * scale_factor, base_y * scale_factor),\n            (-(base_w / Decimal('2')) * scale_factor, base_y * scale_factor),\n            (-(mid_w / Decimal('4')) * scale_factor, tier_2_y * scale_factor),\n            (-(mid_w / Decimal('2')) * scale_factor, tier_2_y * scale_factor),\n            (-(top_w / Decimal('4')) * scale_factor, tier_1_y * scale_factor),\n            (-(top_w / Decimal('2')) * scale_factor, tier_1_y * scale_factor),\n        ])\n        \n        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))\n        self.polygon = affinity.translate(rotated,\n            xoff=float(self.center_x * scale_factor),\n            yoff=float(self.center_y * scale_factor))\n```\n\n### Score Calculation\n```python\ndef get_total_score(dict_of_side_length):\n    score = Decimal('0')\n    for n, side in dict_of_side_length.items():\n        score += side ** 2 / Decimal(str(n))\n    return score\n```\n\n## Simulated Annealing Strategy (Key for Beating Target)\n\n### Temperature Schedule\n```python\ntemperature = 1.0\ncooling_rate = 0.9995  # Slow cooling for better exploration\n\nfor i in range(max_iterations):\n    # High temperature: Random spin and throw trees (Explorer Phase)\n    # Low temperature: Jiggle by microscopic amounts (Exploiter Phase)\n    \n    # Propose move\n    idx = random.randint(0, len(layout) - 1)\n    original_pos = layout[idx].copy()\n    \n    # Perturb position and rotation\n    layout[idx][0] += np.random.normal(0, temperature)\n    layout[idx][1] += np.random.normal(0, temperature)\n    layout[idx][2] += np.random.normal(0, temperature * 10)\n    \n    # Check overlap - if invalid, revert immediately\n    if check_overlap(layout):\n        layout[idx] = original_pos\n        continue\n    \n    # Metropolis-Hastings acceptance\n    new_score = calculate_area(layout)\n    delta = new_score - current_score\n    if delta < 0 or math.exp(-delta / temperature) > random.random():\n        current_score = new_score\n    else:\n        layout[idx] = original_pos\n    \n    temperature *= cooling_rate\n```\n\n### Local Search Neighborhoods\n1. Translate single tree (8 directions + towards center)\n2. Rotate single tree (small angle adjustments)\n3. Swap two trees (positions and/or rotations)\n4. Move boundary trees inward\n\n## Validation Strategy\n- Always validate no overlaps before submission\n- Use STRtree for efficient collision detection\n- Keep backup of known-good configurations\n- Replace invalid configs with donor file versions\n\n## Priority Order for Experiments\n1. **FIRST:** Download datasets and reproduce best kernel score using bbox3 + fix_direction\n2. Run bbox3 with extended iterations (-n 10000+)\n3. Apply backward propagation\n4. Focus on worst-performing N values (analyze score contribution per N)\n5. Try tree_packer_v21 as alternative optimizer\n6. Ensemble best results from different approaches\n7. Experiment with crystalline patterns for large N\n\n## Files and Resources\n- Sample submission: `/home/data/sample_submission.csv`\n- Kernels: `../research/kernels/`\n  - `jazivxt_why-not/` - bbox3 usage (uses `jazivxt/bucket-of-chump` dataset)\n  - `saspav_santa-submission/` - fix_direction implementation (uses `saspav/santa-2025-csv` dataset)\n  - `smartmanoj_santa-claude/` - tree_packer_v21 and backward propagation\n  - `yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - 3-hour optimization runner\n  - `inversion_santa-2025-getting-started/` - Basic greedy algorithm and visualization\n\n## Performance Tips\n1. Use OpenMP for parallelization: `export OMP_NUM_THREADS=96`\n2. Compile with `-O3 -march=native` for maximum speed\n3. Use Decimal precision (25+ digits) for accurate scoring\n4. Scale factor of 1e15 or 1e18 for polygon operations\n5. Run optimization loops for hours, not minutes\n6. Python is too slow - use compiled C++ for core optimization loops\n",
  "evaluator_feedback": "",
  "latest_experiment": {},
  "competitive_intel": "## Available Competitive Intelligence\n\n- Competition description: `../research/description.md`\n- 5 top kernel notebooks in `../research/kernels/`",
  "target_score": 68.931058099451,
  "manual_instructions": "",
  "messages": [],
  "experiments": [],
  "submissions": [],
  "candidates": [],
  "findings": [],
  "metric_lower_is_better": true,
  "strategy_history": [
    {
      "strategy": "# Santa 2025 Christmas Tree Packing - Seed Prompt\n\n## Problem Overview\nThis is a 2D irregular polygon packing optimization problem. The goal is to pack N Christmas trees (N=1 to 200) into the smallest possible square bounding box for each N value.\n\n**Scoring:** score = \u03a3(s_n\u00b2 / n) for n=1 to 200, where s_n is the side length of the bounding square for n trees.\n\n**Tree Shape:** 15-vertex polygon with:\n- Trunk: 0.15 wide, 0.2 tall\n- Base tier: 0.7 wide\n- Middle tier: 0.4 wide  \n- Top tier: 0.25 wide\n- Tip at y=0.8\n- Origin at center of trunk top\n\n**Target Score:** Beat 68.931058 (lower is better)\n\n## Critical Insight: Different Strategies for Different N\nBased on competition analysis:\n- **N < 58:** Use simulated annealing for unstructured, chaotic packings\n- **N \u2265 58:** Consider \"crystalline packing\" (regular geometric lattices) which is mathematically superior for large numbers\n\n## REQUIRED EXTERNAL DATASETS\n**CRITICAL:** Download these datasets before running experiments:\n```bash\nkaggle datasets download -d jazivxt/bucket-of-chump\nkaggle datasets download -d saspav/santa-2025-csv\n```\nThese contain:\n- `bbox3` binary optimizer (compiled C++)\n- Pre-optimized submission.csv files as starting points\n\n## Top Approaches from Public Kernels\n\n### 1. bbox3 Binary Optimizer (CRITICAL - Most Effective)\nThe `bbox3` compiled C++ binary is the core optimizer used by top solutions.\n- **Usage:** `./bbox3 -n <iterations> -r <restarts>`\n- **Recommended settings:**\n  - Quick runs: `-n 1000 -r 30` to `-n 2000 -r 96`\n  - Medium runs: `-n 5000 -r 16`\n  - Long runs: `-n 10000 -r 256`\n- **Source:** Available in kernel datasets (e.g., `bucket-of-chump/bbox3` or `santa-2025-csv/bbox3`)\n- See `../research/kernels/jazivxt_why-not/why-not.ipynb` for usage\n\n### 2. fix_direction - Rotation Optimization (ESSENTIAL)\nAfter bbox3 optimization, rotate the entire configuration to minimize bounding box:\n```python\nfrom scipy.optimize import minimize_scalar\nfrom scipy.spatial import ConvexHull\nimport numpy as np\n\ndef calculate_bbox_side_at_angle(angle_deg, points):\n    angle_rad = np.radians(angle_deg)\n    c, s = np.cos(angle_rad), np.sin(angle_rad)\n    rot_matrix_T = np.array([[c, s], [-s, c]])\n    rotated_points = points.dot(rot_matrix_T)\n    min_xy = np.min(rotated_points, axis=0)\n    max_xy = np.max(rotated_points, axis=0)\n    return max(max_xy[0] - min_xy[0], max_xy[1] - min_xy[1])\n\ndef optimize_rotation(trees):\n    # Get convex hull of all tree polygon points\n    all_points = []\n    for tree in trees:\n        all_points.extend(list(tree.polygon.exterior.coords))\n    points_np = np.array(all_points)\n    hull_points = points_np[ConvexHull(points_np).vertices]\n    \n    # Find optimal rotation angle (0 to 90 degrees)\n    res = minimize_scalar(\n        lambda a: calculate_bbox_side_at_angle(a, hull_points),\n        bounds=(0.001, 89.999), method='bounded'\n    )\n    return res.x, res.fun\n```\n- Apply multiple passes (1-3) for better results\n- See `../research/kernels/saspav_santa-submission/santa-submission.ipynb`\n\n### 3. Backward Propagation (NOVEL TECHNIQUE)\nUse larger N configurations to improve smaller N:\n```\nFor N from 200 down to 2:\n    For each tree touching the bounding box boundary:\n        Try removing that tree\n        If resulting (N-1) config is better than stored best for (N-1):\n            Update the stored best\n```\n- See `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb` for bp.cpp implementation\n\n### 4. C++ Tree Packer v21 (Alternative Optimizer)\nFull C++ implementation with:\n- **Squeeze:** Scale all trees towards center\n- **Compaction:** Move trees towards center in small steps\n- **Local search:** 8-directional moves + rotations\n- **Simulated annealing:** With swap moves\n- **Multi-start:** Different random seeds\n- Compile: `g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer.cpp`\n\n### 5. Overlap Detection and Repair\nAfter optimization, validate and repair overlapping configurations:\n```python\nfrom shapely.strtree import STRtree\n\ndef has_overlap(trees):\n    polygons = [t.polygon for t in trees]\n    tree_index = STRtree(polygons)\n    for i, poly in enumerate(polygons):\n        indices = tree_index.query(poly)\n        for idx in indices:\n            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):\n                return True\n    return False\n```\n- If overlap detected, replace with known-good configuration from donor file\n\n## Recommended Experiment Pipeline\n\n### Phase 1: Baseline (Match Best Kernel ~69-70)\n1. Download datasets: `kaggle datasets download -d jazivxt/bucket-of-chump`\n2. Copy bbox3 and submission.csv to working directory\n3. Make bbox3 executable: `chmod +x ./bbox3`\n4. Run bbox3 with moderate settings: `./bbox3 -n 2000 -r 60`\n5. Apply fix_direction with 1-2 passes\n6. Validate and repair overlaps\n7. Expected score: ~69-70\n\n### Phase 2: Extended Optimization (Beat 68.931)\n1. Run bbox3 with MUCH longer settings: `-n 10000 -r 200`\n2. Apply fix_direction with 3+ passes\n3. Run backward propagation\n4. Identify worst-performing N values and focus optimization there\n5. Try multiple random seeds and keep best\n\n### Phase 3: Advanced Techniques\n1. **Per-tree rotation optimization:** Optimize each tree's angle individually\n2. **Greedy backtracking:** Beam search to remove/reposition trees\n3. **Fractional translation:** Very fine position adjustments (0.001 units)\n4. **Multi-start optimization:** Run from 10+ different initial configurations\n5. **Ensemble:** Combine best configurations from different approaches\n6. **Crystalline lattice patterns:** For large N, try regular geometric arrangements\n\n## Key Implementation Details\n\n### Submission Format\n```csv\nid,x,y,deg\n001_0,s0.0,s0.0,s20.411299\n002_0,s0.0,s0.0,s20.411299\n002_1,s-0.541068,s0.259317,s51.66348\n```\n- Values prefixed with 's' to preserve precision\n- Coordinates constrained to -100 \u2264 x, y \u2264 100\n\n### ChristmasTree Class\n```python\nfrom decimal import Decimal, getcontext\nfrom shapely import affinity\nfrom shapely.geometry import Polygon\n\ngetcontext().prec = 25\nscale_factor = Decimal('1e15')  # For precision\n\nclass ChristmasTree:\n    def __init__(self, center_x='0', center_y='0', angle='0'):\n        self.center_x = Decimal(center_x)\n        self.center_y = Decimal(center_y)\n        self.angle = Decimal(angle)\n        \n        trunk_w = Decimal('0.15')\n        trunk_h = Decimal('0.2')\n        base_w = Decimal('0.7')\n        mid_w = Decimal('0.4')\n        top_w = Decimal('0.25')\n        tip_y = Decimal('0.8')\n        tier_1_y = Decimal('0.5')\n        tier_2_y = Decimal('0.25')\n        base_y = Decimal('0.0')\n        trunk_bottom_y = -trunk_h\n        \n        # Build 15-vertex polygon\n        initial_polygon = Polygon([\n            (Decimal('0.0') * scale_factor, tip_y * scale_factor),\n            (top_w / Decimal('2') * scale_factor, tier_1_y * scale_factor),\n            (top_w / Decimal('4') * scale_factor, tier_1_y * scale_factor),\n            (mid_w / Decimal('2') * scale_factor, tier_2_y * scale_factor),\n            (mid_w / Decimal('4') * scale_factor, tier_2_y * scale_factor),\n            (base_w / Decimal('2') * scale_factor, base_y * scale_factor),\n            (trunk_w / Decimal('2') * scale_factor, base_y * scale_factor),\n            (trunk_w / Decimal('2') * scale_factor, trunk_bottom_y * scale_factor),\n            (-(trunk_w / Decimal('2')) * scale_factor, trunk_bottom_y * scale_factor),\n            (-(trunk_w / Decimal('2')) * scale_factor, base_y * scale_factor),\n            (-(base_w / Decimal('2')) * scale_factor, base_y * scale_factor),\n            (-(mid_w / Decimal('4')) * scale_factor, tier_2_y * scale_factor),\n            (-(mid_w / Decimal('2')) * scale_factor, tier_2_y * scale_factor),\n            (-(top_w / Decimal('4')) * scale_factor, tier_1_y * scale_factor),\n            (-(top_w / Decimal('2')) * scale_factor, tier_1_y * scale_factor),\n        ])\n        \n        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))\n        self.polygon = affinity.translate(rotated,\n            xoff=float(self.center_x * scale_factor),\n            yoff=float(self.center_y * scale_factor))\n```\n\n### Score Calculation\n```python\ndef get_total_score(dict_of_side_length):\n    score = Decimal('0')\n    for n, side in dict_of_side_length.items():\n        score += side ** 2 / Decimal(str(n))\n    return score\n```\n\n## Simulated Annealing Strategy (Key for Beating Target)\n\n### Temperature Schedule\n```python\ntemperature = 1.0\ncooling_rate = 0.9995  # Slow cooling for better exploration\n\nfor i in range(max_iterations):\n    # High temperature: Random spin and throw trees (Explorer Phase)\n    # Low temperature: Jiggle by microscopic amounts (Exploiter Phase)\n    \n    # Propose move\n    idx = random.randint(0, len(layout) - 1)\n    original_pos = layout[idx].copy()\n    \n    # Perturb position and rotation\n    layout[idx][0] += np.random.normal(0, temperature)\n    layout[idx][1] += np.random.normal(0, temperature)\n    layout[idx][2] += np.random.normal(0, temperature * 10)\n    \n    # Check overlap - if invalid, revert immediately\n    if check_overlap(layout):\n        layout[idx] = original_pos\n        continue\n    \n    # Metropolis-Hastings acceptance\n    new_score = calculate_area(layout)\n    delta = new_score - current_score\n    if delta < 0 or math.exp(-delta / temperature) > random.random():\n        current_score = new_score\n    else:\n        layout[idx] = original_pos\n    \n    temperature *= cooling_rate\n```\n\n### Local Search Neighborhoods\n1. Translate single tree (8 directions + towards center)\n2. Rotate single tree (small angle adjustments)\n3. Swap two trees (positions and/or rotations)\n4. Move boundary trees inward\n\n## Validation Strategy\n- Always validate no overlaps before submission\n- Use STRtree for efficient collision detection\n- Keep backup of known-good configurations\n- Replace invalid configs with donor file versions\n\n## Priority Order for Experiments\n1. **FIRST:** Download datasets and reproduce best kernel score using bbox3 + fix_direction\n2. Run bbox3 with extended iterations (-n 10000+)\n3. Apply backward propagation\n4. Focus on worst-performing N values (analyze score contribution per N)\n5. Try tree_packer_v21 as alternative optimizer\n6. Ensemble best results from different approaches\n7. Experiment with crystalline patterns for large N\n\n## Files and Resources\n- Sample submission: `/home/data/sample_submission.csv`\n- Kernels: `../research/kernels/`\n  - `jazivxt_why-not/` - bbox3 usage (uses `jazivxt/bucket-of-chump` dataset)\n  - `saspav_santa-submission/` - fix_direction implementation (uses `saspav/santa-2025-csv` dataset)\n  - `smartmanoj_santa-claude/` - tree_packer_v21 and backward propagation\n  - `yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - 3-hour optimization runner\n  - `inversion_santa-2025-getting-started/` - Basic greedy algorithm and visualization\n\n## Performance Tips\n1. Use OpenMP for parallelization: `export OMP_NUM_THREADS=96`\n2. Compile with `-O3 -march=native` for maximum speed\n3. Use Decimal precision (25+ digits) for accurate scoring\n4. Scale factor of 1e15 or 1e18 for polygon operations\n5. Run optimization loops for hours, not minutes\n6. Python is too slow - use compiled C++ for core optimization loops\n",
      "agent": "explorer",
      "timestamp": "2026-01-18T03:39:06.387808"
    }
  ],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "bbox3 is a compiled C++ binary optimizer that takes -n (iterations) and -r (restarts) parameters. Used by top kernels with settings like -n 1000 -r 96, -n 2000 -r 96, -n 5000 -r 16, -n 10000 -r 256",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "fix_direction technique: Rotates entire configuration to minimize bounding box using scipy.optimize.minimize_scalar with bounds (0.001, 89.999). Calculates convex hull of all tree polygons and finds optimal rotation angle.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Backward propagation: Start from N=200 and work down to N=2. For each N, try removing boundary-touching trees and check if the resulting (N-1) configuration improves the stored best for that size.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Tree shape: 15-vertex polygon with trunk (0.15 wide, 0.2 tall), base tier (0.7 wide), middle tier (0.4 wide), top tier (0.25 wide), tip at y=0.8. Origin at center of trunk top.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "C++ tree_packer_v21 uses: squeeze (scale towards center), compaction (move trees towards center), local search (8-directional moves + rotations), simulated annealing with swap moves, multi-start optimization",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "For N < 58: Use simulated annealing for unstructured chaotic packings. For N >= 58: Consider crystalline packing (regular geometric lattices) which is mathematically superior for large numbers.",
      "source": "Web search: Kaggle Santa 2025 analysis",
      "agent": "explorer"
    },
    {
      "finding": "Top teams use hybrid workflow: Human defines heuristics, LLM writes optimized C++/Rust kernels with AVX2 vectorization, Simulated Annealing does heavy lifting. Python too slow for billions of annealing steps.",
      "source": "Web search: Medium article on Santa 2025",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization to minimize bounding box?",
      "finding": "Two\u2011dimensional irregular\u2011polygon packing that seeks the smallest axis\u2011aligned bounding box is typically tackled with a combination of exact, approximation and meta\u2011heuristic methods.  Recent work on **approximation algorithms** for translational (no\u2011rotation) packing of convex polygons shows that sorting pieces by height and applying shelf\u2011style packing yields provably\u2011good bounds on the container area, perimeter or strip length, improving earlier\u202fO(1)\u2011approximation results\u202f([export.arxiv.org](https://export.arxiv.org/pdf/2308.08523v1.pdf)).  When rotations are allowed, the **no\u2011fit polygon (NFP)** is a central geometric tool; an improved sliding\u2011window algorithm for constructing NFPs speeds up collision checks and enables tighter placements of highly irregular shapes\u202f([mdpi.com](https://www.mdpi.com/2227-7390/10/16/2941)).\n\nFor practical, large\u2011scale instances the most effective approaches are **local\u2011search and evolutionary meta\u2011heuristics**.  An extended local\u2011search scheme that em",
      "agent": "explorer"
    },
    {
      "query": "What techniques do Kaggle winners use for Santa optimization competitions with geometric packing problems?",
      "finding": "Kaggle\u2019s \u201cSanta\u201d contests (e.g.,\u202fPacking\u202fSanta\u2019s\u202fSleigh\u202fand the 2025 Christmas\u2011Tree Packing Challenge) are essentially two\u2011dimensional bin\u2011packing problems with extra constraints such as delivery order or a fixed\u2011size square envelope.  Winners therefore treat the task as a geometric packing problem and apply a mix of classic heuristic packers, problem\u2011specific refinements, and meta\u2011heuristic search.\n\nThe most common baseline is a **shelf\u2011or Guillotine\u2011based algorithm**: items are placed in rows (shelves) and each new rectangle splits the remaining free space with a guillotine cut, after which a simple **height\u2011compaction step** slides rows downward to reduce wasted vertical space.  This approach mirrors the method described by a 2014 Kaggle participant, who linked the technique to the Jyl\u00e4nki rectangle\u2011bin\u2011packing paper and achieved a mid\u2011leaderboard score\u202f([dsgeek.com](http://dsgeek.com/2014/02/26/KagglePackingSantaSleighChallenge.html)).  Many top solutions extend this core with **lo",
      "agent": "explorer"
    }
  ],
  "remaining_submissions": 99,
  "max_submissions": 100,
  "last_reset_date_utc": "2026-01-18",
  "start_time": "2026-01-18T03:34:07.734231",
  "time_limit_minutes": 2100,
  "_saved_at": "2026-01-18T03:39:06.390808"
}