# Christmas Tree Packing Optimization - Seed Prompt

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding box for configurations of N=1 to N=200 trees.

**Scoring:** score = Σ(s²/n) for n=1 to 200, where s is the side length of the bounding square for each n-tree configuration. Lower is better.

**Target Score:** Beat 68.922808
**Baseline (greedy):** ~173.65 (sample submission)
**Improvement needed:** ~60% reduction from baseline

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Tip at (0, 0.8)
- Three tiers of branches at y=0.5, 0.25, 0
- Trunk from y=0 to y=-0.2
- Base width: 0.7, Mid width: 0.4, Top width: 0.25, Trunk width: 0.15

```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

Trees can be rotated (0-360 degrees) and positioned at any (x, y) coordinates.

## Top Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (from `../research/kernels/jazivxt_why-not/`)
The most sophisticated approach uses a compiled C++ optimizer with:
- **Complex number vector coordination** for efficient geometric calculations
- **Fluid dynamics simulation** - treats trees as particles with repulsion forces
- **Hinge pivot mechanics** - allows trees to rotate around contact points
- **Density gradient flow** - moves trees toward denser packing regions
- **Global boundary tension** - applies inward pressure from bounding box edges
- **Aggressive overlap repair** using separation vectors (MTV approximation)

Key parameters: `-n` (iterations), `-r` (random seed)
Multi-phase strategy: Short runs (2min) to find promising parameters, then longer runs (10-20min) on best candidates.

### 2. fix_direction Rotation Optimization (from `../research/kernels/saspav_santa-submission/`)
Post-processing technique to tighten bounding boxes:
- Use `scipy.optimize.minimize_scalar` to find optimal rotation angle (0-90°)
- Calculate convex hull of all tree polygon points
- Find angle that minimizes `max(width, height)` of rotated hull
- Apply rotation to all trees in configuration
- Can improve score significantly with minimal computation

```python
from scipy.optimize import minimize_scalar
from scipy.spatial import ConvexHull

def optimize_rotation(trees):
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points_np = np.array(all_points)
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    def bbox_side_at_angle(angle_deg):
        angle_rad = np.radians(angle_deg)
        c, s = np.cos(angle_rad), np.sin(angle_rad)
        rot_matrix = np.array([[c, s], [-s, c]])
        rotated = points.dot(rot_matrix)
        return max(rotated.max(0) - rotated.min(0))
    
    res = minimize_scalar(bbox_side_at_angle, bounds=(0, 90), method='bounded')
    return res.x, res.fun
```

### 3. Greedy Placement Algorithm (from `../research/kernels/inversion_santa-2025-getting-started/`)
Initial solution generation:
- Use weighted angle distribution: `abs(sin(2*angle))` to favor diagonal placements
- Place trees in corners to better utilize square bounding box
- Start far from center, move inward until collision, back up until no overlap
- Keep best of 10 random attempts per tree
- Build incrementally: use n-tree solution as starting point for (n+1)-tree

### 4. Multi-Phase Optimization Runner (from `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`)
Efficient time management:
- **Phase A:** Short 2-minute runs with various (n, r) parameters to find promising candidates
- **Phase B:** 10-minute runs on top 3-6 candidates
- **Phase C:** 20-minute runs on best 2 candidates
- Only run expensive fix_direction + overlap validation on winners
- Always keep best submission; revert on regressions

## Additional Techniques from Research

### Simulated Annealing (SA) Best Practices
1. **No-Fit Polygon (NFP)** - Precompute valid placement regions for each polygon pair
   - NFP describes all positions where two polygons touch without overlapping
   - Enables fast sampling of legal moves
2. **Adaptive Neighborhoods** - Change move types as temperature drops
   - Large translations/rotations early, fine-grained tweaks later
3. **Hybrid SA** - Embed deterministic placement routine inside SA iterations
   - SA explores ordering/orientation, recursive step finds optimal insertion
4. **Row-building heuristic** - Place polygons in rows before SA refinement

### Meta-heuristics for Irregular Packing
1. **Genetic Algorithms** - Evolve placement sequences with crossover/mutation
2. **Tabu Search** - Forbid recently visited configurations to explore new regions
3. **Local Search with Jostle Moves** - Small perturbations to improve packing

### Placement Heuristics
1. **Bottom-Left Fill (BLF)** - Place each piece at lowest, leftmost valid position
2. **DJD Selection Heuristic** - Smart selection of which piece to place next
3. **Compaction Algorithm** - Iteratively move pieces closer together

### Overlap Resolution
1. **Separation Vector (MTV)** - Minimum Translation Vector to separate overlapping polygons
2. **Nonlinear Programming** - Fine-tune positions to minimize overlap
3. **Binary search for scale factor** - Find maximum scale that fits without overlap

## Recommended Experiments (Priority Order)

### Experiment 1: Implement bbox3-style Optimizer
- Port the C++ bbox3 algorithm to Python or use compiled binary
- Key components: force-based simulation, overlap detection, boundary tension
- Run with multiple random seeds and keep best results
- See `../research/kernels/jazivxt_why-not/` for implementation

### Experiment 2: Rotation Optimization Post-Processing
- Apply fix_direction to any solution to tighten bounding boxes
- Use scipy.optimize.minimize_scalar with bounded method
- Apply to all 200 configurations
- See `../research/kernels/saspav_santa-submission/` for implementation

### Experiment 3: Simulated Annealing with NFP
- Precompute No-Fit Polygons for tree pairs at various angles
- Moves: translate tree along NFP boundary, rotate tree, swap two trees
- Adaptive cooling: start T high, decrease geometrically
- Accept worse moves with probability exp(-delta/T)

### Experiment 4: Improved Greedy Initialization
- Better initial placements lead to better final solutions
- Try different angle distributions and placement orders
- Consider sorting trees by some heuristic before placement

### Experiment 5: Genetic Algorithm
- Chromosome: sequence of tree placements + angles
- Crossover: combine good partial solutions (order crossover)
- Mutation: perturb positions/angles, swap tree order
- Selection: tournament or roulette wheel

### Experiment 6: Ensemble Best Solutions
- Run multiple algorithms with different random seeds
- For each n, keep the configuration with smallest bounding box
- Combine best results from different approaches

## Validation Requirements

### Overlap Detection
Use Shapely library for robust polygon operations:
```python
from shapely.geometry import Polygon
from shapely import affinity
from shapely.strtree import STRtree

def get_tree_polygon(x, y, deg):
    TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
    TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
    base_poly = Polygon(zip(TX, TY))
    rotated = affinity.rotate(base_poly, deg, origin=(0, 0))
    return affinity.translate(rotated, xoff=x, yoff=y)

def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

### Submission Format
- Values must be strings prefixed with 's': `s0.123456`
- Coordinates constrained to -100 ≤ x, y ≤ 100
- ID format: `NNN_T` where NNN is zero-padded tree count, T is tree index
- Total rows: 20100 (sum of 1 to 200)

## Key Insights

1. **Square bounding box** - The metric uses max(width, height), so aim for square-ish arrangements
2. **Diagonal placements** - Trees at 45° angles can interlock better
3. **Corner utilization** - Place trees pointing into corners to minimize wasted space
4. **Incremental building** - Good n-tree solutions often lead to good (n+1)-tree solutions
5. **Post-processing matters** - Rotation optimization can significantly improve any solution
6. **Multiple random seeds** - Run optimizers multiple times and keep best results
7. **Lattice patterns** - For larger n, crystalline/lattice arrangements may be optimal
8. **Blue/Pink phases** - Trees pointing up vs down can interlock efficiently

## Scoring Function
```python
def calculate_total_score(submission_df):
    total_score = 0
    for n in range(1, 201):
        group = submission_df[submission_df['n'] == n]
        polygons = [get_tree_polygon(row['x'], row['y'], row['deg']) for _, row in group.iterrows()]
        union = unary_union(polygons)
        bounds = union.bounds
        side = max(bounds[2] - bounds[0], bounds[3] - bounds[1])
        total_score += (side ** 2) / n
    return total_score
```

## Reference Notebooks
- Getting Started: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 Optimizer: `../research/kernels/jazivxt_why-not/`
- fix_direction: `../research/kernels/saspav_santa-submission/`
- Multi-phase Runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
