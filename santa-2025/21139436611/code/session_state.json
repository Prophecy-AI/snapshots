{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T13:39:24.355803",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D bin packing optimization problem: pack Christmas tree shapes (15-vertex polygons) into smallest square bounding box for N=1-200 trees. Score = sum(s\u00b2/n) where s is side length. Lower is better. Target: 68.922808",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "bbox3 C++ optimizer uses: complex number vector coordination, fluid dynamics simulation, hinge pivot mechanics, density gradient flow, global boundary tension, aggressive overlap repair with separation vectors (MTV approximation)",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "fix_direction technique: Use scipy.optimize.minimize_scalar to find optimal rotation angle (0-90 degrees) that minimizes bounding box side length. Apply rotation to all trees in a configuration. Can improve score by tightening the bounding box.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Multi-phase optimization strategy: Phase A (short 2min runs) to find promising n,r parameters, Phase B (10min runs) on top candidates, Phase C (20min runs) on best few. Only validate/fix overlaps on winners to save time.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Greedy tree placement: Use weighted angle distribution (abs(sin(2*angle))) to place more trees in corners. Start far from center, move inward until collision, then back up. Keep best of 10 random attempts per tree.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization problems?",
      "finding": "Two\u2011dimensional irregular\u2011polygon packing is a notoriously hard combinatorial problem, so the most effective approaches combine exact methods for small instances with powerful heuristics and meta\u2011heuristics for larger, industrial\u2011scale cases.  Exact branch\u2011and\u2011bound or integer\u2011programming formulations can guarantee optimality but quickly become intractable; therefore many researchers rely on **approximation and shelf\u2011packing schemes** that sort polygons by height or area and place them on successive \u201cshelves\u201d inside the container, achieving provable constant\u2011factor bounds for convex polygons\u202f([arXiv](https://export.arxiv.org/pdf/2308.08523v1.pdf)).  For truly irregular shapes, **bottom\u2011left placement** (the Bottom\u2011Left\u2011Fill strategy) remains a simple yet surprisingly effective heuristic, especially when coupled with a good ordering of items\u202f([Taylor\u202f&\u202fFrancis](https://www.taylorfrancis.com/chapters/edit/10.1201/9781351236423-33/practical-algorithms-two-dimensional-packing-general-shape",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 95
}