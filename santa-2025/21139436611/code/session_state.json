{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T13:39:24.355803",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [
    {
      "strategy": "# Christmas Tree Packing Optimization - Seed Prompt\n\n## Problem Overview\nThis is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding box for configurations of N=1 to N=200 trees.\n\n**Scoring:** score = \u03a3(s\u00b2/n) for n=1 to 200, where s is the side length of the bounding square for each n-tree configuration. Lower is better.\n\n**Target Score:** Beat 68.922808\n**Baseline (greedy):** ~173.65 (sample submission)\n**Improvement needed:** ~60% reduction from baseline\n\n## Tree Geometry\nEach tree is a 15-vertex polygon with:\n- Tip at (0, 0.8)\n- Three tiers of branches at y=0.5, 0.25, 0\n- Trunk from y=0 to y=-0.2\n- Base width: 0.7, Mid width: 0.4, Top width: 0.25, Trunk width: 0.15\n\n```python\nTX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]\nTY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]\n```\n\nTrees can be rotated (0-360 degrees) and positioned at any (x, y) coordinates.\n\n## Top Approaches from Public Kernels\n\n### 1. bbox3 C++ Optimizer (from `../research/kernels/jazivxt_why-not/`)\nThe most sophisticated approach uses a compiled C++ optimizer with:\n- **Complex number vector coordination** for efficient geometric calculations\n- **Fluid dynamics simulation** - treats trees as particles with repulsion forces\n- **Hinge pivot mechanics** - allows trees to rotate around contact points\n- **Density gradient flow** - moves trees toward denser packing regions\n- **Global boundary tension** - applies inward pressure from bounding box edges\n- **Aggressive overlap repair** using separation vectors (MTV approximation)\n\nKey parameters: `-n` (iterations), `-r` (random seed)\nMulti-phase strategy: Short runs (2min) to find promising parameters, then longer runs (10-20min) on best candidates.\n\n### 2. fix_direction Rotation Optimization (from `../research/kernels/saspav_santa-submission/`)\nPost-processing technique to tighten bounding boxes:\n- Use `scipy.optimize.minimize_scalar` to find optimal rotation angle (0-90\u00b0)\n- Calculate convex hull of all tree polygon points\n- Find angle that minimizes `max(width, height)` of rotated hull\n- Apply rotation to all trees in configuration\n- Can improve score significantly with minimal computation\n\n```python\nfrom scipy.optimize import minimize_scalar\nfrom scipy.spatial import ConvexHull\n\ndef optimize_rotation(trees):\n    all_points = []\n    for tree in trees:\n        all_points.extend(list(tree.polygon.exterior.coords))\n    points_np = np.array(all_points)\n    hull_points = points_np[ConvexHull(points_np).vertices]\n    \n    def bbox_side_at_angle(angle_deg):\n        angle_rad = np.radians(angle_deg)\n        c, s = np.cos(angle_rad), np.sin(angle_rad)\n        rot_matrix = np.array([[c, s], [-s, c]])\n        rotated = points.dot(rot_matrix)\n        return max(rotated.max(0) - rotated.min(0))\n    \n    res = minimize_scalar(bbox_side_at_angle, bounds=(0, 90), method='bounded')\n    return res.x, res.fun\n```\n\n### 3. Greedy Placement Algorithm (from `../research/kernels/inversion_santa-2025-getting-started/`)\nInitial solution generation:\n- Use weighted angle distribution: `abs(sin(2*angle))` to favor diagonal placements\n- Place trees in corners to better utilize square bounding box\n- Start far from center, move inward until collision, back up until no overlap\n- Keep best of 10 random attempts per tree\n- Build incrementally: use n-tree solution as starting point for (n+1)-tree\n\n### 4. Multi-Phase Optimization Runner (from `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`)\nEfficient time management:\n- **Phase A:** Short 2-minute runs with various (n, r) parameters to find promising candidates\n- **Phase B:** 10-minute runs on top 3-6 candidates\n- **Phase C:** 20-minute runs on best 2 candidates\n- Only run expensive fix_direction + overlap validation on winners\n- Always keep best submission; revert on regressions\n\n## Additional Techniques from Research\n\n### Simulated Annealing (SA) Best Practices\n1. **No-Fit Polygon (NFP)** - Precompute valid placement regions for each polygon pair\n   - NFP describes all positions where two polygons touch without overlapping\n   - Enables fast sampling of legal moves\n2. **Adaptive Neighborhoods** - Change move types as temperature drops\n   - Large translations/rotations early, fine-grained tweaks later\n3. **Hybrid SA** - Embed deterministic placement routine inside SA iterations\n   - SA explores ordering/orientation, recursive step finds optimal insertion\n4. **Row-building heuristic** - Place polygons in rows before SA refinement\n\n### Meta-heuristics for Irregular Packing\n1. **Genetic Algorithms** - Evolve placement sequences with crossover/mutation\n2. **Tabu Search** - Forbid recently visited configurations to explore new regions\n3. **Local Search with Jostle Moves** - Small perturbations to improve packing\n\n### Placement Heuristics\n1. **Bottom-Left Fill (BLF)** - Place each piece at lowest, leftmost valid position\n2. **DJD Selection Heuristic** - Smart selection of which piece to place next\n3. **Compaction Algorithm** - Iteratively move pieces closer together\n\n### Overlap Resolution\n1. **Separation Vector (MTV)** - Minimum Translation Vector to separate overlapping polygons\n2. **Nonlinear Programming** - Fine-tune positions to minimize overlap\n3. **Binary search for scale factor** - Find maximum scale that fits without overlap\n\n## Recommended Experiments (Priority Order)\n\n### Experiment 1: Implement bbox3-style Optimizer\n- Port the C++ bbox3 algorithm to Python or use compiled binary\n- Key components: force-based simulation, overlap detection, boundary tension\n- Run with multiple random seeds and keep best results\n- See `../research/kernels/jazivxt_why-not/` for implementation\n\n### Experiment 2: Rotation Optimization Post-Processing\n- Apply fix_direction to any solution to tighten bounding boxes\n- Use scipy.optimize.minimize_scalar with bounded method\n- Apply to all 200 configurations\n- See `../research/kernels/saspav_santa-submission/` for implementation\n\n### Experiment 3: Simulated Annealing with NFP\n- Precompute No-Fit Polygons for tree pairs at various angles\n- Moves: translate tree along NFP boundary, rotate tree, swap two trees\n- Adaptive cooling: start T high, decrease geometrically\n- Accept worse moves with probability exp(-delta/T)\n\n### Experiment 4: Improved Greedy Initialization\n- Better initial placements lead to better final solutions\n- Try different angle distributions and placement orders\n- Consider sorting trees by some heuristic before placement\n\n### Experiment 5: Genetic Algorithm\n- Chromosome: sequence of tree placements + angles\n- Crossover: combine good partial solutions (order crossover)\n- Mutation: perturb positions/angles, swap tree order\n- Selection: tournament or roulette wheel\n\n### Experiment 6: Ensemble Best Solutions\n- Run multiple algorithms with different random seeds\n- For each n, keep the configuration with smallest bounding box\n- Combine best results from different approaches\n\n## Validation Requirements\n\n### Overlap Detection\nUse Shapely library for robust polygon operations:\n```python\nfrom shapely.geometry import Polygon\nfrom shapely import affinity\nfrom shapely.strtree import STRtree\n\ndef get_tree_polygon(x, y, deg):\n    TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]\n    TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]\n    base_poly = Polygon(zip(TX, TY))\n    rotated = affinity.rotate(base_poly, deg, origin=(0, 0))\n    return affinity.translate(rotated, xoff=x, yoff=y)\n\ndef has_overlap(trees):\n    polygons = [t.polygon for t in trees]\n    tree_index = STRtree(polygons)\n    for i, poly in enumerate(polygons):\n        indices = tree_index.query(poly)\n        for idx in indices:\n            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):\n                return True\n    return False\n```\n\n### Submission Format\n- Values must be strings prefixed with 's': `s0.123456`\n- Coordinates constrained to -100 \u2264 x, y \u2264 100\n- ID format: `NNN_T` where NNN is zero-padded tree count, T is tree index\n- Total rows: 20100 (sum of 1 to 200)\n\n## Key Insights\n\n1. **Square bounding box** - The metric uses max(width, height), so aim for square-ish arrangements\n2. **Diagonal placements** - Trees at 45\u00b0 angles can interlock better\n3. **Corner utilization** - Place trees pointing into corners to minimize wasted space\n4. **Incremental building** - Good n-tree solutions often lead to good (n+1)-tree solutions\n5. **Post-processing matters** - Rotation optimization can significantly improve any solution\n6. **Multiple random seeds** - Run optimizers multiple times and keep best results\n7. **Lattice patterns** - For larger n, crystalline/lattice arrangements may be optimal\n8. **Blue/Pink phases** - Trees pointing up vs down can interlock efficiently\n\n## Scoring Function\n```python\ndef calculate_total_score(submission_df):\n    total_score = 0\n    for n in range(1, 201):\n        group = submission_df[submission_df['n'] == n]\n        polygons = [get_tree_polygon(row['x'], row['y'], row['deg']) for _, row in group.iterrows()]\n        union = unary_union(polygons)\n        bounds = union.bounds\n        side = max(bounds[2] - bounds[0], bounds[3] - bounds[1])\n        total_score += (side ** 2) / n\n    return total_score\n```\n\n## Reference Notebooks\n- Getting Started: `../research/kernels/inversion_santa-2025-getting-started/`\n- bbox3 Optimizer: `../research/kernels/jazivxt_why-not/`\n- fix_direction: `../research/kernels/saspav_santa-submission/`\n- Multi-phase Runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`\n",
      "agent": "explorer",
      "timestamp": "2026-01-19T13:45:34.758319"
    }
  ],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D bin packing optimization problem: pack Christmas tree shapes (15-vertex polygons) into smallest square bounding box for N=1-200 trees. Score = sum(s\u00b2/n) where s is side length. Lower is better. Target: 68.922808",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "bbox3 C++ optimizer uses: complex number vector coordination, fluid dynamics simulation, hinge pivot mechanics, density gradient flow, global boundary tension, aggressive overlap repair with separation vectors (MTV approximation)",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "fix_direction technique: Use scipy.optimize.minimize_scalar to find optimal rotation angle (0-90 degrees) that minimizes bounding box side length. Apply rotation to all trees in a configuration. Can improve score by tightening the bounding box.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Multi-phase optimization strategy: Phase A (short 2min runs) to find promising n,r parameters, Phase B (10min runs) on top candidates, Phase C (20min runs) on best few. Only validate/fix overlaps on winners to save time.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Greedy tree placement: Use weighted angle distribution (abs(sin(2*angle))) to place more trees in corners. Start far from center, move inward until collision, then back up. Keep best of 10 random attempts per tree.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Sample submission (greedy baseline) scores 173.65, target is 68.92. Need ~60% improvement. Bounding box side lengths grow roughly as sqrt(n) - e.g., n=50: 6.65, n=100: 8.96, n=150: 11.10, n=200: 13.03",
      "source": "exploration/eda.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Key SA techniques for 2D packing: 1) No-Fit Polygon (NFP) precomputation for fast legal move sampling, 2) Adaptive neighborhoods (large moves early, fine-grained later), 3) Hybrid SA with deterministic recursive placement inside iterations, 4) Row-building heuristic for initial layout",
      "source": "Web search: simulated annealing 2D polygon packing",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization problems?",
      "finding": "Two\u2011dimensional irregular\u2011polygon packing is a notoriously hard combinatorial problem, so the most effective approaches combine exact methods for small instances with powerful heuristics and meta\u2011heuristics for larger, industrial\u2011scale cases.  Exact branch\u2011and\u2011bound or integer\u2011programming formulations can guarantee optimality but quickly become intractable; therefore many researchers rely on **approximation and shelf\u2011packing schemes** that sort polygons by height or area and place them on successive \u201cshelves\u201d inside the container, achieving provable constant\u2011factor bounds for convex polygons\u202f([arXiv](https://export.arxiv.org/pdf/2308.08523v1.pdf)).  For truly irregular shapes, **bottom\u2011left placement** (the Bottom\u2011Left\u2011Fill strategy) remains a simple yet surprisingly effective heuristic, especially when coupled with a good ordering of items\u202f([Taylor\u202f&\u202fFrancis](https://www.taylorfrancis.com/chapters/edit/10.1201/9781351236423-33/practical-algorithms-two-dimensional-packing-general-shape",
      "agent": "explorer"
    },
    {
      "query": "What are the best techniques for simulated annealing in 2D polygon packing optimization?",
      "finding": "Simulated\u2011annealing (SA) works best for 2\u2011D polygon packing when it is combined with geometric tools that generate feasible candidate placements and with adaptive search strategies that keep the exploration\u2011exploitation balance tight.  The most widely\u2011used geometric primitive is the **No\u2011Fit Polygon (NFP)**, which describes all relative positions where two polygons would touch without overlapping; by pre\u2011computing NFPs the algorithm can quickly sample legal moves and build rows of pieces on the sheet\u202f([Graham\u202fKendall\u202f1999](https://www.graham-kendall.com/papers/bk1999c.pdf)).  Modern implementations also embed the NFP inside a fast interactive packing engine that uses custom heuristics (e.g., greedy row\u2011building and rotation selection) to produce a good initial layout before SA begins\u202f([Sy\u202f2020](https://dspace.mit.edu/bitstream/handle/1721.1/127531/1193030886-MIT.pdf?sequence=1&isAllowed=y)).  \n\nTo improve convergence, researchers employ **adaptive neighbourhoods** that change the size ",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 95
}