{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T13:39:24.355803",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D bin packing optimization problem: pack Christmas tree shapes (15-vertex polygons) into smallest square bounding box for N=1-200 trees. Score = sum(s\u00b2/n) where s is side length. Lower is better. Target: 68.922808",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "bbox3 C++ optimizer uses: complex number vector coordination, fluid dynamics simulation, hinge pivot mechanics, density gradient flow, global boundary tension, aggressive overlap repair with separation vectors (MTV approximation)",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "fix_direction technique: Use scipy.optimize.minimize_scalar to find optimal rotation angle (0-90 degrees) that minimizes bounding box side length. Apply rotation to all trees in a configuration. Can improve score by tightening the bounding box.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Multi-phase optimization strategy: Phase A (short 2min runs) to find promising n,r parameters, Phase B (10min runs) on top candidates, Phase C (20min runs) on best few. Only validate/fix overlaps on winners to save time.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Greedy tree placement: Use weighted angle distribution (abs(sin(2*angle))) to place more trees in corners. Start far from center, move inward until collision, then back up. Keep best of 10 random attempts per tree.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Sample submission (greedy baseline) scores 173.65, target is 68.92. Need ~60% improvement. Bounding box side lengths grow roughly as sqrt(n) - e.g., n=50: 6.65, n=100: 8.96, n=150: 11.10, n=200: 13.03",
      "source": "exploration/eda.ipynb",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization problems?",
      "finding": "Two\u2011dimensional irregular\u2011polygon packing is a notoriously hard combinatorial problem, so the most effective approaches combine exact methods for small instances with powerful heuristics and meta\u2011heuristics for larger, industrial\u2011scale cases.  Exact branch\u2011and\u2011bound or integer\u2011programming formulations can guarantee optimality but quickly become intractable; therefore many researchers rely on **approximation and shelf\u2011packing schemes** that sort polygons by height or area and place them on successive \u201cshelves\u201d inside the container, achieving provable constant\u2011factor bounds for convex polygons\u202f([arXiv](https://export.arxiv.org/pdf/2308.08523v1.pdf)).  For truly irregular shapes, **bottom\u2011left placement** (the Bottom\u2011Left\u2011Fill strategy) remains a simple yet surprisingly effective heuristic, especially when coupled with a good ordering of items\u202f([Taylor\u202f&\u202fFrancis](https://www.taylorfrancis.com/chapters/edit/10.1201/9781351236423-33/practical-algorithms-two-dimensional-packing-general-shape",
      "agent": "explorer"
    },
    {
      "query": "What are the best techniques for simulated annealing in 2D polygon packing optimization?",
      "finding": "Simulated\u2011annealing (SA) works best for 2\u2011D polygon packing when it is combined with geometric tools that generate feasible candidate placements and with adaptive search strategies that keep the exploration\u2011exploitation balance tight.  The most widely\u2011used geometric primitive is the **No\u2011Fit Polygon (NFP)**, which describes all relative positions where two polygons would touch without overlapping; by pre\u2011computing NFPs the algorithm can quickly sample legal moves and build rows of pieces on the sheet\u202f([Graham\u202fKendall\u202f1999](https://www.graham-kendall.com/papers/bk1999c.pdf)).  Modern implementations also embed the NFP inside a fast interactive packing engine that uses custom heuristics (e.g., greedy row\u2011building and rotation selection) to produce a good initial layout before SA begins\u202f([Sy\u202f2020](https://dspace.mit.edu/bitstream/handle/1721.1/127531/1193030886-MIT.pdf?sequence=1&isAllowed=y)).  \n\nTo improve convergence, researchers employ **adaptive neighbourhoods** that change the size ",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 95
}