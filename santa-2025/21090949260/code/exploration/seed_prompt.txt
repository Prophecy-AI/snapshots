# Christmas Tree Packing Optimization - Seed Prompt

## Problem Overview
This is a 2D bin packing optimization problem where we must pack Christmas tree-shaped polygons (15 vertices each) into the smallest possible square bounding box for configurations of N=1 to N=200 trees.

**Scoring:** score = Σ(side_n² / n) for n=1 to 200, where side_n is the side length of the minimum bounding square for the n-tree configuration. **Lower is better.**

**Target Score to Beat:** 68.931058

## Data Format
- Submission CSV with columns: id, x, y, deg
- id format: "NNN_tree_index" (e.g., "001_0", "002_0", "002_1")
- Values prefixed with 's' for string precision (e.g., "s0.123456")
- Total rows: 20100 (sum of 1+2+...+200)
- Coordinates constrained to -100 ≤ x, y ≤ 100

## Tree Geometry (15-vertex polygon)
```python
trunk_w = 0.15, trunk_h = 0.2
base_w = 0.7, mid_w = 0.4, top_w = 0.25
tip_y = 0.8, tier_1_y = 0.5, tier_2_y = 0.25, base_y = 0.0
```
The tree has a trunk at the bottom and three tiers of branches, with the tip at y=0.8.

## Key Techniques from Top Kernels

### 1. bbox3 External Optimizer (CRITICAL)
The top kernels use an external binary optimizer called `bbox3`:
- Usage: `./bbox3 -n <iterations> -r <rounds>`
- Typical parameters: -n 1000-2000, -r 30-96
- This is the primary optimization tool used by winning solutions
- See: `../research/kernels/jazivxt_why-not/why-not.ipynb`

### 2. Fix Direction / Rotation Optimization
After packing, optimize the rotation angle of the entire configuration:
```python
from scipy.optimize import minimize_scalar
from scipy.spatial import ConvexHull

def optimize_rotation(trees):
    # Get convex hull of all tree vertices
    # Use minimize_scalar to find optimal rotation angle (0-90°)
    # Rotate all trees together to minimize bounding box
```
This can significantly reduce the bounding box by aligning the configuration diagonally.
See: `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

### 3. Overlap Detection and Repair
Use Shapely's STRtree for efficient collision detection:
```python
from shapely.strtree import STRtree
# Check intersects() but not touches() for true overlaps
# Replace invalid configurations with known-good donor configurations
```

### 4. C++ Simulated Annealing Optimizer
The Santa Claude kernel implements a sophisticated C++ optimizer with:
- Simulated annealing with temperature scheduling
- Local search with multiple step sizes
- Compaction (move trees toward center)
- Squeeze (scale configuration down)
- Swap moves between trees
- Multi-angle restarts
- Boundary tree optimization
See: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

### 5. Backward Propagation
Start from N=200 and work backwards:
- For each N, try removing boundary-touching trees
- If the resulting (N-1) configuration is better than current best, save it
- This can improve smaller N configurations using larger N solutions

### 6. Greedy Initialization
The getting-started notebook shows a greedy approach:
- Place trees one at a time
- For each new tree, try multiple random angles
- Move from far away toward center until collision
- Back up until no collision
- Keep the best placement
See: `../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb`

## Recommended Experiment Pipeline

### Experiment 1: Baseline with bbox3
1. Start with sample_submission.csv
2. Run bbox3 optimizer with various parameters
3. Apply fix_direction rotation optimization
4. Validate and repair overlaps
5. Expected: Should beat baseline significantly

### Experiment 2: C++ Optimizer
1. Implement the tree_packer C++ code from Santa Claude
2. Compile with: `g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer.cpp`
3. Run with high iterations: `-n 5000 -r 16` or higher
4. Apply backward propagation post-processing

### Experiment 3: Ensemble/Combination
1. Run multiple optimizers with different seeds
2. For each N, keep the best configuration across all runs
3. Combine best results from bbox3 and C++ optimizer

### Experiment 4: Parameter Tuning
- bbox3: Try different -n and -r combinations
- C++ optimizer: Tune temperature, iterations, step sizes
- fix_direction: Multiple passes

## Implementation Notes

### ChristmasTree Class (Python)
```python
from decimal import Decimal, getcontext
from shapely import affinity
from shapely.geometry import Polygon

getcontext().prec = 25
scale_factor = Decimal('1e15')  # For precision

class ChristmasTree:
    def __init__(self, center_x='0', center_y='0', angle='0'):
        # Build 15-vertex polygon
        # Apply rotation and translation
        # Store as Shapely Polygon
```

### Scoring Function
```python
def get_score(trees, n):
    # Collect all polygon vertices
    # Find min/max x and y
    # side = max(width, height)
    # return side**2 / n
```

### Validation
```python
def has_overlap(trees):
    # Use STRtree for efficient queries
    # Check intersects() and not touches()
```

## Key Insights

1. **Precision matters**: Use Decimal with high precision (25+ digits) and scale factors
2. **Rotation optimization is cheap**: Always apply fix_direction after any optimization
3. **Overlap repair is essential**: Optimizers may create overlaps; always validate and repair
4. **Parallel processing**: Use OpenMP for C++ or multiprocessing for Python
5. **Incremental improvement**: Keep best solutions and only accept improvements
6. **Time budget**: Kaggle kernels have ~12 hour limit; plan optimization phases accordingly

## Files to Reference
- Getting started: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- Fix direction: `../research/kernels/saspav_santa-submission/`
- C++ optimizer: `../research/kernels/smartmanoj_santa-claude/`
- Why Not (bbox3): `../research/kernels/jazivxt_why-not/`
