# Christmas Tree Packing Optimization - Evolved Seed Prompt (Loop 1)

## Current Status
- Best CV score: 135.819103 from exp_000 (baseline C++ optimizer)
- Best LB score: 135.819103 (submitted, CV=LB perfect match)
- Target: 68.931058 | Gap to target: 66.89 (97% worse)

## CV-LB Relationship Analysis
- Only 1 submission so far, CV=LB exactly (optimization problem, not prediction)
- This is expected - the score is deterministic based on configuration quality
- No distribution shift concerns - this is pure optimization

## Response to Evaluator

**I agree with the evaluator's assessment:**
1. ✅ The 2x gap to target is too large for parameter tuning - need fundamental approach changes
2. ✅ bbox3 binary not available - must work with C++ optimizer or implement alternatives
3. ✅ Single optimization run is insufficient - need multi-phase, multi-seed approach
4. ✅ Backward propagation not implemented - this is a key technique from top kernels

**Key insight from kernel research:**
The top kernels (74.75 score) use **ENSEMBLE + BACKWARD PROPAGATION** as the primary strategy:
1. Collect solutions from 15+ sources (datasets, notebooks, previous runs)
2. For each N, keep the best configuration across all sources
3. Apply backward propagation: start from N=200, work backwards, propagate good patterns

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY] Multi-Phase Optimization with Backward Propagation**
The current approach ran only 290 seconds with conservative parameters. Top kernels run for 3+ hours with multiple phases.

**Implementation:**
```
Phase 1 (30 min): Parameter sweep with short runs
- Parameters: -n {2000, 3000, 4000} × -r {32, 48, 64}
- Keep best result for each N

Phase 2 (60 min): Extended runs on best parameters
- Run 5 seeds per parameter setting
- Keep best result for each N across all runs

Phase 3 (30 min): Backward propagation
- Start from N=200, iterate to N=1
- For each N, try removing each tree from N+1 config
- If result is better than current N config, use it

Phase 4 (30 min): Fractional translation polish
- Apply very fine position adjustments (0.0001 steps)
- 8 directions per tree
```

### 2. **[HIGH PRIORITY] Implement Fractional Translation**
After main optimization, apply very fine-grained position adjustments:
```cpp
double frac_steps[] = {0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001};
double dx[] = {0, 0, 1, -1, 1, 1, -1, -1};
double dy[] = {1, -1, 0, 0, 1, -1, 1, -1};
// For each tree, try each step in each direction
// Keep if improves and no collision
```

### 3. **[HIGH PRIORITY] Enhanced C++ Optimizer**
The current C++ optimizer is good but can be improved:
- Add swap moves between trees
- Implement multi-angle restarts (try different initial rotations)
- Add boundary tree optimization (focus on trees touching bbox)
- Increase SA iterations and rounds

### 4. **[MEDIUM PRIORITY] Iterative Refinement Loop**
Run optimization in a loop until no improvement:
```
while True:
    old_score = current_score
    run_optimizer()
    apply_fix_direction()
    apply_fractional_translation()
    if current_score >= old_score - epsilon:
        break
```

## What NOT to Try
- ❌ Simple parameter tuning (gap too large)
- ❌ Single-pass optimization (need multi-phase)
- ❌ Starting from scratch each time (need to build on best solutions)
- ❌ Ignoring backward propagation (key technique)

## Validation Notes
- CV scheme: Direct score calculation (deterministic)
- Overlap validation: Use STRtree for efficient collision detection
- Score formula: Σ(side²/N) for N=1 to 200

## SUBMISSION STRATEGY
- Remaining submissions: 99
- **SUBMIT AFTER EVERY EXPERIMENT** - we have abundant submissions
- LB feedback is free information - use it to calibrate

## Technical Implementation Notes

### Backward Propagation Algorithm
```python
for n in range(200, 1, -1):
    current_side = get_side_length(configs[n-1])
    best_side = current_side
    best_tree_to_remove = None
    
    for tree_idx in range(n):
        # Try removing this tree from config[n]
        candidate = configs[n].copy()
        del candidate[tree_idx]
        candidate_side = get_side_length(candidate)
        
        if candidate_side < best_side:
            best_side = candidate_side
            best_tree_to_remove = tree_idx
    
    if best_tree_to_remove is not None:
        configs[n-1] = configs[n].copy()
        del configs[n-1][best_tree_to_remove]
```

### Enhanced SA Parameters
```cpp
// Higher temperature for more exploration
double Tmax = 1.0;
double Tmin = 0.000005;
double alpha = 0.25;  // Cooling rate
int sa_iterations = 20000;  // Much higher than current 2000
int rounds = 80;  // Much higher than current 32
```

## Files to Reference
- C++ optimizer: `research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`
- Backward propagation: `research/kernels/crodoc_74-75-backpacking-christmas-trees/`
- Fractional translation: `research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation/`
- Ensemble approach: `research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation/`

## Expected Outcome
With multi-phase optimization + backward propagation + fractional translation:
- Target: Score < 80 (significant improvement from 135.82)
- Stretch goal: Score < 75 (approaching top kernel scores)