{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-17T07:51:53.055548",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [
    {
      "strategy": "# Christmas Tree Packing Optimization - Seed Prompt\n\n## Problem Overview\nThis is a 2D bin packing optimization problem where we must pack Christmas tree-shaped polygons (15 vertices each) into the smallest possible square bounding box for configurations of N=1 to N=200 trees.\n\n**Scoring:** score = \u03a3(side_n\u00b2 / n) for n=1 to 200, where side_n is the side length of the minimum bounding square for the n-tree configuration. **Lower is better.**\n\n**Target Score to Beat:** 68.931058\n\n## Data Format\n- Submission CSV with columns: id, x, y, deg\n- id format: \"NNN_tree_index\" (e.g., \"001_0\", \"002_0\", \"002_1\")\n- Values prefixed with 's' for string precision (e.g., \"s0.123456\")\n- Total rows: 20100 (sum of 1+2+...+200)\n- Coordinates constrained to -100 \u2264 x, y \u2264 100\n\n## Tree Geometry (15-vertex polygon)\n```python\ntrunk_w = 0.15, trunk_h = 0.2\nbase_w = 0.7, mid_w = 0.4, top_w = 0.25\ntip_y = 0.8, tier_1_y = 0.5, tier_2_y = 0.25, base_y = 0.0\n```\nThe tree has a trunk at the bottom and three tiers of branches, with the tip at y=0.8. Total height ~1.0 units.\n\n## Key Techniques from Top Kernels\n\n### 1. bbox3 External Optimizer (CRITICAL - PRIMARY TOOL)\nThe top kernels use an external binary optimizer called `bbox3`:\n- Usage: `./bbox3 -n <iterations> -r <rounds>`\n- Typical parameters: -n 1000-2000, -r 30-96\n- Higher values = better results but longer runtime\n- This is the primary optimization tool used by winning solutions\n- See: `../research/kernels/jazivxt_why-not/why-not.ipynb`\n\n### 2. Fix Direction / Rotation Optimization\nAfter packing, optimize the rotation angle of the entire configuration:\n```python\nfrom scipy.optimize import minimize_scalar\nfrom scipy.spatial import ConvexHull\n\ndef optimize_rotation(trees):\n    # Get convex hull of all tree vertices\n    # Use minimize_scalar to find optimal rotation angle (0-90\u00b0)\n    # Rotate all trees together to minimize bounding box\n```\nThis can significantly reduce the bounding box by aligning the configuration diagonally.\nSee: `../research/kernels/saspav_santa-submission/santa-submission.ipynb`\n\n### 3. Overlap Detection and Repair\nUse Shapely's STRtree for efficient collision detection:\n```python\nfrom shapely.strtree import STRtree\n# Check intersects() but not touches() for true overlaps\n# Replace invalid configurations with known-good donor configurations\n```\n\n### 4. C++ Simulated Annealing Optimizer\nThe Santa Claude kernel implements a sophisticated C++ optimizer with:\n- Simulated annealing with temperature scheduling\n- Local search with multiple step sizes (0.01, 0.004, 0.0015, 0.0006, 0.00025, 0.0001)\n- Compaction (move trees toward center)\n- Squeeze (scale configuration down uniformly)\n- Swap moves between trees\n- Multi-angle restarts\n- Boundary tree optimization\n- Compile: `g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer.cpp`\nSee: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n\n### 5. Backward Propagation\nStart from N=200 and work backwards:\n- For each N, try removing boundary-touching trees\n- If the resulting (N-1) configuration is better than current best, save it\n- This can improve smaller N configurations using larger N solutions\n- Focus on trees that touch the bounding box boundary\n\n### 6. Greedy Initialization\nThe getting-started notebook shows a greedy approach:\n- Place trees one at a time\n- For each new tree, try multiple random angles (weighted by |sin(2*angle)|)\n- Move from far away toward center until collision\n- Back up until no collision\n- Keep the best placement from multiple attempts\nSee: `../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb`\n\n## Academic Literature Insights (2D Irregular Polygon Packing)\n\nFrom research on 2D irregular packing problems:\n1. **Meta-heuristics dominate**: GA, simulated annealing, tabu search are most effective\n2. **No-fit polygon (NFP)**: Precompute collision-free placement regions for efficiency\n3. **Bottom-left heuristic**: Classic placement strategy - place at lowest-leftmost valid position\n4. **Jostle algorithm**: Iteratively shake/compact pieces to reduce waste\n5. **Extended local search**: Combine local search with nonlinear programming for fine-tuning\n\n## Recommended Experiment Pipeline\n\n### Experiment 1: Baseline with bbox3 (PRIORITY)\n1. Start with sample_submission.csv\n2. Run bbox3 optimizer: `./bbox3 -n 1000 -r 60`\n3. Apply fix_direction rotation optimization\n4. Validate and repair overlaps\n5. Expected: Should beat baseline significantly\n\n### Experiment 2: C++ Optimizer\n1. Implement the tree_packer C++ code from Santa Claude\n2. Compile with: `g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer.cpp`\n3. Run with high iterations: `-n 5000 -r 16` or higher\n4. Apply backward propagation post-processing\n\n### Experiment 3: Multi-Phase Optimization\n1. Phase A: Short runs with many parameter combinations (2 min each)\n2. Phase B: Medium runs on top candidates (10 min each)\n3. Phase C: Long runs on best few (20 min each)\n4. Always keep best solution, revert on regression\n\n### Experiment 4: Ensemble/Combination\n1. Run multiple optimizers with different seeds\n2. For each N, keep the best configuration across all runs\n3. Combine best results from bbox3 and C++ optimizer\n\n### Experiment 5: Parameter Tuning\n- bbox3: Try -n {1000, 1200, 1500, 1800, 2000} and -r {30, 60, 90}\n- C++ optimizer: Tune temperature, iterations, step sizes\n- fix_direction: Multiple passes (1-3)\n\n## Implementation Notes\n\n### ChristmasTree Class (Python)\n```python\nfrom decimal import Decimal, getcontext\nfrom shapely import affinity\nfrom shapely.geometry import Polygon\n\ngetcontext().prec = 25\nscale_factor = Decimal('1e15')  # For precision\n\nclass ChristmasTree:\n    def __init__(self, center_x='0', center_y='0', angle='0'):\n        # Build 15-vertex polygon\n        # Apply rotation and translation\n        # Store as Shapely Polygon\n```\n\n### Scoring Function\n```python\ndef get_score(trees, n):\n    # Collect all polygon vertices\n    # Find min/max x and y\n    # side = max(width, height)\n    # return side**2 / n\n\ndef total_score(all_configs):\n    return sum(get_score(trees, n) for n, trees in all_configs.items())\n```\n\n### Validation\n```python\ndef has_overlap(trees):\n    # Use STRtree for efficient queries\n    # Check intersects() and not touches()\n    polygons = [t.polygon for t in trees]\n    tree_index = STRtree(polygons)\n    for i, poly in enumerate(polygons):\n        indices = tree_index.query(poly)\n        for idx in indices:\n            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):\n                return True\n    return False\n```\n\n## Key Insights\n\n1. **Precision matters**: Use Decimal with high precision (25+ digits) and scale factors (1e15 or 1e18)\n2. **Rotation optimization is cheap**: Always apply fix_direction after any optimization\n3. **Overlap repair is essential**: Optimizers may create overlaps; always validate and repair\n4. **Parallel processing**: Use OpenMP for C++ or multiprocessing for Python\n5. **Incremental improvement**: Keep best solutions and only accept improvements\n6. **Time budget**: Kaggle kernels have ~12 hour limit; plan optimization phases accordingly\n7. **Boundary trees matter**: Trees touching the bounding box boundary determine the score\n8. **Lattice patterns**: Good solutions often show crystalline/lattice-like arrangements\n\n## Files to Reference\n- Getting started: `../research/kernels/inversion_santa-2025-getting-started/`\n- bbox3 runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`\n- Fix direction: `../research/kernels/saspav_santa-submission/`\n- C++ optimizer: `../research/kernels/smartmanoj_santa-claude/`\n- Why Not (bbox3): `../research/kernels/jazivxt_why-not/`\n\n## Critical Implementation Details\n\n### Submission Format\n```python\n# Values must be prefixed with 's' for string precision\nfor col in ['x', 'y', 'deg']:\n    submission[col] = 's' + submission[col].astype('string')\n```\n\n### Overlap Repair Strategy\nWhen overlaps are detected, replace the invalid configuration with a known-good one:\n```python\ndef replace_group(target_file, donor_file, group_id, output_file):\n    # Load both files\n    # Replace the invalid group with donor's version\n    # Save result\n```\n\n### Multi-Run Best Selection\n```python\ndef merge_best_configs(run_results):\n    best_configs = {}\n    for n in range(1, 201):\n        best_side = float('inf')\n        for result in run_results:\n            if result[n]['side'] < best_side and not result[n]['has_overlap']:\n                best_side = result[n]['side']\n                best_configs[n] = result[n]['trees']\n    return best_configs\n```\n",
      "agent": "explorer",
      "timestamp": "2026-01-17T07:54:58.331385"
    }
  ],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D bin packing optimization problem: pack Christmas tree shapes (15-vertex polygons) into smallest square bounding box for N=1 to 200 trees. Score = sum of (side^2/N) for all N. Lower is better.",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "Key tool: bbox3 binary - external optimizer that takes -n (iterations) and -r (rounds) parameters. Used by top kernels for optimization. Example: ./bbox3 -n 1000 -r 96",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "fix_direction technique: Optimize rotation angle of entire configuration to minimize bounding box. Uses scipy.optimize.minimize_scalar on convex hull points. Can improve score by rotating all trees together.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Overlap repair strategy: After optimization, check for overlapping trees and replace invalid configurations with known-good ones from a donor file. Use STRtree for efficient collision detection.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "C++ optimizer (Santa Claude): Uses simulated annealing, local search, compaction, squeeze operations. Multi-threaded with OpenMP. Includes swap moves, multi-angle restarts, boundary tree optimization.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Backward propagation technique: Start from N=200 and work backwards, removing boundary-touching trees to potentially improve smaller N configurations.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "State-of-the-art 2D irregular polygon packing uses: (1) Meta-heuristics: GA, simulated annealing, tabu search (2) Local search with nonlinear programming (3) No-fit polygon for efficient collision detection (4) Bottom-left placement heuristics (5) Compaction/jostle algorithms",
      "source": "Web search: 2D irregular polygon packing algorithms",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization problems?",
      "finding": "Two\u2011dimensional irregular polygon packing is a classic combinatorial optimisation problem that appears in shipbuilding, metal\u2011working, textile, furniture and many other manufacturing sectors.  Because the shapes are non\u2011convex and can be rotated arbitrarily, exact methods quickly become intractable, so the most successful approaches combine clever geometric preprocessing (e.g., robust no\u2011fit\u2011polygon generation) with powerful heuristic or approximation schemes\u202f([ScienceDirect](https://www.sciencedirect.com/science/article/abs/pii/S0377221706001639)).  \n\nThe current state\u2011of\u2011the\u2011art consists of three complementary families of algorithms.  \n\n1. **Meta\u2011heuristics** \u2013 Genetic algorithms, simulated\u2011annealing, tabu search and artificial\u2011neural\u2011network based methods dominate the literature for irregular strip\u2011 and bin\u2011packing, often using a bottom\u2011left placement rule to construct feasible layouts from a given item order\u202f([Springer](https://link.springer.com/article/10.1023/A:1012590107280)).  ",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 100
}