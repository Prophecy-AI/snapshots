# Santa 2025 - Christmas Tree Packing Challenge

## Problem Overview
This is a 2D bin packing optimization problem where we need to fit Christmas tree-shaped polygons (15 vertices each) into the smallest possible square bounding box for configurations of N=1 to 200 trees.

**Scoring:** score = Σ(S_n²/n) for n=1 to 200, where S_n is the side length of the bounding square for n trees. **Lower is better.**

**Target Score:** Beat 68.894234

## Current Status (from previous experiments)
- Best achieved score: ~70.62 (verified on LB)
- Gap to target: ~1.73 points (2.5%)
- 38+ experiments tried: bbox3, SA, GA, MIP, tessellation, basin hopping, deletion cascade, asymmetric solutions, ensemble from 107+ sources
- **ALL converged to same local optimum** - need fundamentally different approach

## Score Breakdown by N Range
- N=1-10: 4.33 (6.1%) - **Lowest efficiency, highest impact per tree**
- N=11-50: 14.70 (20.8%)
- N=51-100: 17.61 (24.9%)
- N=101-150: 17.14 (24.3%)
- N=151-200: 16.84 (23.8%)

**Key insight:** N=1 is already at theoretical minimum (0.813 side at 45°). Need ~1.23% reduction in ALL side lengths uniformly to reach target.

## CRITICAL: Overlap Detection
- **Local overlap detection is LESS strict than Kaggle's**
- Solutions that pass local validation may FAIL on LB with "Overlapping trees in group XXX"
- **ALWAYS use buffer=0.001 in overlap detection to avoid LB failures**
- Test on LB early to verify solutions are valid

## Key Optimization Tools

### 1. bbox3 C++ Optimizer (Primary Tool)
Advanced version from jazivxt "why-not" kernel with features:
- Global Boundary Tension (GLOBAL_TENSION_STRENGTH = 0.05)
- Density Gradient Flow
- Complex Number Vector Coordination
- Hinge Pivot mechanics
- Aggressive Overlap-and-Repair Cycle

**Compilation:**
```bash
g++ -O3 -march=native -fopenmp -std=c++17 bbox3.cpp -o bbox3
```

**Usage:**
```bash
./bbox3 -n <iterations> -r <restarts>
# Example: ./bbox3 -n 10000 -r 128
```

### 2. tree_packer C++ Optimizers
From jonathanchan/smartmanoj kernels:
- tree_packer_v3.cpp: Corner tree targeting, population-based search, basin hopping
- tree_packer_v18.cpp: Parallel + aggressive back propagation, free-area heuristic
- tree_packer_v21.cpp: Swap moves, multi-angle restarts, higher temperature SA

**Usage:**
```bash
g++ -fopenmp -O3 -march=native -std=c++17 -o tree_packer tree_packer_v18.cpp
./tree_packer -i input.csv -o output.csv -n 150000 -r 32
```

### 3. fix_direction Rotation Optimization
Optimizes the rotation angle of the entire configuration to minimize bounding box:
- Uses scipy.optimize.minimize_scalar
- Searches angles 0-90 degrees
- Can reduce side length by finding optimal rotation

### 4. Squeeze/Compaction
- Scale all trees toward centroid
- Start at 0.9995 scale, decrease by 0.0005
- Stop when overlap detected

## Tree Geometry (15 vertices)
```python
# Tree dimensions
trunk_w = 0.15, trunk_h = 0.2
base_w = 0.7, mid_w = 0.4, top_w = 0.25
tip_y = 0.8, tier_1_y = 0.5, tier_2_y = 0.25, base_y = 0.0

# Vertices (TX, TY)
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- Values must be prefixed with 's'
- Coordinates constrained to -100 ≤ x, y ≤ 100
- Use high-precision Decimal arithmetic (25+ digits)
- scale_factor = 1e15 for Decimal precision

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Ensemble from ALL Available Sources
The jonathanchan kernel approach:
1. Collect submissions from ALL available sources:
   - `/home/nonroot/snapshots/santa-2025/*/submission/*.csv`
   - `/home/nonroot/snapshots/santa-2025/*/code/submission_candidates/*.csv`
   - All experiment outputs
2. For each N (1-200), keep the configuration with smallest side length
3. Override N=1 with fixed 45° rotation (theoretical minimum)
4. Run tree_packer optimization on ensemble result with LONG runs:
   ```bash
   ./tree_packer -i ensemble.csv -o output.csv -n 150000 -r 32
   ```

**Sources to ensemble from (jonathanchan list):**
- bucket-of-chump
- why-not
- santa25-improved-sa-with-translations
- santa-submission
- santa25-simulated-annealing-with-translations
- telegram-public-shared-solution
- santa-claude
- All snapshot submissions

### 2. **[HIGH PRIORITY]** Very Long Optimization Runs
Top solutions run for HOURS, not minutes:
- `-n 150000` iterations (not 1000)
- `-r 32` or more restarts
- Multiple generations with perturbation to escape local optima
- Use OMP_NUM_THREADS=32 for parallelization

### 3. **[HIGH PRIORITY]** Lattice/Grid-Based Approach for Large N
For N >= 58, use crystalline packing:
- Start with 2 base trees in optimal configuration
- Translate in x and y directions to create grid pattern
- Parameters: nt = [nx, ny] where nx*ny >= N
- Can achieve tighter bounds than random optimization

### 4. **[MEDIUM PRIORITY]** Backward Propagation
Start from N=200, work down to N=2:
```python
for n in range(200, 1, -1):
    for tree_to_remove in range(n):
        candidate = remove_tree(config[n], tree_to_remove)
        if score(candidate) < score(config[n-1]):
            config[n-1] = candidate
```

### 5. **[MEDIUM PRIORITY]** Focus on Small N Values (1-10)
- These have lowest efficiency and highest score contribution
- N=1 MUST be at 45° rotation (theoretical minimum: side=0.813)
- Try exhaustive search for optimal rotation angles for N=2-10

### 6. **[NEW - NOT TRIED]** Guided Local Search (GLS)
- Penalize features of local optima to escape them
- Systematically explore different regions of solution space

### 7. **[NEW - NOT TRIED]** Variable Neighborhood Search (VNS)
- Start with small neighborhood (fine moves)
- If stuck, switch to larger neighborhood (coarse moves)
- Prevents cycling back to recently visited solutions

## What NOT to Try (Exhausted)
- Standard bbox3 with short iterations (tried extensively)
- Standard SA with same initialization
- Simple ensemble without optimization
- MIP for small N (baseline already optimal)
- Basin hopping (no improvement)
- Greedy beam search (no improvement)
- Deletion cascade (no improvement)

## Reference Implementations
- Getting Started: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 Runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- Advanced bbox3: `../research/kernels/jazivxt_why-not/` (HAS ADVANCED FEATURES)
- SA + Fractional Translation: `../research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation/`
- Tree Packer: `../research/kernels/smartmanoj_santa-claude/`

## Pre-optimized Solutions Available
- Best snapshots in `/home/nonroot/snapshots/santa-2025/`
- Best submission: `/home/nonroot/snapshots/santa-2025/21322576451/submission/submission.csv`
- Look for submission.csv files with scores ~70.62
- Use as starting point for further optimization

## Scoring Function (Python)
```python
from numba import njit
import math
import numpy as np

@njit
def make_polygon_template():
    tw=0.15; th=0.2; bw=0.7; mw=0.4; ow=0.25
    tip=0.8; t1=0.5; t2=0.25; base=0.0; tbot=-th
    x=np.array([0,ow/2,ow/4,mw/2,mw/4,bw/2,tw/2,tw/2,-tw/2,-tw/2,-bw/2,-mw/4,-mw/2,-ow/4,-ow/2],np.float64)
    y=np.array([tip,t1,t1,t2,t2,base,base,tbot,tbot,base,base,t2,t2,t1,t1],np.float64)
    return x,y

@njit
def score_group(xs,ys,degs,tx,ty):
    n=xs.size; V=tx.size
    mnx=1e300; mny=1e300; mxx=-1e300; mxy=-1e300
    for i in range(n):
        r=degs[i]*math.pi/180.0
        c=math.cos(r); s=math.sin(r)
        xi=xs[i]; yi=ys[i]
        for j in range(V):
            X=c*tx[j]-s*ty[j]+xi
            Y=s*tx[j]+c*ty[j]+yi
            if X<mnx: mnx=X
            if X>mxx: mxx=X
            if Y<mny: mny=Y
            if Y>mxy: mxy=Y
    side=max(mxx-mnx,mxy-mny)
    return side*side/n
```

## Validation Checklist
1. ✅ Check for overlaps with buffer=0.001
2. ✅ Verify coordinates within [-100, 100]
3. ✅ Ensure 's' prefix on all values
4. ✅ Calculate local score before submitting
5. ✅ Submit early to verify LB acceptance

## Key Insights
1. **38 experiments all converged to same optimum** - Need fundamentally different approach
2. **Local validation is less strict than Kaggle's** - Use conservative overlap detection
3. **Current N=2 config is better than exhaustive search** - Solution uses sophisticated non-obvious configurations
4. **1.23% reduction in all side lengths needed** - This is the uniform improvement target
5. **Advanced bbox3 has untried features** - Global tension, density gradient, hinge pivot
6. **Academic techniques not tried** - GLS, L-BFGS, VNS, Tabu Search, Partitioning
7. **jonathanchan kernel achieves sub-68** - Uses ensemble + very long SA runs (150000 iterations)

## CRITICAL PATH TO TARGET
The gap (1.73 points) requires ~1.23% reduction in ALL side lengths uniformly.
This is NOT achievable by fixing individual N values - it requires GLOBAL improvement.

**Approaches that could achieve this:**
1. Ensemble from ALL available sources + VERY LONG optimization runs (hours)
2. Advanced bbox3 with global tension features + LONG runs (hours)
3. Lattice-based approach for large N values
4. Guided Local Search to escape current local optimum
5. Variable Neighborhood Search for systematic exploration

**The target IS achievable** - we just need to find the right approach that escapes the current local optimum.
