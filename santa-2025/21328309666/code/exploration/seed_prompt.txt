# Santa 2025 - Christmas Tree Packing Challenge

## Problem Overview
This is a 2D bin packing optimization problem where we need to fit Christmas tree-shaped polygons (15 vertices each) into the smallest possible square bounding box for configurations of N=1 to 200 trees.

**Scoring:** score = Σ(S_n²/n) for n=1 to 200, where S_n is the side length of the bounding square for n trees. **Lower is better.**

**Target Score:** Beat 68.894234

## Current Status (from previous experiments)
- Best achieved score: ~70.62 (verified on LB)
- Gap to target: ~1.73 points (2.5%)
- 38+ experiments tried: bbox3, SA, GA, MIP, tessellation, basin hopping, deletion cascade, asymmetric solutions, ensemble from 107+ sources
- **ALL converged to same local optimum** - need fundamentally different approach

## Score Breakdown by N Range
- N=1-10: 4.33 (6.1%) - **Lowest efficiency, highest impact per tree**
- N=11-50: 14.70 (20.8%)
- N=51-100: 17.61 (24.9%)
- N=101-150: 17.14 (24.3%)
- N=151-200: 16.84 (23.8%)

**Key insight:** N=1 is already at theoretical minimum (0.813 side at 45°). Need ~1.23% reduction in ALL side lengths uniformly to reach target.

## CRITICAL: Overlap Detection
- **Local overlap detection is LESS strict than Kaggle's**
- Solutions that pass local validation may FAIL on LB with "Overlapping trees in group XXX"
- **ALWAYS use buffer=0.001 in overlap detection to avoid LB failures**
- Test on LB early to verify solutions are valid

## Key Optimization Tools

### 1. bbox3 C++ Optimizer (Primary Tool)
Advanced version from jazivxt "why-not" kernel with features:
- Global Boundary Tension (GLOBAL_TENSION_STRENGTH = 0.05)
- Density Gradient Flow
- Complex Number Vector Coordination
- Hinge Pivot mechanics
- Aggressive Overlap-and-Repair Cycle

**Compilation:**
```bash
g++ -O3 -march=native -fopenmp -std=c++17 bbox3.cpp -o bbox3
```

**Usage:**
```bash
./bbox3 -n <iterations> -r <restarts>
# Example: ./bbox3 -n 10000 -r 128
```

### 2. fix_direction Rotation Optimization
Optimizes the rotation angle of the entire configuration to minimize bounding box:
- Uses scipy.optimize.minimize_scalar
- Searches angles 0-90 degrees
- Can reduce side length by finding optimal rotation

### 3. Simulated Annealing with Fractional Translation
Fine-tuning with micro-adjustments:
- Step sizes: 0.001, 0.0005, 0.0002, 0.0001
- Move operators: translation, rotation, swap
- Temperature schedule: geometric cooling

### 4. Squeeze/Compaction
- Scale all trees toward centroid
- Start at 0.9995 scale, decrease by 0.0005
- Stop when overlap detected

## Tree Geometry (15 vertices)
```python
# Tree dimensions
trunk_w = 0.15, trunk_h = 0.2
base_w = 0.7, mid_w = 0.4, top_w = 0.25
tip_y = 0.8, tier_1_y = 0.5, tier_2_y = 0.25, base_y = 0.0

# Vertices (TX, TY)
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- Values must be prefixed with 's'
- Coordinates constrained to -100 ≤ x, y ≤ 100
- Use high-precision Decimal arithmetic (25+ digits)

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Ensemble from Multiple Sources
- Collect submissions from all available snapshots
- For each N, keep the configuration with smallest side length
- Run bbox3 optimization on the ensemble result
- Previous ensemble found 87 improvements totaling 0.006 points

### 2. **[HIGH PRIORITY]** Long Optimization Runs
Top solutions run for HOURS, not minutes:
- `-n 20000` iterations or more
- `-r 100` restarts or more
- Multiple generations with perturbation to escape local optima

### 3. **[HIGH PRIORITY]** Lattice/Grid-Based Approach for Large N
For N >= 58, use crystalline packing:
- Start with 2 base trees in optimal configuration
- Translate in x and y directions to create grid pattern
- Parameters: nt = [nx, ny] where nx*ny >= N
- Can achieve tighter bounds than random optimization

### 4. **[MEDIUM PRIORITY]** Backward Propagation
Start from N=200, work down to N=2:
```python
for n in range(200, 1, -1):
    for tree_to_remove in range(n):
        candidate = remove_tree(config[n], tree_to_remove)
        if score(candidate) < score(config[n-1]):
            config[n-1] = candidate
```

### 5. **[MEDIUM PRIORITY]** Focus on Small N Values (1-10)
- These have lowest efficiency and highest score contribution
- Try exhaustive search for optimal rotation angles
- N=1 should be at 45° rotation (theoretical minimum)

### 6. **[NEW - NOT TRIED]** Guided Local Search (GLS)
- Penalize features of local optima to escape them
- Systematically explore different regions of solution space

### 7. **[NEW - NOT TRIED]** Variable Neighborhood Search (VNS)
- Start with small neighborhood (fine moves)
- If stuck, switch to larger neighborhood (coarse moves)
- Prevents cycling back to recently visited solutions

## What NOT to Try (Exhausted)
- Standard bbox3 with short iterations (tried extensively)
- Standard SA with same initialization
- Simple ensemble without optimization
- MIP for small N (baseline already optimal)
- Basin hopping (no improvement)
- Greedy beam search (no improvement)
- Deletion cascade (no improvement)

## Reference Implementations
- Getting Started: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 Runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- Advanced bbox3: `../research/kernels/jazivxt_why-not/` (HAS ADVANCED FEATURES)
- SA + Fractional Translation: `../research/kernels/smartmanoj_santa-claude/`

## Pre-optimized Solutions Available
- Best snapshots in `/home/nonroot/snapshots/santa-2025/`
- Look for submission.csv files with scores ~70.62
- Use as starting point for further optimization

## Validation Checklist
1. ✅ Check for overlaps with buffer=0.001
2. ✅ Verify coordinates within [-100, 100]
3. ✅ Ensure 's' prefix on all values
4. ✅ Calculate local score before submitting
5. ✅ Submit early to verify LB acceptance

## Key Insights
1. **38 experiments all converged to same optimum** - Need fundamentally different approach
2. **Local validation is less strict than Kaggle's** - Use conservative overlap detection
3. **Current N=2 config is better than exhaustive search** - Solution uses sophisticated non-obvious configurations
4. **1.23% reduction in all side lengths needed** - This is the uniform improvement target
5. **Advanced bbox3 has untried features** - Global tension, density gradient, hinge pivot
6. **Academic techniques not tried** - GLS, L-BFGS, VNS, Tabu Search, Partitioning

## CRITICAL PATH TO TARGET
The gap (1.73 points) requires ~1.23% reduction in ALL side lengths uniformly.
This is NOT achievable by fixing individual N values - it requires GLOBAL improvement.

**Approaches that could achieve this:**
1. Advanced bbox3 with global tension features + LONG runs (hours)
2. Ensemble from ALL available sources + optimization
3. Lattice-based approach for large N values
4. Guided Local Search to escape current local optimum
5. Variable Neighborhood Search for systematic exploration

**The target IS achievable** - we just need to find the right approach that escapes the current local optimum.
