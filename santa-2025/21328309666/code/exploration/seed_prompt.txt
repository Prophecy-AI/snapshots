# Santa 2025 - Christmas Tree Packing Challenge

## Current Status
- Best CV score: 70.619825 from exp_000 (001_baseline)
- Best LB score: N/A (no submissions yet)
- Target: 68.894234 | Gap to target: 1.725591 points (2.5%)

## Public Kernel Status (CRITICAL!)
- Have we implemented the best kernel yet? **NO** - only copied a snapshot
- Top kernels identified:
  1. jonathanchan/santa25-ensemble-sa-fractional-translation (176 votes) - Ensemble + SA + Fractional Translation
  2. jazivxt/why-not (352 votes) - bbox3 with Global Dynamics (Complex Numbers, Hinge Pivot, Density Gradient)
  3. smartmanoj/santa-claude (378 votes) - tree_packer_v21 with swap moves, multi-angle restarts
  4. yongsukprasertsuk/santa-2025-best-keeping-bbox3-runner (369 votes) - Best-keeping bbox3 runner
- Kernels we've implemented: NONE (only copied a snapshot)
- Kernels still to implement: ALL OF THEM
- **STOP - implement best kernel approach FIRST!**

## Response to Evaluator

The evaluator correctly identified that:
1. **The ensemble hasn't been built yet** - This is the #1 priority but wasn't executed
2. **No LB submission made** - With 100 submissions available, we need to verify baseline is valid
3. **No optimization run executed** - The baseline is just a copy

I fully agree with the evaluator's assessment. The next experiment MUST:
1. Build ensemble from ALL 3209 CSV files available
2. Run tree_packer optimization on the ensemble
3. Submit to LB to verify validity

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Build Ensemble + Run Optimization
The jonathanchan kernel approach is the most direct path to improvement:

**Step 1: Build ensemble from ALL available sources**
```python
# Find all CSV files in snapshots
import glob
csv_files = glob.glob('/home/nonroot/snapshots/santa-2025/**/submission*.csv', recursive=True)
csv_files += glob.glob('/home/nonroot/snapshots/santa-2025/**/candidate*.csv', recursive=True)
# For each N (1-200), keep the configuration with smallest side length
```

**Step 2: Override N=1 with optimal 45° rotation**
- N=1 theoretical minimum: side = 0.813173 at 45° rotation
- Score contribution: 0.661250 (already optimal)

**Step 3: Compile and run tree_packer_v21 from smartmanoj kernel**
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer_v21.cpp
./tree_packer -i ensemble.csv -o optimized.csv -n 15000 -r 5
```

**Step 4: Submit to LB to verify validity**

### 2. **[HIGH PRIORITY]** Very Long Optimization Runs
After ensemble is built, run LONG optimization:
- `-n 150000` iterations (not 1000)
- `-r 32` or more restarts
- Use OMP_NUM_THREADS for parallelization
- Run for HOURS, not minutes

### 3. **[MEDIUM PRIORITY]** bbox3 with Global Dynamics
The jazivxt "why-not" kernel has advanced features:
- Global Boundary Tension (GLOBAL_TENSION_STRENGTH = 0.05)
- Complex Number Vector Coordination
- Hinge Pivot mechanics
- Aggressive Overlap-and-Repair Cycle

### 4. **[MEDIUM PRIORITY]** Focus on Small N Values (2-10)
- N=1 is already optimal (45° rotation)
- N=2-10 have highest score contribution per tree
- Try exhaustive search for optimal configurations

## What NOT to Try
- Short optimization runs (< 10000 iterations)
- Standard SA without ensemble
- Building from scratch when 3209 CSV files are available

## Key Resources
- **3209 CSV files** available in `/home/nonroot/snapshots/santa-2025/`
- **tree_packer_v21.cpp** in `/home/code/research/kernels/smartmanoj_santa-claude/`
- **bbox3.cpp** in `/home/code/research/kernels/jazivxt_why-not/`
- **jonathanchan ensemble approach** in `/home/code/research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation/`

## Submission Strategy
- Remaining submissions: 100
- **Submit after this experiment?** YES - we have abundant submissions
- LB feedback is FREE information - use it!

## Validation Notes
- **CRITICAL**: Local overlap detection is LESS strict than Kaggle's
- Use buffer=0.001 in overlap detection to avoid LB failures
- Submit early to verify solutions are valid

## Score Breakdown (for reference)
- N=1-10: 4.33 (6.1%) - Lowest efficiency, highest impact
- N=11-50: 14.70 (20.8%)
- N=51-100: 17.61 (24.9%)
- N=101-150: 17.14 (24.3%)
- N=151-200: 16.84 (23.9%)

## Tree Geometry (15 vertices)
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## Scoring Function
```python
score = Σ(S_n²/n) for n=1 to 200
# where S_n is the side length of the bounding square for n trees
# Lower is better
```
