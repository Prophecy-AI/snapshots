# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt

## Problem Overview

This is a 2D irregular polygon packing optimization problem. The goal is to pack N Christmas tree-shaped polygons (N=1 to 200) into the smallest possible square bounding box for each N value.

**Scoring Formula:** `score = sum(side_n^2 / n)` for n=1 to 200

Lower scores are better. The target score to beat is **68.882921**.

## ⛔ ABSOLUTELY FORBIDDEN (EXPERIMENT WILL BE REJECTED)

The following are PERMANENTLY FORBIDDEN after baseline:
- bbox3 - FORBIDDEN
- sa_fast_v2 - FORBIDDEN  
- eazy_optimizer - FORBIDDEN
- tree_packer - FORBIDDEN
- shake_public - FORBIDDEN
- subprocess.run() - FORBIDDEN
- os.system() - FORBIDDEN
- ANY pre-compiled binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any tool - FORBIDDEN
- Running "more iterations" on any optimizer - FORBIDDEN

If your experiment runs ANY binary, it will produce ~70.6.
The target is 68.89. BINARIES CANNOT GET THERE.

## ✅ MANDATORY FIRST TASK: SOLVE N=1-10 OPTIMALLY

BEFORE any other work, implement exhaustive search for small N:

For N=1 (contributes ~0.66 to score - HIGHEST!):
- Test EVERY rotation angle from 0° to 360° in 0.01° increments
- Find the angle that minimizes bounding box
- This alone can improve score by 0.05-0.1 points

For N=2-10:
- Implement branch-and-bound or exhaustive placement search
- These contribute ~2.5 points total - worth optimizing!

## ✅ MANDATORY: PER-N SOLUTION TRACKING

Track best solution for EACH N value separately:
1. Load baseline per-N scores from existing submission
2. After your algorithm runs, compare per-N scores
3. SAVE any N where you improved (even if total is worse)
4. Accumulate improvements across experiments

## Baseline Solutions Available

Pre-optimized solutions exist in `/home/nonroot/snapshots/santa-2025/*/submission/submission.csv`
- These are already optimized by previous runs
- Use the BEST one as your starting point
- Focus on improving specific N values, not starting from scratch

## Tree Geometry (CRITICAL)

The Christmas tree is a 15-vertex polygon with these coordinates:
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

Key dimensions:
- Height: 1.0 (from y=-0.2 trunk bottom to y=0.8 tip)
- Base width: 0.7 (at y=0)
- Middle tier width: 0.4 (at y=0.25)
- Top tier width: 0.25 (at y=0.5)
- Trunk: 0.15 wide, 0.2 tall

The reference point (x, y in submission) is at the center-top of the trunk (0, 0).

## Submission Format

```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```

- `id`: `{n:03d}_{tree_index}` (e.g., "001_0" for N=1, tree 0)
- `x`, `y`: Position coordinates prefixed with 's'
- `deg`: Rotation angle in degrees prefixed with 's'

## ✅ REQUIRED: IMPLEMENT ALGORITHM IN PYTHON

Write YOUR OWN code. Choose ONE:
1. Bottom-left constructive heuristic (easiest)
2. Genetic algorithm with crossover (medium)
3. Custom local search written from scratch (medium)
4. Branch-and-bound for exact solutions (hardest)

NO BINARIES. NO SUBPROCESS. NO OS.SYSTEM.
WRITE THE ALGORITHM YOURSELF IN PYTHON.

## Key Algorithms from Research (IMPLEMENT THESE!)

### 1. Bottom-Left Heuristic
Place trees one at a time at the lowest-leftmost valid position:
```python
def bottom_left_place(existing_trees, new_tree_angle):
    # Start from far away, move toward center
    # Find first non-overlapping position
    # Use binary search for efficiency
```

### 2. No-Fit Polygon (NFP) for Fast Overlap Detection
The NFP represents all positions where two polygons touch/overlap:
- Precompute NFP for tree pairs at different rotation combinations
- Reduces overlap check from O(nm) to O(k) where k = NFP edges
- Use Minkowski sum to compute NFP

### 3. Rotation Optimization (fix_direction)
After placing trees, optimize the global rotation:
```python
def optimize_rotation(trees):
    # Get convex hull of all tree vertices
    # Use scipy.optimize.minimize_scalar to find best rotation angle
    # Rotate all trees together to minimize bounding box
```

### 4. Squeeze/Compaction
Move all trees toward center while maintaining non-overlap:
```python
def squeeze(config, scale_factor=0.9995):
    # Scale all positions toward centroid
    # Check for overlaps
    # Keep best valid configuration
```

### 5. Local Search
Iteratively improve by small moves:
```python
def local_search(config, steps=[0.01, 0.004, 0.001]):
    for tree in config.trees:
        for step in steps:
            # Try 8 directions + rotation changes
            # Keep improvements
```

### 6. Backward Propagation (Novel Technique!)
Use N+1 solution to improve N solution:
```python
def backward_propagation(configs):
    for n in range(200, 1, -1):
        # Try removing each tree from N solution
        # If resulting (N-1) solution is better than current best for N-1
        # Save it!
```

## Insights from Discussions (MANDATORY)

- Discussion "Why the winning solutions will be Asymmetric" (40 votes): Asymmetric packings outperform symmetric ones for larger N
- Discussion "Symmetric solutions that are apparently optimal" (43 votes): For small N, symmetric solutions may be optimal
- Discussion "Expected Leaderboard Progression" (20 votes): Staff guidance on expected score progression

## What Discussions Say DOESN'T Work
- Simple greedy placement without optimization
- Running binaries with "more iterations" - diminishing returns
- Ignoring small N values (they contribute significantly to score!)

## Unexplored Ideas from Discussions
- Tessellation patterns for specific N values
- Backward propagation: Use N+1 solution to improve N solution by removing one tree
- Lattice-based initial placements

## Score Contribution by N (CRITICAL!)

The score formula `side^2/n` means:
- N=1 contributes ~0.66 (HIGHEST single contribution!)
- N=2 contributes ~0.55
- N=3 contributes ~0.48
- Small N values are DISPROPORTIONATELY important!

Focus optimization effort on small N first!

## Collision Detection (Essential)

```python
from shapely.geometry import Polygon
from shapely import affinity
from shapely.strtree import STRtree

def create_tree_polygon(x, y, deg):
    TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
    TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
    poly = Polygon(zip(TX, TY))
    rotated = affinity.rotate(poly, deg, origin=(0, 0))
    return affinity.translate(rotated, x, y)

def check_overlap(poly1, poly2):
    return poly1.intersects(poly2) and not poly1.touches(poly2)

def get_bounding_box_side(trees):
    from shapely.ops import unary_union
    all_polys = [create_tree_polygon(t['x'], t['y'], t['deg']) for t in trees]
    bounds = unary_union(all_polys).bounds
    return max(bounds[2] - bounds[0], bounds[3] - bounds[1])
```

## Recommended Experiments (Priority Order)

1. **Load best baseline** - Find best existing solution in snapshots
2. **Exhaustive search for N=1-5** - Find provably optimal solutions
3. **Local search with rotation optimization** - Improve existing solutions
4. **Backward propagation** - Use N+1 to improve N
5. **Genetic algorithm** - Population-based search for larger N
6. **Per-N tracking system** - Save best solution for each N separately

## Validation

Before submitting:
1. Check all trees for overlaps using Shapely
2. Verify coordinates are within [-100, 100]
3. Calculate local score to compare with leaderboard
4. Track per-N improvements

## Key Files

- Sample submission: `/home/data/sample_submission.csv`
- Pre-optimized solutions: `/home/nonroot/snapshots/santa-2025/*/submission/submission.csv`
- Competition description: `/home/code/research/description.md`
- Getting started kernel: `/home/code/research/kernels/inversion_santa-2025-getting-started/`

## CRITICAL REMINDERS

1. **NO BINARIES** - Write all optimization code in Python
2. **SMALL N FIRST** - N=1-10 contribute disproportionately to score
3. **PER-N TRACKING** - Save improvements for each N separately
4. **OVERLAP VALIDATION** - Always check for overlaps before saving
5. **ROTATION OPTIMIZATION** - Always apply fix_direction after placement
6. **USE EXISTING BASELINES** - Don't start from scratch, improve existing solutions

## Mathematical Insights

For N=1, the optimal rotation minimizes the bounding box of a single tree.
The tree is roughly 1.0 tall and 0.7 wide at base.
- At 0° rotation: bbox ≈ 0.7 × 1.0
- At 45° rotation: bbox changes due to rotation
- Optimal angle is NOT 0° or 90° - must be computed!

For small N, trees can often interlock (tips fitting into gaps between branches).
This is why asymmetric solutions often beat symmetric ones.
