# Santa 2025 - Evolved Seed Prompt (Loop 2)

## Current Status
- **Best CV score**: 70.6151 from exp_001 (002_valid_baseline)
- **Best LB score**: 70.6151 (CV-LB gap: 0.0000 - validation is accurate!)
- **Target**: 68.881647 | **Gap to target**: 1.733 points (2.5%)

## Submission Log
| Exp | Approach | CV | LB | Notes |
|-----|----------|----|----|-------|
| 000 | baseline (invalid) | 70.5233 | REJECTED | 69 N values had overlaps |
| 001 | valid_baseline | 70.6151 | 70.6151 | Valid submission, N=1 optimal at 45° |

## ⛔ ABSOLUTELY FORBIDDEN (EXPERIMENT WILL BE REJECTED)
- bbox3, sa_fast_v2, eazy_optimizer, tree_packer, shake_public - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY pre-compiled binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any binary tool - FORBIDDEN

**WHY**: These binaries produce ~70.6. Target is 68.88. BINARIES CANNOT GET THERE.

## ✅ MANDATORY NEXT EXPERIMENT: FRACTIONAL TRANSLATION IN PYTHON

### Algorithm (from top kernels, implemented in Python):

```python
from shapely.geometry import Polygon
from shapely import affinity
import math

TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def create_tree_polygon(x, y, deg):
    """Create a tree polygon at position (x, y) with rotation deg."""
    poly = Polygon(zip(TX, TY))
    rotated = affinity.rotate(poly, deg, origin=(0, 0))
    return affinity.translate(rotated, x, y)

def check_overlap(poly1, poly2):
    """Check if two polygons overlap (not just touch)."""
    return poly1.intersects(poly2) and not poly1.touches(poly2)

def get_bounding_box_side(trees):
    """Get the side length of the bounding box for a list of trees."""
    from shapely.ops import unary_union
    all_polys = [create_tree_polygon(t['x'], t['y'], t['deg']) for t in trees]
    bounds = unary_union(all_polys).bounds
    return max(bounds[2] - bounds[0], bounds[3] - bounds[1])

def has_any_overlap(trees, idx):
    """Check if tree at idx overlaps with any other tree."""
    poly_i = create_tree_polygon(trees[idx]['x'], trees[idx]['y'], trees[idx]['deg'])
    for j, t in enumerate(trees):
        if j != idx:
            poly_j = create_tree_polygon(t['x'], t['y'], t['deg'])
            if check_overlap(poly_i, poly_j):
                return True
    return False

def fractional_translation(trees, max_iter=200):
    """Improve configuration by tiny translations."""
    frac_steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    
    best_side = get_bounding_box_side(trees)
    
    for iteration in range(max_iter):
        improved = False
        for idx in range(len(trees)):
            for step in frac_steps:
                for dx, dy in directions:
                    old_x, old_y = trees[idx]['x'], trees[idx]['y']
                    trees[idx]['x'] = old_x + dx * step
                    trees[idx]['y'] = old_y + dy * step
                    
                    if not has_any_overlap(trees, idx):
                        new_side = get_bounding_box_side(trees)
                        if new_side < best_side - 1e-12:
                            best_side = new_side
                            improved = True
                        else:
                            trees[idx]['x'] = old_x
                            trees[idx]['y'] = old_y
                    else:
                        trees[idx]['x'] = old_x
                        trees[idx]['y'] = old_y
        
        if not improved:
            break
    
    return trees, best_side
```

### Experiment Steps:

1. **Create experiment folder**: `experiments/003_fractional_translation/`

2. **Load baseline solution**:
```python
import pandas as pd
df = pd.read_csv('/home/code/experiments/002_valid_baseline/submission.csv')
```

3. **Optimize N=2-20 first** (highest impact, small enough for Python):
```python
for n in range(2, 21):
    trees = load_trees_for_n(df, n)
    optimized_trees, new_side = fractional_translation(trees, max_iter=100)
    old_score = baseline_per_n_scores[n]
    new_score = new_side * new_side / n
    if new_score < old_score:
        print(f"✅ N={n}: IMPROVED {old_score:.6f} → {new_score:.6f}")
        save_improved_trees(n, optimized_trees)
```

4. **Track per-N improvements**:
```python
improvements = {}
for n in range(1, 201):
    if my_score[n] < baseline_score[n]:
        improvements[n] = baseline_score[n] - my_score[n]
        print(f"N={n}: improved by {improvements[n]:.6f}")
```

5. **Create submission with best per-N**:
```python
# Combine baseline with improvements
final_df = baseline_df.copy()
for n in improvements:
    final_df = replace_n_with_improved(final_df, n, improved_solutions[n])
```

## ✅ REQUIRED: STRICT OVERLAP VALIDATION

Before ANY submission, validate with Kaggle's exact method:

```python
from decimal import Decimal, getcontext
getcontext().prec = 30
SCALE = 10**18

def validate_no_overlap(trees):
    from shapely import Polygon
    polygons = []
    for tree in trees:
        coords = [(int(Decimal(str(x)) * SCALE), 
                   int(Decimal(str(y)) * SCALE)) 
                  for x, y in tree.vertices]
        polygons.append(Polygon(coords))
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                return False, f"Trees {i} and {j} overlap"
    return True, "OK"
```

## Score Contribution Analysis

From baseline metrics:
- **N=1-10**: 4.329 points (6.1%) - N=1 is optimal, N=2-10 have room
- **N=11-50**: 14.704 points (20.8%) - Large contribution
- **N=51-100**: 17.606 points (24.9%)
- **N=101-150**: 17.134 points (24.3%)
- **N=151-200**: 16.842 points (23.9%)

**Top 10 N values by score contribution**:
1. N=1: 0.6612 (already optimal)
2. N=2: 0.4508 (HIGH PRIORITY)
3. N=3: 0.4347 (HIGH PRIORITY)
4. N=5: 0.4169 (HIGH PRIORITY)
5. N=4: 0.4165 (HIGH PRIORITY)
6. N=7: 0.3999 (HIGH PRIORITY)
7. N=6: 0.3996 (HIGH PRIORITY)
8. N=9: 0.3874 (HIGH PRIORITY)
9. N=8: 0.3854 (HIGH PRIORITY)
10. N=15: 0.3769

## Available Resources

### Snapshots for Ensemble (116 available!)
```python
snapshot_dir = '/home/nonroot/snapshots/santa-2025'
# Each snapshot has: {snapshot_id}/submission/submission.csv
```

### Per-N Ensemble Strategy
1. Load all 116 snapshots
2. For each N, find the best (lowest score) solution
3. Validate each candidate for overlaps
4. Create ensemble with best per-N from all sources

## Expected Outcomes

### Experiment 003: Fractional Translation
- **Target**: Improve N=2-20 by 0.1-0.3 points total
- **Method**: Python implementation of fractional translation
- **Time**: ~30 minutes for N=2-20

### Experiment 004: Per-N Ensemble
- **Target**: Improve by 0.2-0.5 points from ensemble
- **Method**: Best per-N selection from 116 snapshots
- **Time**: ~10 minutes to scan and validate

## What NOT to Try
- ❌ Running bbox3 or any C++ binary
- ❌ "More iterations" on existing optimizers
- ❌ Copying solutions without validation (may have overlaps)

## SUBMIT EVERY EXPERIMENT
We have 98 submissions remaining. Submit after EVERY experiment to get LB feedback!
