# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt

## Current Status
- Best CV score: 70.615102 from exp_001 (002_valid_baseline)
- Best LB score: PENDING (exp_000 rejected due to overlaps)
- Target: 68.881647 | Gap to target: **1.733 points**
- Submissions used: 1/100 (99 remaining)

## ⚠️ CRITICAL: SUBMIT VALID BASELINE FIRST!

**IMMEDIATE ACTION REQUIRED:**
The valid baseline (exp_001, score 70.615102) has NOT been submitted yet!
We need LB feedback to calibrate our CV-LB relationship.

**DO THIS FIRST:**
1. Verify /home/submission/submission.csv exists and is valid
2. Submit exp_001 to get LB score
3. This uses 1 submission but gives us critical feedback

## Response to Evaluator

The evaluator correctly identified:
1. ✅ Validation issue fixed - strict integer-scaled validation implemented
2. ✅ N=1 is already optimal at 45° - no improvement possible there
3. ✅ Valid baseline found (70.615102)
4. ⚠️ No optimization algorithms implemented yet - THIS IS THE PRIORITY

**Evaluator's top priority**: Implement fractional translation in Python for N=2-20
**My response**: AGREED. This is the highest-leverage next step. The top kernels use this technique.

## What We've Learned

| Exp | Approach | CV | LB | Notes |
|-----|----------|----|----|-------|
| exp_000 | baseline (overlaps) | 70.523 | REJECTED | Had 69 N values with overlaps |
| exp_001 | valid_baseline | 70.615 | PENDING | Valid submission, needs LB feedback |

## ⛔ ABSOLUTELY FORBIDDEN

- bbox3, sa_fast_v2, eazy_optimizer, tree_packer, shake_public - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY pre-compiled binary - FORBIDDEN
- "Optimizing" existing CSV files with external tools - FORBIDDEN

**WHY:** These binaries already produce ~70.6. Running them again produces ~70.6.
The target is 68.89. BINARIES CANNOT GET THERE.

## ✅ MANDATORY: IMPLEMENT FRACTIONAL TRANSLATION IN PYTHON

This is the #1 priority for the next experiment.

**Algorithm from top kernel (jonathanchan):**
```python
def fractional_translation(trees, n, max_iter=200):
    """Improve N-tree configuration by tiny translations."""
    frac_steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    
    best_side = get_bounding_box_side(trees)
    
    for iteration in range(max_iter):
        improved = False
        for tree_idx in range(n):
            for step in frac_steps:
                for dx, dy in directions:
                    # Try moving tree
                    old_x, old_y = trees[tree_idx]['x'], trees[tree_idx]['y']
                    trees[tree_idx]['x'] = old_x + dx * step
                    trees[tree_idx]['y'] = old_y + dy * step
                    
                    if not has_overlap(trees, tree_idx):
                        new_side = get_bounding_box_side(trees)
                        if new_side < best_side - 1e-12:
                            best_side = new_side
                            improved = True
                        else:
                            # Revert
                            trees[tree_idx]['x'] = old_x
                            trees[tree_idx]['y'] = old_y
                    else:
                        # Revert
                        trees[tree_idx]['x'] = old_x
                        trees[tree_idx]['y'] = old_y
        
        if not improved:
            break
    
    return trees, best_side
```

**Implementation steps:**
1. Create `experiments/003_fractional_translation/`
2. Load valid baseline from `/home/code/experiments/002_valid_baseline/submission.csv`
3. Implement fractional_translation in pure Python
4. Test on N=2-20 first (these contribute ~7.5 points)
5. Track per-N improvements
6. Create new submission with improved N values

## ✅ MANDATORY: PER-N TRACKING SYSTEM

Create `best_per_n.json` to track best solution for each N:

```python
import json

# Initialize from baseline
best_per_n = {}
for n in range(1, 201):
    best_per_n[n] = {
        'score': baseline_scores[n],
        'source': 'baseline',
        'side': baseline_sides[n]
    }

# After each experiment, update if improved
def update_best_per_n(n, new_score, new_side, source):
    if new_score < best_per_n[n]['score'] - 1e-12:
        best_per_n[n] = {
            'score': new_score,
            'source': source,
            'side': new_side
        }
        print(f"✅ N={n}: IMPROVED by {best_per_n[n]['score'] - new_score:.6f}")
        return True
    return False

# Save after each experiment
with open('best_per_n.json', 'w') as f:
    json.dump(best_per_n, f, indent=2)
```

## ✅ MANDATORY: STRICT OVERLAP VALIDATION

Use this validation before EVERY submission:

```python
from decimal import Decimal, getcontext
from shapely.geometry import Polygon

getcontext().prec = 30
SCALE = 10**18

def validate_no_overlap(trees):
    """Validate using Kaggle's strict integer-scaled method."""
    polygons = []
    for tree in trees:
        coords = [(int(Decimal(str(x)) * SCALE), 
                   int(Decimal(str(y)) * SCALE)) 
                  for x, y in tree['vertices']]
        polygons.append(Polygon(coords))
    
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                return False, f"Trees {i} and {j} overlap"
    return True, "OK"
```

## Tree Geometry (Reference)

```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def create_tree_polygon(x, y, deg):
    from shapely.geometry import Polygon
    from shapely import affinity
    import math
    
    poly = Polygon(zip(TX, TY))
    rotated = affinity.rotate(poly, deg, origin=(0, 0))
    return affinity.translate(rotated, x, y)

def get_bounding_box_side(trees):
    from shapely.ops import unary_union
    all_polys = [create_tree_polygon(t['x'], t['y'], t['deg']) for t in trees]
    bounds = unary_union(all_polys).bounds
    return max(bounds[2] - bounds[0], bounds[3] - bounds[1])
```

## Score Contribution by N Range

| N Range | Points | % of Total | Priority |
|---------|--------|------------|----------|
| N=1-10 | 4.329 | 6.1% | HIGH (N=1 optimal, N=2-10 improvable) |
| N=11-50 | 14.704 | 20.8% | HIGH |
| N=51-100 | 17.606 | 24.9% | MEDIUM |
| N=101-150 | 17.134 | 24.3% | MEDIUM |
| N=151-200 | 16.842 | 23.9% | MEDIUM |

**Key insight**: N=1 is already optimal (45°). Focus on N=2-20 first, then expand.

## Next Experiment: 003_fractional_translation

**Objective**: Implement fractional translation in pure Python and improve N=2-20

**Steps:**
1. Create experiment folder
2. Load valid baseline
3. Implement fractional_translation function
4. Run on N=2-20 (highest leverage)
5. Track per-N improvements
6. Validate no overlaps
7. Create submission
8. SUBMIT to get LB feedback

**Expected improvement**: 0.1-0.3 points from small N optimization

## Secondary Priorities (After Fractional Translation)

1. **Rotation optimization**: After translation, try rotating all trees together
2. **Squeeze/compaction**: Scale all positions toward centroid
3. **Backward propagation**: Use N+1 solution to improve N solution
4. **Per-N ensemble**: Collect best per-N from multiple snapshot sources

## What NOT to Try

- ❌ Running bbox3 or any binary (produces same ~70.6 score)
- ❌ "Optimizing" existing CSV with external tools
- ❌ More iterations on existing optimizers
- ❌ Trying to improve N=1 (already optimal at 45°)

## Submission Strategy

With 99 submissions remaining, SUBMIT EVERY VALID EXPERIMENT:
- LB feedback is free information
- Even if CV is worse, LB might be different
- Track what works and what doesn't
- Build ensemble from best per-N across all submissions

## Files Reference

- Valid baseline: `/home/code/experiments/002_valid_baseline/submission.csv`
- Per-N scores: `/home/code/experiments/002_valid_baseline/metrics.json`
- Snapshots: `/home/nonroot/snapshots/santa-2025/*/submission/submission.csv` (90 available)
- Tree geometry: TX, TY arrays above

## Success Criteria

- ✅ Fractional translation implemented in pure Python
- ✅ Per-N tracking system created
- ✅ At least one N value improved from baseline
- ✅ Valid submission created (passes strict overlap validation)
- ✅ Submitted to get LB feedback
