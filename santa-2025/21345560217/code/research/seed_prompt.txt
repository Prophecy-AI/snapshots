# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt

## Current Status
- Best CV score: 70.615102 from exp_001 (002_valid_baseline)
- Best LB score: 70.615102 (verified - perfect CV-LB match!)
- Target: 68.881647 | Gap to target: **1.733 points (2.5%)**
- Submissions used: 2/100 (98 remaining - ABUNDANT!)

## ⚠️ CRITICAL SITUATION: STUCK AT LOCAL OPTIMUM

**Last 2 experiments produced IDENTICAL scores (70.615102).**
- exp_001: Valid baseline = 70.615102
- exp_002: Fractional translation = 70.615102 (NO IMPROVEMENT)

**PROVEN FACT:** Local search (fractional translation, squeeze) CANNOT improve the baseline.
The baseline is already at a local optimum. We need FUNDAMENTALLY DIFFERENT approaches.

## Submission Log
| Exp | Approach | CV | LB | Notes |
|-----|----------|----|----|-------|
| 000 | baseline (invalid) | 70.523 | REJECTED | Had 69 N values with overlaps |
| 001 | valid_baseline | 70.615 | 70.615 | Perfect CV-LB match! |
| 002 | fractional_translation | 70.615 | - | NO IMPROVEMENT - local optimum |

## Response to Evaluator

The evaluator correctly identified that:
1. **Local search cannot escape local optima** - CONFIRMED by exp_002
2. **Per-N ensemble from 116 snapshots** - We tried this in exp_002, found NO improvements > 0.0001
3. **Backward propagation** - NOT YET TRIED - this is the highest priority!
4. **Simulated annealing** - NOT YET TRIED - can escape local optima

The evaluator's recommendation to implement backward propagation is CORRECT and should be the next experiment.

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with binaries - FORBIDDEN
- More fractional translation attempts - PROVEN NOT TO WORK

## ✅ NEXT EXPERIMENT: BACKWARD PROPAGATION (MANDATORY)

**Reference Implementation:** `research/kernels/chistyakov_santa-2025-simple-optimization-new-slow-version/`

The backward propagation technique works as follows:
1. Start from N=200 and work down to N=2
2. For each N, try removing each tree that touches the bounding box boundary
3. If the resulting (N-1) configuration is better than current best for N-1, save it!
4. This propagates improvements from larger N to smaller N

**Implementation:**
```python
from shapely.geometry import box

def get_bbox_touching_tree_indices(tree_list):
    """Find indices of trees that touch the bounding box boundary."""
    polys = [t.polygon for t in tree_list]
    minx = min(p.bounds[0] for p in polys)
    miny = min(p.bounds[1] for p in polys)
    maxx = max(p.bounds[2] for p in polys)
    maxy = max(p.bounds[3] for p in polys)
    bbox = box(minx, miny, maxx, maxy)
    
    touching_indices = [
        i for i, poly in enumerate(polys)
        if poly.boundary.intersects(bbox.boundary)
    ]
    return touching_indices

# Main backward propagation loop
for n_main in range(200, 2, -1):
    candidate_trees = trees_for_n[n_main].copy()
    
    while len(candidate_trees) > 1:
        n_prev = len(candidate_trees) - 1
        best_side_for_prev = current_best_side[n_prev]
        
        # Try removing each boundary-touching tree
        touching_indices = get_bbox_touching_tree_indices(candidate_trees)
        for idx in touching_indices:
            candidate_short = [t for i, t in enumerate(candidate_trees) if i != idx]
            new_side = get_bounding_box_side(candidate_short)
            
            if new_side < best_side_for_prev:
                print(f"✅ N={n_prev}: IMPROVED! {best_side_for_prev:.6f} -> {new_side:.6f}")
                trees_for_n[n_prev] = candidate_short
                current_best_side[n_prev] = new_side
        
        # Remove best tree and continue
        candidate_trees = remove_best_tree(candidate_trees)
        
        # Stop if we've gone too far from original N
        if n_main - len(candidate_trees) > 5:
            break
```

## ✅ SECONDARY PRIORITY: SIMULATED ANNEALING FROM SCRATCH

If backward propagation doesn't yield enough improvement, implement SA:

```python
import random
import math

def simulated_annealing(trees, T_start=1.0, T_end=0.001, cooling=0.995):
    """SA can accept worse moves to escape local optima."""
    T = T_start
    best = [t.copy() for t in trees]
    best_score = compute_score(best)
    current = [t.copy() for t in trees]
    current_score = best_score
    
    while T > T_end:
        # Random perturbation
        idx = random.randint(0, len(current)-1)
        old_x, old_y, old_deg = current[idx]['x'], current[idx]['y'], current[idx]['deg']
        
        # Perturbation magnitude scales with temperature
        current[idx]['x'] += random.uniform(-T*0.1, T*0.1)
        current[idx]['y'] += random.uniform(-T*0.1, T*0.1)
        current[idx]['deg'] += random.uniform(-T*10, T*10)
        
        if is_valid(current):
            new_score = compute_score(current)
            delta = new_score - current_score
            
            # Accept if better, or probabilistically if worse
            if delta < 0 or random.random() < math.exp(-delta/T):
                current_score = new_score
                if current_score < best_score:
                    best = [t.copy() for t in current]
                    best_score = current_score
            else:
                # Revert
                current[idx]['x'], current[idx]['y'], current[idx]['deg'] = old_x, old_y, old_deg
        else:
            # Revert
            current[idx]['x'], current[idx]['y'], current[idx]['deg'] = old_x, old_y, old_deg
        
        T *= cooling
    
    return best, best_score
```

## ✅ REQUIRED: PER-N TRACKING

Track best solution for EACH N separately:
```python
# Load baseline per-N scores
baseline_per_n = load_baseline_per_n_scores()

# After each experiment, compare per-N
improvements = []
for n in range(1, 201):
    my_score = compute_score_for_n(my_solution, n)
    base_score = baseline_per_n[n]['score']
    if my_score < base_score - 1e-8:
        improvements.append((n, base_score - my_score))
        print(f"✅ N={n}: IMPROVED by {base_score - my_score:.6f}")

# Keep only N values where we improved
# Create ensemble: best per-N from all experiments
```

## Key Insights from Research

1. **Zaburo's constructive approach** (88.33 score): Grid-based placement with alternating rows
   - Trees at 0° and 180° rotation
   - Spacing: 0.7 horizontal, 1.0 vertical
   - This is a starting point, not optimal

2. **Chistyakov's backward propagation**: Remove trees from N+1 to improve N
   - Only try removing trees that touch the bounding box boundary
   - This is efficient and can find improvements local search misses

3. **Top kernels use ensemble + SA + fractional translation**:
   - Ensemble: Best per-N from 15+ sources
   - SA: Escape local optima
   - Fractional translation: Final polish (we proved this doesn't help alone)

## Score Breakdown (Where to Focus)

From baseline per-N scores:
- N=1-10: 4.329 pts (6.1%) - Already well-optimized
- N=11-50: 14.704 pts (20.8%) - Medium potential
- N=51-100: 17.606 pts (24.9%) - High potential
- N=101-150: 17.134 pts (24.3%) - High potential
- N=151-200: 16.842 pts (23.9%) - High potential

**Focus on N=51-200** - these contribute 75% of the score!

## Experiment Sequence

1. **exp_003: Backward Propagation** (THIS EXPERIMENT)
   - Implement Chistyakov's technique in pure Python
   - Start from N=200, propagate improvements down
   - Expected gain: 0.1-0.5 points

2. **exp_004: Simulated Annealing** (if needed)
   - Implement SA from scratch for N=10-50
   - Use temperature-based acceptance of worse moves
   - Expected gain: 0.2-0.5 points

3. **exp_005: Constructive + Optimize** (if needed)
   - Build solutions from scratch using grid patterns
   - Then optimize with SA
   - Expected gain: 0.3-1.0 points

## SUBMIT EVERY EXPERIMENT!

With 98 submissions remaining, submit EVERY valid experiment:
- LB feedback tells us what ACTUALLY works
- Even if CV is same, LB might be different
- We need data to understand CV-LB relationship

## What NOT to Try

- ❌ More fractional translation - PROVEN NOT TO WORK
- ❌ More squeeze attempts - PROVEN NOT TO WORK
- ❌ Per-N ensemble from snapshots - ALREADY TRIED, no improvements found
- ❌ Any binary optimizer - FORBIDDEN

## Success Criteria

- ✅ **SUCCESS**: Score improved by > 0.01 from 70.615
- ⚠️ **MARGINAL**: Score improved by 0.001 - 0.01
- ❌ **FAILURE**: Score same or worse

If backward propagation fails, PIVOT to simulated annealing immediately.