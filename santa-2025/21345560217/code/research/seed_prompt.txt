# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt

## Current Status
- Best CV score: 70.615102 from exp_001 (002_valid_baseline)
- Best LB score: 70.615102 (verified submission)
- Target: 68.881647 | Gap to target: 1.733 points (2.5%)
- Submissions used: 2/100 (98 remaining)

## ⚠️ CRITICAL: 7 EXPERIMENTS AT SAME SCORE - PARADIGM SHIFT REQUIRED

All 7 experiments have produced the SAME score (70.615102). This means:
- The baseline is at a STRONG LOCAL OPTIMUM
- Local optimization approaches DO NOT WORK
- We need a FUNDAMENTALLY DIFFERENT approach

## Submission Log
| Exp | Approach | CV | LB | Notes |
|-----|----------|----|----|-------|
| 000 | baseline | 70.523 | REJECTED | Had overlaps |
| 001 | valid_baseline | 70.615 | 70.615 | Best valid solution |
| 002 | fractional_translation | 70.615 | - | No improvement |
| 003 | backward_propagation | 70.615 | - | No improvement |
| 004 | per_n_ensemble | 70.615 | - | Snapshots have overlaps |
| 005 | python_sa | 70.615 | - | SA worse than baseline |
| 006 | asymmetric_exploration | 70.615 | - | No improvement |

## Response to Evaluator

The evaluator correctly identified that:
1. **The baseline (70.615102) is BETTER than all public sources** - confirmed
2. **All "improve existing solutions" approaches have failed** - confirmed
3. **We need mathematical analysis + specialized optimization** - AGREED

The evaluator recommends:
- Mathematical analysis for N=1-5 (provably optimal solutions)
- Specialized algorithms for different N ranges
- Gradient-based optimization (square pressure)

I AGREE with this assessment. The next experiment must implement a NOVEL algorithm.

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any tool - FORBIDDEN
- Loading solutions then running optimizer on them - FORBIDDEN
- ANY more perturbation-based approaches - THEY DON'T WORK

## ✅ WHAT WE LEARNED FROM EAZY OPTIMIZER (IMPLEMENT THIS!)

The Eazy Optimizer kernel reveals the MATHEMATICAL techniques that work:

### 1. Square Pressure Gradient Descent
```python
def apply_square_pressure(tree_x, tree_y, bounding_side, scale):
    """Push trees toward center using log-barrier derivatives."""
    L = bounding_side / 2.0
    
    def get_grad(pos):
        d1 = L - pos  # distance to right/top boundary
        d2 = L + pos  # distance to left/bottom boundary
        d1 = max(d1, 1e-9)
        d2 = max(d2, 1e-9)
        return (1.0 / d1) - (1.0 / d2)
    
    # Move AGAINST gradient to move toward center
    gx = get_grad(tree_x)
    gy = get_grad(tree_y)
    
    new_x = tree_x - gx * scale * 0.01
    new_y = tree_y - gy * scale * 0.01
    return new_x, new_y
```

### 2. Complex Orbital Moves
```python
import cmath

def orbital_move(x, y, scale):
    """Rotate position using complex number multiplication."""
    z = complex(x, y)
    rotation = cmath.exp(complex(0, (random.random() - 0.5) * scale * 0.2))
    z_new = z * rotation
    return z_new.real, z_new.imag
```

### 3. Elastic Pulse (Periodic Squeeze/Relax)
```python
def elastic_pulse(trees, iteration, centroid_x, centroid_y):
    """Periodically squeeze toward centroid then relax."""
    if iteration % 40000 == 0:
        factor = 0.999999 if (iteration % 80000 == 0) else 1.0000001
        for tree in trees:
            tree.x = centroid_x + (tree.x - centroid_x) * factor
            tree.y = centroid_y + (tree.y - centroid_y) * factor
```

### 4. Multi-Scale Optimization
```python
scales = [1e-3, 1e-5, 1e-7, 1e-9]
for scale in scales:
    for iteration in range(250000):
        # Apply moves at this scale
        pass
```

## ✅ REQUIRED: IMPLEMENT GRADIENT-BASED COMPACTION

For this experiment, implement the gradient-based compaction algorithm from scratch:

```python
def gradient_compaction(trees, n, max_iterations=100000):
    """
    Implement gradient-based compaction using square pressure.
    This is what the Eazy Optimizer uses.
    """
    best_side = calculate_bounding_side(trees)
    
    for scale in [1e-3, 1e-4, 1e-5, 1e-6]:
        for iteration in range(max_iterations // 4):
            # Pick random tree
            i = random.randint(0, n-1)
            old_x, old_y, old_angle = trees[i]
            
            # Choose move type
            r = random.random()
            if r < 0.3:
                # Random translation
                trees[i][0] += (random.random() - 0.5) * scale
                trees[i][1] += (random.random() - 0.5) * scale
            elif r < 0.6:
                # Orbital move
                new_x, new_y = orbital_move(trees[i][0], trees[i][1], scale)
                trees[i][0], trees[i][1] = new_x, new_y
            elif r < 0.9:
                # Angle perturbation
                trees[i][2] += (random.random() - 0.5) * scale * 45
            else:
                # Square pressure
                new_x, new_y = apply_square_pressure(
                    trees[i][0], trees[i][1], best_side, scale
                )
                trees[i][0], trees[i][1] = new_x, new_y
            
            # Check validity and improvement
            if not has_overlap(trees) and calculate_bounding_side(trees) <= best_side:
                best_side = calculate_bounding_side(trees)
            else:
                # Revert
                trees[i] = [old_x, old_y, old_angle]
    
    return trees, best_side
```

## ✅ ALTERNATIVE: CONSTRUCTIVE BOTTOM-LEFT FILL

If gradient compaction doesn't work, try building solutions from scratch:

```python
def bottom_left_fill(n, angle=45):
    """
    Constructive heuristic: place trees one by one at bottom-left position.
    """
    trees = []
    
    for i in range(n):
        # Find the bottom-left valid position for this tree
        best_pos = None
        best_y = float('inf')
        
        for x in np.arange(-5, 5, 0.05):
            for y in np.arange(-5, 5, 0.05):
                test_tree = [x, y, angle]
                test_config = trees + [test_tree]
                
                if not has_overlap(test_config):
                    if y < best_y:
                        best_y = y
                        best_pos = (x, y)
        
        if best_pos:
            trees.append([best_pos[0], best_pos[1], angle])
    
    return trees
```

## ✅ REQUIRED: PER-N TRACKING

Track best solution for EACH N separately:
```python
# After each experiment, compare per-N
improvements = []
for n in range(1, 201):
    my_score = calculate_score(my_solution[n], n)
    base_score = baseline_scores[n]
    if my_score < base_score - 1e-8:
        improvements.append((n, base_score - my_score))
        print(f"✅ N={n}: IMPROVED by {base_score - my_score:.6f}")

# Keep only N values where we improved
# Create ensemble: best per-N from all experiments
```

## Next Experiment: 008_gradient_compaction

1. **Approach**: Implement gradient-based compaction with square pressure
2. **Expected improvement**: This is what top kernels use - should find improvements
3. **Test on small N first**: N=10, N=20, N=30 before full run
4. **SUBMIT**: YES - we need LB feedback on this novel approach

## What NOT to Try
- ❌ More perturbation-based approaches (tried 5 times, all failed)
- ❌ Ensembling from external sources (all have overlaps or worse scores)
- ❌ Running any pre-compiled binary
- ❌ Simple SA without the gradient/pressure techniques

## Key Insight

The gap of 1.733 points represents improvements that:
1. Are NOT in any public source
2. Required sophisticated mathematical optimization
3. Accumulated over 900+ submissions by top teams

Our path forward is to implement the MATHEMATICAL techniques (gradient descent, orbital moves, elastic pulse) that the top kernels use, but in pure Python.

**THE TARGET IS REACHABLE.** The Eazy Optimizer shows exactly what techniques work. Implement them.