# Santa 2025 - Evolved Seed Prompt (Loop 6)

## Current Status
- Best CV score: 70.615102 from exp_001 (002_valid_baseline)
- Best LB score: 70.615102 (verified)
- Target: 68.881647 | Gap to target: 1.733 points (2.5%)

## CRITICAL FINDING: BASELINE IS THE BEST VALID SOLUTION
After comprehensive analysis:
- Checked 79 external source files (bucket-of-chump, santa25-public, telegram, etc.)
- Checked 492 snapshot submission files
- Result: **NO VALID IMPROVEMENTS FOUND**
- All external sources either have overlaps or scores >= 70.67 (worse than baseline)
- The baseline (70.615102) is confirmed as the BEST VALID solution available

## What We've Learned
1. **The baseline is at a strong local optimum** - No local search method can improve it
2. **External sources don't help** - They either have overlaps or worse scores
3. **Top kernels use C++ binaries** - They achieve better scores by running sophisticated C++ optimizers for hours
4. **The gap to target (1.733 points) requires fundamentally different approach**

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with binaries - FORBIDDEN

## ✅ NEXT EXPERIMENT: ASYMMETRIC PLACEMENT EXPLORATION

The discussion "Why the winning solutions will be Asymmetric" (40 votes) suggests asymmetric solutions outperform symmetric ones. Our baseline may be stuck at a symmetric local optimum.

### MANDATORY FIRST STEP: Analyze baseline symmetry
```python
# Check if baseline configurations are symmetric
for n in [10, 20, 50, 100]:
    config = baseline_configs[n]
    # Check for rotational symmetry
    # Check for reflection symmetry
    # Identify which N values have symmetric vs asymmetric solutions
```

### THEN: Implement Asymmetric Placement Generator
```python
def asymmetric_placement(n, baseline_config):
    """Generate asymmetric variations of baseline."""
    # Start from baseline
    trees = [list(t) for t in baseline_config]
    
    # Apply asymmetric perturbations
    for i in range(n):
        # Bias toward one direction
        trees[i][0] += random.gauss(0.01, 0.005)  # Slight x-bias
        trees[i][2] += random.uniform(-5, 5)  # Angle variation
    
    # Validate and return if no overlaps
    if not has_any_overlap(trees):
        return trees
    return None
```

### Focus on N=50-150 where there's most room for improvement
- N=1-10: 4.329 pts (6.1%) - Already optimal
- N=11-50: 14.704 pts (20.8%) - Some room
- N=51-100: 17.606 pts (24.9%) - MOST ROOM
- N=101-150: 17.134 pts (24.3%) - MOST ROOM
- N=151-200: 16.842 pts (23.9%) - Some room

## Per-N Tracking (MANDATORY)
Track best solution for EACH N separately:
- Load baseline per-N scores
- After each experiment, compare per-N
- Keep only N values where you improved
- Even if total score is worse, individual N improvements are valuable

## SUBMIT EVERY EXPERIMENT
With 98 submissions remaining, submit after every experiment for LB feedback.

## Alternative Approaches to Try
1. **Genetic Algorithm with Crossover** - Evolve populations of configurations
2. **Constraint Satisfaction** - Model as CSP and find feasible regions
3. **Pattern-based Placement** - Identify patterns in optimal solutions for small N, extrapolate to larger N
4. **Rotation Optimization** - For each N, try different global rotation angles to minimize bounding box

## Key Insight
The target score (68.89) was achieved by teams with:
- 953 submissions accumulated over weeks
- Multiple C++ binaries running for hours
- Ensemble from 15+ sources

We need to find a NOVEL approach that doesn't require C++ speed. Focus on:
- Finding configurations that are fundamentally different from baseline
- Exploiting mathematical properties of the tree shape
- Testing asymmetric placements that might escape local optima