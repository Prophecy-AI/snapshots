# Santa 2025 - Christmas Tree Packing Challenge

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding box for N=1 to 200 trees.

**Scoring:** score = Σ(side_length² / N) for N=1 to 200
**Target:** Beat 68.894234 (lower is better)

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Tip at (0, 0.8)
- Three tiers of branches at y=0.5, 0.25, 0
- Trunk from y=0 to y=-0.2
- Base width: 0.7, Mid width: 0.4, Top width: 0.25, Trunk width: 0.15

Trees can be positioned at (x, y) and rotated by any angle (deg).

## Insights from Discussions (MANDATORY)
Based on discussion analysis:
- **"Why the winning solutions will be Asymmetric" (38 votes):** Asymmetric solutions outperform symmetric ones for most N values
- **"Symmetric solutions that are apparently optimal" (43 votes):** Some specific N values have optimal symmetric solutions, but most benefit from asymmetric arrangements
- **"The score of our group" (20 votes):** Top teams share per-N scores, indicating where improvements are possible
- **Key insight:** Per-N optimization is critical - different N values require different strategies

## What Discussions Say DOESN'T Work
- Simple greedy placement alone (baseline ~100+ score)
- Pure symmetric solutions for all N (loses to asymmetric for most N)
- Random search without intelligent initialization

## Key Approaches from Public Kernels

### 1. Getting Started Kernel (Baseline)
- Greedy placement with collision detection using Shapely
- Weighted angle generation to fill corners better
- Uses STRtree for efficient spatial queries
- Score: ~100+ (baseline)

### 2. bbox3 C++ Optimizer
- Complex number vector coordination
- Fluid dynamics-inspired movement
- Hinge pivot optimization
- Global boundary tension
- Aggressive overlap repair cycles
- Multi-phase optimization (short→medium→long runs)

### 3. shake_public Optimizer
- Binary optimizer for local refinement
- Works well in combination with bbox3

### 4. Fix Direction / Rotation Tightening
- Optimize global rotation angle to minimize bounding box
- Uses ConvexHull + minimize_scalar optimization
- Can reduce score by rotating entire configuration

### 5. Overlap Validation and Repair
- Check for overlapping trees using Shapely
- Replace invalid configurations with known-good solutions

## Academic Techniques for 2D Irregular Packing

### No-Fit Polygon (NFP)
- Precompute feasible positions between polygon pairs
- Enables O(1) overlap checks instead of expensive polygon intersection
- Critical for fast collision detection

### Jostle Heuristics
- Addresses both allocation and placement together
- Diversification mechanism for better search
- Alternative placement criteria (not just bottom-left)

### Guided Cuckoo Search (GCS)
- Current state-of-the-art for nesting problems
- Two-stage: piece clustering + NFP-based bottom-left
- Shrinking via overlap minimization

### Simulated Annealing (SA)
- Move types: translate, rotate, swap positions
- Temperature scheduling critical
- Works well for local refinement

### Genetic Algorithms
- Encode tree order/rotation as chromosomes
- Crossover: combine good partial solutions
- Mutation: small position/angle perturbations

## Recommended Experiments (Priority Order)

### Phase 1: Establish Strong Baseline
1. **Use pre-optimized snapshots** - Check /home/nonroot/snapshots/santa-2025/ for best existing solutions
2. **Run bbox3 + shake_public** - These compiled optimizers are highly effective
3. **Apply fix_direction** - Rotation tightening for additional gains

### Phase 2: Per-N Optimization
4. **Identify worst-performing N values** - Calculate per-N scores, focus on outliers
5. **Small N (1-20):** May benefit from exhaustive/near-exhaustive search
6. **Medium N (20-100):** SA with good initialization
7. **Large N (100-200):** Lattice/tessellation patterns + local refinement

### Phase 3: Novel Approaches
8. **Implement NFP-based collision detection** - Much faster than Shapely
9. **Try asymmetric vs symmetric patterns** - Test both for each N
10. **Hybrid optimization:** Combine multiple optimizers

## Implementation Tips

### Collision Detection
```python
from shapely.geometry import Polygon
from shapely.strtree import STRtree

# Fast collision check
def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

### Score Calculation
```python
def calculate_score(dict_of_side_length):
    score = 0
    for n, side in dict_of_side_length.items():
        score += side**2 / int(n)
    return score
```

### Rotation Tightening
```python
from scipy.optimize import minimize_scalar
from scipy.spatial import ConvexHull

def optimize_rotation(trees):
    # Get all polygon points
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points_np = np.array(all_points)
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    # Find optimal rotation angle
    res = minimize_scalar(
        lambda a: calculate_bbox_side_at_angle(a, hull_points),
        bounds=(0.001, 89.999), method='bounded'
    )
    return res.x, res.fun
```

## Validation
- Always check for overlaps before submission
- Use high-precision Decimal arithmetic for coordinates
- Prepend 's' to all numeric values in submission CSV
- Coordinates must be in range [-100, 100]

## File Format
```
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```

## Key Resources
- Kernels: `../research/kernels/` - Contains bbox3, shake implementations
- Sample submission: `/home/data/sample_submission.csv`
- Pre-optimized solutions: `/home/nonroot/snapshots/santa-2025/`

## Critical Success Factors
1. **Start from best known solution** - Don't build from scratch
2. **Per-N optimization** - Each N may need different approach
3. **Asymmetric solutions** - Generally outperform symmetric
4. **Fast collision detection** - NFP or optimized Shapely
5. **Multiple optimization passes** - bbox3 → shake → fix_direction
6. **Validate before submit** - Check for overlaps
