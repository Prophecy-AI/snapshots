# Santa 2025 - Christmas Tree Packing Challenge

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding box for N=1 to 200 trees.

**Scoring:** score = Σ(side_length² / N) for N=1 to 200
**Target:** Beat 68.894234 (lower is better)
**Current Best Known:** ~70.676 (gap of ~1.78 points to target)

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Tip at (0, 0.8)
- Three tiers of branches at y=0.5, 0.25, 0
- Trunk from y=0 to y=-0.2
- Base width: 0.7, Mid width: 0.4, Top width: 0.25, Trunk width: 0.15

Trees can be positioned at (x, y) and rotated by any angle (deg).

## CRITICAL INSIGHTS FROM PREVIOUS EXPLORATION

### Current State
- Best publicly available solution: santa-2025.csv scores ~70.676
- This is a TIGHT LOCAL OPTIMUM - standard optimization cannot improve it
- Gap to target: ~1.78 points (2.5%)
- The pre-optimized submission dominates ALL 200 N values

### What Has Been Tried (and FAILED)
1. ❌ Short optimization runs (minutes) - No improvements found
2. ❌ Backward propagation (removing trees from larger N) - No improvements
3. ❌ Simple ensemble of 30 CSV files - santa-2025.csv dominates all N values
4. ❌ fix_direction post-processing - Causes precision loss and overlaps

### What MUST Be Tried (Not Yet Implemented)
1. **MUCH LONGER OPTIMIZATION RUNS** - Hours, not minutes
   - Top kernels run sa_v1_parallel with -n 15000 iterations, -r 80 rounds
   - Multiple generations with perturbation to escape local optima
   
2. **LATTICE-BASED APPROACH FOR LARGE N (N >= 58)** - CRITICAL!
   - The egortrushin kernel uses fundamentally different approach
   - Start with 2 base trees in specific configuration
   - Translate them in x and y directions to create grid pattern
   - Parameters: nt = [nx, ny] where nx*ny = N
   - This generates crystalline/lattice packings tighter than random optimization

3. **FOCUS ON SMALL N VALUES (1-10)**
   - N=1 contributes 0.66 to score (highest single contribution)
   - Small N values have lowest efficiency (1.5-2.6 trees/unit area)
   - Try exhaustive search for optimal rotation angles
   - For N=1, optimal angle is 45 degrees (minimizes bounding box)

## Insights from Discussions (MANDATORY)
Based on discussion analysis:
- **"Why the winning solutions will be Asymmetric" (38 votes):** Asymmetric solutions outperform symmetric ones for most N values
- **"Symmetric solutions that are apparently optimal" (43 votes):** Some specific N values have optimal symmetric solutions, but most benefit from asymmetric arrangements
- **Key insight:** Per-N optimization is critical - different N values require different strategies

## Key Approaches from Public Kernels

### 1. bbox3 C++ Optimizer
- Complex number vector coordination
- Fluid dynamics-inspired movement
- Hinge pivot optimization
- Global boundary tension
- Aggressive overlap repair cycles
- Multi-phase optimization (short→medium→long runs)

### 2. sa_v1_parallel (Simulated Annealing)
- Parallel optimization across N values
- Perturbation to escape local optima
- Key parameters: -n (iterations), -r (rounds)
- **MUST RUN FOR HOURS, NOT MINUTES**

### 3. shake_public Optimizer
- Binary optimizer for local refinement
- Works well in combination with bbox3

### 4. Fix Direction / Rotation Tightening
- Optimize global rotation angle to minimize bounding box
- Uses ConvexHull + minimize_scalar optimization
- Can reduce score by rotating entire configuration

## Academic Techniques for 2D Irregular Packing

### No-Fit Polygon (NFP)
- Precompute feasible positions between polygon pairs
- Enables O(1) overlap checks instead of expensive polygon intersection
- Critical for fast collision detection

### Guided Cuckoo Search (GCS)
- Current state-of-the-art for nesting problems
- Two-stage: piece clustering + NFP-based bottom-left
- Shrinking via overlap minimization

### Simulated Annealing (SA)
- Move types: translate, rotate, swap positions
- Temperature scheduling critical
- Works well for local refinement
- **MUST RUN LONG ENOUGH TO ESCAPE LOCAL OPTIMA**

## Recommended Experiments (Priority Order)

### Phase 1: Lattice-Based Approach (HIGHEST PRIORITY)
1. **Implement lattice packing for large N (N >= 58)**
   - Start with 2 base trees
   - Translate in x and y to create grid
   - Optimize base configuration and translation vectors
   - This is the KEY to beating the target

### Phase 2: Long Optimization Runs
2. **Run sa_v1_parallel for HOURS**
   - Parameters: -n 15000+ iterations, -r 80+ rounds
   - Use perturbation to escape local optima
   - Multiple random seeds

### Phase 3: Small N Optimization
3. **Exhaustive search for N=1 to 10**
   - Try all rotation angles in 0.001 degree increments
   - N=1 alone contributes 0.66 to score
   - Optimal N=1 angle is 45 degrees

### Phase 4: Hybrid Approaches
4. **Combine lattice (large N) + SA (medium N) + exhaustive (small N)**
5. **Use backward propagation AFTER lattice optimization**

## Implementation Tips

### Collision Detection
```python
from shapely.geometry import Polygon
from shapely.strtree import STRtree

def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

### Score Calculation
```python
def calculate_score(dict_of_side_length):
    score = 0
    for n, side in dict_of_side_length.items():
        score += side**2 / int(n)
    return score
```

### Lattice Packing (CRITICAL)
```python
def generate_lattice_config(n, base_trees, dx, dy):
    """Generate N trees by translating base configuration"""
    # base_trees: list of 2 trees in optimal relative position
    # dx, dy: translation vectors
    # Returns N trees arranged in grid pattern
    nx = int(np.ceil(np.sqrt(n)))
    ny = int(np.ceil(n / nx))
    trees = []
    for i in range(nx):
        for j in range(ny):
            if len(trees) >= n:
                break
            for base in base_trees:
                if len(trees) >= n:
                    break
                new_tree = Tree(
                    x=base.x + i * dx,
                    y=base.y + j * dy,
                    angle=base.angle
                )
                trees.append(new_tree)
    return trees[:n]
```

## Validation
- Always check for overlaps before submission
- Use high-precision Decimal arithmetic for coordinates
- Prepend 's' to all numeric values in submission CSV
- Coordinates must be in range [-100, 100]

## File Format
```
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```

## Key Resources
- Kernels: `../research/kernels/` - Contains bbox3, shake implementations
- Sample submission: `/home/data/sample_submission.csv`
- Pre-optimized solutions: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`
- Best known submission: `santa-2025.csv` in preoptimized folder

## Critical Success Factors
1. **LATTICE APPROACH FOR LARGE N** - This is the key differentiator
2. **LONG OPTIMIZATION RUNS** - Hours, not minutes
3. **Per-N optimization** - Different strategies for different N values
4. **Asymmetric solutions** - Generally outperform symmetric
5. **Fast collision detection** - NFP or optimized Shapely
6. **Validate before submit** - Check for overlaps

## What NOT to Try
- Simple ensemble (santa-2025.csv dominates all N values)
- Short optimization runs (local optimum is too tight)
- fix_direction alone (causes precision loss)
- Random search without intelligent initialization
