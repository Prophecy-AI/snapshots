# Santa 2025 Christmas Tree Packing - Seed Prompt

## Problem Overview
This is a 2D polygon packing optimization problem. The goal is to pack Christmas tree toys (15-vertex polygons) into the smallest possible square bounding box for configurations of N=1 to N=200 trees.

**Metric:** Score = Σ(s_n² / n) for n=1 to 200, where s_n is the side length of the bounding square for n trees.
**Target Score:** Beat 68.922808 (lower is better)

## Tree Geometry
- 15-vertex polygon with trunk (0.15w x 0.2h), base (0.7w), mid (0.4w), top (0.25w), tip at y=0.8
- Trees can be rotated (angle in degrees) and positioned (x,y coordinates)
- Collision detection uses Shapely with point-in-polygon and segment intersection tests

## Key Techniques from Public Kernels

### 1. bbox3 C++ Optimizer (HIGHEST PRIORITY)
From `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`:
- Uses simulated annealing with moves: translate, rotate, swap
- Multi-phase approach: short runs to find promising (n,r) parameters, then medium/long runs on best candidates
- Parameters: n (iterations), r (restart count)
- Compile with: `g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp`

### 2. fix_direction - Global Rotation Optimization
From `../research/kernels/saspav_santa-submission/`:
- Optimizes global rotation angle of entire tree configuration to minimize bounding box
- Uses scipy.optimize.minimize_scalar on convex hull points
- Can reduce score by finding better axis alignment
- Apply after each optimization pass

### 3. Backward Propagation
From `../research/kernels/smartmanoj_santa-claude/`:
- Start from N=200 and work backwards
- Remove boundary-touching trees one at a time
- If removing a tree from N gives a better N-1 configuration, use it
- Trees touching bounding box boundary are candidates for removal

### 4. C++ Optimizer Features
- **squeeze**: Scale all trees toward center until overlap
- **compaction**: Move individual trees toward center
- **local search**: 8-directional moves + rotations with decreasing step sizes
- **swap moves**: Exchange positions between tree pairs
- Use OpenMP for parallelization, long double precision for accuracy

### 5. Greedy Initialization
From `../research/kernels/inversion_santa-2025-getting-started/`:
- Place trees one at a time, starting far from center at weighted random angle
- Move toward center until collision, then back up
- Use previous N-tree config as starting point for N+1
- Weight angles toward diagonals (abs(sin(2*angle))) for better corner packing

## Recommended Experiment Strategy

### Experiment 1: Baseline with Best Public Kernel
1. Download pre-optimized submission from public datasets (look for santa-2025-csv or similar)
2. Run fix_direction to optimize global rotation
3. Validate no overlaps, submit to establish baseline

### Experiment 2: bbox3 Optimization
1. Compile bbox3.cpp with OpenMP optimization
2. Run with parameters: n=5000-10000, r=16-256
3. Apply fix_direction after each run
4. Use backward propagation to improve smaller N configurations

### Experiment 3: Multi-Start Optimization
1. Generate multiple random initial configurations
2. Run bbox3 on each with different seeds
3. Keep best configuration for each N
4. Ensemble by taking best N from any run

### Experiment 4: Constructive Approaches (if local search plateaus)
1. **Greedy Backtracking with Beam Search:**
   - Build solutions tree-by-tree from scratch
   - Use beam search to explore multiple paths
   - Parameters: BEAM=10, DEPTH=10, MAX_STATES=4000

2. **Per-N Construction:**
   - For each N, try multiple different construction strategies
   - Don't just inherit from N+1 configuration
   - Try different initial tree placements and angles

### Experiment 5: Advanced Techniques
1. **No-Fit Polygon (NFP):** Pre-compute collision-free placement regions
2. **Lattice-based packing:** Exploit crystalline patterns (blue/pink phase from kernel analysis)
3. **Rotation discretization:** Try specific angles (0, 90, 180, 270) that may pack better

## Validation
- Always check for overlaps before submission
- Use Shapely for precise collision detection
- Replace any overlapping configurations with known-good baseline

## Implementation Notes

### Submission Format
```
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- Values prefixed with 's' to preserve precision
- Total 20100 rows (sum of 1+2+...+200)

### Key Code Patterns
```python
# Score calculation
def get_score(side_length, n):
    return side_length ** 2 / n

# Total score
total_score = sum(s_n**2 / n for n in range(1, 201))

# Collision detection with Shapely
from shapely.geometry import Polygon
from shapely.strtree import STRtree

def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

## Critical Success Factors
1. Start from best available pre-optimized solution
2. Use C++ for optimization (much faster than Python)
3. Apply fix_direction after every optimization pass
4. Use backward propagation to improve smaller N
5. Validate all configurations before submission
6. If local search plateaus, try constructive approaches with different random seeds
