# Santa 2025 Christmas Tree Packing - Evolved Seed Prompt (Loop 1)

## Current Status
- Best CV score: 70.676102 from exp_000 (001_baseline_preoptimized)
- Best LB score: N/A (no submissions yet)
- Target: 68.922808 | Gap to target: 1.753 points

## Public Kernel Status (CRITICAL!)
- Have we implemented the best kernel yet? **YES** - saspav santa-2025.csv scores 70.676
- Top kernels identified:
  - saspav/santa-submission: 70.676 (IMPLEMENTED)
  - bucket-of-chump: 70.677 (slightly worse)
  - telegram solutions: 71.97, 72.49 (worse)
  - best-public: 70.926 (worse)
- **All available public solutions score ~70.67-72.5, none beat target of 68.92**

## Critical Issue: bbox3 Binary Incompatibility
The bbox3 C++ optimizer binary has GLIBC version mismatch:
```
/lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34' not found
```
**MUST compile from source or implement Python-based SA optimizer**

## Response to Evaluator
The evaluator correctly identified that:
1. bbox3 optimizer was not used - **BLOCKED by GLIBC incompatibility**
2. Backward propagation not attempted - Will implement in Python
3. No submission made - **AGREE: Should submit baseline to establish LB score**

The evaluator's suggestion to run bbox3 is blocked by system constraints. We need to:
1. Find bbox3 source code and compile it, OR
2. Implement equivalent SA optimizer in Python/Numba

## Key Insight from Research
To break the 69-point barrier, top competitors use:
1. **Lattice-based packing** with 2-tree units (alternating up/down) → mid-70s
2. **Larger repeating lattice blocks** (3-4 tree motifs) → sub-69 scores
3. **Simulated annealing** with translate/rotate/swap moves
4. **C++ optimization** with AVX2 vectorization for speed

The current best public solutions are at ~70.67, which means:
- Public kernels have NOT achieved the target score
- We need to implement BETTER optimization than what's publicly available
- The gap of 1.75 points requires significant algorithmic improvement

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Submit Baseline to LB
- Submit current best (70.676) to establish LB score
- Verify local score matches LB score
- Use 1 of 99 remaining submissions

### 2. **[HIGH PRIORITY]** Implement Python SA Optimizer
Since bbox3 binary is incompatible, implement SA in Python with Numba:
- Use the C++ code from jonathanchan kernel as reference
- Implement translate, rotate, swap moves
- Use geometric cooling schedule
- Target: improve specific N values with highest contribution

### 3. **[HIGH PRIORITY]** Backward Propagation
From smartmanoj kernel:
- Start from N=200, work backwards
- Remove boundary-touching trees one at a time
- If removing a tree from N gives better N-1 config, use it

### 4. **[MEDIUM PRIORITY]** Lattice Pattern Optimization
Research shows larger lattice blocks (3-4 tree motifs) can break 69:
- Analyze current best solutions for lattice patterns
- Try different tree arrangements for small N
- Optimize lattice parameters with SA

### 5. **[MEDIUM PRIORITY]** Compile bbox3 from Source
- Search for bbox3.cpp source code in kernels
- Compile with: `g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp`
- If source not available, implement equivalent in C++

## What NOT to Try
- ❌ Reinforcement learning (proven ineffective for this problem)
- ❌ Running pre-compiled bbox3 binary (GLIBC incompatible)
- ❌ Simple grid search (too slow, doesn't scale)

## SUBMISSION STRATEGY
- Remaining submissions: 99
- **Submit after this experiment? YES** - We have abundant submissions
- Submit baseline to establish LB score and verify scoring consistency

## Validation Notes
- Score = Σ(s_n² / n) for n=1 to 200
- Lower is better
- No overlapping trees allowed
- Use Shapely for collision detection

## Next Experiment: 002_python_sa_optimizer
1. Implement SA optimizer in Python with Numba
2. Focus on N values with highest score contribution (N=1,2,3,4,5 have highest per-N scores)
3. Apply backward propagation
4. Submit improved solution
