{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T03:50:19.074193",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D packing optimization problem: fit Christmas tree toys (polygon shapes) into smallest square bounding box for N=1 to 200 trees. Score = sum(s_n^2/n) where s_n is side length for n trees. Lower is better. Target score: 68.922808",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "Tree geometry: 15-vertex polygon with trunk (0.15w x 0.2h), base (0.7w), mid (0.4w), top (0.25w), tip at y=0.8. Trees can be rotated (angle in degrees) and positioned (x,y coordinates). Collision detection uses Shapely with point-in-polygon and segment intersection tests.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Key technique: bbox3 C++ optimizer - uses simulated annealing with moves: translate, rotate, swap. Multi-phase approach: short runs to find promising (n,r) parameters, then medium/long runs on best candidates. Uses fix_direction to optimize global rotation of entire configuration.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Key technique: fix_direction - optimizes global rotation angle of entire tree configuration to minimize bounding box. Uses scipy.optimize.minimize_scalar on convex hull points. Can reduce score by finding better axis alignment.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Key technique: Backward propagation - start from N=200 and work backwards, removing boundary-touching trees one at a time to potentially improve smaller N configurations. Trees touching bounding box boundary are candidates for removal.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "C++ optimizer features: squeeze (scale all trees toward center), compaction (move trees toward center), local search (8-directional moves + rotations), swap moves between tree pairs. Uses OpenMP for parallelization. Long double precision for accuracy.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Greedy initialization: Place trees one at a time, starting far from center at weighted random angle (favoring diagonal directions), move toward center until collision, then back up. Use previous N-tree config as starting point for N+1.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D polygon packing optimization to minimize bounding box area?",
      "finding": "2\u2011D polygon packing that seeks the smallest enclosing rectangle (or \u201cbounding box\u201d) is tackled by two families of methods.  **Exact branch\u2011and\u2011bound/absolute\u2011placement algorithms** enumerate the possible x\u2011coordinates of all pieces first, then resolve the y\u2011coordinates in a perfect\u2011packing subproblem, pruning the search with strong lower\u2011bounds derived from a one\u2011dimensional bin\u2011packing relaxation and dominance rules.  This approach, introduced by Korf\u202f(2003) and later refined by Huang\u202f&\u202fKorf (2009, 2013), can solve optimal rectangle\u2011packing instances far beyond earlier benchmarks (e.g., extending the consecutive\u2011square benchmark from\u202fN\u202f=\u202f27 to\u202fN\u202f=\u202f32) and has been adapted to non\u2011rectangular polygons by exploiting the same coordinate\u2011ordering and pruning ideas ([Korf\u202f2003](https://cdn.aaai.org/ICAPS/2003/ICAPS03-029.pdf); [Huang\u202f2009](https://ijcai.org/Proceedings/09/Papers/092.pdf); [Huang\u202f2013](https://jair.org/index.php/jair/article/view/10797)).  \n\nWhen optimality is infeasible for",
      "agent": "explorer"
    },
    {
      "query": "What are the best simulated annealing parameters and cooling schedules for 2D packing optimization problems?",
      "finding": "Simulated\u2011annealing (SA) is a widely\u2011used meta\u2011heuristic for two\u2011dimensional (2\u2011D) packing because it can explore the highly non\u2011convex layout space while respecting non\u2011overlap constraints.  The most influential parameters are the **initial temperature (T\u2080)**, the **cooling schedule (how T is reduced)**, and the **length of the Markov chain at each temperature** (number of neighbour moves before cooling).  In practice\u202fT\u2080 is chosen so that a large fraction (\u2248\u202f70\u201180\u202f%) of randomly generated moves are accepted; this can be obtained by a short pilot run that measures the average increase \u0394E of the objective and sets\u202fT\u2080\u202f\u2248\u202f\u2212\u0394E/ln\u202f0.8.  The chain length is usually taken proportional to the number of items (e.g.,\u202f10\u202fN\u202fto\u202f20\u202fN moves per temperature) so that each rectangle has several chances to be repositioned before the temperature drops.  An adaptive neighbourhood, controlled by a \u201ccrystallisation factor\u201d, further improves acceptance by enlarging move amplitudes after a successful step and s",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 99
}