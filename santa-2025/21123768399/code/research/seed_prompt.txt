# Santa 2025 Christmas Tree Packing - Evolved Seed Prompt (Loop 3)

## Current Status
- Best CV score: 70.676102 from exp_000 (saspav baseline)
- Best LB score: 70.676102 (verified submission)
- Target: 68.922808 | Gap to target: 1.753 points (2.5%)

## CRITICAL LEADERBOARD CONTEXT
- **Current LB Leader**: 71.19 (terry_u16)
- **Our Score**: 70.68 (BETTER than LB leader!)
- **Target**: 68.92 (2.26 points BETTER than LB leader)

**IMPORTANT**: The target (68.92) is MORE AGGRESSIVE than the current leaderboard leader!
This means we're already competitive, but the target may be theoretical optimum.

## Public Kernel Status
- **Best kernel implemented**: YES - saspav santa-2025.csv (70.676)
- **Kernels we've tried**: saspav, bucket-of-chump, telegram, santa25-public (all ensembled)
- **Result**: saspav is best for ALL 200 N values

## Techniques Tried (All showed 0 improvement on saspav baseline)
1. ❌ Ensemble of 20 solutions - saspav already best for all N
2. ❌ Backward propagation - 0 improvements
3. ❌ Simple lattice construction - Worse than baseline (0.385 vs 0.349 for N=72)
4. ✅ Rebuild from corners - Found 1 improvement (N=54: 0.000634 score reduction)

## Response to Evaluator
The evaluator correctly identified that our lattice construction was INCOMPLETE:
- We used binary search for translations (too simplistic)
- We did NOT apply SA to optimize the lattice
- The egortrushin kernel runs SA for 10,000+ iterations

**AGREED**: The lattice approach needs FULL SA optimization, not just binary search.

The evaluator also noted that the C++ optimizer has false positives due to tolerance issues.
**AGREED**: We should use Python-based SA with Numba acceleration instead.

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Implement jiweiliu's Super Fast SA
From `research/kernels/jiweiliu_super-fast-simulated-annealing-with-translations/`:
- Uses Numba-accelerated geometry operations
- Key optimizations:
  - Center distance check before polygon overlap (skip if centers > 1.8 apart)
  - Cross-product based segment intersection (avoids divisions)
  - Multiprocessing for parallelization
- Achieves ~0.15 improvement in under 2 minutes
- Key features:
  1. Random noise on translation lengths
  2. Simultaneous rotation of all unit cell trees
  3. Edge tree addition for non-multiple counts
  4. Backward propagation after SA
  5. Automatic grid size exploration

### 2. **[HIGH PRIORITY]** Full SA on Lattice Construction
From `research/kernels/egortrushin_santa25-simulated-annealing-with-translations/`:
- Create 2-tree unit cell (one up at 67°, one down at 250°)
- Use SA to optimize:
  - Translation parameters (lengthx, lengthy)
  - Individual tree positions (x, y)
  - Tree angles
- Parameters:
  ```python
  Tmax = 0.1
  Tmin = 1e-6
  nsteps = 10000
  position_delta = 0.1
  angle_delta = 10
  ```
- Apply backward propagation AFTER SA

### 3. **[MEDIUM PRIORITY]** Fractional Translation
From jonathanchan kernel:
- For each tree, try moving by tiny amounts (0.001, 0.0005, 0.0001) in 8 directions
- Keep moves that reduce bounding box without causing overlap
- Simpler than full SA, can squeeze out small improvements

### 4. **[MEDIUM PRIORITY]** Rebuild from Corners (Extended)
From chistyakov kernel:
- Already found 1 improvement (N=54)
- Try more large N configurations as sources
- Try different corner selection strategies

### 5. **[LOW PRIORITY]** C++ bbox3 Optimizer
- Need to compile from source (GLIBC version mismatch)
- Or fix the overlap tolerance issue (change 1e-10 to 1e-8)

## What NOT to Try
- Simple backward propagation (already tried, 0 improvements)
- Ensemble of existing solutions (saspav already best for all N)
- Binary search for lattice translations (too simplistic)
- Using pre-compiled bbox3 binary (GLIBC mismatch)

## Implementation Strategy

### Experiment 004: Super Fast SA with Numba
1. Copy the jiweiliu kernel's Numba-accelerated geometry functions
2. Implement the SA optimization loop
3. Start from saspav baseline
4. Run SA for each N value (or focus on large N which contributes 48% of score)
5. Apply backward propagation after SA
6. Validate no overlaps before submission

### Key Code Components Needed:
```python
# From jiweiliu kernel - Numba-accelerated overlap check
@njit(cache=True)
def polygons_overlap(verts1, verts2, cx1, cy1, cx2, cy2):
    # Quick center distance check
    dx = cx2 - cx1
    dy = cy2 - cy1
    dist_sq = dx * dx + dy * dy
    if dist_sq > MAX_OVERLAP_DIST_SQ:  # 1.8^2 = 3.24
        return False
    # ... rest of overlap check
```

### Expected Outcome
- The jiweiliu kernel claims ~0.15 improvement in 2 minutes
- If we can achieve similar improvement: 70.676 - 0.15 = 70.526
- Still 1.6 points from target, but progress

## SUBMISSION STRATEGY
- Remaining submissions: 98
- **SUBMIT after this experiment** - we have abundant submissions
- LB feedback is valuable for calibrating our approach

## Validation Notes
- Use Shapely for final overlap validation before submission
- Check all 200 configurations for overlaps
- Score calculation: sum(side_length^2 / n) for n=1 to 200