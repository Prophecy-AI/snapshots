# Santa 2025 Christmas Tree Packing - Evolved Seed Prompt (Loop 4)

## Current Status
- Best CV score: 70.676102 (all 4 experiments have identical score - STUCK!)
- Best LB score: 70.676102 (exp_000)
- Target: 68.922808 | Gap to target: 1.753294 (2.54%)
- Submissions used: 2/100 (98 remaining - ABUNDANT!)

## CRITICAL DIAGNOSIS: WE ARE STUCK AT A LOCAL OPTIMUM

All 4 experiments have the EXACT SAME score (70.676102). This means:
1. The saspav baseline is already optimized for backward propagation
2. Ensembling existing solutions shows no improvement
3. We MUST try fundamentally different approaches

## Response to Evaluator

The evaluator is CORRECT:
- We implemented backward propagation but NOT the full SA optimization
- The jiweiliu kernel's value is in `sa_optimize_improved()`, not just the cascade
- The workflow should be: SA generates new configs → backward propagation improves them
- We did: backward propagation on baseline → 0 improvements (baseline already optimized)

**Action:** Implement the FULL SA optimization from jiweiliu, not just backward propagation.

## What We've Tried (ALL FAILED TO IMPROVE)
1. ✅ Pre-optimized baseline (saspav) - 70.676102
2. ✅ Ensemble of 20 solutions - same score (saspav best for all N)
3. ✅ Backward propagation (Python) - 0 improvements
4. ✅ Backward propagation (Numba) - 0 improvements

## What We MUST Try Next (Priority Order)

### 1. **[HIGHEST PRIORITY] Full SA Optimization from jiweiliu**

The jiweiliu kernel achieves ~0.15 improvement by:
- Creating 2-tree unit cells (one up at 67°, one down at 250°)
- Tiling into grids (ncols × nrows)
- SA optimization of: translation lengths (a, b), tree positions (x, y), angles
- Cooling schedule: Tmax=0.1, Tmin=1e-6, nsteps=10000

**Key grid configurations to try:**
- N=72: ncols=4, nrows=9 (4×9×2 = 72)
- N=100: ncols=5, nrows=10 (5×10×2 = 100)
- N=144: ncols=6, nrows=12 (6×12×2 = 144)
- N=196: ncols=7, nrows=14 (7×14×2 = 196)

**Implementation:**
```python
# Initial seed configuration (from jiweiliu)
seed_xs = np.array([0.0, 0.046])
seed_ys = np.array([0.0, -0.229])
seed_degs = np.array([67.0, 250.0])

# SA parameters
Tmax = 0.1
Tmin = 1e-6
nsteps = 10000
nsteps_per_T = 100
position_delta = 0.1
angle_delta = 10
delta_t = 0.05  # translation delta
```

### 2. **[HIGH PRIORITY] C++ Tree Packer from jonathanchan**

The jonathanchan kernel has a C++ optimizer that runs 150000 iterations with 32 restarts.
This is much more aggressive than the Python SA.

**Compile and run:**
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer.cpp
./tree_packer -i submission.csv -o output.csv -n 150000 -r 32
```

### 3. **[MEDIUM PRIORITY] Rebuild from Corners (chistyakov)**

Previous analysis found 1 improvement: N=54 improved from 4.41716128 to 4.41328175.
This is a small but REAL improvement (0.000634 points).

**Apply this improvement to the submission!**

### 4. **[MEDIUM PRIORITY] Fractional Translation**

For each tree in the baseline, try moving by tiny amounts (0.001, 0.0005, 0.0001) in 8 directions.
Keep moves that reduce bounding box without causing overlap.

## SUBMISSION STRATEGY

**SUBMIT AFTER EVERY EXPERIMENT!** We have 98 submissions remaining.
- LB feedback is FREE information
- We need to calibrate CV-LB relationship
- Don't waste submissions by not using them

## What NOT to Try
- ❌ More backward propagation (already confirmed 0 improvements)
- ❌ More ensembling of existing solutions (saspav is best for all N)
- ❌ Local optimization on the baseline (it's at a local optimum)

## Validation Notes
- Score = Σ(s_n² / n) for n=1 to 200
- Lower is better
- Must check for overlaps before submission (exp_001 failed due to overlaps)
- Use Numba for fast geometry operations

## Expected Outcomes
- jiweiliu SA: ~0.15 improvement → 70.53
- C++ tree_packer: potentially more improvement
- Rebuild from corners: ~0.001 improvement
- Combined: hopefully closer to target

## Gap Analysis
- Target: 68.922808
- Current: 70.676102
- Gap: 1.753294 (2.54%)
- jiweiliu claims 0.15 improvement → still 1.60 from target
- We need ~12x more improvement than jiweiliu alone provides
- This suggests we need to run SA for MUCH longer or try multiple approaches

## Key Insight from Evaluator
The jiweiliu kernel has TWO key components:
1. `sa_optimize_improved()` - SA optimization (THE MAIN VALUE)
2. `deletion_cascade_numba()` - Backward propagation (POST-PROCESSING)

We implemented #2 but not #1. Without #1, #2 has nothing to work with.
**IMPLEMENT #1 FIRST!**