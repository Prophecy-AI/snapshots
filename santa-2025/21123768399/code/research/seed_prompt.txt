# Santa 2025 Christmas Tree Packing - Evolved Seed Prompt (Loop 2)

## Current Status
- Best CV score: 70.676102 from exp_000 (001_baseline_preoptimized)
- Best LB score: 70.676102 (confirmed)
- Target: 68.922808 | Gap to target: 1.753294 (2.5%)
- Submissions used: 2/100 (98 remaining)

## CRITICAL: Last Submission Failed
**Submission 002 failed with "Overlapping trees in group 040"**
- The ensemble notebook created invalid configurations
- MUST validate for overlaps before any submission
- Use the saspav solution as the known-good baseline

## Response to Evaluator

The evaluator correctly identified that:
1. **Local optimization cannot improve pre-optimized solutions** - they are at local optima
2. **The egortrushin kernel shows a fundamentally different approach** - lattice-based construction
3. **Backward propagation hasn't been properly applied**

I agree with all these points. The key insight is that we need CONSTRUCTIVE approaches, not more local search.

## Key Findings

### 1. Solutions are at Local Optima
- bbox3 C++ optimizer: 0 improvement
- tree_packer v18/v21: 0 improvement  
- Ensembling 20 sources: saspav already best for ALL 200 N values
- **Conclusion: Local search cannot improve these solutions**

### 2. Score Breakdown
- Small N (1-50): 19.04 (27%)
- Medium N (51-100): 17.64 (25%)
- Large N (101-200): 33.99 (48%)
- **Large N contributes most to score - focus optimization there**

### 3. Packing Efficiency
- Small N: 80.6% efficient
- Medium N: 83.4% efficient
- Large N: 85.0% efficient
- **Room for improvement across all ranges**

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY] Implement Lattice-Based Construction**
The egortrushin kernel (`research/kernels/egortrushin_santa25-simulated-annealing-with-translations/`) shows the key technique:

```python
# Key concept: 2-tree unit cell with fractional translations
# 1. Create initial_trees = [tree_up, tree_down] with specific angles
# 2. Tile using: nt = [nx, ny] grid dimensions
# 3. SA optimizes: delta1 (translation offset), position_delta, angle_delta
# 4. Generate N trees by taking first N from the tiled grid
```

**Implementation steps:**
1. Extract the SimulatedAnnealing class from egortrushin kernel
2. Run SA for key N values: 72, 100, 110, 144, 156, 196, 200
3. Apply backward propagation to improve smaller N
4. Validate no overlaps before submission

### 2. **[HIGH PRIORITY] Backward Propagation**
From N=200 down to N=2:
- For each tree in configuration N, try removing it
- If the resulting N-1 configuration is better than current N-1, use it
- This propagates improvements from large N to small N

```python
for n in range(200, 1, -1):
    for tree_idx in range(n):
        candidate = remove_tree(solutions[n], tree_idx)
        if score(candidate) < score(solutions[n-1]):
            solutions[n-1] = candidate
```

### 3. **[MEDIUM PRIORITY] Fix Overlap Validation**
The submission failed because of overlapping trees. MUST:
1. Use Shapely with proper precision (scale_factor = 1e15 or 1e18)
2. Check `intersects()` but not `touches()` for overlap detection
3. Replace any overlapping configurations with known-good baseline

### 4. **[LOW PRIORITY] Try Different Lattice Parameters**
The egortrushin kernel uses specific parameters:
- nt = [6, 12] for N=144
- nt = [7, 14] for N=196
- nt = [7, 15] for N=210 (then take first 200)

Try different grid dimensions to find better packings.

## What NOT to Try
- ❌ More local optimization (SA, bbox3) on existing solutions - they're at local optima
- ❌ Ensembling different sources - saspav is already best for all N
- ❌ Running tree_packer with different parameters - 0 improvement observed
- ❌ Submitting without overlap validation - will fail

## Validation Notes
- Use Shapely with scale_factor = 1e15 or 1e18 for precision
- Check for overlaps: `poly1.intersects(poly2) and not poly1.touches(poly2)`
- Score calculation: `sum(side_n**2 / n for n in range(1, 201))`
- Expected total rows: 20100

## SUBMISSION STRATEGY
- Remaining submissions: 98
- Submit after this experiment? **YES - we have abundant submissions**
- But ONLY if overlap validation passes!

## Key Code References
- Lattice SA: `research/kernels/egortrushin_santa25-simulated-annealing-with-translations/santa25-simulated-annealing-with-translations.ipynb`
- Backward propagation: Same kernel, last cell
- Overlap validation: `research/kernels/jazivxt_why-not/why-not.ipynb` (Cell 5-7)
- Known-good baseline: `/home/code/santa-2025-csv/santa-2025.csv`

## Expected Outcome
The lattice-based approach can achieve scores in the 69-70 range for large N configurations. With proper backward propagation, we should be able to improve the total score. The target of 68.922808 is achievable with the right lattice parameters and optimization.