# Santa 2025 Christmas Tree Packing - Evolved Seed Prompt (Loop 7)

## Current Status
- Best CV score: 70.676102 from exp_000 (saspav baseline)
- Best LB score: 70.676102398091 (verified match)
- Target: 68.922808 | Gap to target: 1.753294 (2.54%)

## CRITICAL DISCOVERY
**The target (68.922808) is BETTER than the current LB #1 (71.191427)!**

This means:
1. Our current score (70.676102) is actually 0.5 points BETTER than LB #1
2. The target requires techniques BEYOND what's publicly available
3. We need to INNOVATE, not just copy existing kernels
4. Top competitors use "crystallography-inspired hybrid lattice packing"

## Response to Evaluator

The evaluator correctly identified that:
1. tree_packer_v18 lacks `fractional_translation` - a key micro-optimization technique
2. The jonathanchan C++ optimizer has this technique and should be tried
3. 7 experiments with identical scores indicates we're stuck at a local optimum

**I AGREE** with the evaluator's assessment. The jonathanchan optimizer is the most promising next step because:
- It has `fractional_translation` with step sizes down to 0.00001
- It has `sa_v3` with 8 move types including corner tree focus
- It has population-based search with basin hopping
- It runs `fractional_translation` after every SA run (120-150 iterations)

However, I note that even the jonathanchan optimizer may not reach the target since:
- The target is 2.27 points better than LB #1
- This suggests the target was achieved with techniques not in public kernels
- We may need to research crystallography-inspired approaches

## Experiment History (ALL IDENTICAL SCORES)
| Exp | Name | Score | Technique |
|-----|------|-------|-----------|
| 000 | baseline_preoptimized | 70.676102 | saspav dataset |
| 001 | ensemble_all_sources | 70.676102 | Ensemble 20 sources |
| 002 | lattice_backward_prop | 70.676102 | Backward prop + lattice |
| 003 | numba_backward_prop | 70.676102 | Numba backward prop |
| 004 | full_sa_lattice | 70.676102 | Full SA lattice |
| 005 | correct_sa_params | 70.676102 | SA with jiweiliu params |
| 006 | long_cpp_optimization | 70.676102 | tree_packer_v18 1M iters |

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Compile and run jonathanchan C++ optimizer
The jonathanchan kernel has a complete C++ optimizer with key techniques missing from tree_packer_v18:

**Extract from notebook cell 8 (a.cpp) or cell 20 (sa_v1_parallel.cpp):**
```bash
# Extract the C++ code from the notebook
cd /home/code/research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation
# The code is in cells 8 and 20 of the notebook

# Compile
g++ -O3 -march=native -std=c++17 -fopenmp -o jonathanchan_optimizer sa_v1_parallel.cpp

# Run with saspav baseline as input
./jonathanchan_optimizer -i /home/code/santa-2025-csv/santa-2025.csv -n 20000 -r 80
```

**Key parameters:**
- `-n 20000` (SA iterations per restart)
- `-r 80` (number of restarts)
- Adaptive parameters for different N ranges
- `fractional_translation` with 120-150 iterations after each SA run

### 2. **[HIGH PRIORITY]** Research crystallography-inspired techniques
Web search revealed top competitors use "crystallography-inspired hybrid lattice packing":
- This is different from simple 2-tree lattice
- May involve larger repeating units (3-4 tree motifs)
- May use specific rotation angles based on crystal symmetry

**Research questions:**
- What are the optimal lattice parameters for tree packing?
- What rotation angles minimize bounding box for different N?
- Can we use hexagonal or other non-rectangular lattices?

### 3. **[MEDIUM PRIORITY]** Decimal precision arithmetic
Top solutions use Python's `Decimal` type for exact collision detection:
- Avoids floating-point errors that cause false overlaps
- May allow tighter packing
- Implement in Python for verification, then port to C++

### 4. **[LOWER PRIORITY]** Exact algorithms for small N
For N=1 to 20, exact solutions may be achievable:
- Branch-and-bound (Korf 2003)
- Constraint programming
- These N values contribute 19.04 to total score (27%)

## What NOT to Try
- ❌ More tree_packer_v18 runs (already tried 1M iterations, 0 improvement)
- ❌ Simple backward propagation (already tried, 0 improvement)
- ❌ Simple lattice construction (produces worse scores than baseline)
- ❌ Ensembling existing solutions (saspav is already best for all N)

## Validation Notes
- CV scheme: Calculate total score = Σ(s_n² / n) for n=1 to 200
- Score verified to match LB exactly (70.676102 ≈ 70.676102398091)
- No overlaps in baseline solution

## SUBMISSION STRATEGY
- Remaining submissions: 98
- **SUBMIT after every experiment** - we have abundant submissions
- LB feedback is free information - use it!
- Even if jonathanchan optimizer shows small improvement, SUBMIT to verify

## Key Insight
The saspav baseline is at a very strong local optimum. All 7 experiments produced identical scores. The jonathanchan optimizer's `fractional_translation` technique may be able to find micro-improvements that escape this local optimum. If that fails, we need to research fundamentally different approaches (crystallography-inspired lattice packing).
