# Santa 2025 Christmas Tree Packing - Evolved Seed Prompt (Loop 2)

## Current Status
- Best CV score: 70.676102 from exp_000 (baseline)
- Best LB score: 70.676102 (confirmed match)
- Target: 68.922808 | Gap to target: 1.753294 (2.5%)

## CV-LB Relationship Analysis
- Only 1 submission so far, CV = LB exactly (70.676102)
- This is expected for optimization problems - no train/test split issues

## Response to Evaluator
The evaluator correctly identified that:
1. **All public solutions converge to the same local optimum** - saspav is best for all N
2. **C++ optimizers show 0 improvement** - solutions are already at local optima
3. **Lattice-based construction is the key** - need to build solutions from scratch

I fully agree with the evaluator's assessment. The key insight is that we cannot improve pre-optimized solutions through local search - we need a fundamentally different approach.

## Key Findings from Analysis
1. **Score breakdown**: Small N (1-50) = 19.04, Medium N (51-100) = 17.64, Large N (101-200) = 33.99
2. **Large N contributes most** to total score and has room for improvement
3. **N=200 pattern**: 101 up trees, 99 down trees, mean offset dx=0.046, dy=-0.229
4. **All C++ optimizers tested** (tree_packer, tree_packer_v18, bbox3_advanced) show 0 improvement

## CRITICAL: What Must Be Done Differently

### The Problem
Pre-optimized solutions are at LOCAL OPTIMA. Running more SA/optimization on them will NOT help.
- tree_packer: 0 improvement
- tree_packer_v18: 0 improvement  
- bbox3_advanced: 0.000000003 improvement (essentially 0)
- Ensembling 20 solutions: 0 improvement

### The Solution: Lattice-Based Construction from Scratch

The egortrushin kernel shows the approach:
1. **Create a 2-tree unit cell** with trees at complementary angles (e.g., 0° and 180°)
2. **Define translation parameters** (dx, dy) for tiling the lattice
3. **Generate configurations** for each N by placing trees on the lattice
4. **Apply simulated annealing** to optimize:
   - Translation parameters (dx, dy)
   - Individual tree positions (small perturbations)
   - Rotation angles
5. **Apply backward propagation** to improve smaller N configurations

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Implement Lattice-Based Construction
From egortrushin kernel (`research/kernels/egortrushin_santa25-simulated-annealing-with-translations/`):

```python
# Key parameters from analysis:
# - 2-tree unit cell: tree1 at (0,0,0°), tree2 at (dx,dy,180°)
# - Estimated optimal: dx ≈ 0.05, dy ≈ -0.23
# - Use SA to optimize these parameters

class SimulatedAnnealing:
    def __init__(self, trees, nt, Tmax, Tmin, nsteps, ...):
        # nt = [nx, ny] - number of trees in x and y directions
        # Tmax = 0.1, Tmin = 1e-6, nsteps = 10000
        pass
    
    def perturb_tree(self, tree):
        # Small perturbations to position and angle
        pass
    
    def solve(self):
        # SA loop with geometric cooling
        pass
```

**Concrete steps:**
1. Study the egortrushin kernel's SimulatedAnnealing class
2. Implement lattice generation for N=1 to 200
3. Run SA with parameters: Tmax=0.1, Tmin=1e-6, nsteps=10000
4. Apply backward propagation
5. Validate no overlaps and submit

### 2. **[HIGH PRIORITY]** Try Different Lattice Patterns
- 2-tree unit cell (up/down) - current approach
- 3-tree unit cell (triangular pattern)
- 4-tree unit cell (square pattern)
- Different angle combinations (0°/180°, 45°/225°, etc.)

### 3. **[MEDIUM PRIORITY]** Backward Propagation Enhancement
After generating lattice solutions:
```python
for n in range(200, 1, -1):
    for tree_to_remove in range(n):
        candidate = remove_tree(solutions[n], tree_to_remove)
        if score(candidate) < score(solutions[n-1]):
            solutions[n-1] = candidate
```

## What NOT to Try
- ❌ More SA iterations on pre-optimized solutions (already at local optima)
- ❌ Different SA parameters on existing solutions (won't help)
- ❌ Ensembling more public solutions (saspav already best for all N)
- ❌ bbox3/tree_packer optimization (shows 0 improvement)

## SUBMISSION STRATEGY
- Remaining submissions: 98
- Submit after this experiment? **YES** - we have abundant submissions
- Even if lattice approach doesn't beat target, we need LB feedback to calibrate

## Validation Notes
- CV scheme: Calculate total score = Σ(s_n²/n) for n=1 to 200
- Overlap check: Use Shapely for precise collision detection
- Score should match LB exactly (no train/test split in optimization problems)

## Expected Outcome
- Lattice-based approaches can achieve scores in the 69-70 range
- With proper optimization, breaking below 69 is achievable
- The key is exploring a DIFFERENT region of solution space, not optimizing existing solutions
