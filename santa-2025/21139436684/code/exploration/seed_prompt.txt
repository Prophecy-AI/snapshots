# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (1-200 trees per configuration) into the smallest possible square bounding box. 

**Metric:** Score = Σ(side_length² / n) for n=1 to 200. Lower is better.
**Target Score:** Beat 68.922808

## Tree Geometry (CRITICAL)
The Christmas tree is a 15-vertex polygon with these dimensions:
- Trunk: 0.15 wide, 0.2 tall (bottom at y=-0.2)
- Base tier: 0.7 wide at y=0
- Middle tier: 0.4 wide at y=0.25
- Top tier: 0.25 wide at y=0.5
- Tip: at y=0.8
- Trees can be rotated 0-360 degrees

Vertex coordinates (TX, TY):
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## Submission Format
- CSV with columns: id, x, y, deg
- Values must be prefixed with 's' (e.g., "s0.123456")
- id format: "NNN_T" where NNN is tree count (001-200), T is tree index
- Coordinates constrained to -100 ≤ x, y ≤ 100
- NO OVERLAPPING TREES ALLOWED (submission will error)

## Top Approaches from Public Kernels

### 1. bbox3 Optimizer (PRIMARY APPROACH)
See `../research/kernels/jazivxt_why-not/why-not.ipynb`

The bbox3 C++ optimizer is the state-of-the-art for this competition. Key features:
- Complex number vector coordination for tree movement
- Fluid dynamics-inspired placement
- Hinge pivot rotations
- Density gradient flow
- Global boundary tension
- Aggressive overlap repair with separation vectors

**Usage:** `./bbox3 -n <iterations> -r <radius>`
- Typical parameters: n=1000-2000, r=30-90
- Longer runs with higher n values produce better results

### 2. Tree Packer v21 (Alternative C++ Optimizer)
See `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Features:
- **Swap moves:** Exchange positions of two trees
- **Multi-angle restarts:** Try different initial rotation configurations
- **Simulated annealing:** Accept worse solutions with decreasing probability
- **Squeeze operation:** Scale all trees toward center
- **Compaction:** Move individual trees toward center
- **Local search:** 8-directional movement + rotation adjustments

**Usage:** `./tree_packer_v21.exe -n <iterations> -r <radius>`
- Typical: n=5000-10000, r=16-256

### 3. Backward Propagation (POST-PROCESSING)
See `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Novel technique to propagate improvements from larger to smaller configurations:
1. Start from N=200, work down to N=2
2. For each configuration, identify boundary-touching trees
3. Try removing each boundary tree
4. If resulting (N-1) config is better than current best, save it
5. Continue removing trees until no improvement

This exploits the fact that good N-tree packings often contain good (N-1)-tree sub-packings.

### 4. Multi-Phase Optimization Strategy
See `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`

Three-phase approach:
- **Phase A:** Short 2-min runs to find promising (n, r) parameter combinations
- **Phase B:** Medium 10-min runs on top candidates  
- **Phase C:** Long 20-min runs on best few configurations

Key principle: Always keep best submission and revert on regression.

### 5. Rotation Optimization (fix_direction)
See `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

After placing trees, rotate the ENTIRE configuration to minimize bounding box:
```python
from scipy.optimize import minimize_scalar
from scipy.spatial import ConvexHull

# Get convex hull of all tree vertices
hull_points = points_np[ConvexHull(points_np).vertices]

# Find optimal rotation angle
res = minimize_scalar(
    lambda a: calculate_bbox_side_at_angle(a, hull_points),
    bounds=(0.001, 89.999), 
    method='bounded'
)
```

### 6. Greedy Placement Baseline
See `../research/kernels/inversion_santa-2025-getting-started/`

Basic greedy algorithm:
1. Place first tree at origin
2. For each new tree:
   - Start far from center at random weighted angle
   - Move toward center until collision
   - Back up until no overlap
3. Keep best of multiple random attempts

Weighted angle distribution: `abs(sin(2*angle))` - places more trees in corners.

## Key Techniques from Research

### Collision Detection
Use Shapely library with STRtree for efficient spatial queries:
```python
from shapely.strtree import STRtree
from shapely.geometry import Polygon

# Build spatial index
tree_index = STRtree(placed_polygons)

# Query nearby polygons
possible_indices = tree_index.query(candidate_poly)

# Check actual collision (intersects but NOT touches)
if candidate_poly.intersects(placed_polygons[i]) and not candidate_poly.touches(placed_polygons[i]):
    # COLLISION!
```

### Boundary Tree Identification
Trees touching the bounding box are key optimization targets:
```cpp
// Check if tree touches any boundary
bool touches = false;
if (abs(p.x0 - gx0) < eps) touches = true;  // left
if (abs(p.x1 - gx1) < eps) touches = true;  // right
if (abs(p.y0 - gy0) < eps) touches = true;  // bottom
if (abs(p.y1 - gy1) < eps) touches = true;  // top
```

### Overlap Repair
When overlaps occur, use separation vectors (MTV - Minimum Translation Vector):
1. Calculate centroid difference between overlapping polygons
2. Push apart by half the separation vector each
3. Re-validate and iterate

### Local Search Neighborhoods
From academic literature on 2D irregular packing:
1. **Swap:** Exchange positions of two trees
2. **Translate:** Move single tree to new position
3. **Rotate:** Change rotation angle of single tree
4. **Jostle:** Small random perturbations to escape local minima

### Squeeze and Compaction
```cpp
// Squeeze: Scale all trees toward center
for (scale = 0.9995; scale >= 0.98; scale -= 0.0005) {
    for (i = 0; i < n; i++) {
        trial.x[i] = cx + (c.x[i] - cx) * scale;
        trial.y[i] = cy + (c.y[i] - cy) * scale;
    }
    if (!trial.anyOvl()) c = trial;
    else break;
}

// Compaction: Move individual trees toward center
for (i = 0; i < n; i++) {
    dx = cx - x[i]; dy = cy - y[i];
    for (step : {0.02, 0.008, 0.003, 0.001}) {
        // Try moving toward center by step
        if (!hasOvl(i) && side() < best_side) accept();
    }
}
```

### Meta-heuristics
- **Simulated Annealing:** Accept worse solutions with decreasing probability
- **Tabu Search:** Avoid revisiting recent configurations
- **Genetic Algorithms:** Evolve population of solutions

## Implementation Strategy

### Recommended Pipeline
1. **Start with bbox3 or tree_packer:** Compile and run C++ optimizer
2. **Apply backward propagation:** Propagate improvements from larger configs
3. **Apply rotation optimization:** Use fix_direction to tighten bounding boxes
4. **Validate overlaps:** Check all configurations for collisions
5. **Repair if needed:** Replace invalid configurations with known-good ones
6. **Iterate:** Run multiple times with different parameters

### Parameter Tuning for bbox3
Good starting points:
- n_values: [1000, 1200, 1500, 1800, 2000]
- r_values: [30, 60, 90]

### Parameter Tuning for tree_packer
Good starting points:
- n_values: [5000, 10000]
- r_values: [16, 64, 256]

### Time Budget Allocation
For a 9-hour run:
- Phase A (exploration): 30% of time
- Phase B (refinement): 40% of time  
- Phase C (final polish): 30% of time

## Validation (CRITICAL)
Before submitting, ALWAYS validate:
1. No overlapping trees in any configuration
2. All coordinates within bounds (-100 to 100)
3. Correct submission format (s-prefixed values)

```python
def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

## Key Libraries
- shapely: Polygon geometry and collision detection
- numpy: Numerical operations
- scipy: Optimization (minimize_scalar, ConvexHull)
- decimal: High-precision arithmetic for coordinates

## Files to Reference
- `../research/kernels/jazivxt_why-not/why-not.ipynb` - bbox3 C++ source code
- `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb` - tree_packer + backward propagation
- `../research/kernels/saspav_santa-submission/santa-submission.ipynb` - fix_direction implementation
- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - Multi-phase runner
- `../research/kernels/inversion_santa-2025-getting-started/` - Basic greedy baseline

## Expected Score Improvements
- Baseline greedy: ~100+ score
- bbox3 with basic params: ~70-80 score
- bbox3 + rotation optimization: ~68-70 score
- Extended runs + backward propagation: <68 score (target)

## Critical Success Factors
1. **Use C++ optimizers:** bbox3 or tree_packer are essential for competitive scores
2. **Backward propagation:** Propagate improvements from larger to smaller configs
3. **Rotation optimization:** Always apply fix_direction after optimization
4. **Validate thoroughly:** Overlapping submissions are rejected
5. **Long runs:** More iterations = better packing
6. **Parameter exploration:** Try multiple (n, r) combinations
7. **Focus on boundary trees:** These determine the bounding box size

## Advanced Techniques
1. **Lattice patterns:** Analyze crystallization patterns in good solutions
2. **Phase analysis:** Blue (upward) vs Pink (downward) tree orientations
3. **Interlock patterns:** Study how trees nest together efficiently
4. **Multi-start:** Try different initial configurations and keep best
