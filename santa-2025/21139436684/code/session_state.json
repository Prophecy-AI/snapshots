{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T13:38:37.688248",
  "time_limit_minutes": 2100,
  "experiments": [
    {
      "id": "exp_000",
      "name": "001_bbox3_baseline",
      "model_type": "optimization",
      "score": 148.177124,
      "cv_score": 148.177124,
      "lb_score": null,
      "notes": "Baseline using Python optimizer with rotation optimization. Started from sample submission (score 173.65), applied simulated annealing local search and rotation optimization. Score improved to 148.18 but still far from target of 68.92. The Python optimizer is too slow compared to C++ bbox3. Key techniques used: 1) Rotation optimization (fix_direction) to minimize bounding box by rotating entire configuration, 2) Simulated annealing with translate/rotate/squeeze moves, 3) Aggressive squeeze toward center. Next steps: Need to implement or compile the C++ bbox3 optimizer for better results.",
      "experiment_folder": "/home/code/experiments/001_bbox3_baseline",
      "timestamp": "2026-01-19T14:13:52.266773"
    }
  ],
  "candidates": [
    {
      "file_path": "/home/code/submission_candidates/candidate_000.csv",
      "score": 148.177124,
      "cv_score": 148.177124,
      "model_name": "001_bbox3_baseline",
      "experiment_id": "exp_000",
      "timestamp": "2026-01-19T14:13:52.268146"
    }
  ],
  "submissions": [],
  "strategy_history": [
    {
      "strategy": "# Santa 2025 - Christmas Tree Packing Optimization\n\n## Problem Overview\nThis is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (1-200 trees per configuration) into the smallest possible square bounding box. \n\n**Metric:** Score = \u03a3(side_length\u00b2 / n) for n=1 to 200. Lower is better.\n**Target Score:** Beat 68.922808\n\n## Tree Geometry (CRITICAL)\nThe Christmas tree is a 15-vertex polygon with these dimensions:\n- Trunk: 0.15 wide, 0.2 tall (bottom at y=-0.2)\n- Base tier: 0.7 wide at y=0\n- Middle tier: 0.4 wide at y=0.25\n- Top tier: 0.25 wide at y=0.5\n- Tip: at y=0.8\n- Trees can be rotated 0-360 degrees\n\nVertex coordinates (TX, TY):\n```python\nTX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]\nTY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]\n```\n\n## Submission Format\n- CSV with columns: id, x, y, deg\n- Values must be prefixed with 's' (e.g., \"s0.123456\")\n- id format: \"NNN_T\" where NNN is tree count (001-200), T is tree index\n- Coordinates constrained to -100 \u2264 x, y \u2264 100\n- NO OVERLAPPING TREES ALLOWED (submission will error)\n\n## Top Approaches from Public Kernels\n\n### 1. bbox3 Optimizer (PRIMARY APPROACH)\nSee `../research/kernels/jazivxt_why-not/why-not.ipynb`\n\nThe bbox3 C++ optimizer is the state-of-the-art for this competition. Key features:\n- Complex number vector coordination for tree movement\n- Fluid dynamics-inspired placement\n- Hinge pivot rotations\n- Density gradient flow\n- Global boundary tension\n- Aggressive overlap repair with separation vectors\n\n**Usage:** `./bbox3 -n <iterations> -r <radius>`\n- Typical parameters: n=1000-2000, r=30-90\n- Longer runs with higher n values produce better results\n\n### 2. Tree Packer v21 (Alternative C++ Optimizer)\nSee `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n\nFeatures:\n- **Swap moves:** Exchange positions of two trees\n- **Multi-angle restarts:** Try different initial rotation configurations\n- **Simulated annealing:** Accept worse solutions with decreasing probability\n- **Squeeze operation:** Scale all trees toward center\n- **Compaction:** Move individual trees toward center\n- **Local search:** 8-directional movement + rotation adjustments\n\n**Usage:** `./tree_packer_v21.exe -n <iterations> -r <radius>`\n- Typical: n=5000-10000, r=16-256\n\n### 3. Backward Propagation (POST-PROCESSING)\nSee `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n\nNovel technique to propagate improvements from larger to smaller configurations:\n1. Start from N=200, work down to N=2\n2. For each configuration, identify boundary-touching trees\n3. Try removing each boundary tree\n4. If resulting (N-1) config is better than current best, save it\n5. Continue removing trees until no improvement\n\nThis exploits the fact that good N-tree packings often contain good (N-1)-tree sub-packings.\n\n### 4. Multi-Phase Optimization Strategy\nSee `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`\n\nThree-phase approach:\n- **Phase A:** Short 2-min runs to find promising (n, r) parameter combinations\n- **Phase B:** Medium 10-min runs on top candidates  \n- **Phase C:** Long 20-min runs on best few configurations\n\nKey principle: Always keep best submission and revert on regression.\n\n### 5. Rotation Optimization (fix_direction)\nSee `../research/kernels/saspav_santa-submission/santa-submission.ipynb`\n\nAfter placing trees, rotate the ENTIRE configuration to minimize bounding box:\n```python\nfrom scipy.optimize import minimize_scalar\nfrom scipy.spatial import ConvexHull\n\n# Get convex hull of all tree vertices\nhull_points = points_np[ConvexHull(points_np).vertices]\n\n# Find optimal rotation angle\nres = minimize_scalar(\n    lambda a: calculate_bbox_side_at_angle(a, hull_points),\n    bounds=(0.001, 89.999), \n    method='bounded'\n)\n```\n\n### 6. Greedy Placement Baseline\nSee `../research/kernels/inversion_santa-2025-getting-started/`\n\nBasic greedy algorithm:\n1. Place first tree at origin\n2. For each new tree:\n   - Start far from center at random weighted angle\n   - Move toward center until collision\n   - Back up until no overlap\n3. Keep best of multiple random attempts\n\nWeighted angle distribution: `abs(sin(2*angle))` - places more trees in corners.\n\n## Key Techniques from Research\n\n### Collision Detection\nUse Shapely library with STRtree for efficient spatial queries:\n```python\nfrom shapely.strtree import STRtree\nfrom shapely.geometry import Polygon\n\n# Build spatial index\ntree_index = STRtree(placed_polygons)\n\n# Query nearby polygons\npossible_indices = tree_index.query(candidate_poly)\n\n# Check actual collision (intersects but NOT touches)\nif candidate_poly.intersects(placed_polygons[i]) and not candidate_poly.touches(placed_polygons[i]):\n    # COLLISION!\n```\n\n### Boundary Tree Identification\nTrees touching the bounding box are key optimization targets:\n```cpp\n// Check if tree touches any boundary\nbool touches = false;\nif (abs(p.x0 - gx0) < eps) touches = true;  // left\nif (abs(p.x1 - gx1) < eps) touches = true;  // right\nif (abs(p.y0 - gy0) < eps) touches = true;  // bottom\nif (abs(p.y1 - gy1) < eps) touches = true;  // top\n```\n\n### Overlap Repair\nWhen overlaps occur, use separation vectors (MTV - Minimum Translation Vector):\n1. Calculate centroid difference between overlapping polygons\n2. Push apart by half the separation vector each\n3. Re-validate and iterate\n\n### Local Search Neighborhoods\nFrom academic literature on 2D irregular packing:\n1. **Swap:** Exchange positions of two trees\n2. **Translate:** Move single tree to new position\n3. **Rotate:** Change rotation angle of single tree\n4. **Jostle:** Small random perturbations to escape local minima\n\n### Squeeze and Compaction\n```cpp\n// Squeeze: Scale all trees toward center\nfor (scale = 0.9995; scale >= 0.98; scale -= 0.0005) {\n    for (i = 0; i < n; i++) {\n        trial.x[i] = cx + (c.x[i] - cx) * scale;\n        trial.y[i] = cy + (c.y[i] - cy) * scale;\n    }\n    if (!trial.anyOvl()) c = trial;\n    else break;\n}\n\n// Compaction: Move individual trees toward center\nfor (i = 0; i < n; i++) {\n    dx = cx - x[i]; dy = cy - y[i];\n    for (step : {0.02, 0.008, 0.003, 0.001}) {\n        // Try moving toward center by step\n        if (!hasOvl(i) && side() < best_side) accept();\n    }\n}\n```\n\n### Meta-heuristics\n- **Simulated Annealing:** Accept worse solutions with decreasing probability\n- **Tabu Search:** Avoid revisiting recent configurations\n- **Genetic Algorithms:** Evolve population of solutions\n\n## Implementation Strategy\n\n### Recommended Pipeline\n1. **Start with bbox3 or tree_packer:** Compile and run C++ optimizer\n2. **Apply backward propagation:** Propagate improvements from larger configs\n3. **Apply rotation optimization:** Use fix_direction to tighten bounding boxes\n4. **Validate overlaps:** Check all configurations for collisions\n5. **Repair if needed:** Replace invalid configurations with known-good ones\n6. **Iterate:** Run multiple times with different parameters\n\n### Parameter Tuning for bbox3\nGood starting points:\n- n_values: [1000, 1200, 1500, 1800, 2000]\n- r_values: [30, 60, 90]\n\n### Parameter Tuning for tree_packer\nGood starting points:\n- n_values: [5000, 10000]\n- r_values: [16, 64, 256]\n\n### Time Budget Allocation\nFor a 9-hour run:\n- Phase A (exploration): 30% of time\n- Phase B (refinement): 40% of time  \n- Phase C (final polish): 30% of time\n\n## Validation (CRITICAL)\nBefore submitting, ALWAYS validate:\n1. No overlapping trees in any configuration\n2. All coordinates within bounds (-100 to 100)\n3. Correct submission format (s-prefixed values)\n\n```python\ndef has_overlap(trees):\n    polygons = [t.polygon for t in trees]\n    tree_index = STRtree(polygons)\n    for i, poly in enumerate(polygons):\n        indices = tree_index.query(poly)\n        for idx in indices:\n            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):\n                return True\n    return False\n```\n\n## Key Libraries\n- shapely: Polygon geometry and collision detection\n- numpy: Numerical operations\n- scipy: Optimization (minimize_scalar, ConvexHull)\n- decimal: High-precision arithmetic for coordinates\n\n## Files to Reference\n- `../research/kernels/jazivxt_why-not/why-not.ipynb` - bbox3 C++ source code\n- `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb` - tree_packer + backward propagation\n- `../research/kernels/saspav_santa-submission/santa-submission.ipynb` - fix_direction implementation\n- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - Multi-phase runner\n- `../research/kernels/inversion_santa-2025-getting-started/` - Basic greedy baseline\n\n## Expected Score Improvements\n- Baseline greedy: ~100+ score\n- bbox3 with basic params: ~70-80 score\n- bbox3 + rotation optimization: ~68-70 score\n- Extended runs + backward propagation: <68 score (target)\n\n## Critical Success Factors\n1. **Use C++ optimizers:** bbox3 or tree_packer are essential for competitive scores\n2. **Backward propagation:** Propagate improvements from larger to smaller configs\n3. **Rotation optimization:** Always apply fix_direction after optimization\n4. **Validate thoroughly:** Overlapping submissions are rejected\n5. **Long runs:** More iterations = better packing\n6. **Parameter exploration:** Try multiple (n, r) combinations\n7. **Focus on boundary trees:** These determine the bounding box size\n\n## Advanced Techniques\n1. **Lattice patterns:** Analyze crystallization patterns in good solutions\n2. **Phase analysis:** Blue (upward) vs Pink (downward) tree orientations\n3. **Interlock patterns:** Study how trees nest together efficiently\n4. **Multi-start:** Try different initial configurations and keep best\n",
      "agent": "explorer",
      "timestamp": "2026-01-19T13:44:40.970213"
    }
  ],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D packing optimization problem: fit Christmas tree-shaped polygons into the smallest square box for configurations of 1-200 trees. Score = sum of (side_length^2 / n) for all n. Lower is better.",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "The tree shape is a 15-vertex polygon with specific dimensions: trunk (0.15 wide, 0.2 tall), base tier (0.7 wide), middle tier (0.4 wide), top tier (0.25 wide), tip at y=0.8. Trees can be rotated 0-360 degrees.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Key optimizer: bbox3 - a C++ program using complex number vector coordination, fluid dynamics-inspired movement, hinge pivot, density gradient flow, and global boundary tension. Run with parameters -n (iterations) and -r (radius/range).",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Rotation optimization: After placing trees, rotate the entire configuration to minimize bounding box side length. Uses scipy.optimize.minimize_scalar with bounds (0.001, 89.999) on convex hull points.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Overlap detection uses Shapely library with STRtree for efficient spatial queries. Collision = intersects but not touches. Must validate no overlaps before submission.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Multi-phase optimization strategy: Phase A (short 2-min runs to find promising n,r params), Phase B (10-min runs on top candidates), Phase C (20-min long runs on best few). Always keep best submission and revert on regression.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Backward Propagation technique: Start from N=200 and work down to N=2. For each configuration, try removing boundary-touching trees and check if the resulting (N-1) configuration is better than the current best. This propagates improvements from larger to smaller configurations.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Tree Packer v21 features: Swap moves (exchange two trees), multi-angle restarts, higher temperature simulated annealing, squeeze operation (scale toward center), compaction (move trees toward center), and local search with 8-directional movement + rotation.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Boundary tree identification: Trees that touch the bounding box boundary are the key targets for optimization. Check if tree's x0/x1/y0/y1 aligns with global gx0/gx1/gy0/gy1 within epsilon.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization problems?",
      "finding": "Two\u2011dimensional irregular polygon packing is a combinatorial optimisation problem that appears in sheet\u2011metal cutting, textile layout, ship\u2011building and many other manufacturing processes.  Because the shapes are non\u2011convex and may be rotated arbitrarily, exact methods (e.g., branch\u2011and\u2011bound or mixed\u2011integer programming) are only feasible for very small instances, so most practical solvers rely on heuristics, meta\u2011heuristics or approximation algorithms that can explore the huge search space efficiently\u202f([Frontiers](https://www.frontiersin.org/articles/10.3389/fmech.2022.966691/full)).\n\nAmong the most successful approaches are:  \n\n* **Approximation algorithms with provable guarantees** for convex polygons that use height\u2011sorted shelf packing and achieve improved constant\u2011factor bounds (e.g., the polynomial\u2011time schemes of Kurpisz & Suter 2023)\u202f([arXiv](https://export.arxiv.org/pdf/2308.08523v1.pdf)).  \n* **Heuristic placement rules** such as the Bottom\u2011Left (BL) and Bottom\u2011Left\u2011Fill st",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 95
}