{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T13:38:37.688248",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D packing optimization problem: fit Christmas tree-shaped polygons into the smallest square box for configurations of 1-200 trees. Score = sum of (side_length^2 / n) for all n. Lower is better.",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "The tree shape is a 15-vertex polygon with specific dimensions: trunk (0.15 wide, 0.2 tall), base tier (0.7 wide), middle tier (0.4 wide), top tier (0.25 wide), tip at y=0.8. Trees can be rotated 0-360 degrees.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Key optimizer: bbox3 - a C++ program using complex number vector coordination, fluid dynamics-inspired movement, hinge pivot, density gradient flow, and global boundary tension. Run with parameters -n (iterations) and -r (radius/range).",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Rotation optimization: After placing trees, rotate the entire configuration to minimize bounding box side length. Uses scipy.optimize.minimize_scalar with bounds (0.001, 89.999) on convex hull points.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Overlap detection uses Shapely library with STRtree for efficient spatial queries. Collision = intersects but not touches. Must validate no overlaps before submission.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Multi-phase optimization strategy: Phase A (short 2-min runs to find promising n,r params), Phase B (10-min runs on top candidates), Phase C (20-min long runs on best few). Always keep best submission and revert on regression.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization problems?",
      "finding": "Two\u2011dimensional irregular polygon packing is a combinatorial optimisation problem that appears in sheet\u2011metal cutting, textile layout, ship\u2011building and many other manufacturing processes.  Because the shapes are non\u2011convex and may be rotated arbitrarily, exact methods (e.g., branch\u2011and\u2011bound or mixed\u2011integer programming) are only feasible for very small instances, so most practical solvers rely on heuristics, meta\u2011heuristics or approximation algorithms that can explore the huge search space efficiently\u202f([Frontiers](https://www.frontiersin.org/articles/10.3389/fmech.2022.966691/full)).\n\nAmong the most successful approaches are:  \n\n* **Approximation algorithms with provable guarantees** for convex polygons that use height\u2011sorted shelf packing and achieve improved constant\u2011factor bounds (e.g., the polynomial\u2011time schemes of Kurpisz & Suter 2023)\u202f([arXiv](https://export.arxiv.org/pdf/2308.08523v1.pdf)).  \n* **Heuristic placement rules** such as the Bottom\u2011Left (BL) and Bottom\u2011Left\u2011Fill st",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 95
}