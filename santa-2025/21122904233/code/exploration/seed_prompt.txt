# Santa 2025 - Seed Prompt

## Goal
Beat the target score of **68.922808**.
The problem is a 2D packing problem: pack `n` Christmas trees (specific polygon shape) into the smallest square box for each `n` from 1 to 200.
Metric: Sum of `s_n^2 / n` where `s_n` is the side length.

## Core Strategy: C++ Optimization
The top public kernels use a high-performance C++ optimizer (Simulated Annealing + Local Search) coupled with a "Backward Propagation" technique.
**Do not attempt to write a Python optimizer from scratch.** It will be too slow.

### Step 1: Setup & Code Extraction
1. **Fetch the Source Code:**
   The best optimizer is in the kernel `smartmanoj/santa-claude`.
   Run this Python script to extract the C++ files (`tree_packer.cpp` and `bp.cpp`):

```python
import json
import os
# You must fetch the kernel first: default_api.FetchKernel(ref='smartmanoj/santa-claude')
notebook_path = '../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb'

with open(notebook_path, 'r') as f:
    nb = json.load(f)

for cell in nb['cells']:
    if cell['cell_type'] == 'code':
        source = ''.join(cell['source'])
        if '%%writefile a.cpp' in source:
            content = source.replace('%%writefile a.cpp\n', '')
            with open('tree_packer.cpp', 'w') as f_out:
                f_out.write(content)
            print("Extracted tree_packer.cpp")
        if '%%writefile bp.cpp' in source:
            content = source.replace('%%writefile bp.cpp\n', '')
            with open('bp.cpp', 'w') as f_out:
                f_out.write(content)
            print("Extracted bp.cpp")
```

2. **Compile the Code:**
   ```bash
   g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer.cpp
   g++ -O3 -std=c++17 -o bp bp.cpp
   ```

### Step 2: Initialization
Start with the provided sample submission or a greedy baseline.
```bash
cp /home/data/sample_submission.csv submission.csv
```

### Step 3: Optimization Loop
Run the optimizer and backward propagation in a loop.
`tree_packer` improves the packing for each `N`.
`bp` (Backward Propagation) tries to improve `N-1` by removing a tree from `N`.

**Command:**
```bash
# Run tree_packer (adjust -n iterations and -r restarts as needed)
# Start with lower values for quick checks, increase for final run
./tree_packer -i submission.csv -o submission_opt.csv -n 5000 -r 16

# Run Backward Propagation
./bp submission_opt.csv submission.csv
```

Repeat this loop. The score should decrease.

### Step 4: Validation
Always validate the result using the Python geometry logic to ensure no overlaps.
Use the `score_and_validate_submission` function from `../research/kernels/saspav_santa-submission/santa-submission.ipynb` (or implement it using `shapely`).

## Alternative/Complementary Techniques
- **Greedy Construction:** See `../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb`. Useful for generating a fresh start if the sample submission is stuck in a local optimum.
- **Rotation Optimization:** The `fix_direction` function in `saspav_santa-submission` can fine-tune rotations.
- **Ensembling:** Run `tree_packer` with different random seeds (it uses `std::mt19937`) and combine the best `N` configurations from each run.

## Key Data Findings
- The trees are non-convex polygons.
- `N` ranges from 1 to 200.
- Metric is sum of squares, so larger `N` (which have larger `s`) contribute significantly. However, `s^2/n` tends to be somewhat constant, so all `N` matter.
- Overlaps are strictly forbidden.

## Recommended Experiment Plan
1. **Baseline:** Run `tree_packer` on `sample_submission.csv` for 5 minutes. Verify score improvement.
2. **Scale Up:** Run with more iterations (`-n 50000`) and restarts (`-r 64`).
3. **Loop:** Implement the `tree_packer` -> `bp` -> `tree_packer` loop.
4. **Ensemble:** Run 3 parallel experiments with different seeds, then merge the best `N`s.

**Note:** If `tree_packer` fails to compile or run, debug the C++ code. It is the key to winning.
