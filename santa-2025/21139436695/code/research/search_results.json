{
  "query": "What are the best techniques for minimizing bounding box area when packing non-convex polygons?",
  "results": [
    {
      "title": "ANSWER",
      "text": "Minimizing the area of a bounding box for a non\u2011convex polygon is usually tackled by first reducing the shape to its convex hull, because the smallest\u2011area enclosing rectangle must also enclose the hull\u202f\u2013\u202fthe optimal rectangle will have at least one side collinear with an edge of the hull\u202f([wikipedia](https://en.wikipedia.org/wiki/Minimum_bounding_box_algorithms)). Once the convex hull is obtained (in \\(O(n\\log n)\\) time for a general polygon), the **rotating\u2011calipers** method can be applied to examine all candidate orientations in linear time, yielding the exact oriented minimum\u2011area bounding rectangle ([grokipedia](https://grokipedia.com/page/Minimum_bounding_box_algorithms); [blog](https://geidav.wordpress.com/2014/01/23/computing-oriented-minimum-bounding-boxes-in-2d)). This two\u2011step pipeline (convex\u2011hull\u202f\u2192\u202frotating calipers) is the most reliable exact technique and is widely used in computational geometry and graphics.\n\nWhen many non\u2011convex pieces must be packed together, exact minimization becomes computationally prohibitive, so practitioners turn to **approximation and heuristic schemes**. Near\u2011linear \\((1+\\varepsilon)\\)-approximation algorithms compute an almost\u2011optimal oriented box by sampling a limited set of orientations after the hull step, offering a practical trade\u2011off between speed and quality ([grokipedia](https://grokipedia.com/page/Minimum_bounding_box_algorithms)). For multi\u2011polygon packing, recent work on **shelf\u2011packing** and **height\u2011sorted placement** extends the rotating\u2011calipers insight: polygons are first transformed (often decomposed into convex components), sorted by height or a chosen orientation, and then placed on horizontal shelves, achieving improved area guarantees for translational packing ([arxiv\u202f2023](https://export.arxiv.org/pdf/2308.08523v1.pdf)). More exact formulations use **mixed\u2011integer programming** with vertical slice variables to model irregular strip packing, allowing optimal solutions for modest instance sizes at the cost of higher computational effort ([arxiv\u202f2022](https://arxiv.org/pdf/2206.00032)).  \n\nIn practice, the workflow that yields the best results is: (1) compute the convex hull of each non\u2011convex polygon, (2) obtain its oriented minimum\u2011area rectangle via rotating calipers, (3) optionally apply a \\((1+\\varepsilon)\\) orientation sampling if speed is critical, and (4) pack the resulting rectangles using shelf\u2011based heuristics or, when optimality is required, a mixed\u2011integer model that respects the original polygon geometry. This combination balances exactness for individual pieces with scalable heuristics for the overall packing problem.",
      "url": ""
    },
    {
      "title": "Minimum bounding box algorithms - Wikipedia",
      "text": "Minimum bounding box algorithms - Wikipedia\n[Jump to content](#bodyContent)\n[![](https://en.wikipedia.org/static/images/icons/wikipedia.png)![Wikipedia](https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg)![The Free Encyclopedia](https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg)](https://en.wikipedia.org/wiki/Main_Page)\n[Search](https://en.wikipedia.org/wiki/Special:Search)\nSearch\n# Minimum bounding box algorithms\nAdd languages\n[Add links](https://www.wikidata.org/wiki/Special:EntityPage/Q6865427#sitelinks-wikipedia)\nFrom Wikipedia, the free encyclopedia\nAlgorithms in computational geometry\nIn[computational geometry](https://en.wikipedia.org/wiki/Computational_geometry), the**smallest enclosing box**problem is that of finding the[oriented minimum bounding box](https://en.wikipedia.org/wiki/Minimum_bounding_box#Arbitrarily_oriented_minimum_bounding_box)enclosing a set of points. It is a type of[bounding volume](https://en.wikipedia.org/wiki/Bounding_volume). \"Smallest\" may refer to[volume](https://en.wikipedia.org/wiki/Volume),[area](https://en.wikipedia.org/wiki/Area),[perimeter](https://en.wikipedia.org/wiki/Perimeter),*etc.*of the box.\nIt is sufficient to find the smallest enclosing box for the[convex hull](https://en.wikipedia.org/wiki/Convex_hull)of the objects in question. It is straightforward to find the smallest enclosing box that has sides parallel to the coordinate axes; the difficult part of the problem is to determine the orientation of the box.\n## Two dimensions\n[[edit](https://en.wikipedia.org/w/index.php?title=Minimum_bounding_box_algorithms&amp;action=edit&amp;section=1)]\nFor the[convex polygon](https://en.wikipedia.org/wiki/Convex_polygon), a[linear time](https://en.wikipedia.org/wiki/Linear_time)algorithm for the**minimum-area enclosing rectangle**is known. It is based on the observation that a side of a minimum-area enclosing box must be colinear with a side of the convex polygon.[&#91;1&#93;](#cite_note-1)It is possible to enumerate boxes of this kind in linear time with the approach called[rotating calipers](https://en.wikipedia.org/wiki/Rotating_calipers)by[Godfried Toussaint](https://en.wikipedia.org/wiki/Godfried_Toussaint)in 1983.[&#91;2&#93;](#cite_note-tous83-2)The same approach is applicable for finding the**minimum-perimeter enclosing rectangle**.[&#91;2&#93;](#cite_note-tous83-2)A C++ implementation of the algorithm that is robust against floating point errors is available.[&#91;3&#93;](#cite_note-3)\n## Three dimensions\n[[edit](https://en.wikipedia.org/w/index.php?title=Minimum_bounding_box_algorithms&amp;action=edit&amp;section=2)]\nIn 1985,[Joseph O'Rourke](https://en.wikipedia.org/wiki/Joseph_O'Rourke_(professor))published a cubic-time algorithm to find the minimum-volume enclosing box of a 3-dimensional point set. O'Rourke's approach uses a 3-dimensional rotating calipers technique, and is based on lemmas characterizing the minimum enclosing box:\n* There must exist two neighbouring faces of the smallest-volume enclosing box which both contain an edge of the convex hull of the point set. This criterion is satisfied by a single convex hull edge collinear with an edge of the box, or by two distinct hull edges lying in adjacent box faces.\n* The other four faces need only contain a point of the convex hull. Again, the points which they contain need not be distinct: a single hull point lying in the corner of the box already satisfies three of these four criteria.\nIt follows in the most general case where no convex hull vertices lie in edges of the minimal enclosing box, that at least 8 convex hull points must lie within faces of the box: two endpoints of each of the two edges, and four more points, one for each of the remaining four box faces. Conversely, if the convex hull consists of 7 or fewer vertices, at least one of them must lie within an edge of the hull's minimal enclosing box.[&#91;4&#93;](#cite_note-4)\nIt is also possible to approximate the minimum bounding box volume, to within any constant factor greater than one, in[linear time](https://en.wikipedia.org/wiki/Linear_time). The algorithm for doing this involves finding an approximation to the diameter of the point set, and using a box oriented towards this diameter as an initial approximation to the minimum volume bounding box. Then, this initial bounding box is partitioned into a grid of smaller cubes, and grid points near the boundary of the[convex hull](https://en.wikipedia.org/wiki/Convex_hull)of the input are used as a[coreset](https://en.wikipedia.org/wiki/Coreset), a small set of points whose optimum bounding box approximates the optimum bounding box of the original input. Finally, O'Rourke's algorithm is applied to find the exact optimum bounding box of this coreset.[&#91;5&#93;](#cite_note-5)\nA Matlab implementation of the algorithm is available.[&#91;6&#93;](#cite_note-6)\n[![](https://upload.wikimedia.org/wikipedia/commons/7/7f/Tetraeder_animation_with_cube.gif)](https://en.wikipedia.org/wiki/File:Tetraeder_animation_with_cube.gif)The minimum bounding box of a regular tetrahedron\nThe minimal enclosing box of the[regular tetrahedron](https://en.wikipedia.org/wiki/Regular_tetrahedron)is a cube with side length12{\\\\displaystyle {\\\\frac {1}{\\\\sqrt {2}}}}![{\\displaystyle {\\frac {1}{\\sqrt {2}}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/db5f73af5805a28d23fa6782b4199ff31aa108ee)that of the tetrahedron; for instance, a regular tetrahedron with side length2{\\\\displaystyle {\\\\sqrt {2}}}![{\\displaystyle {\\sqrt {2}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b4afc1e27d418021bf10898eb44a7f5f315735ff)fits into a[unit cube](https://en.wikipedia.org/wiki/Unit_cube), with the tetrahedron's vertices lying at the vertices (0,0,0), (0,1,1), (1,0,1) and (1,1,0) of the unit cube.[&#91;7&#93;](#cite_note-7)\n## See also\n[[edit](https://en.wikipedia.org/w/index.php?title=Minimum_bounding_box_algorithms&amp;action=edit&amp;section=3)]\n* [Smallest enclosing ball](https://en.wikipedia.org/wiki/Smallest_enclosing_ball)\n* [Minimum bounding rectangle](https://en.wikipedia.org/wiki/Minimum_bounding_rectangle)\n## References\n[[edit](https://en.wikipedia.org/w/index.php?title=Minimum_bounding_box_algorithms&amp;action=edit&amp;section=4)]\n1. **[^](#cite_ref-1)**[> Freeman, H.\n](https://en.wikipedia.org/wiki/Herbert_Freeman)> ; Shapira, R. (1975), \"Determining the minimum-area encasing rectangle for an arbitrary closed curve\", *[> Communications of the ACM\n](https://en.wikipedia.org/wiki/Communications_of_the_ACM)*> , **> 18\n**> (7): > 409\u2013\n> 413, [> doi\n](https://en.wikipedia.org/wiki/Doi_(identifier))> :\n[> 10.1145/360881.360919\n](https://doi.org/10.1145/360881.360919)> , [> MR\n](https://en.wikipedia.org/wiki/MR_(identifier))> &#160;\n[> 0375828\n](https://mathscinet.ams.org/mathscinet-getitem?mr=0375828)> , [> S2CID\n](https://en.wikipedia.org/wiki/S2CID_(identifier))> &#160;\n[> 2079688\n](https://api.semanticscholar.org/CorpusID:2079688).\n2. ^[***a***](#cite_ref-tous83_2-0)[***b***](#cite_ref-tous83_2-1)[> Toussaint, G. T\n](https://en.wikipedia.org/wiki/Godfried_Toussaint)> (1983), [> \"Solving geometric problems with the rotating calipers\"\n](https://web.cs.swarthmore.edu/~adanner/cs97/s08/pdf/calipers.pdf)> > (PDF)\n> , *> Proc. MELECON '83, Athens\n*.\n3. **[^](#cite_ref-3)**Eberly, D. (2015),[\"Minimum-area rectangle containing a set of points\"](https://www.geometrictools.com/Documentation/MinimumAreaRectangle.pdf),*Geometric Tools, LLC*.\n4. **[^](#cite_ref-4)**[> O'Rourke, Joseph\n](https://en.wikipedia.org/wiki/Joseph_O'Rourke_(professor))> (1985), \"Finding minimal enclosing boxes\", *> International Journal of Computer and Information Sciences\n*> , **> 14\n**> (3): > 183\u2013\n> 199, [> doi\n](https://en.wikipedia.org/wiki/Doi_(identifier))> :\n[> 10.1007/BF00991005\n](https://doi.org/10.1007/BF00991005)> , [> MR\n](https://en.wikipedia.org/wiki/MR_(identifier))> &#160;\n[> 0824371\n](https://mathscinet.ams....",
      "url": "https://en.wikipedia.org/wiki/Minimum_bounding_box_algorithms"
    },
    {
      "title": "Minimum bounding box algorithms - Grokipedia",
      "text": "<div><article>\n<span>Minimum bounding box algorithms, also known as smallest enclosing box algorithms, are a class of methods in <a href=\"https://grokipedia.com/page/Computational_geometry\">computational geometry</a> that determine the oriented or axis-aligned box of minimal volume (or area in <a href=\"https://grokipedia.com/page/2D\">2D</a>) enclosing a given set of points, <a href=\"https://grokipedia.com/page/Polygon\">polygon</a>, or <a href=\"https://grokipedia.com/page/Solid\">solid</a> object.<sup>[1]</sup> These algorithms address the smallest enclosing box problem by optimizing the box's dimensions and orientation to tightly bound the input data while minimizing wasted space.<sup>[2]</sup></span>\n<span>In two dimensions, the problem focuses on finding the minimum-area bounding rectangle for a convex polygon, which can be solved exactly in linear time, O(n), using the rotating calipers technique.<sup>[3]</sup> This method relies on the key property that the optimal rectangle has at least one side collinear with an edge of the convex hull, allowing the algorithm to iteratively rotate pairs of parallel support lines around the hull while computing candidate rectangle areas in constant time per step.<sup>[3]</sup> For non-convex polygons or point sets, the convex hull is first computed in O(n log n) time, after which the rotating calipers apply.<sup>[3]</sup></span>\n<span>In three dimensions, computing the exact minimum-volume bounding box for a point set is more complex, with Joseph O'Rourke's 1985 algorithm achieving O(n\u00b3) time using a 3D extension of <a href=\"https://grokipedia.com/page/Rotating_calipers\">rotating calipers</a> on the <a href=\"https://grokipedia.com/page/Convex_hull\">convex hull</a>.<sup>[1]</sup> Due to this cubic complexity, approximation algorithms are often preferred for large inputs; for instance, (1 + \u03b5)-approximations can be computed in near-linear time, such as O(n log n + n/\u03b5\u00b3), by sampling and optimizing over candidate orientations.<sup>[1]</sup> For arbitrary solids, voxel-based or decomposition approaches simplify the search by reducing it to bounding boxes of component faces or projections.<sup>[4]</sup></span>\n<span>These algorithms find broad applications in fields requiring efficient spatial representation and querying, including <a href=\"https://grokipedia.com/page/Collision_detection\">collision detection</a> and visibility culling in <a href=\"https://grokipedia.com/page/Computer_graphics\">computer graphics</a>, range-search data structures in statistics, <a href=\"https://grokipedia.com/page/Rapid_prototyping\">rapid prototyping</a> in <a href=\"https://grokipedia.com/page/Manufacturing\">manufacturing</a>, and optimal packing or layout in <a href=\"https://grokipedia.com/page/Industrial_design\">industrial design</a>.<sup>[1]</sup><sup>[4]</sup><sup>[5]</sup></span>\n<h2>Introduction and Definitions</h2>\n<h3>Problem Statement</h3>\n<span>The minimum bounding box problem in <a href=\"https://grokipedia.com/page/Computational_geometry\">computational geometry</a> seeks to identify the box of smallest measure that encloses a <a href=\"https://grokipedia.com/page/Finite_set\">finite set</a> of points in <a href=\"https://grokipedia.com/page/Euclidean_space\">Euclidean space</a>, where the measure is typically volume in three or more dimensions, area in two dimensions, or perimeter as an alternative objective in lower dimensions.<sup>[6]</sup> This box is defined under the <a href=\"https://grokipedia.com/page/Euclidean_distance\">Euclidean distance</a> metric, which uses the L2 norm to quantify distances between points, ensuring the enclosure aligns with standard geometric properties in <span><span></span></span>.<sup>[7]</sup> Computations often rely on the <a href=\"https://grokipedia.com/page/Convex_hull\">convex hull</a> of the input points, defined as the smallest <a href=\"https://grokipedia.com/page/Convex_set\">convex set</a> containing all points, which serves as a simplified <a href=\"https://grokipedia.com/page/Representation\">representation</a> since any enclosing box for the full set must also enclose the hull; this holds particularly for non-collinear point configurations where the hull reduces redundancy.<sup>[7]</sup></span>\n<span>The origins of this problem trace to early investigations into bounding enclosures, with <a href=\"https://grokipedia.com/page/Freeman\">Freeman</a> and Shapira's 1975 work establishing a foundational approach for determining the minimum-area encasing <a href=\"https://grokipedia.com/page/Rectangle\">rectangle</a> around an arbitrary closed <a href=\"https://grokipedia.com/page/Curve\">curve</a> in the plane.<sup>[8]</sup> Their method emphasized the geometric constraints of such enclosures, influencing the field's progression toward more general oriented bounding structures in <a href=\"https://grokipedia.com/page/Computational_geometry\">computational geometry</a> during the late <a href=\"https://grokipedia.com/page/1970s\">1970s</a> and <a href=\"https://grokipedia.com/page/1980s\">1980s</a>.<sup>[6]</sup></span>\n<span>Variants of the problem arise from different optimization criteria and input formats: in two dimensions, objectives may minimize either area or perimeter of the <a href=\"https://grokipedia.com/page/Rectangle\">rectangle</a>; in three dimensions, the focus shifts to <a href=\"https://grokipedia.com/page/Volume\">volume</a> minimization for boxes.<sup>[6]</sup> Inputs can be raw point sets or polygonal representations, where polygons are treated via their vertices, allowing uniform handling across formats while preserving the enclosure requirements.<sup>[8]</sup></span>\n<h3>Types of Bounding Boxes</h3>\n<span>Bounding boxes, used to enclose point sets or geometric objects in <a href=\"https://grokipedia.com/page/Computational_geometry\">computational geometry</a>, are categorized primarily by their alignment with respect to the coordinate axes and any imposed constraints on <a href=\"https://grokipedia.com/page/Orientation\">orientation</a> or <a href=\"https://grokipedia.com/page/Shape\">shape</a>. These classifications distinguish between exact enclosures that achieve the minimal <a href=\"https://grokipedia.com/page/Volume\">volume</a> or area and approximate variants that trade optimality for computational efficiency. The choice of bounding box type influences both the tightness of the enclosure and the <a href=\"https://grokipedia.com/page/Complexity\">complexity</a> of its <a href=\"https://grokipedia.com/page/Computation\">computation</a>.</span>\n<span>The axis-aligned bounding <a href=\"https://grokipedia.com/page/Box\">box</a> (AABB) is the most straightforward type, featuring sides <a href=\"https://grokipedia.com/page/Parallel\">parallel</a> to the coordinate axes. It is defined by the minimum and maximum extents of <a href=\"https://grokipedia.com/page/The_Points\">the points</a> along each axis, resulting in a <a href=\"https://grokipedia.com/page/Box\">box</a> that fully contains the set with no <a href=\"https://grokipedia.com/page/Rotation\">rotation</a> applied.<sup>[9]</sup> This <a href=\"https://grokipedia.com/page/Construction\">construction</a> leverages the L<span><span></span></span> <a href=\"https://grokipedia.com/page/Norm\">norm</a> in the <a href=\"https://grokipedia.com/page/Standard\">standard</a> <a href=\"https://grokipedia.com/page/Coordinate_system\">coordinate system</a>, where the <a href=\"https://grokipedia.com/page/Box\">box</a> represents the smallest aligned <a href=\"https://grokipedia.com/page/Interval\">interval</a> product enclosing <a href=\"https://grokipedia.com/page/The_Points\">the points</a>.<sup>[10]</sup> AABBs are particularly advantageous for their simplicity, enabling rapid computation in linear time relative to the number of points.<sup>[11]</sup></span>\n<span>In contrast, the oriented bounding box (OBB) permits arbitrary rotation of the box to align more closely with the principal directions of the enclosed <a href=\"https://grokipedia.com/page/Geometry\">geometry</a>, of...",
      "url": "https://grokipedia.com/page/Minimum_bounding_box_algorithms"
    },
    {
      "title": "Minimum bounding box - Wikipedia",
      "text": "Minimum bounding box - Wikipedia\n[Jump to content](#bodyContent)\n[![](https://en.wikipedia.org/static/images/icons/wikipedia.png)![Wikipedia](https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg)![The Free Encyclopedia](https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg)](https://en.wikipedia.org/wiki/Main_Page)\n[Search](https://en.wikipedia.org/wiki/Special:Search)\nSearch\n# Minimum bounding box\n8 languages\n* [\u0627\u0644\u0639\u0631\u0628\u064a\u0629](https://ar.wikipedia.org/wiki/\u0625\u0637\u0627\u0631_\u0627\u0644\u062a\u062d\u062f\u064a\u062f_\u0627\u0644\u0623\u0635\u063a\u0631)\n* [Espa\u00f1ol](https://es.wikipedia.org/wiki/Caja_delimitadora)\n* [\u0641\u0627\u0631\u0633\u06cc](https://fa.wikipedia.org/wiki/\u06a9\u0648\u0686\u06a9\u200c\u062a\u0631\u06cc\u0646_\u062c\u0639\u0628\u0647_\u0641\u0631\u0627\u06af\u06cc\u0631)\n* [Italiano](https://it.wikipedia.org/wiki/Bounding_box)\n* [Portugu\u00eas](https://pt.wikipedia.org/wiki/Caixa_delimitadora_m\u00ednima)\n* [\u0420\u0443\u0441\u0441\u043a\u0438\u0439](https://ru.wikipedia.org/wiki/AABB)\n* [\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430](https://uk.wikipedia.org/wiki/\u041c\u0456\u043d\u0456\u043c\u0430\u043b\u044c\u043d\u0430_\u043e\u0431\u043c\u0435\u0436\u0443\u0432\u0430\u043b\u044c\u043d\u0430_\u043a\u043e\u0440\u043e\u0431\u043a\u0430)\n* [\u7cb5\u8a9e](https://zh-yue.wikipedia.org/wiki/\u6700\u7d30\u5305\u570d\u6846)\n[Edit links](https://www.wikidata.org/wiki/Special:EntityPage/Q6865426#sitelinks-wikipedia)\nFrom Wikipedia, the free encyclopedia\nSmallest box which encloses some set of points\n[![](https://upload.wikimedia.org/wikipedia/commons/thumb/0/02/Bounding_box.png/250px-Bounding_box.png)](https://en.wikipedia.org/wiki/File:Bounding_box.png)A sphere enclosed by its axis-aligned minimum bounding box (in 3 dimensions)\nIn[geometry](https://en.wikipedia.org/wiki/Geometry), the**minimum bounding box**or**smallest bounding box**(also known as the**minimum enclosing box**or**smallest enclosing box**) for a point setSinN[dimensions](https://en.wikipedia.org/wiki/Dimension)is the[box](https://en.wikipedia.org/wiki/Hyperrectangle)with the smallest[measure](https://en.wikipedia.org/wiki/Measure_(mathematics))([area](https://en.wikipedia.org/wiki/Area),[volume](https://en.wikipedia.org/wiki/Volume), or[hypervolume](https://en.wikipedia.org/wiki/Hypervolume)in higher dimensions) within which all the points lie. When other kinds of measure are used, the minimum box is usually called accordingly, e.g., \"minimum-perimeter bounding box\".\nThe minimum bounding box of a point set is the same as the minimum bounding box of its[convex hull](https://en.wikipedia.org/wiki/Convex_hull), a fact which may be used[heuristically](https://en.wikipedia.org/wiki/Heuristic)to speed up computation.[&#91;1&#93;](#cite_note-tous83-1)\nIn the two-dimensional case it is called the*[minimum bounding rectangle](https://en.wikipedia.org/wiki/Minimum_bounding_rectangle)*.\n## Axis-aligned minimum bounding box\n[[edit](https://en.wikipedia.org/w/index.php?title=Minimum_bounding_box&amp;action=edit&amp;section=1)]\nThe[axis-aligned](https://en.wikipedia.org/wiki/Axis-aligned)minimum bounding box (or**AABB**) for a given point set is its minimum bounding box subject to the constraint that the edges of the box are parallel to the (Cartesian) coordinate axes. It is the[Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product)of*N*intervals each of which is defined by the minimal and maximal value of the corresponding coordinate for the points in*S*.\nAxis-aligned minimal bounding boxes are used as an approximate location of an object in question and as a very simple descriptor of its shape. For example, in[computational geometry](https://en.wikipedia.org/wiki/Computational_geometry)and its applications when it is required to find intersections in the set of objects, the initial check is the intersections between their MBBs. Since it is usually a much less expensive operation than the check of the actual intersection (because it only requires comparisons of coordinates), it allows quickly excluding checks of the pairs that are far apart.\n## Arbitrarily oriented minimum bounding box\n[[edit](https://en.wikipedia.org/w/index.php?title=Minimum_bounding_box&amp;action=edit&amp;section=2)]\nThe arbitrarily oriented minimum bounding box is the minimum bounding box, calculated subject to no constraints as to the orientation of the result.[Minimum bounding box algorithms](https://en.wikipedia.org/wiki/Minimum_bounding_box_algorithms)based on the[rotating calipers](https://en.wikipedia.org/wiki/Rotating_calipers)method can be used to find the minimum-area or minimum-perimeter bounding box of a two-dimensional convex polygon in linear time, and of a three-dimensional point set in the time it takes to construct its[convex hull](https://en.wikipedia.org/wiki/Convex_hull)followed by a linear-time computation.[&#91;1&#93;](#cite_note-tous83-1)A three-dimensional rotating calipers algorithm can find the minimum-volume arbitrarily-oriented bounding box of a three-dimensional point set in cubic time.[&#91;2&#93;](#cite_note-2)Matlab implementations of the latter as well as the optimal compromise between accuracy and CPU time are available.[&#91;3&#93;](#cite_note-3)\n## Object-oriented minimum bounding box\n[[edit](https://en.wikipedia.org/w/index.php?title=Minimum_bounding_box&amp;action=edit&amp;section=3)]\nIn the case where an object has its own[local coordinate system](https://en.wikipedia.org/wiki/Local_coordinate_system), it can be useful to store a bounding box relative to these axes, which requires no transformation as the object's own transformation changes.\n## Digital image processing\n[[edit](https://en.wikipedia.org/w/index.php?title=Minimum_bounding_box&amp;action=edit&amp;section=4)]\nIn[digital image processing](https://en.wikipedia.org/wiki/Digital_image_processing), the*bounding box*is merely the coordinates of the rectangular border that fully encloses a[digital image](https://en.wikipedia.org/wiki/Digital_image)when it is placed over a page, a canvas, a screen or other similar bidimensional background.\n## See also\n[[edit](https://en.wikipedia.org/w/index.php?title=Minimum_bounding_box&amp;action=edit&amp;section=5)]\n* [Bounding sphere](https://en.wikipedia.org/wiki/Bounding_sphere)\n* [Bounding volume](https://en.wikipedia.org/wiki/Bounding_volume)\n* [Minimum bounding rectangle](https://en.wikipedia.org/wiki/Minimum_bounding_rectangle)\n* [Darboux integral](https://en.wikipedia.org/wiki/Darboux_integral)\n## References\n[[edit](https://en.wikipedia.org/w/index.php?title=Minimum_bounding_box&amp;action=edit&amp;section=6)]\n1. ^[***a***](#cite_ref-tous83_1-0)[***b***](#cite_ref-tous83_1-1)> Toussaint, G. T. (1983). [> \"Solving geometric problems with the rotating calipers\"\n](http://web.cs.swarthmore.edu/~adanner/cs97/s08/pdf/calipers.pdf)> > (PDF)\n> . Proc. MELECON '83, Athens.\n2. **[^](#cite_ref-2)**> Joseph O'Rourke (1985), \"Finding minimal enclosing boxes\", *> Parallel Programming\n*> , [> Springer Netherlands\n](https://en.wikipedia.org/wiki/Springer_Netherlands)\n3. **[^](#cite_ref-3)**> Chang, Chia-Tche; Gorissen, Bastien; Melchior, Samuel (2018). [> \"Matlab implementation of several minimum-volume bounding box algorithms\"\n](https://github.com/chadogome/OptimalOBB)> . *[> GitHub\n](https://en.wikipedia.org/wiki/GitHub)*> .\n.\nRetrieved from \"[https://en.wikipedia.org/w/index.php?title=Minimum\\_bounding\\_box&amp;&amp;oldid=1249919681](https://en.wikipedia.org/w/index.php?title=Minimum_bounding_box&amp;oldid=1249919681)\"\n[Categories](https://en.wikipedia.org/wiki/Help:Category):\n* [Geometry](https://en.wikipedia.org/wiki/Category:Geometry)\n* [Geometric algorithms](https://en.wikipedia.org/wiki/Category:Geometric_algorithms)\nHidden categories:\n* [Articles with short description](https://en.wikipedia.org/wiki/Category:Articles_with_short_description)\n* [Short description is different from Wikidata](https://en.wikipedia.org/wiki/Category:Short_description_is_different_from_Wikidata)\nSearch\nSearch\nMinimum bounding box\n[](#)[](#)[](#)[](#)[](#)[](#)[](#)\n8 languages[Add topic](#)",
      "url": "https://en.wikipedia.org/wiki/Minimum_bounding_box"
    },
    {
      "title": "Computing oriented minimum bounding boxes in 2D",
      "text": "# Introduction\n\n_Oriented bounding boxes_ are an important tool for visibility testing and collision detection in computer graphics. In this post I want to talk about how to compute the oriented _minimum_ bounding box (OMBB) of an arbitrary polygon in two dimensions. As a polygon just enforces an ordering on a set of points (vertices), everything described in the following equally applies to simple point sets. _Minimum_ in this context refers to the area of the bounding box. A minimum oriented bounding box is also known as _smallest-area enclosing rectangle_. However, I will stick to the former term throughout this article as it is more frequently used in the computer graphics world.\n\nThe easiest way of computing a bounding box for a polygon is to determine the minimum and maximum ![x](https://s0.wp.com/latex.php?latex=x&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5)\u2013 and ![y](https://s0.wp.com/latex.php?latex=y&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5)\u2013 coordinates of its vertices. Such an _axis aligned bounding box_ (AABB) can be computed trivially but it\u2019s in most cases significantly bigger than the polygon\u2019s OMBB. Finding the OMBB requires some more work as the bounding box\u2019 area must be minimized, constrained by the location of the polygon\u2019s vertices. Look at the following figure for an illustration (AABB in blue, OMBB in red).\n\n![AABB vs OMBB](https://geidav.wordpress.com/wp-content/uploads/2014/01/aabb_vs_ombb.png?w=820)\n\nThe technique for computing OMBBs presented in the following consists of two detached steps. In the first step the _convex hull_ of the input polygon is computed. If the polygon is convex this step can be omitted because a convex polygon is equal to its convex hull. In the second step the _Rotating Calipers_ method is employed on the convex hull to compute the resulting OMBB. I will focus on the Rotating Calipers method because it\u2019s not very widely known in comparison to the numerous ways of computing convex hulls.\n\n# Convex hulls\n\nIn less mathematical but more illustrative terms the _convex hull_ of a set of ![n](https://s0.wp.com/latex.php?latex=n&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) points can be described as the closed polygonal chain of all outer points of the set, which entirely encloses all set elements. You can picture it as the shape of a rubber band stretched around all set elements. The convex hull of a set of two-dimensional points can be efficiently computed in ![O(n\\log n)](https://s0.wp.com/latex.php?latex=O%28n%5Clog+n%29&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5). In the figure below the convex hull of the vertices of a concave polygon is depicted.\n\n![Convex hull of vertices of concave polygon](https://geidav.wordpress.com/wp-content/uploads/2014/01/convex_hull2.png?w=820)\n\nThere are numerous algorithms for computing convex hulls: _Quick Hull_, _Gift Wrapping_ (also known as _Jarvis March_), _Graham\u2019s Algorithm_ and some more. I\u2019ve chosen the Gift Wrapping algorithm for my implementation because it\u2019s easy to implement and provides good performance in case ![n](https://s0.wp.com/latex.php?latex=n&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) is small or the polygon\u2019s convex hull contains only a few vertices. The runtime complexity is ![O(nh)](https://s0.wp.com/latex.php?latex=O%28nh%29&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5), where ![h](https://s0.wp.com/latex.php?latex=h&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) is the number of vertices in the convex hull. In the general case Gift Wrapping is outperformed by other algorithms. Especially, when all points are part of the convex hull. In that case the complexity degrades to ![O(n^2)](https://s0.wp.com/latex.php?latex=O%28n%5E2%29&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5).\n\nAs there are many good articles on the Gift Wrapping algorithm available online, I won\u2019t describe it another time here. Instead I want to focus on the lesser-known Rotating Calipers method for computing OMBBs. However, take care that your convex hull algorithm correctly handles collinear points. If multiple points lie on a convex hull edge, only the spanning points should end up in the convex hull.\n\n# Rotating Calipers\n\n_Rotating Calipers_ is a versatile method for solving a number of problems from the field of computational geometry. It resembles the idea of rotating a dynamically adjustable caliper around the outside of a polygon\u2019s convex hull. Originally, this method was invented to compute the diameter of convex polygons. Beyond that, it can be used to compute OMBBs, the minimum and maximum distance between two convex polygons, the intersection of convex polygons and many things more.\n\nThe idea of using the Rotating Calipers method for computing OMBBs is based on the following theorem, establishing a connection between the input polygon\u2019s convex hull and the orientation of the resulting OMBB. The theorem was proven in 1975 by Freeman and Shapira[1](https://geidav.wordpress.com/2014/01/23/computing-oriented-minimum-bounding-boxes-in-2d/#fn-1057-FreemanShapira1975):\n\n> The smallest-area enclosing rectangle of a polygon has a side collinear with one of the edges of its convex hull.\n\nThanks to this theorem the number of OMBB candidates is dramatically reduced to the number of convex hull edges. Thus, the complexity of the Rotating Calipers method is _linear_ if the convex hull is already available. If it isn\u2019t available the overall complexity is bound by the cost of computing the convex hull. An example of a set of OMBB candidates (red) for a convex hull (green) is depicted in the figure below. Note, that there are as many OMBB candidates as convex hull edges and each OMBB candidate has one side flush with one edge of the convex hull.\n\n![OMBB candidates](https://geidav.wordpress.com/wp-content/uploads/2014/01/ombb_candidates.png?w=820)\n\nTo determine the OMBB of a polygon, first, two orthogonally aligned pairs of parallel _supporting lines_ through the convex hull\u2019s _extreme points_ are created. The intersection of the four lines forms a rectangle. Next, the lines are simultaneously rotated about their supporting points until one line coincides with an edge of the convex hull. Each time an edge coincides, the four lines form another rectangle / OMBB candidate. This process is repeated until each convex hull edge once coincided with one of the four caliper lines. The resulting OMBB is the OMBB candidate with the smallest area. The entire algorithm is outlined step by step below.\n\n1. Compute the convex hull of the input polygon.\n2. Find the the extreme points ![p_\\text{min}=(x_\\text{min},y_\\text{min})^T](https://s0.wp.com/latex.php?latex=p_%5Ctext%7Bmin%7D%3D%28x_%5Ctext%7Bmin%7D%2Cy_%5Ctext%7Bmin%7D%29%5ET&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) and ![p_\\text{max}=(x_\\text{max},y_\\text{max})^T](https://s0.wp.com/latex.php?latex=p_%5Ctext%7Bmax%7D%3D%28x_%5Ctext%7Bmax%7D%2Cy_%5Ctext%7Bmax%7D%29%5ET&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) of the convex hull.\n3. Construct two vertical supporting lines at ![x_\\text{min}](https://s0.wp.com/latex.php?latex=x_%5Ctext%7Bmin%7D&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) and ![x_\\text{max}](https://s0.wp.com/latex.php?latex=x_%5Ctext%7Bmax%7D&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) and two horizontal ones at ![y_\\text{min}](https://s0.wp.com/latex.php?latex=y_%5Ctext%7Bmin%7D&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) and ![y_\\text{max}](https://s0.wp.com/latex.php?latex=y_%5Ctext%7Bmax%7D&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5).\n4. Initialize the current minimum rectangle area ![A_\\text{min}=\\infty](https://s0.wp.com/latex.php?latex=A_%5Ctext%7Bmin%7D%3D%5Cinfty&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5).\n5. Rotate the supporting lines until one coincides with an edge of the convex hull.\n1. Compute the area ![A](https://s0.wp.com/latex.php?latex=A&bg=ffffff&fg=777777&s=0&c=20201002&zoom=4.5) of the current rectangle.\n2. Update the minimum area and store the current rectangle if ![A<A_\\text{min}](https://s...",
      "url": "https://geidav.wordpress.com/2014/01/23/computing-oriented-minimum-bounding-boxes-in-2d"
    },
    {
      "title": "Improved Approximations for Translational Packing of Convex Polygons",
      "text": "Improved Approximations for Translational Packing\nof Convex Polygons\nAdam Kurpisz # \u00d1 \u001a\nBern University of Applied Sciences and Department of Mathematics, ETH Zurich, Switzerland\nSilvan Suter # \u001a\nDepartment of Mathematics, ETH Zurich, Switzerland\nAbstract\nOptimal packing of objects in containers is a critical problem in various real-life and industrial\napplications. This paper investigates the two-dimensional packing of convex polygons without\nrotations, where only translations are allowed. We study different settings depending on the type of\ncontainers used, including minimizing the number of containers or the size of the container based on\nan objective function.\nBuilding on prior research in the field, we develop polynomial-time algorithms with improved\napproximation guarantees upon the best-known results by Alt, de Berg and Knauer, as well as\nAamand, Abrahamsen, Beretta and Kleist, for problems such as Polygon Area Minimization, Polygon\nPerimeter Minimization, Polygon Strip Packing, and Polygon Bin Packing. Our approach utilizes a\nsequence of object transformations that allows sorting by height and orientation, thus enhancing\nthe effectiveness of shelf packing algorithms for polygon packing problems. In addition, we present\nefficient approximation algorithms for special cases of the Polygon Bin Packing problem, progressing\ntoward solving an open question concerning an O(1)-approximation algorithm for arbitrary polygons.\n2012 ACM Subject Classification Theory of computation \u2192 Packing and covering problems\nKeywords and phrases Approximation algorithms, Packing problems, Convex polygons, Bin packing,\nStrip packing, Area minimization\nRelated Version This is the full version of the same-named ESA 2023 paper. A link will be provided\nin a future version of this document.\narXiv:2308.08523v1 [cs.CG] 16 Aug 2023\n2 Improved Approximations for Translational Packing of Convex Polygons\n1 Introduction\nMany real-life situations require us to make decisions about optimally packing a collection\nof objects into a specific container. One particular category of these packing problems is\ntwo-dimensional packing, which is encountered in everyday scenarios like arranging items\non a shelf and in industrial applications such as cutting cookies from rolled-out dough\nor manufacturing sets of tiles from standard-sized panels made of wood, glass, or metal.\nAnother intriguing example involves cutting fabric pieces for clothing production. In this\ncase, the pieces often cannot be rotated freely, as they must adhere to a desired pattern\nin the final product, which is tailored of multiple elements. The widespread applicability\nof two-dimensional packing problems has led to a surge of interest in designing efficient\nalgorithms to address them. In this paper, we follow the line of research and study the\nproblem of packing convex polygons without rotations in various settings depending on the\ntype of containers used.\nPast research focusing on theoretical considerations of two-dimensional packings mainly\nconcentrates on the scenario when all objects are axis-parallel rectangles. In this paper, we\nwill discuss packing without rotations, in which only translations are permitted. There are\ntwo main classes of the problem depending on whether the size of the container is fixed and\nwe want to minimize the number of containers used or whether we want to minimize the\ncontainer\u2019s size with respect to some objective function.\nA seminal example of the first class is the Geometric Bin Packing problem in which\na number of unit size squared bins to pack is to be minimized. The problem is arguably\nthe most natural generalization of the regular (1D) Bin Packing to two dimensions, and\nits absolute approximability has been fully understood. Unless P = N P, the best possible\nefficient constant factor approximation is 2 [15], and such an algorithm is known [10].\nIn the second class, there are several variants to be considered. An example is the\nStrip Packing Problem which is concerned with packing objects into a strip of width\n1 and infinite height in such a way that the maximum of all the heights of the placed\nobjects is minimized. Like Geometric Bin Packing, Strip Packing generalizes (1D)\nBin Packing. The best known efficient constant factor approximation for Strip Packing\nhas approximation factor (5/3 + \u03f5) [9]. It is known that there can not exist a polynomial\ntime algorithm with an approximation ratio of (3/2 \u2212 \u03f5) for any \u03f5 > 0 unless P = N P, which\nfollows directly from the approximation hardness of (1D) Bin Packing. Both classes of\nproblems have been also considered in the asymptotic setting, see e.g. [11, 5, 12].\nIn younger time, there was also an increase of interest in cases where the objects in\nquestion are general convex polygons. Alt, de Berg and Knauer [2, 3] considered the problem\nof packing an instance consisting of a number of convex polygons of the form p \u2282 [0, 1]2into\na minimum area axis-parallel rectangular container. We refer to this problem as Polygon\nArea Minimization throughout this paper. In the special case where the instance consists\nof rectangles only, the problem is known to admit a PTAS [4]. They proved the existence of\nthe following efficient algorithm:\nA 23.78-approximation for Polygon Area Minimization.\nRecently, Aamand, Abrahamsen, Beretta and Kleist [1] showed that the algorithm of Alt,\nde Berg and Knauer can be leveraged to obtain also efficient approximation algorithms of\nfurther problems:\nA 7-approximation for Polygon Perimeter Minimization.\nA 51-approximation for Polygon Strip Packing.\nAn 11-approximation for Polygon Bin Packing for polygons with diameter at most 1\n10 .\nA. Kurpisz and S. Suter 3\n1.1 Our results\nThe results of Alt, de Berg and Knauer [2, 3] and Aamand et al. [1] are heavily based on\nso-called shelf packing algorithms. In shelf packing algorithms, the objects are first placed\non the shelves, possibly ordered by height, which are later stacked on one another to build\na final solution. Compared to axis-parallel rectangles, the main challenge in designing an\napproximation algorithm for polygon packing problems is that objects cannot be sorted by\nheight and orientation simultaneously. As a result, the algorithm and its analysis in [2, 3]\nhave such a large approximation guarantee. In this paper, we provide new insight into how\nshelf packing algorithms should be applied to polygon packing problems. We introduce a\nsequence of transformations of the objects that allow us first to sort them by height and later\nby orientation to build a solution of a much better approximation guarantee. More precisely,\nwe design polynomial-time algorithms with the following factors:\nA 9.45-approximation for Polygon Area Minimization.\nUsing this algorithm as a subroutine, we build upon the methods from Aamand et al. [1] to\nobtain the following efficient approximation algorithms:\nA (3.75 + \u03f5)-approximation for Polygon Perimeter Minimization.\nA 21.89-approximation for Polygon Strip Packing.\nA 5.09-approximation for Polygon Bin Packing for polygons which have their diameter\nbounded by 1\n10 .\nThe results are proved in Sections 4, 5, 6, and 7 respectively. Furthermore, in Section 8\nwe show the following results, which make progress towards solving an open question of a\nO(1)-approximation algorithm for Polygon Bin Packing for arbitrary polygons.\nThere is an efficient O(\n1\n\u03b4\n)-approximation algorithm for Polygon Bin Packing for\ninstances where each polygon has width or height at most 1 \u2212 \u03b4.\nThere is an efficient O(1)-approximation algorithm for Polygon Bin Packing for\ninstances with the property that all polygons share a spine (up to translation) with height\nat least 3\n4\n.\n2 Preliminaries\nWe start out considerations by recalling a classical and well-known problem in theoretical\ncomputer science, the Bin Packing problem: Given a list of numbers s1, . . . , sn \u2208 (0, 1] \u2229 Q,\nrepresenting the sizes of n objects, the goal is to find the minimum number of bins of size 1,\nso that we can pac...",
      "url": "https://export.arxiv.org/pdf/2308.08523v1.pdf"
    },
    {
      "title": "A new mixed-integer programming model for irregular strip packing based on vertical slices with a reproducible survey",
      "text": "[We gratefully acknowledge support from\\\nthe Simons Foundation and member institutions.](https://confluence.cornell.edu/x/ALlRF)",
      "url": "https://arxiv.org/pdf/2206.00032"
    },
    {
      "title": "Minimum Bounding Geometry (Data Management)\u2014ArcGIS Pro",
      "text": "<div><div>\n\t<header></header>\n\t \n\t\n \n \n\t<main>\n\t\n \t\n \n\t\n<div><h2>Summary</h2><p>Creates a feature class containing polygons which represent a specified minimum bounding geometry enclosing each input feature or each group of input features.</p></div>\n<div><h2>Parameters</h2><nav><a>Dialog</a><a>Python</a></nav><section><article><table><thead><tr><td>Label</td><td>Explanation</td><td>Data Type</td></tr></thead><tbody><tr><td><p>Input Features</p></td><td><p>The input features that can be point, multipoint, line, polygon, or multipatch.</p></td><td>Feature Layer</td></tr><tr><td><p>Output Feature Class</p></td><td><p>The output polygon feature class.</p></td><td>Feature Class</td></tr><tr><td><p>Geometry Type</p><p>(Optional)</p></td><td><p>Specifies what type of minimum bounding geometry the output polygons will represent.</p><div><ul><li><span>Rectangle by area</span>\u2014<span>The rectangle of the smallest area enclosing an input feature. This is the default.</span></li><li><span>Rectangle by width</span>\u2014<span>The rectangle of the smallest width enclosing an input feature. </span></li><li><span>Convex hull</span>\u2014<span>The smallest convex polygon enclosing an input feature. </span></li><li><span>Circle</span>\u2014<span>The smallest circle enclosing an input feature envelope. </span></li><li><span>Envelope</span>\u2014<span>The envelope of an input feature.</span></li></ul></div></td><td>String</td></tr><tr><td><p>Group Option</p><p>(Optional)</p></td><td><p>Specifies how the input features will be grouped; each group will be enclosed with one output polygon.</p><div><ul><li><span>None</span>\u2014<span>Input features will not be grouped. This is the default. This option is not available for point input. </span></li><li><span>All</span>\u2014<span>All input features will be treated as one group. </span></li><li><span>List</span>\u2014<span>Input features will be grouped based on their common values in the specified field or fields in the group field parameter.</span></li></ul></div></td><td>String</td></tr><tr><td><p>Group Field(s)</p><p>(Optional)</p></td><td><p>The field or fields in the input features that will be used to group features, when <span>List</span> is specified as <span>Group Option</span>. At least one group field is required for <span>List</span> option. All features that have the same value in the specified field or fields will be treated as a group.</p></td><td>Field</td></tr><tr><td><p>Add geometry characteristics as attributes to output</p><p>(Optional)</p></td><td><p>Specifies whether to add the geometric attributes in the output feature class or omit them in the output feature class.</p><ul><li>Unchecked\u2014Omits the geometric attributes in the output feature class. This is the default.</li><li>Checked\u2014Adds the geometric attributes in the output feature class.</li></ul></td><td>Boolean</td></tr></tbody></table></article><article><pre>arcpy.management.MinimumBoundingGeometry(in_features, out_feature_class, {geometry_type}, {group_option}, {group_field}, {mbg_fields_option})</pre><table><thead><tr><td>Name</td><td>Explanation</td><td>Data Type</td></tr></thead><tbody><tr><td><p>in_features</p></td><td><p>The input features that can be point, multipoint, line, polygon, or multipatch.</p></td><td>Feature Layer</td></tr><tr><td><p>out_feature_class</p></td><td><p>The output polygon feature class.</p></td><td>Feature Class</td></tr><tr><td><p>geometry_type</p><p>(Optional)</p></td><td><p>Specifies what type of minimum bounding geometry the output polygons will represent.</p><div><ul><li><span>RECTANGLE_BY_AREA</span>\u2014<span>The rectangle of the smallest area enclosing an input feature. This is the default.</span></li><li><span>RECTANGLE_BY_WIDTH</span>\u2014<span>The rectangle of the smallest width enclosing an input feature. </span></li><li><span>CONVEX_HULL</span>\u2014<span>The smallest convex polygon enclosing an input feature. </span></li><li><span>CIRCLE</span>\u2014<span>The smallest circle enclosing an input feature envelope. </span></li><li><span>ENVELOPE</span>\u2014<span>The envelope of an input feature.</span></li></ul></div></td><td>String</td></tr><tr><td><p>group_option</p><p>(Optional)</p></td><td><p>Specifies how the input features will be grouped; each group will be enclosed with one output polygon.</p><div><ul><li><span>NONE</span>\u2014<span>Input features will not be grouped. This is the default. This option is not available for point input. </span></li><li><span>ALL</span>\u2014<span>All input features will be treated as one group. </span></li><li><span>LIST</span>\u2014<span>Input features will be grouped based on their common values in the specified field or fields in the group field parameter.</span></li></ul></div></td><td>String</td></tr><tr><td><p>group_field</p><p>[group_field,...]</p><p>(Optional)</p></td><td><p>The field or fields in the input features that will be used to group features, when <span>LIST</span> is specified as <span>group_option</span>. At least one group field is required for <span>LIST</span> option. All features that have the same value in the specified field or fields will be treated as a group.</p></td><td>Field</td></tr><tr><td><p>mbg_fields_option</p><p>(Optional)</p></td><td><p>Specifies whether to add the geometric attributes in the output feature class or omit them in the output feature class.</p><div><ul><li><span>NO_MBG_FIELDS</span>\u2014<span>Omits any input attributes in the output feature class. This is the default.</span></li><li><span>MBG_FIELDS</span>\u2014<span>Adds the geometric attributes in the output feature class.</span></li></ul></div></td><td>Boolean</td></tr></tbody></table><div><h3>Code sample</h3><section>MinimumBoundingGeometry Example 1 (Python window)\n<p>The following Python window script demonstrates how to use the MinimumBoundingGeometry function in immediate mode.</p><div><pre><code>import arcpy\nfrom arcpy import env\nenv.workspace = \"C:/data\"\narcpy.MinimumBoundingGeometry_management(\"parks.shp\",\n \"c:/output/output.gdb/parks_mbg\",\n \"RECTANGLE_BY_AREA\", \"NONE\")</code></pre></div></section><section>MinimumBoundingGeometry Example 2 (stand-alone script)\n<p>The following stand-alone script is a simple example of how to apply the MinimumBoundingGeometry function in a scripting environment.</p><div><pre><code># Name: MinimumBoundingGeometry.py\n# Description: Use MinimumBoundingGeometry function to find an area \n# for each multipoint input feature.\n# import system modules \nimport arcpy\nfrom arcpy import env\n# Set environment settings\nenv.workspace = \"C:/data\"\n# Create variables for the input and output feature classes\ninFeatures = \"treeclusters.shp\"\noutFeatureClass = \"forests.shp\"\n# Use MinimumBoundingGeometry function to get a convex hull area\n# for each cluster of trees which are multipoint features\narcpy.MinimumBoundingGeometry_management(inFeatures, outFeatureClass, \n \"CONVEX_HULL\", \"NONE\")</code></pre></div></section></div></article></section></div>\n<div><h2>Environments</h2></div><a></a><div><h2>Licensing information</h2><ul><li>Basic: Yes</li><li>Standard: Yes</li><li>Advanced: Yes</li></ul></div><section><h4>Related topics</h4><ul><li><a href=\"https://pro.arcgis.com/en/pro-app/3.4/tool-reference/data-management/an-overview-of-the-features-toolset.htm\">An overview of the Features toolset</a></li><li><a href=\"https://pro.arcgis.com/en/pro-app/3.4/help/analysis/geoprocessing/basics/find-geoprocessing-tools.htm\">Find a geoprocessing tool</a></li></ul></section>\n\t<hr/>\n\t\n \n\t <p>\n\t <a href=\"https://pro.arcgis.com/feedback/\">Feedback on this topic?</a>\n\t </p>\n \n\t</main>\n\t</div></div>",
      "url": "https://pro.arcgis.com/en/pro-app/3.4/tool-reference/data-management/minimum-bounding-geometry.htm"
    },
    {
      "title": "Convex Polygon -- from Wolfram MathWorld",
      "text": "![](https://mathworld.wolfram.com/images/sidebar/menu-close.png)![Search](https://mathworld.wolfram.com/images/header/search-icon.png)\n\n# Convex Polygon\n\n* * *\n\n[![DOWNLOAD Mathematica Notebook](https://mathworld.wolfram.com/images/entries/download-notebook-icon.png)Download\\\nWolfram\u00a0Notebook](https://mathworld.wolfram.com/notebooks/PlaneGeometry/ConvexPolygon.nb)\n\n![ConvexPolygon](https://mathworld.wolfram.com/images/eps-svg/ConvexPolygon_1001.svg)\n\nA planar [polygon](https://mathworld.wolfram.com/Polygon.html) is convex if it contains _all_ the [line segments](https://mathworld.wolfram.com/LineSegment.html) connecting any pair of its points.\nThus, for example, a regular pentagon is convex (left figure), while an indented\npentagon is not (right figure). A planar polygon that is not convex is said to be\na [concave polygon](https://mathworld.wolfram.com/ConcavePolygon.html).\n\nLet a [simple polygon](https://mathworld.wolfram.com/SimplePolygon.html) have ![n](https://mathworld.wolfram.com/images/equations/ConvexPolygon/Inline1.svg) vertices ![x_i](https://mathworld.wolfram.com/images/equations/ConvexPolygon/Inline2.svg) for ![i=1](https://mathworld.wolfram.com/images/equations/ConvexPolygon/Inline3.svg), 2, ..., ![n](https://mathworld.wolfram.com/images/equations/ConvexPolygon/Inline4.svg), and define the edge vectors as\n\n|     |     |\n| --- | --- |\n| ![ v_i=x_(i+1)-x_i, ](https://mathworld.wolfram.com/images/equations/ConvexPolygon/NumberedEquation1.svg) | (1) |\n\nwhere ![x_(n+1)](https://mathworld.wolfram.com/images/equations/ConvexPolygon/Inline5.svg)\nis understood to be equivalent to ![x_1](https://mathworld.wolfram.com/images/equations/ConvexPolygon/Inline6.svg). Then the polygon is convex [iff](https://mathworld.wolfram.com/Iff.html)\nall turns from one edge vector to the next have the same sense. Therefore, a simple\npolygon is convex iff\n\n|     |     |\n| --- | --- |\n| ![ v_i^_|_\u00b7v_(i+1) ](https://mathworld.wolfram.com/images/equations/ConvexPolygon/NumberedEquation2.svg) | (2) |\n\nhas the same sign for all ![i](https://mathworld.wolfram.com/images/equations/ConvexPolygon/Inline7.svg), where ![a^_|_\u00b7b](https://mathworld.wolfram.com/images/equations/ConvexPolygon/Inline8.svg) denotes the [perp\\\ndot product](https://mathworld.wolfram.com/PerpDotProduct.html) (Hill 1994). However, a more efficient test that doesn't require\na priori knowledge that the polygon is simple is known (Moret and Shapiro 1991).\n\nThe [happy end problem](https://mathworld.wolfram.com/HappyEndProblem.html) considers convex ![n](https://mathworld.wolfram.com/images/equations/ConvexPolygon/Inline9.svg)-gons and the minimal number of points ![f(n)](https://mathworld.wolfram.com/images/equations/ConvexPolygon/Inline10.svg) (in the [general position](https://mathworld.wolfram.com/GeneralPosition.html))\nin which a convex ![n](https://mathworld.wolfram.com/images/equations/ConvexPolygon/Inline11.svg)-gon\ncan always be found. The answers for ![n=3](https://mathworld.wolfram.com/images/equations/ConvexPolygon/Inline12.svg), 4, 5, and 6 are 3, 5, 9, and 17. It is conjectured that\n![f(n)=2^(n-2)+1](https://mathworld.wolfram.com/images/equations/ConvexPolygon/Inline13.svg), but only proven that\n\n|     |     |\n| --- | --- |\n| ![ 2^(n-2)<=f(n)<=(2n-4; n-2), ](https://mathworld.wolfram.com/images/equations/ConvexPolygon/NumberedEquation3.svg) | (3) |\n\nwhere ![(n; k)](https://mathworld.wolfram.com/images/equations/ConvexPolygon/Inline14.svg)\nis a [binomial coefficient](https://mathworld.wolfram.com/BinomialCoefficient.html).\n\n* * *\n\n## See also\n\n[Concave Polygon](https://mathworld.wolfram.com/ConcavePolygon.html), [Convex Hull](https://mathworld.wolfram.com/ConvexHull.html), [Convex Polyomino](https://mathworld.wolfram.com/ConvexPolyomino.html), [Convex\\\nPolyhedron](https://mathworld.wolfram.com/ConvexPolyhedron.html), [Convex Polytope](https://mathworld.wolfram.com/ConvexPolytope.html), [Happy\\\nEnd Problem](https://mathworld.wolfram.com/HappyEndProblem.html), [Lattice Polygon](https://mathworld.wolfram.com/LatticePolygon.html), [Polygon](https://mathworld.wolfram.com/Polygon.html)\n\n## Explore with Wolfram\\|Alpha\n\n![WolframAlpha](https://mathworld.wolfram.com/images/wolframalpha/WA-logo.png)\n\nMore things to try:\n\n- [65537-gon](http://www.wolframalpha.com/input/?i=65537-gon)\n- [257-gon](http://www.wolframalpha.com/input/?i=257-gon)\n- [polygons](http://www.wolframalpha.com/input/?i=polygons)\n\n## References\n\nHill, F.\u00a0S.\u00a0Jr. \"The Pleasures of 'Perp Dot' Products.\" Ch.\u00a0II.5 in _[Graphics\\_\n_Gems IV](http://www.amazon.com/exec/obidos/ASIN/0123361559/ref=nosim/ericstreasuretro)_ (Ed. P.\u00a0S.\u00a0Heckbert). San Diego: Academic Press, pp.\u00a0138-148,\n1994.Moret, B. and Shapiro, H. _[Algorithms\\_\n_from P to NP.](http://www.amazon.com/exec/obidos/ASIN/0805380086/ref=nosim/ericstreasuretro)_ Reading, MA: Benjamin Cummings, 1991.\n\n## Referenced on Wolfram\\|Alpha\n\n[Convex Polygon](http://www.wolframalpha.com/entities/mathworld/convex_polygon/d6/j7/e8/)\n\n## Cite this as:\n\n[Weisstein, Eric W.](https://mathworld.wolfram.com/about/author.html) \"Convex Polygon.\" From\n[_MathWorld_](https://mathworld.wolfram.com/)--A Wolfram Web Resource. [https://mathworld.wolfram.com/ConvexPolygon.html](https://mathworld.wolfram.com/ConvexPolygon.html)\n\n## Subject classifications",
      "url": "https://mathworld.wolfram.com/ConvexPolygon.html"
    }
  ]
}