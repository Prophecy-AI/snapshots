# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
Pack Christmas tree toys (15-vertex polygons) into the smallest square bounding box for N=1 to N=200 trees. The score is the sum of (side²/N) for all configurations. Lower is better.

## Current Status
- **Best pre-optimized score**: 70.658891
- **Target score**: 68.919154
- **Gap**: 1.74 points (2.5%)
- **Best submission location**: `/home/code/exploration/best_preoptimized.csv`

## CRITICAL INSIGHT: Pre-optimized Submissions Are at Local Optima
Previous experiments show that running standard optimizers (bbox3, tree_packer_v21) on pre-optimized submissions finds NO improvements. The gap of 1.74 points requires fundamentally different approaches, not micro-optimization.

## Tree Geometry (15 vertices)
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```
- Tree height: 1.0 (from y=-0.2 to y=0.8)
- Tree width: 0.7 (from x=-0.35 to x=0.35)
- Trunk: 0.15 wide, 0.2 tall

## Scoring Function
```python
from shapely.geometry import Polygon
from shapely import affinity
import numpy as np

def score_submission(df):
    total = 0
    for n in range(1, 201):
        group = df[df['id'].str.startswith(f'{n:03d}_')]
        all_coords = []
        for _, row in group.iterrows():
            x = float(str(row['x']).replace('s', ''))
            y = float(str(row['y']).replace('s', ''))
            deg = float(str(row['deg']).replace('s', ''))
            tree = make_tree(x, y, deg)  # Create rotated/translated polygon
            all_coords.append(np.array(tree.exterior.coords))
        all_coords = np.vstack(all_coords)
        side = max(all_coords[:, 0].max() - all_coords[:, 0].min(),
                   all_coords[:, 1].max() - all_coords[:, 1].min())
        total += side**2 / n
    return total
```

## Top Kernel Approaches

### 1. bbox3.cpp (from jazivxt "Why Not" kernel)
- Complex Number Vector Coordination
- Fluid Dynamics simulation
- Hinge Pivot moves
- Density Gradient Flow
- Global Boundary Tension
- Uses aggressive_repair for overlap resolution
- Parameters: `-n <iterations> -r <rounds>`
- Uses OpenMP for parallelization

### 2. tree_packer_v21.cpp (from smartmanoj "Santa Claude" kernel)
- Swap moves between trees
- Multi-angle restarts
- Higher temperature Simulated Annealing
- Backward propagation (bp.cpp) - removes trees from larger N configs to improve smaller N
- Functions: squeeze, compaction, localSearch
- Parameters: `-n <iterations> -r <rounds>`

### 3. Greedy Placement (from Getting Started kernel)
- Place trees at weighted random angles (abs(sin(2*angle)))
- Move toward center until collision
- Back up until no overlap
- Uses STRtree for efficient collision detection

## Strategies to Beat Target (Priority Order)

### 1. [HIGHEST PRIORITY] Lattice/Grid-Based Approach for Large N (N >= 58)
Top solutions use crystalline packing patterns:
- Start with 2 base trees in optimal configuration
- Translate in x and y directions to create grid
- Parameters: `nt = [nx, ny]` where nx*ny >= N
- This generates tighter packings than random optimization for large N

### 2. [HIGH PRIORITY] Focus on Small N Values (1-10)
These have the highest score contribution per tree:
- N=1: side≈0.813, contributes ~0.66 to score
- N=2: side≈0.950, contributes ~0.45 to score
- Try exhaustive search for optimal rotation angles
- For N=1, optimal angle is 45° (minimizes bounding box)

### 3. [HIGH PRIORITY] Asymmetric Solutions
Discussion insight: "Why the winning solutions will be Asymmetric"
- Symmetric solutions may be optimal for small N but asymmetric for large N
- Try breaking symmetry in configurations

### 4. [MEDIUM PRIORITY] Much Longer Optimization Runs
Top solutions run for HOURS, not minutes:
- `-n 15000+` iterations
- `-r 80+` rounds
- Multiple generations with perturbation to escape local optima

### 5. [MEDIUM PRIORITY] Backward Propagation
Start from N=200, work down to N=2:
```python
for n in range(200, 1, -1):
    for tree_to_remove in range(n):
        candidate = remove_tree(config[n], tree_to_remove)
        if score(candidate) < score(config[n-1]):
            config[n-1] = candidate
```

### 6. [MEDIUM PRIORITY] Different Starting Configurations
Instead of optimizing pre-optimized submission:
- Generate new random configurations
- Use lattice-based initial placement
- Try different angle distributions

## What NOT to Try (Already Proven Ineffective)
- Short optimization runs on pre-optimized submissions (local optimum is too tight)
- Simple ensemble of existing solutions (one source dominates all N values)
- fix_direction post-processing (causes precision loss and overlaps)

## Overlap Detection
```python
from shapely.strtree import STRtree

def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- id: `{n:03d}_{tree_index}` (e.g., 001_0, 002_0, 002_1)
- x, y, deg: prefixed with 's' to preserve precision
- Total rows: 20100 (1+2+3+...+200)
- Coordinates must be within [-100, 100]

## Validation Checklist
1. No overlapping trees (use has_overlap function)
2. All coordinates within [-100, 100]
3. All 200 configurations present (20100 rows)
4. Values prefixed with 's' in submission

## Key Insights from Discussions
1. Symmetric solutions may be optimal for small N but asymmetric for large N
2. Focus optimization effort on N values with worst efficiency
3. Winning solutions use extensive compute time and multiple optimization passes
4. Lattice-like patterns emerge in well-optimized configurations
5. Trees tend to interlock with alternating orientations (0°, 90°, 180°, 270°)

## Recommended Experiment Sequence

### Experiment 1: Baseline Verification
- Load best_preoptimized.csv
- Verify score matches 70.658891
- Submit to confirm LB score

### Experiment 2: Lattice Approach for Large N
- Implement grid-based placement for N >= 58
- Use 2-tree base configuration with translation vectors
- Optimize base configuration and translation parameters

### Experiment 3: Small N Optimization
- Focus on N=1 to N=10
- Exhaustive angle search for N=1 (should be 45°)
- Try all combinations for N=2, N=3

### Experiment 4: Extended Optimization
- Run bbox3 or tree_packer_v21 for hours (not minutes)
- Use `-n 20000 -r 256` or higher
- Multiple random seeds

### Experiment 5: Asymmetric Solutions
- Break symmetry in configurations
- Try random perturbations that break symmetry
- Focus on N values where symmetric solutions underperform

## External Resources
- Pre-optimized submissions available in snapshots
- C++ optimizers: bbox3.cpp, tree_packer_v21.cpp, bp.cpp
- Use OpenMP for parallelization (26 threads available)
