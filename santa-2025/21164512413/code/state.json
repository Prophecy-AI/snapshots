{
  "phase": "executor",
  "loop_count": 1,
  "last_submission": null,
  "competition_id": "santa-2025",
  "seed_prompt": "# Santa 2025 - Christmas Tree Packing Optimization\n\n## Problem Overview\nPack Christmas tree toys (15-vertex polygons) into the smallest square bounding box for N=1 to N=200 trees. The score is the sum of (side\u00b2/N) for all configurations. Lower is better.\n\n## Current Status\n- **Best pre-optimized score**: 70.658891\n- **Target score**: 68.919154\n- **Gap**: 1.74 points (2.5%)\n- **Best submission location**: `/home/code/exploration/best_preoptimized.csv`\n\n## CRITICAL INSIGHT: Pre-optimized Submissions Are at Local Optima\nPrevious experiments show that running standard optimizers (bbox3, tree_packer_v21) on pre-optimized submissions finds NO improvements. The gap of 1.74 points requires fundamentally different approaches, not micro-optimization.\n\n## Tree Geometry (15 vertices)\n```python\nTX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]\nTY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]\n```\n- Tree height: 1.0 (from y=-0.2 to y=0.8)\n- Tree width: 0.7 (from x=-0.35 to x=0.35)\n- Trunk: 0.15 wide, 0.2 tall\n\n## Scoring Function\n```python\nfrom shapely.geometry import Polygon\nfrom shapely import affinity\nimport numpy as np\n\ndef score_submission(df):\n    total = 0\n    for n in range(1, 201):\n        group = df[df['id'].str.startswith(f'{n:03d}_')]\n        all_coords = []\n        for _, row in group.iterrows():\n            x = float(str(row['x']).replace('s', ''))\n            y = float(str(row['y']).replace('s', ''))\n            deg = float(str(row['deg']).replace('s', ''))\n            tree = make_tree(x, y, deg)  # Create rotated/translated polygon\n            all_coords.append(np.array(tree.exterior.coords))\n        all_coords = np.vstack(all_coords)\n        side = max(all_coords[:, 0].max() - all_coords[:, 0].min(),\n                   all_coords[:, 1].max() - all_coords[:, 1].min())\n        total += side**2 / n\n    return total\n```\n\n## Top Kernel Approaches\n\n### 1. bbox3.cpp (from jazivxt \"Why Not\" kernel)\n- Complex Number Vector Coordination\n- Fluid Dynamics simulation\n- Hinge Pivot moves\n- Density Gradient Flow\n- Global Boundary Tension\n- Uses aggressive_repair for overlap resolution\n- Parameters: `-n <iterations> -r <rounds>`\n- Uses OpenMP for parallelization\n\n### 2. tree_packer_v21.cpp (from smartmanoj \"Santa Claude\" kernel)\n- Swap moves between trees\n- Multi-angle restarts\n- Higher temperature Simulated Annealing\n- Backward propagation (bp.cpp) - removes trees from larger N configs to improve smaller N\n- Functions: squeeze, compaction, localSearch\n- Parameters: `-n <iterations> -r <rounds>`\n\n### 3. Greedy Placement (from Getting Started kernel)\n- Place trees at weighted random angles (abs(sin(2*angle)))\n- Move toward center until collision\n- Back up until no overlap\n- Uses STRtree for efficient collision detection\n\n## Strategies to Beat Target (Priority Order)\n\n### 1. [HIGHEST PRIORITY] Lattice/Grid-Based Approach for Large N (N >= 58)\nTop solutions use crystalline packing patterns:\n- Start with 2 base trees in optimal configuration\n- Translate in x and y directions to create grid\n- Parameters: `nt = [nx, ny]` where nx*ny >= N\n- This generates tighter packings than random optimization for large N\n\n### 2. [HIGH PRIORITY] Focus on Small N Values (1-10)\nThese have the highest score contribution per tree:\n- N=1: side\u22480.813, contributes ~0.66 to score\n- N=2: side\u22480.950, contributes ~0.45 to score\n- Try exhaustive search for optimal rotation angles\n- For N=1, optimal angle is 45\u00b0 (minimizes bounding box)\n\n### 3. [HIGH PRIORITY] Asymmetric Solutions\nDiscussion insight: \"Why the winning solutions will be Asymmetric\"\n- Symmetric solutions may be optimal for small N but asymmetric for large N\n- Try breaking symmetry in configurations\n\n### 4. [MEDIUM PRIORITY] Much Longer Optimization Runs\nTop solutions run for HOURS, not minutes:\n- `-n 15000+` iterations\n- `-r 80+` rounds\n- Multiple generations with perturbation to escape local optima\n\n### 5. [MEDIUM PRIORITY] Backward Propagation\nStart from N=200, work down to N=2:\n```python\nfor n in range(200, 1, -1):\n    for tree_to_remove in range(n):\n        candidate = remove_tree(config[n], tree_to_remove)\n        if score(candidate) < score(config[n-1]):\n            config[n-1] = candidate\n```\n\n### 6. [MEDIUM PRIORITY] Different Starting Configurations\nInstead of optimizing pre-optimized submission:\n- Generate new random configurations\n- Use lattice-based initial placement\n- Try different angle distributions\n\n## What NOT to Try (Already Proven Ineffective)\n- Short optimization runs on pre-optimized submissions (local optimum is too tight)\n- Simple ensemble of existing solutions (one source dominates all N values)\n- fix_direction post-processing (causes precision loss and overlaps)\n\n## Overlap Detection\n```python\nfrom shapely.strtree import STRtree\n\ndef has_overlap(trees):\n    polygons = [t.polygon for t in trees]\n    tree_index = STRtree(polygons)\n    for i, poly in enumerate(polygons):\n        indices = tree_index.query(poly)\n        for idx in indices:\n            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):\n                return True\n    return False\n```\n\n## Submission Format\n```csv\nid,x,y,deg\n001_0,s0.0,s0.0,s90.0\n002_0,s0.0,s0.0,s90.0\n002_1,s0.202736,s-0.511271,s90.0\n...\n```\n- id: `{n:03d}_{tree_index}` (e.g., 001_0, 002_0, 002_1)\n- x, y, deg: prefixed with 's' to preserve precision\n- Total rows: 20100 (1+2+3+...+200)\n- Coordinates must be within [-100, 100]\n\n## Validation Checklist\n1. No overlapping trees (use has_overlap function)\n2. All coordinates within [-100, 100]\n3. All 200 configurations present (20100 rows)\n4. Values prefixed with 's' in submission\n\n## Key Insights from Discussions\n1. Symmetric solutions may be optimal for small N but asymmetric for large N\n2. Focus optimization effort on N values with worst efficiency\n3. Winning solutions use extensive compute time and multiple optimization passes\n4. Lattice-like patterns emerge in well-optimized configurations\n5. Trees tend to interlock with alternating orientations (0\u00b0, 90\u00b0, 180\u00b0, 270\u00b0)\n\n## Recommended Experiment Sequence\n\n### Experiment 1: Baseline Verification\n- Load best_preoptimized.csv\n- Verify score matches 70.658891\n- Submit to confirm LB score\n\n### Experiment 2: Lattice Approach for Large N\n- Implement grid-based placement for N >= 58\n- Use 2-tree base configuration with translation vectors\n- Optimize base configuration and translation parameters\n\n### Experiment 3: Small N Optimization\n- Focus on N=1 to N=10\n- Exhaustive angle search for N=1 (should be 45\u00b0)\n- Try all combinations for N=2, N=3\n\n### Experiment 4: Extended Optimization\n- Run bbox3 or tree_packer_v21 for hours (not minutes)\n- Use `-n 20000 -r 256` or higher\n- Multiple random seeds\n\n### Experiment 5: Asymmetric Solutions\n- Break symmetry in configurations\n- Try random perturbations that break symmetry\n- Focus on N values where symmetric solutions underperform\n\n## External Resources\n- Pre-optimized submissions available in snapshots\n- C++ optimizers: bbox3.cpp, tree_packer_v21.cpp, bp.cpp\n- Use OpenMP for parallelization (26 threads available)\n",
  "evaluator_feedback": "",
  "latest_experiment": {},
  "competitive_intel": "## Available Competitive Intelligence\n\n- Competition description: `../research/description.md`\n- 5 top kernel notebooks in `../research/kernels/`",
  "target_score": 68.919154316391,
  "manual_instructions": "",
  "messages": [],
  "experiments": [],
  "submissions": [],
  "candidates": [],
  "findings": [],
  "metric_lower_is_better": true,
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "bbox3.cpp optimizer uses: Complex Number Vector Coordination, Fluid Dynamics, Hinge Pivot, Density Gradient Flow, Global Boundary Tension. Key parameters: -n (iterations), -r (rounds). Uses aggressive_repair for overlap resolution. Uses OpenMP for parallelization.",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "tree_packer_v21.cpp uses: Swap moves, Multi-angle restarts, Higher temperature SA, Backward propagation (bp.cpp). Key functions: squeeze, compaction, localSearch. bp.exe removes trees from larger configs to improve smaller ones.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Best pre-optimized submission scores 70.658891. Target is 68.919154. Gap is 1.74 points (2.5%). The scoring uses full tree polygon geometry (15 vertices), not just center coordinates.",
      "source": "exploration analysis",
      "agent": "explorer"
    }
  ],
  "web_research": [],
  "remaining_submissions": 91,
  "max_submissions": 100,
  "last_reset_date_utc": "2026-01-20",
  "start_time": "2026-01-20T08:31:46.433968",
  "time_limit_minutes": 2100,
  "_saved_at": "2026-01-20T08:42:59.868674"
}