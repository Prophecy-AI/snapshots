# Santa 2025 Christmas Tree Packing - Seed Prompt

## Problem Overview
This is a 2D packing optimization problem where we must pack Christmas tree polygons (specific 15-vertex shape) into the smallest square bounding box for N=1 to 200 trees.

**Score formula:** `sum of (side^2 / N) for N=1 to 200`
**Target:** 68.919154 (lower is better)
**Current best public:** ~70.67

The gap of ~1.75 points requires fundamentally better solutions, not just local optimization.

## Tree Geometry
The Christmas tree is a 15-vertex polygon with:
- Trunk: width 0.15, height 0.2
- Base tier: width 0.7
- Middle tier: width 0.4
- Top tier: width 0.25
- Tip at y=0.8
- Reference point at center of trunk top (0, 0)

Vertex coordinates (before rotation):
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## CRITICAL INSIGHT: Local Optimum Problem
**Pre-optimized solutions at ~70.67 are at a STRONG LOCAL OPTIMUM.**

Previous experiments showed:
- bbox3 with -n 50000 -r 256 (1927s): 0 improvement
- SA with various parameters: 0 improvement
- Backward propagation: 0 improvement
- Corner extraction: Only 0.000634 improvement

**LOCAL SEARCH ON PRE-OPTIMIZED DATA = WASTED EXPERIMENTS!**

## REQUIRED APPROACHES (Priority Order)

### 1. Deletion Cascade (HIGHEST PRIORITY)
Generate better small-N configurations by iteratively removing trees from large-N configs:
```python
def deletion_cascade(configs):
    """Propagate good large configs to smaller sizes."""
    best_configs = {n: configs[n] for n in range(1, 201)}
    
    for n in range(200, 1, -1):
        config = best_configs[n]
        best_removal_score = float('inf')
        best_removal_config = None
        
        for i in range(n):
            # Remove tree i
            new_config = remove_tree(config, i)
            new_score = calculate_bbox_score(new_config, n-1)
            
            if new_score < best_removal_score:
                best_removal_score = new_score
                best_removal_config = new_config
        
        # Update if better than current best for n-1
        if best_removal_score < calculate_bbox_score(best_configs[n-1], n-1):
            best_configs[n-1] = best_removal_config
    
    return best_configs
```
This generates NOVEL configurations for smaller N values.

### 2. Grid-Based Initialization with SA
Generate configurations from grid patterns:
```python
def grid_initialization(n, ncols, nrows):
    """Generate grid-based initial configuration."""
    trees = []
    cell_size = 1.0  # Adjust based on tree size
    
    for row in range(nrows):
        for col in range(ncols):
            if len(trees) >= n:
                break
            # Place 2 trees per cell with alternating orientations
            x = col * cell_size
            y = row * cell_size
            trees.append((x, y, 0))  # First tree at 0 degrees
            if len(trees) < n:
                trees.append((x + 0.3, y + 0.3, 180))  # Second tree at 180 degrees
    
    return trees[:n]
```
This explores DIFFERENT SOLUTION BASINS.

### 3. Multi-Start Random Initialization
Generate completely new starting configurations:
```python
def multi_start_random(n, num_restarts=100):
    """Generate random initial configurations and optimize."""
    best_config = None
    best_score = float('inf')
    
    for _ in range(num_restarts):
        # Random placement
        config = random_placement(n)
        # Run SA optimization
        config = simulated_annealing(config)
        score = calculate_bbox_score(config, n)
        
        if score < best_score:
            best_score = score
            best_config = config
    
    return best_config
```

### 4. Bottom-Left Placement with DJD Selection
Use DJD (Djang-Finch) selection heuristic with bottom-left placement:
```python
def djd_bottom_left(n):
    """DJD selection + bottom-left placement."""
    trees = []
    remaining = list(range(n))
    
    while remaining:
        # DJD: Select tree that fits best in remaining space
        best_tree = None
        best_position = None
        best_score = float('inf')
        
        for tree_idx in remaining:
            # Try bottom-left positions
            for angle in [0, 90, 180, 270]:
                pos = find_bottom_left_position(trees, tree_idx, angle)
                if pos is not None:
                    score = evaluate_placement(trees + [pos])
                    if score < best_score:
                        best_score = score
                        best_tree = tree_idx
                        best_position = pos
        
        if best_tree is not None:
            trees.append(best_position)
            remaining.remove(best_tree)
    
    return trees
```

### 5. Corner Extraction from Larger Configs
Extract smaller layouts from corners of larger configurations:
```python
def corner_extraction(large_config, target_n):
    """Extract target_n trees from corner of large_config."""
    corners = [
        (min, min),  # bottom-left
        (max, min),  # bottom-right
        (min, max),  # top-left
        (max, max),  # top-right
    ]
    
    best_config = None
    best_score = float('inf')
    
    for corner_func_x, corner_func_y in corners:
        # Sort trees by distance from corner
        corner_x = corner_func_x([t[0] for t in large_config])
        corner_y = corner_func_y([t[1] for t in large_config])
        
        sorted_trees = sorted(large_config, 
            key=lambda t: (t[0] - corner_x)**2 + (t[1] - corner_y)**2)
        
        extracted = sorted_trees[:target_n]
        score = calculate_bbox_score(extracted, target_n)
        
        if score < best_score:
            best_score = score
            best_config = extracted
    
    return best_config
```

## Key Optimization Techniques

### bbox3 C++ Optimizer
- Simulated annealing with translation and rotation moves
- Squeeze: Scale all trees toward center
- Compaction: Move each tree toward center
- Boundary tree focus: Prioritize trees on bounding box edges

Compile and run:
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp
./bbox3 -i submission.csv -o optimized.csv -n 10000 -r 64
```

### fix_direction Rotation
Optimize global rotation angle to minimize bounding box:
```python
from scipy.optimize import minimize_scalar
from scipy.spatial import ConvexHull

def fix_direction(trees):
    """Optimize global rotation to minimize bounding box."""
    all_points = get_all_polygon_vertices(trees)
    hull_points = all_points[ConvexHull(all_points).vertices]
    
    def bbox_at_angle(angle):
        rotated = rotate_points(hull_points, angle)
        return max(rotated[:, 0].max() - rotated[:, 0].min(),
                   rotated[:, 1].max() - rotated[:, 1].min())
    
    result = minimize_scalar(bbox_at_angle, bounds=(0.001, 89.999), method='bounded')
    return apply_rotation(trees, result.x)
```

### Overlap Detection
Use Shapely STRtree for efficient collision detection:
```python
from shapely.strtree import STRtree

def has_overlap(trees):
    polygons = [get_polygon(t) for t in trees]
    tree_index = STRtree(polygons)
    
    for i, poly in enumerate(polygons):
        candidates = tree_index.query(poly)
        for j in candidates:
            if i != j and poly.intersects(polygons[j]) and not poly.touches(polygons[j]):
                return True
    return False
```

## Implementation Strategy

### Experiment 1: Baseline with Pre-optimized CSV
1. Download pre-optimized santa-2025.csv: `kaggle datasets download smartmanoj/santa-2025-csv`
2. Apply fix_direction optimization
3. Verify score ~70.67
4. This establishes baseline

### Experiment 2: Deletion Cascade
1. Implement deletion cascade algorithm
2. Start from N=200, propagate down to N=1
3. For each N, keep best configuration found
4. Expected improvement: ~0.15 points

### Experiment 3: Grid Initialization + SA
1. Generate grid-based initial configurations for all N
2. Run SA optimization on each
3. Ensemble with deletion cascade results
4. Expected improvement: ~0.2-0.5 points

### Experiment 4: Multi-Start Random for Small N
1. For N=1 to 50, run 100+ random restarts each
2. Small N contributes disproportionately to score
3. Focus optimization effort here
4. Expected improvement: ~0.3-0.5 points

### Experiment 5: Final Ensemble
1. Combine all sources: pre-optimized, deletion cascade, grid, random
2. Select best per-N configuration
3. Apply final fix_direction pass
4. Verify no overlaps

## Per-N Score Analysis
Small N values contribute disproportionately:
- N=1: contributes side^2 / 1 = side^2 (highest weight)
- N=10: contributes side^2 / 10
- N=100: contributes side^2 / 100
- N=200: contributes side^2 / 200 (lowest weight)

**Focus optimization on N=1 to N=50 for maximum impact.**

## Code Resources
- Getting started kernel: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 optimizer: `../research/kernels/jazivxt_why-not/` (bbox3.cpp)
- SA optimizer: `../research/kernels/smartmanoj_santa-claude/` (tree_packer_v21.cpp)
- Pre-optimized CSV: `kaggle datasets download smartmanoj/santa-2025-csv`

## Validation
1. Check for overlaps using Shapely
2. Verify all 200 N values have configurations
3. Calculate score using exact polygon bounds (not just centers)
4. Score must match leaderboard calculation

```python
def validate_and_score(submission_path):
    df = pd.read_csv(submission_path)
    total_score = 0
    
    for n in range(1, 201):
        trees = load_trees_for_n(df, n)
        
        # Check overlaps
        if has_overlap(trees):
            raise ValueError(f"Overlap detected for N={n}")
        
        # Calculate score
        side = get_bounding_box_side(trees)
        score = side**2 / n
        total_score += score
    
    return total_score
```

## Key Constraints
- Coordinates must be in range [-100, 100]
- No overlapping trees (touching is OK)
- Values in submission must be prefixed with 's' (e.g., "s0.123456")

## Expected Progression
1. Baseline: ~70.67
2. After deletion cascade: ~70.5
3. After grid initialization: ~70.0
4. After multi-start random: ~69.5
5. Target: 68.919

## Additional Techniques from Research

### Jostle Algorithm (Local Search)
Iteratively move pieces to reduce overlap and improve packing:
```python
def jostle(trees, iterations=100):
    for _ in range(iterations):
        for i in range(len(trees)):
            # Try small perturbations
            for dx, dy, da in perturbations:
                new_tree = perturb(trees[i], dx, dy, da)
                if not causes_overlap(trees, i, new_tree):
                    if improves_score(trees, i, new_tree):
                        trees[i] = new_tree
    return trees
```

### Nonlinear Programming for Overlap Minimization
Use scipy.optimize to minimize overlap:
```python
from scipy.optimize import minimize

def minimize_overlap(trees):
    def objective(x):
        # x contains all tree positions and angles
        return total_overlap_area(x)
    
    x0 = flatten_trees(trees)
    result = minimize(objective, x0, method='L-BFGS-B')
    return unflatten_trees(result.x)
```

The target requires finding configurations that don't exist in public solutions.
Focus on CONSTRUCTIVE approaches that generate NEW solutions, not optimization of existing ones.
