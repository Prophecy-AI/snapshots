# Santa 2025 Christmas Tree Packing - Seed Prompt

## Problem Overview
This is a 2D packing optimization problem where we must pack Christmas tree polygons (specific 15-vertex shape) into the smallest square bounding box for N=1 to 200 trees.

**Score formula:** `sum of (side^2 / N) for N=1 to 200`
**Target:** 68.919154 (lower is better)
**Current best public:** ~70.67

The gap of ~1.75 points requires fundamentally better solutions, not just local optimization.

## Tree Geometry
The Christmas tree is a 15-vertex polygon with:
- Trunk: width 0.15, height 0.2
- Base tier: width 0.7
- Middle tier: width 0.4
- Top tier: width 0.25
- Tip at y=0.8
- Reference point at center of trunk top (0, 0)

## CRITICAL INSIGHT: Local Optimum Problem
**Pre-optimized solutions at ~70.67 are at a STRONG LOCAL OPTIMUM.**

Previous experiments showed:
- bbox3 with -n 50000 -r 256 (1927s): 0 improvement
- SA with various parameters: 0 improvement
- Backward propagation: 0 improvement
- Corner extraction: Only 0.000634 improvement

**LOCAL SEARCH ON PRE-OPTIMIZED DATA = WASTED EXPERIMENTS!**

## REQUIRED APPROACHES (Priority Order)

### 1. Deletion Cascade (HIGHEST PRIORITY)
Generate better small-N configurations by iteratively removing trees from large-N configs:
```
For N = 200 down to 2:
    For each tree i in config:
        Create config_without_i = remove tree i
        Calculate new bounding box
    Keep the removal that minimizes bounding box
    If better than current best for (N-1), save it
```
This generates NOVEL configurations for smaller N values.

### 2. Grid-Based Initialization with SA
Generate configurations from grid patterns:
```
For various (ncols, nrows) combinations:
    Place trees in grid pattern (2 trees per cell, alternating orientations)
    Add extra trees at edges for non-multiple counts
    Run SA optimization on grid configuration
```
This explores DIFFERENT SOLUTION BASINS.

### 3. Multi-Start Random Initialization
Generate completely new starting configurations:
```
For each N from 1 to 200:
    For restart in range(100):
        Generate random initial placement
        Run SA optimization
        Keep best result
```

### 4. Corner Extraction from Larger Configs
Extract smaller layouts from corners of larger configurations:
```
For each large N config (N=100 to 200):
    For each corner (min_x, min_y), (max_x, min_y), etc.:
        Sort trees by distance from corner
        Take first M trees (M < N)
        If better than current best for M, save it
```

### 5. Ensemble Best-of-N Selection
After generating multiple solutions per N:
```
For each N:
    Select configuration with smallest bounding box
    Apply fix_direction rotation optimization
    Verify no overlaps
```

## Key Optimization Techniques

### bbox3 C++ Optimizer
- Simulated annealing with translation and rotation moves
- Squeeze: Scale all trees toward center
- Compaction: Move each tree toward center
- Boundary tree focus: Prioritize trees on bounding box edges

### fix_direction Rotation
Optimize global rotation angle to minimize bounding box:
```python
def fix_direction(trees):
    hull_points = get_convex_hull(all_tree_vertices)
    best_angle = minimize_scalar(
        lambda a: calculate_bbox_side_at_angle(a, hull_points),
        bounds=(0.001, 89.999)
    )
    return apply_rotation(trees, best_angle)
```

### Overlap Detection
Use Shapely STRtree for efficient collision detection:
- Point-in-polygon test
- Segment intersection test
- Bounding box pre-filter

## Implementation Strategy

### Experiment 1: Baseline with Pre-optimized CSV
1. Copy pre-optimized santa-2025.csv from datasets
2. Apply fix_direction optimization
3. Verify score ~70.67
4. This establishes baseline

### Experiment 2: Deletion Cascade
1. Implement deletion cascade algorithm
2. Start from N=200, propagate down to N=1
3. For each N, keep best configuration found
4. Expected improvement: ~0.15 points

### Experiment 3: Grid Initialization + SA
1. Generate grid-based initial configurations
2. Run SA optimization on each
3. Ensemble with deletion cascade results
4. Expected improvement: ~0.2-0.5 points

### Experiment 4: Multi-Start Random
1. For small N (1-50), run many random restarts
2. Small N contributes disproportionately to score
3. Focus optimization effort here

### Experiment 5: Final Ensemble
1. Combine all sources: pre-optimized, deletion cascade, grid, random
2. Select best per-N configuration
3. Apply final fix_direction pass
4. Verify no overlaps

## Per-N Score Analysis
Small N values contribute disproportionately:
- N=1: contributes side^2 / 1 = side^2
- N=200: contributes side^2 / 200

Focus optimization on N=1 to N=50 for maximum impact.

## Code Resources
- Getting started kernel: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 optimizer: `../research/kernels/jazivxt_why-not/` (bbox3.cpp)
- SA optimizer: `../research/kernels/smartmanoj_santa-claude/` (tree_packer_v21.cpp)
- Pre-optimized CSV: Download from kaggle datasets `smartmanoj/santa-2025-csv`

## Validation
1. Check for overlaps using Shapely
2. Verify all 200 N values have configurations
3. Calculate score using exact polygon bounds (not just centers)
4. Score must match leaderboard calculation

## Key Constraints
- Coordinates must be in range [-100, 100]
- No overlapping trees (touching is OK)
- Values in submission must be prefixed with 's' (e.g., "s0.123456")

## Expected Progression
1. Baseline: ~70.67
2. After deletion cascade: ~70.5
3. After grid initialization: ~70.0
4. After multi-start random: ~69.5
5. Target: 68.919

The target requires finding configurations that don't exist in public solutions.
Focus on CONSTRUCTIVE approaches that generate NEW solutions, not optimization of existing ones.
