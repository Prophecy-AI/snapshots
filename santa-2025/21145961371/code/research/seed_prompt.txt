# Santa 2025 Christmas Tree Packing - Evolved Seed Prompt (Loop 6)

## Current Status
- Best CV score: 70.676102 from exp_000 (baseline)
- Best LB score: 70.676102 (confirmed via 2 submissions)
- Target: 68.919154 | Gap: 1.757 points (2.55%)
- Experiments: 6 | All at same score (70.676102)
- Submissions: 3/100 used, 97 remaining

## Critical Situation Assessment

**LOCAL SEARCH IS EXHAUSTED.** After 6 experiments:
- ✅ bbox3 with 160k iterations - no improvement
- ✅ Parallel SA with 800k iterations per N - no improvement
- ✅ Deletion cascade - no improvement
- ✅ Random initialization - much worse
- ✅ Lattice without SA - much worse
- ✅ Full ensemble of 30 CSVs - same score

**The baseline is at a GLOBAL OPTIMUM for local search methods.**

## Response to Evaluator

The evaluator correctly identified that:
1. Local search is exhausted - I fully agree
2. The egortrushin lattice + SA approach hasn't been properly tried - this is the key insight
3. We need to pivot to fundamentally different approaches

**I agree with the evaluator's assessment.** The next experiment MUST implement the egortrushin lattice + SA approach properly, which optimizes grid TRANSLATION PARAMETERS (dx, dy), not just tree positions. This explores DIFFERENT solution basins.

## CV-LB Relationship Analysis
- CV = LB exactly (gap is 0.000002)
- Our scoring function is accurate
- No distribution shift - this is a deterministic optimization problem

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY] Egortrushin Lattice + SA**

The egortrushin kernel uses a fundamentally different approach:
- Creates 2 initial trees at specific positions
- SA optimizes translation parameters (dx, dy) and angles
- The grid is created by tiling these 2 trees with translation (dx, dy)
- This explores DIFFERENT solution basins, not local search from baseline

**Implementation from egortrushin kernel:**
```python
# Key insight: SA optimizes the GRID PARAMETERS, not individual tree positions

class SimulatedAnnealing:
    def __init__(self, trees, nt, Tmax, Tmin, nsteps, ...):
        self.trees = trees  # 2 initial trees
        self.nt = nt  # grid dimensions [ncols, nrows]
        # SA will optimize: dx, dy (translation), and angles
    
    def solve(self):
        # SA perturbs dx, dy, angles to minimize bounding box
        # The grid is created by tiling the 2 trees with translation (dx, dy)
        pass

# For N=72, use nt=[4, 9] (4 columns, 9 rows, 2 trees per cell = 72 trees)
initial_trees = [ChristmasTree("0", "0", "0"), ChristmasTree("0.4", "0.4", "180")]
sa = SimulatedAnnealing(initial_trees, nt=[4, 9], Tmax=1.0, Tmin=0.0001, nsteps=100000)
score, trees_72 = sa.solve()
```

**Target N values for lattice approach:**
- N=72: nt=[4, 9] (4 columns, 9 rows, 2 trees per cell)
- N=100: nt=[5, 10]
- N=110: nt=[5, 11]
- N=144: nt=[6, 12]
- N=156: nt=[6, 13]
- N=196: nt=[7, 14]
- N=200: nt=[7, 15] (use first 200 of 210)

### 2. **[HIGH PRIORITY] Basin Hopping**

If lattice + SA doesn't work, try basin hopping:
- Randomly perturb ALL trees by large amounts (e.g., 0.5 units)
- Run local optimization (bbox3 or SA)
- Repeat many times, keep best result
- This escapes local optima by jumping to different basins

### 3. **[MEDIUM PRIORITY] Genetic Algorithm with Crossover**

- Maintain population of different solutions
- Crossover: combine trees from different solutions
- Mutation: random perturbations
- Selection: keep best solutions
- This explores the solution space more globally

### 4. **[MEDIUM PRIORITY] Symmetric Packing Patterns**

The discussion "Symmetric solutions that are apparently optimal" (42 votes) suggests:
- Symmetric packings may be provably optimal for certain N values
- Investigate symmetric packing patterns for specific N values

## What NOT to Try
- ❌ More local search on the baseline (exhausted)
- ❌ bbox3 or parallel SA with more iterations (won't help)
- ❌ Deletion cascade (already tried)
- ❌ Random initialization without optimization (much worse)
- ❌ Simple lattice without SA optimization (much worse)

## Validation Notes
- CV = LB exactly (no gap)
- Use float_format='%.18f' when saving CSV to avoid precision loss
- Verify no overlaps before submission

## SUBMISSION STRATEGY
- Remaining submissions: 97
- **Submit after EVERY experiment** - we have abundant submissions
- LB feedback is free information - USE IT!

## Key Files
- Baseline: /home/code/experiments/001_baseline/santa-2025.csv
- Egortrushin kernel: /home/code/research/kernels/egortrushin_santa25-simulated-annealing-with-translations/
- Parallel SA: /home/code/experiments/006_parallel_sa/sa_v1_parallel.cpp

## Summary

After 6 experiments with zero improvement, we've confirmed that the baseline is at a global optimum for local search. The next step MUST be a PIVOT to the egortrushin lattice + SA approach, which:
1. Explores DIFFERENT solution basins (not local search from baseline)
2. Optimizes translation parameters (dx, dy), not just tree positions
3. Is specifically designed for large N values where lattice patterns are natural
4. Has NOT been properly tried yet (previous attempt was without SA)

The target (68.919154) is 2.55% better than the baseline. This gap cannot be closed by local optimization - it requires finding a different solution basin.
