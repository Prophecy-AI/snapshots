# Santa 2025 Christmas Tree Packing - Evolved Seed Prompt (Loop 7)

## Current Status
- Best CV score: 70.676102 from exp_000 (baseline)
- Best LB score: 70.676102 (confirmed via 2 submissions)
- Target: 68.919154 | Gap to target: 1.757 points (2.55%)
- Experiments: 7 (all stuck at 70.676102)

## Response to Evaluator

The evaluator correctly identified that the lattice+SA implementation is broken:
1. The SA is not finding any improvements (best_length stays constant)
2. The initial configuration likely has overlaps
3. The perturbation deltas may be too large

**Key insight from my analysis:**
- I checked ALL CSV files across ALL snapshots (714 files)
- Every file with a score better than 70.676102 has COLLISIONS
- The 70.676102 baseline is the BEST VALID solution available
- This confirms the baseline is at a TRUE GLOBAL OPTIMUM for public approaches

**The gap to target (1.757 points) requires approaches NOT in public kernels.**

## Critical Findings

1. **All "better" solutions have collisions:**
   - 51.42 score: 199 N values with collisions
   - 67.72 score: 30 N values with collisions
   - 70.59 score: 78 N values with collisions
   - 70.66 score: 7 N values with collisions
   - Our 70.676102: 0 collisions (VALID)

2. **The leaderboard shows scores down to 68.919154 are achievable:**
   - Top teams have found solutions 2.55% better than public kernels
   - These solutions are NOT shared publicly
   - We need to discover novel approaches

3. **What we've tried (all failed):**
   - bbox3 C++ optimizer: No improvement
   - sa_v1_parallel C++ optimizer: No improvement
   - Deletion cascade: No improvement
   - Random initialization: Much worse
   - Lattice without SA: Much worse
   - Lattice with SA: SA not working (broken implementation)

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY] Fix the Lattice+SA Implementation**

The egortrushin kernel approach is fundamentally different from local search:
- It optimizes TRANSLATION PARAMETERS (lengthx, lengthy), not tree positions
- It uses a `translate()` function to create grids from 2 base trees
- It uses `get_length()` to find the minimum translation that avoids collisions

**Key differences from our broken implementation:**
1. The egortrushin kernel uses `get_length()` which iteratively reduces lengthx/lengthy until collision
2. Our implementation used fixed dx=0.6, dy=0.6 which may cause overlaps
3. The egortrushin kernel's SA perturbs the BASE TREES, then recalculates optimal translations

**To fix:**
```python
# Start with larger spacing to avoid overlaps
initial_lengthx = 1.0
initial_lengthy = 1.0

# Use get_length() to find minimum valid translation
lengthx, lengthy = get_length(base_trees, initial_lengthx, initial_lengthy)

# SA should perturb base trees, then recalculate translations
```

### 2. **[HIGH PRIORITY] Try Different Grid Configurations**

The egortrushin kernel tests specific grid sizes:
- N=72: [4, 9] grid (4x9x2 = 72)
- N=100: [5, 10] grid
- N=144: [6, 12] grid
- N=196: [7, 14] grid

But there may be BETTER grid configurations:
- N=72: Try [3, 12], [6, 6], [2, 18]
- N=100: Try [4, 13], [10, 5]
- Different aspect ratios may pack better

### 3. **[MEDIUM PRIORITY] Symmetric Packing Patterns**

The discussion "Symmetric solutions that are apparently optimal" (42 votes) suggests:
- For certain N values, symmetric packings may be provably optimal
- Perfect squares (N=4, 9, 16, 25, ...) may have special symmetric solutions
- Triangular numbers may have hexagonal packings

### 4. **[MEDIUM PRIORITY] Basin Hopping**

Instead of local SA, try:
1. Large random perturbation (completely new configuration)
2. Local optimization (SA or gradient descent)
3. Accept if better, otherwise try another random perturbation
4. Repeat many times

This explores different basins, not just the local optimum.

### 5. **[LOW PRIORITY] Genetic Algorithm**

- Population of different configurations
- Crossover: combine good parts of two configurations
- Mutation: small random changes
- Selection: keep best configurations

## What NOT to Try

- ❌ More local search on the baseline (exhausted - 7 experiments confirm this)
- ❌ Ensemble of existing CSVs (all converge to same solution)
- ❌ Backward propagation (already tried, no improvement)
- ❌ Random initialization without optimization (produces much worse results)

## Validation Notes

- CV scheme: Calculate score for each N, sum all 200 scores
- Our scoring function matches LB exactly (confirmed via 2 submissions)
- Collision detection is critical - many "better" solutions have overlaps

## SUBMISSION STRATEGY

- Remaining submissions: 93
- Submit after EVERY experiment that produces a valid submission
- We need LB feedback to calibrate our approaches
- Even if score doesn't improve, submit to confirm CV-LB alignment

## Key Insight for Next Experiment

The egortrushin kernel's approach is fundamentally different:
1. It doesn't optimize individual tree positions
2. It optimizes the TRANSLATION PARAMETERS that define the grid
3. The `get_length()` function finds the minimum valid translation
4. SA perturbs the base trees, then recalculates optimal translations

**Implement this correctly and it may find improvements the local search cannot.**

The target (68.919154) IS achievable - the leaderboard proves it. We just need to find the right approach.
