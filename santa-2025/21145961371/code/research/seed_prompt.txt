# Santa 2025 Christmas Tree Packing - Evolved Seed Prompt (Loop 3)

## Current Status
- Best CV score: 70.676102 from exp_000 (baseline)
- Best LB score: 70.676102 (verified)
- Target: 68.919154 | Gap to target: 1.757 points (2.55%)
- Submissions used: 2/100 (94 remaining)

## Response to Evaluator

The evaluator correctly identified that:
1. The deletion cascade found ZERO improvements - confirming the baseline is at a very strong local optimum
2. All three experiments (baseline, ensemble, deletion cascade) converge to the same score
3. We need to try FUNDAMENTALLY DIFFERENT approaches that explore different solution basins

I agree with the evaluator's assessment. The key insight is that the pre-optimized solutions from the Kaggle community are already at a strong local optimum. Local search methods (SA, deletion cascade, combining solutions) cannot escape this optimum.

**The evaluator's top priority recommendation is correct**: Multi-start random initialization for small N (1-20) is the right next step. However, I want to add that we should also try:
1. Grid/lattice initialization for larger N
2. Using the bbox3 C++ optimizer for fast refinement after generating new initial configurations

## CV-LB Relationship Analysis
- We have 2 submissions, both at exactly 70.676102
- CV-LB gap is essentially zero (0.000002)
- Our scoring function is accurate - no calibration needed

## Key Findings from Analysis

1. **N=1 is already optimal**: The baseline uses 45° rotation which gives the minimum bounding box (0.813173 side, 0.661250 score). No improvement possible here.

2. **Small N values contribute most**: N=1-15 have the highest per-N scores (0.38-0.66 each). These are the best targets for improvement.

3. **bbox3 C++ optimizer is available**: Located at `/home/nonroot/snapshots/santa-2025/21116303805/code/bbox3`. Can be used for fast refinement.

4. **Pre-optimized solutions are at strong local optimum**: Three experiments confirmed this. We cannot improve by:
   - Combining existing solutions
   - Deletion cascade
   - Local search/SA on existing solutions

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Multi-Start Random Initialization for Small N (2-20)

Since N=1 is already optimal, focus on N=2 to N=20. For each N:
- Generate 10,000+ random configurations
- Keep only non-overlapping ones
- Recenter and calculate score
- Use bbox3 to refine the best ones

```python
def random_initialization(n, num_restarts=10000):
    best_config = None
    best_score = float('inf')
    
    for _ in range(num_restarts):
        trees = []
        for i in range(n):
            x = np.random.uniform(-2, 2)
            y = np.random.uniform(-2, 2)
            deg = np.random.uniform(0, 360)
            trees.append((x, y, deg))
        
        if not has_overlap(trees):
            trees = recenter_trees(trees)
            score = get_bounding_box_side(trees)**2 / n
            if score < best_score:
                best_score = score
                best_config = trees
    
    return best_config, best_score
```

### 2. **[HIGH PRIORITY]** Grid/Lattice Initialization for Large N (50-200)

The discussions mention that crystalline/lattice packings are mathematically superior for large N. Try:
- Hexagonal lattice with alternating up/down trees
- Square lattice with 45° rotation
- Optimize lattice parameters (spacing, offset)

Use the lattice generator from snapshots:
`/home/nonroot/snapshots/santa-2025/21129624106/code/experiments/002_lattice_init/lattice_generator.py`

### 3. **[MEDIUM PRIORITY]** Use bbox3 for Post-Processing

After generating new initial configurations, use bbox3 for fast refinement:
```bash
/home/nonroot/snapshots/santa-2025/21116303805/code/bbox3 -i input.csv -o output.csv -n 50000 -r 256
```

### 4. **[MEDIUM PRIORITY]** Exhaustive Rotation Search for Small N

For N=2-10, try exhaustive rotation search:
- For each tree, try all angles from 0-360° in 0.1° increments
- This is computationally tractable for small N

## What NOT to Try

1. ❌ More local search on existing baseline (proven ineffective)
2. ❌ Deletion cascade (already tried, 0 improvements)
3. ❌ Combining existing solutions (already tried, no improvement)
4. ❌ SA with different parameters (same local optimum)

## SUBMISSION STRATEGY

- Remaining submissions: 94
- **Submit after EVERY experiment** - we have abundant submissions
- LB feedback is free information - use it to calibrate approaches

## Validation Notes

- CV scheme: Calculate bounding box side for each N, score = side^2 / N, total = sum over all N
- Precision: Use `%.18f` format when saving to preserve full precision
- Overlap check: Use Shapely for accurate polygon intersection detection

## Technical Notes

1. **Precision is critical**: When loading/saving CSV, use `dtype=str` and strip 's' prefix manually
2. **bbox3 usage**: The C++ optimizer is much faster than Python. Use it for refinement.
3. **Overlap validation**: Always validate for overlaps before submission

## Expected Outcome

If multi-start random initialization finds better configurations for even a few N values, we could see meaningful improvement. The target is 1.757 points below current score - this requires finding better configurations for multiple N values.

## Files to Reference

- Baseline: `/home/code/experiments/001_baseline/santa-2025.csv`
- bbox3: `/home/nonroot/snapshots/santa-2025/21116303805/code/bbox3`
- Lattice generator: `/home/nonroot/snapshots/santa-2025/21129624106/code/experiments/002_lattice_init/lattice_generator.py`
- Pre-optimized solutions: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`
