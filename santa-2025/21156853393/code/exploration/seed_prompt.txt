# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (15 vertices each) into the smallest possible square bounding box for each N from 1 to 200 trees.

**Scoring**: score = Σ(side_n² / n) for n=1 to 200, where side_n is the bounding box side length for n trees.
**Target Score**: 68.919154 (lower is better)
**Current Best Available**: ~70.68 from pre-optimized public submissions

## Critical Insights from Previous Experiments

### What DOESN'T Work (Already Tried)
1. **Short optimization runs** - The pre-optimized submissions are at tight local optima
2. **Simple ensemble** - One source (santa-2025.csv) dominates all N values
3. **Backward propagation alone** - Found no improvements on pre-optimized data
4. **Standard SA on pre-optimized CSV** - Cannot escape local optimum

### What MIGHT Work (Needs More Exploration)
1. **Much longer optimization runs** - Hours, not minutes (top solutions use -n 15000+ -r 80+)
2. **Lattice/grid-based approach for large N** - Fundamentally different from random optimization
3. **Focus on small N values (1-10)** - Highest score contribution per tree
4. **Multiple random restarts with different seeds**
5. **Greedy backtracking with beam search** - Build solutions from scratch

## Key Optimization Techniques from Top Kernels

### 1. bbox3 Binary Optimizer (jazivxt/why-not)
C++ optimizer with:
- Complex Number Vector Coordination
- Fluid Dynamics simulation
- Hinge Pivot moves
- Density Gradient Flow
- Global Boundary Tension
- Parameters: `-n <iterations>` `-r <rounds>`
- Uses OpenMP parallelization

### 2. tree_packer_v21 (smartmanoj/santa-claude)
C++ optimizer with:
- Swap moves between trees
- Multi-angle restarts
- Higher temperature Simulated Annealing
- Squeeze, compaction, localSearch phases
- Backward propagation (bp.cpp) - removes trees from larger configs

### 3. fix_direction Post-Processing
- Optimizes global rotation angle to minimize bounding box
- Uses scipy.optimize.minimize_scalar
- Rotates entire configuration, not individual trees
- Apply after main optimization

### 4. Overlap Repair Strategy
- Validate for overlaps after optimization
- Replace overlapping configurations with known-good donor file
- Use STRtree for efficient collision detection

## Recommended Experiment Strategy

### Experiment 1: Extended Optimization Run
```bash
# Compile bbox3 or tree_packer_v21
g++ -O3 -march=native -std=c++17 -fopenmp -o optimizer optimizer.cpp

# Run with extended parameters (hours, not minutes)
./optimizer -n 20000 -r 128

# Apply fix_direction
python fix_direction.py submission.csv

# Validate and repair overlaps
python validate_and_repair.py submission.csv donor.csv
```

### Experiment 2: Lattice-Based Approach for Large N
For N >= 58, try crystalline packing:
```python
# Start with 2 base trees in optimal configuration
# Translate them in x and y directions to create grid
# nt = [rows, cols] such that rows * cols >= N
# Optimize base configuration and translation vectors
```

### Experiment 3: Focus on Small N (1-10)
These contribute most to score:
- N=1: side=0.813, contributes 0.66 to score
- N=2: side=0.950, contributes 0.45 to score
- Try exhaustive search for optimal rotation angles
- The tree has 15 vertices - try all 360 degrees in 0.001 increments

### Experiment 4: Greedy Backtracking with Beam Search
Build solutions from scratch instead of optimizing pre-optimized:
```python
def greedy_backtracking(n, beam_width=10, max_depth=10):
    # Start with empty configuration
    # For each tree to add:
    #   - Try multiple positions and angles
    #   - Keep top beam_width candidates
    #   - Backtrack if stuck
    # Return best configuration found
```

### Experiment 5: Multi-Start Random Initialization
```python
for seed in range(100):
    config = generate_random_config(n, seed)
    optimized = run_optimizer(config)
    if score(optimized) < best_score:
        best = optimized
```

## ChristmasTree Polygon Definition
```python
# 15-vertex polygon (trunk + 3 tiers)
vertices = [
    (0.0, 0.8),      # Tip
    (0.125, 0.5),    # Right top tier
    (0.0625, 0.5),
    (0.2, 0.25),     # Right mid tier
    (0.1, 0.25),
    (0.35, 0.0),     # Right base
    (0.075, 0.0),    # Right trunk
    (0.075, -0.2),
    (-0.075, -0.2),  # Left trunk
    (-0.075, 0.0),
    (-0.35, 0.0),    # Left base
    (-0.1, 0.25),    # Left mid tier
    (-0.2, 0.25),
    (-0.0625, 0.5),  # Left top tier
    (-0.125, 0.5),
]
```

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- id: `{n:03d}_{tree_index}` (e.g., 001_0, 002_0, 002_1)
- x, y, deg: prefixed with 's' to preserve precision
- Total rows: 20100 (1+2+3+...+200)
- Coordinates must be in [-100, 100]

## Validation Checklist
1. No overlapping trees (use STRtree + intersects check)
2. All coordinates within [-100, 100]
3. All 200 configurations present (20100 rows)
4. Values prefixed with 's' in submission

## Key Code Snippets

### Overlap Detection
```python
from shapely.strtree import STRtree

def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

### Scoring Function
```python
def get_total_score(submission_df):
    total = 0
    for n in range(1, 201):
        trees = load_trees_for_n(submission_df, n)
        xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])
        side = max(xys.max(axis=0) - xys.min(axis=0))
        total += side**2 / n
    return total
```

### fix_direction Implementation
```python
from scipy.optimize import minimize_scalar
from scipy.spatial import ConvexHull

def optimize_rotation(trees):
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points_np = np.array(all_points)
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    def bbox_at_angle(angle_deg):
        angle_rad = np.radians(angle_deg)
        c, s = np.cos(angle_rad), np.sin(angle_rad)
        rot_matrix = np.array([[c, s], [-s, c]])
        rotated = hull_points.dot(rot_matrix.T)
        return max(rotated.max(axis=0) - rotated.min(axis=0))
    
    res = minimize_scalar(bbox_at_angle, bounds=(0.001, 89.999), method='bounded')
    return res.x, res.fun
```

## External Resources
- Pre-optimized submissions available in Kaggle datasets
- bbox3 binary optimizer (compiled C++)
- tree_packer_v21.cpp source code
- Interactive editor for manual adjustments

## Strategy to Beat Target (68.919154)

1. **Start with best available pre-optimized submission** (~70.68)
2. **Run extended optimization** (hours with -n 20000 -r 256)
3. **Apply fix_direction multiple passes**
4. **Try lattice approach for large N** (N >= 58)
5. **Focus on small N values** (1-10) with exhaustive search
6. **Generate new random starting configurations** and optimize
7. **Ensemble best results from multiple runs**
8. **Validate thoroughly before each submission**

The gap of ~1.75 points requires reducing average side by ~0.053 units across all N values. This is achievable with the right combination of techniques and sufficient compute time.
