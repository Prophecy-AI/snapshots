# Christmas Tree Packing Optimization - Seed Prompt

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree toys (15-vertex irregular polygons) into the smallest possible square bounding box for N=1 to N=200 trees.

**Scoring:** score = Σ(side_length² / N) for all N from 1 to 200. Lower is better.
**Target Score:** Beat 68.922808

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Trunk: 0.15 width × 0.2 height (at bottom)
- Base tier: 0.7 width at y=0
- Mid tier: 0.4 width at y=0.25
- Top tier: 0.25 width at y=0.5
- Tip: at y=0.8
- Trees can be rotated (0-360 degrees) and positioned at (x, y)

## Submission Format
- CSV with columns: id, x, y, deg
- Values prefixed with 's' (e.g., "s0.123456")
- id format: "NNN_T" where NNN is tree count (001-200), T is tree index

## Top Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (from jazivxt_why-not and saspav_santa-submission)
The most effective approach uses a compiled C++ optimizer called "bbox3" with:
- Simulated annealing with complex number vector coordination
- Fluid dynamics-inspired movement
- Hinge pivot rotations
- Density gradient flow
- Global boundary tension
- Multi-phase optimization with increasing timeouts

**Key parameters:**
- `-n`: number of iterations (1000-10000)
- `-r`: rotation granularity (30-256)
- Run in phases: Phase A (2 min), Phase B (10 min), Phase C (20 min)

**Implementation:** See `../research/kernels/jazivxt_why-not/why-not.ipynb` for bbox3.cpp source code

### 2. Rotation Tightening (fix_direction)
After optimization, apply rotation tightening to minimize bounding box:
```python
from scipy.optimize import minimize_scalar
from scipy.spatial import ConvexHull

def optimize_rotation(trees):
    # Get convex hull of all tree polygon points
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    # Find optimal rotation angle (0-90 degrees)
    res = minimize_scalar(
        lambda a: calculate_bbox_side_at_angle(a, hull_points),
        bounds=(0.001, 89.999), method='bounded'
    )
    return res.x, res.fun
```

### 3. Backward Propagation (from smartmanoj_santa-claude)
For N=200 down to N=2:
1. Start with N-tree configuration
2. Try removing each boundary-touching tree
3. If resulting (N-1) config is better than current best for N-1, save it
4. Continue removing trees until no improvement

This leverages larger configurations to improve smaller ones.

### 4. Greedy Tree Placement (baseline from getting-started)
For building initial configurations:
1. Place first tree at origin
2. For each new tree:
   - Start at distance 20 from center at random weighted angle
   - Weight by |sin(2*angle)| to prefer corners
   - Move inward until collision
   - Back up until no overlap
3. Try 10 random angles, keep best placement

### 5. Overlap Repair
When optimizer creates overlaps:
```python
def repair_overlaps(target_csv, donor_csv):
    # For each N with overlap, replace with donor configuration
    for n in failed_overlap_n:
        replace_group(target_csv, donor_csv, f'{n:03d}')
```

## Recommended Experiment Strategy

### Experiment 1: Baseline with Pre-optimized CSV
1. Download best available pre-optimized submission from Kaggle datasets
2. Apply fix_direction rotation tightening
3. Validate no overlaps
4. Submit to establish baseline score

### Experiment 2: bbox3 Optimization
1. Compile bbox3.cpp with: `g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp`
2. Run multi-phase optimization:
   - Phase A: Short runs (2 min) with various n,r combinations
   - Phase B: Medium runs (10 min) on top candidates
   - Phase C: Long runs (20 min) on best few
3. Apply fix_direction after each phase
4. Repair any overlaps with donor configurations

### Experiment 3: Backward Propagation
1. Start from best submission
2. Run backward propagation from N=200 to N=2
3. For each N, try removing boundary trees to improve N-1

### Experiment 4: Greedy Backtracking with Beam Search
Build solutions from scratch using constructive approach:
1. For each N from 1 to 200:
   - Use beam search with BEAM=10, DEPTH=10
   - Try multiple tree placements at each step
   - Keep top-k configurations
2. This is fundamentally different from local search on pre-optimized data

### Experiment 5: Random Restarts
1. Generate completely new random initial configurations
2. Apply bbox3 optimization from random start
3. Compare with pre-optimized baseline

## Key Optimization Techniques

### Collision Detection
Use Shapely library with STRtree for efficient spatial indexing:
```python
from shapely.strtree import STRtree
tree_index = STRtree(placed_polygons)
possible_indices = tree_index.query(candidate_poly)
```

### Scoring Function
```python
def get_score(trees, n):
    bounds = unary_union([t.polygon for t in trees]).bounds
    side = max(bounds[2] - bounds[0], bounds[3] - bounds[1])
    return side**2 / n
```

### Decimal Precision
Use Python's Decimal for high precision:
```python
from decimal import Decimal, getcontext
getcontext().prec = 30
```

## Critical Implementation Notes

1. **Pre-optimized baselines are at local optimum** - Simple local search (SA, parameter tuning) won't improve them significantly
2. **Constructive approaches needed** - Build solutions tree-by-tree rather than just optimizing existing
3. **Rotation is key** - The fix_direction step can significantly reduce bounding box
4. **Overlap validation required** - Always check for overlaps before submission
5. **Use external datasets** - Best kernels use pre-computed optimized CSVs from Kaggle datasets

## External Resources
- Pre-optimized submissions available on Kaggle datasets (e.g., "santa-2025-csv", "bucket-of-chump")
- bbox3 binary and source code in kernel datasets

## Validation
Always validate submissions:
```python
def validate_submission(file_path, max_n=200):
    for n in range(1, max_n + 1):
        trees = load_configuration(n, df)
        if has_overlap(trees):
            return False, n
    return True, None
```
