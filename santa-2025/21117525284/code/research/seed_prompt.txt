# Christmas Tree Packing Optimization - Seed Prompt (Loop 4)

## Current Status
- Best CV score: 70.682741 from exp_002 (003_preoptimized_baseline_with_overlap_repair)
- Best LB score: 70.682741 (verified - perfect CV-LB alignment!)
- Target: 68.922808 | Gap to target: 1.76 points (2.5%)

## CV-LB Relationship Analysis
- **Perfect alignment**: CV = LB (gap: 0.0000)
- This is an OPTIMIZATION problem, not a prediction problem
- No distribution shift - what we compute locally IS the LB score
- All improvements in CV will directly translate to LB improvements

## Response to Evaluator

The evaluator correctly identified the ROOT CAUSE of the problem:

1. ✅ **C++ overlap detection mismatch is BLOCKING**: The jonathanchan C++ optimizer improved score from 70.68 to 51.66 but introduced overlaps in 176/200 N configurations. When validated with Python/Shapely, these were detected as overlaps and repaired, returning the score to 70.68.

2. ✅ **The optimizer IS working**: The C++ code found better configurations (51.66 vs 70.68), but they're invalid because the C++ overlap detection differs from Python/Shapely.

3. ✅ **Pure Python approach needed**: The evaluator recommended either fixing C++ overlap detection or using a pure Python optimizer with Shapely. I agree - we need to use Shapely for overlap detection.

4. ✅ **Backpacking approach**: The crodoc kernel shows a backward iteration approach that uses Shapely. The egortrushin kernel also has a pure Python SA with Shapely collision detection.

**Key insight**: The pre-optimized baselines are at a local optimum for overlap-free configurations. All 12 N values where best_ensemble.csv is better have overlaps. We need a DIFFERENT approach to escape this local optimum.

## What's Been Tried (and Results)
1. **Greedy placement** (exp_000): Score 164.09 - too far from target
2. **Grid baseline + bbox3** (exp_001): Score 88.14 - better but still far
3. **Pre-optimized baseline** (exp_002): Score 70.68 - close to target!
   - bbox3 optimizer: No improvement (already at local optimum)
   - fix_direction rotation: No improvement (already rotation-optimized)
   - Backward propagation: Tiny improvement (0.0017 points)
   - Ensemble of CSVs: Tiny improvement (0.003 points)
4. **jonathanchan C++ SA optimizer** (exp_003): Score 70.68 after repair
   - Optimizer improved to 51.66 but 176/200 had overlaps
   - After repair with donor configs, returned to 70.68
   - **ROOT CAUSE**: C++ overlap detection differs from Python/Shapely

## Key Findings from Analysis
1. **C++ overlap detection is not strict enough**: Uses point-in-polygon and segment intersection tests that differ from Shapely's algorithm
2. **All improvements in best_ensemble.csv have overlaps**: The 12 N values where it's better all have overlaps
3. **Pre-optimized baselines are at local optimum**: For overlap-free configurations
4. **egortrushin kernel has pure Python SA**: Uses Shapely for collision detection, guarantees valid results

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Pure Python SA Optimizer with Shapely
Implement a Python-based simulated annealing optimizer that uses Shapely for overlap detection:

**Key components from egortrushin kernel:**
```python
def has_collision(trees: list[ChristmasTree]) -> bool:
    """Check for collisions between trees using Shapely"""
    if len(trees) <= 1:
        return False
    for i, tree1 in enumerate(trees):
        for j, tree2 in enumerate(trees):
            if i < j:
                if tree1.polygon.intersects(tree2.polygon) and not tree1.polygon.touches(tree2.polygon):
                    return True
    return False
```

**SA parameters from egortrushin:**
- Tmax=1.0, Tmin=0.001
- nsteps=10000, nsteps_per_T=100
- position_delta=0.1, angle_delta=10.0
- cooling="exponential", alpha=0.99

**Implementation steps:**
1. Load repaired_baseline.csv as starting point
2. For each N from 1 to 200:
   - Run SA with Shapely collision detection
   - Only accept moves that don't create overlaps
   - Save if score improves
3. Run backward propagation at the end

### 2. **[HIGH PRIORITY]** Backward Propagation with Shapely (crodoc approach)
Start from N=200 and work backward to N=1:
1. For each N from 199 down to 1:
   - Take the N+1 configuration
   - Try removing each tree
   - If resulting N-config is better than current best for N AND has no overlaps, use it
2. Uses Shapely for overlap detection (guaranteed correct)

**Key difference from previous attempt**: Use Shapely for overlap detection, not C++ code.

### 3. **[MEDIUM PRIORITY]** smartmanoj tree_packer_v21 + backward propagation
The smartmanoj kernel has a sophisticated C++ optimizer with:
- tree_packer_v21: Multi-start SA with swap moves, squeeze, compaction, local search
- bp.cpp: Backward propagation

**BUT**: This also uses C++ overlap detection, so may have the same issue. Only try if Python approaches don't work.

### 4. **[LOW PRIORITY]** Fix C++ Overlap Detection
Modify the C++ overlap() function to use a stricter tolerance:
```cpp
bool overlap(const Poly& a, const Poly& b) {
    // Add buffer to bounding box check
    double buffer = 1e-6;
    if (a.x1 + buffer < b.x0 || b.x1 + buffer < a.x0 || 
        a.y1 + buffer < b.y0 || b.y1 + buffer < a.y0) return false;
    
    // Use stricter point-in-polygon test
    // ...
}
```

This is risky because we don't know exactly how Shapely's algorithm differs.

## What NOT to Try
- ❌ More C++ optimization without fixing overlap detection (will just create invalid configs)
- ❌ More ensemble of existing CSVs (already maxed out at 70.679)
- ❌ Building from scratch (pre-optimized baselines are much better)
- ❌ Simple local search on existing configs (already at local optimum)

## SUBMISSION STRATEGY
- **Remaining submissions: 93** (abundant!)
- **Submit after EVERY experiment** - LB feedback is free information
- This is an optimization problem with perfect CV-LB alignment
- Every improvement in CV will directly translate to LB improvement

## Validation Notes
- Score = Σ(side_length² / N) for N=1 to 200
- Lower is better
- Must have NO overlaps for valid submission
- CV = LB for this problem (no distribution shift)
- **ALWAYS validate with Shapely before saving**

## Technical Notes
- Python/Shapely is the ground truth for overlap detection
- C++ optimizers produce invalid results due to overlap detection mismatch
- egortrushin kernel code in: /home/code/research/kernels/egortrushin_santa25-simulated-annealing-with-translations/
- crodoc backpacking kernel code in: /home/code/research/kernels/crodoc_74-75-backpacking-christmas-trees/
- Pre-optimized CSVs in: /home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/
