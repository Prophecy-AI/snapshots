# Christmas Tree Packing Optimization - Evolved Seed Prompt (Loop 1)

## Current Status
- Best CV score: 164.09 from exp_000 (greedy baseline)
- Best LB score: N/A (no submissions yet)
- Target: 68.922808 | Gap to target: 95.17 points (138% worse)

## Public Kernel Status (CRITICAL!)
- Have we implemented the best kernel yet? **NO**
- Top kernels identified:
  1. jazivxt/why-not - uses bbox3 optimizer + pre-optimized CSV
  2. saspav/santa-submission - uses bbox3 + fix_direction + pre-optimized CSV
  3. zaburo/88-32999-a-well-aligned-initial-solution - grid placement, scores 88.33
  4. jonathanchan/santa25-ensemble-sa-fractional-translation - ensemble approach
- Kernels we've implemented: None (only custom greedy)
- Kernels still to implement: ALL OF THEM
- **STOP - implement best kernel FIRST!**

## Key Analysis Findings
1. **Grid placement (zaburo) scores 88.33** - much better than our greedy 164.09
2. **Score contribution is equal across N ranges** - all N values matter equally
3. **Top kernels use pre-optimized CSVs** from Kaggle datasets (bucket-of-chump, santa-2025-csv)
4. **Ensemble approach** - take best configuration for each N from multiple sources

## Response to Evaluator
The evaluator correctly identified the critical issue: we're building from scratch when top kernels start from pre-optimized CSVs. The evaluator's recommendation to "PIVOT IMMEDIATELY" is correct.

**Specific actions based on evaluator feedback:**
1. ✅ Confirmed: bbox3.cpp compiles and runs (but on bad starting point)
2. ✅ Confirmed: fix_direction is implemented
3. ❌ NOT DONE: Use pre-optimized baseline CSV
4. ❌ NOT DONE: Multi-phase bbox3 optimization
5. ❌ NOT DONE: Backward propagation

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Implement Grid-Based Baseline (zaburo kernel)
- Score: 88.33 (vs our 164.09)
- Implementation: Alternating rows with 0/180 degree rotations
- This is a constructive approach that doesn't need external data
- **DO THIS FIRST** as it's self-contained

### 2. **[HIGH PRIORITY]** Apply bbox3 Multi-Phase Optimization to Grid Baseline
After getting the 88.33 baseline:
- Phase A: 2-minute runs with various n,r combinations
- Phase B: 10-minute runs on top candidates  
- Phase C: 20-minute runs on best few
- Apply fix_direction after each phase

### 3. **[HIGH PRIORITY]** Implement Backward Propagation
From smartmanoj kernel:
- For N=200 down to N=2
- Try removing boundary-touching trees
- Check if resulting (N-1) config is better than current best

### 4. **[MEDIUM PRIORITY]** Ensemble Multiple Approaches
From jonathanchan kernel:
- Take best configuration for each N from multiple sources
- Sources: grid baseline, bbox3-optimized, backward propagation results

### 5. **[LOWER PRIORITY]** Fractional Translation Refinement
From jonathanchan kernel:
- After SA, apply micro-translations (0.001, 0.0005, etc.)
- 8 directions per tree
- Can squeeze out extra precision

## What NOT to Try
- ❌ More greedy placement variations (already proven inferior)
- ❌ Random initialization without structure (won't reach competitive scores)
- ❌ Short bbox3 runs on bad starting points (waste of time)

## Validation Notes
- CV scheme: Calculate total score = Σ(S²/N) for N=1 to 200
- Always validate for overlaps before submission
- Use Shapely STRtree for efficient collision detection

## SUBMISSION STRATEGY
- Remaining submissions: 94
- Submit after this experiment? **YES** - we have abundant submissions and need LB feedback
- Submit the grid baseline after optimization to establish a proper baseline on LB

## Next Experiment: 002_grid_baseline_with_optimization
1. Implement zaburo's grid placement for all N=1 to 200
2. Apply fix_direction rotation tightening
3. Run bbox3 optimizer for 10-15 minutes
4. Validate no overlaps
5. Submit to get LB feedback

Expected score: ~85-88 (grid baseline with some optimization)

## Reference Code (from zaburo kernel)
```python
def find_best_trees(n: int) -> tuple[float, list[ChristmasTree]]:
    best_score, best_trees = float("inf"), None
    for n_even in range(1, n + 1):
        for n_odd in [n_even, n_even - 1]:
            all_trees = []
            rest = n
            r = 0
            while rest > 0:
                m = min(rest, n_even if r % 2 == 0 else n_odd)
                rest -= m
    
                angle = 0 if r % 2 == 0 else 180
                x_offset = 0 if r % 2 == 0 else Decimal("0.7") / 2
                y = r // 2 * Decimal("1.0") if r % 2 == 0 else (Decimal("0.8") + (r - 1) // 2 * Decimal("1.0"))
                row_trees = [ChristmasTree(center_x=Decimal("0.7") * i + x_offset, center_y=y, angle=angle) for i in range(m)]
                all_trees.extend(row_trees)
    
                r += 1
            xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T / 1e15 for t in all_trees])
    
            min_x, min_y = xys.min(axis=0)
            max_x, max_y = xys.max(axis=0)

            score = max(max_x - min_x, max_y - min_y) ** 2
            if score < best_score:
                best_score = score
                best_trees = all_trees
    return best_score, best_trees
```

## bbox3 Compilation and Usage
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp
./bbox3 -i submission.csv -o submission.csv -n 5000 -t 600
```
