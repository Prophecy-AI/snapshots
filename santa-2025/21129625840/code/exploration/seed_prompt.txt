# Seed Prompt: Santa 2025 Tree Packing

## Problem Definition
- **Goal:** Pack $n$ identical irregular polygons ("Christmas Trees") into the smallest square box.
- **Instances:** $n = 1$ to $200$.
- **Metric:** Minimize $\sum_{n=1}^{200} \frac{s_n^2}{n}$.
- **Key Characteristic:** All items are **IDENTICAL**. This enables specific "Lattice Packing" techniques.

## Top Approaches

### 1. Lattice Packing (Periodic Packing) - CRITICAL for Large $N$
Since trees are identical, the optimal packing in the limit ($N \to \infty$) is a periodic lattice.
- **Single-Lattice:** All trees have rotation $\theta$. Placed at $i \cdot \vec{v}_1 + j \cdot \vec{v}_2$.
- **Double-Lattice:** Trees alternate rotations (e.g., $\theta$ and $\theta + 180^\circ$). This is highly likely to be optimal due to the tree's triangular shape (interlocking).
- **Strategy:**
    1.  Optimize the "Unit Cell" (1 or 2 trees) to minimize area.
    2.  Variables: Rotation $\theta$, Lattice vectors $\vec{v}_1, \vec{v}_2$.
    3.  Generate $N$ trees using this lattice.
    4.  Crop/adjust the lattice to fit a square aspect ratio.

### 2. No-Fit Polygon (NFP) - CRITICAL for Speed
- **Concept:** The NFP of polygon A and B is the locus of points where B touches A.
- **Usage:** If point $P$ is outside $NFP_{AB}$, then A and B do not overlap.
- **Benefit:** Reduces collision detection from complex polygon intersection to simple "point in polygon" check.
- **Implementation:** Precompute NFP for the specific tree shape at discrete angles (or just the optimal lattice angle).

### 3. Global Optimization (Small/Medium $N$)
- **Simulated Annealing (SA):**
    -   State: Positions $(x_i, y_i)$ and Rotations $\theta_i$.
    -   Moves: Translate single tree, Rotate single tree, Swap two trees.
    -   Objective: Minimize bounding box + Penalty for overlap.
    -   Cooling: Slow cooling allows settling into dense configurations.
- **Guided Local Search (GLS):** Penalize specific overlaps to force the solver to explore new configurations.

### 4. Physics-Based "Shaking" (Refinement)
- **Jostle Heuristic:**
    -   Apply "gravity" towards the center.
    -   Resolve overlaps by moving trees apart (repulsion).
    -   Iterate until stable.
    -   Use this to "tighten" a loose lattice packing into a square box.

## Recommended Experiments
1.  **Lattice Search:** Write a script to find the optimal density for:
    -   Same rotation (0 deg).
    -   Alternating rotation (0 and 180 deg).
    -   Free rotation (optimize $\theta$).
2.  **NFP Generation:** Generate the NFP for the tree with itself.
3.  **SA Solver:** Implement a Simulated Annealing solver using `shapely` (or NFP if possible) to solve for $N=1..50$ where boundary effects dominate.
4.  **Hybrid:** For $N=51..200$, generate a lattice patch, then compress it using the "Jostle" method.

## Tools & Libraries
- **Shapely:** For polygon operations (intersection, union, NFP via Minkowski sum if supported or manual).
- **Scipy.optimize:** For optimizing lattice parameters.
- **Matplotlib:** For visualizing packings.

## Data Insights
- Tree shape has "tiers". Interlocking is key.
- Inverted trees (180 deg) likely fit into the gaps of upright trees.
- The problem asks for a *square* box, so we must arrange the lattice to form a square (e.g., $\sqrt{N} \times \sqrt{N}$ grid).
