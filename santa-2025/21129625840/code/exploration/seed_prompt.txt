# Seed Prompt: Santa 2025 Tree Packing

## Problem Definition
- **Goal:** Pack $n$ identical irregular polygons ("Christmas Trees") into the smallest square box.
- **Instances:** $n = 1$ to $200$.
- **Metric:** Minimize $\sum_{n=1}^{200} \frac{s_n^2}{n}$.
- **Key Characteristic:** All items are **IDENTICAL**. This enables specific "Lattice Packing" techniques.

## Top Approaches

### 1. Lattice Packing (Periodic Packing) - CRITICAL for Large $N$
Since trees are identical, the optimal packing in the limit ($N \to \infty$) is a periodic lattice.
- **Single-Lattice:** All trees have rotation $\theta$. Placed at $i \cdot \vec{v}_1 + j \cdot \vec{v}_2$.
- **Double-Lattice:** Trees alternate rotations (e.g., $\theta$ and $\theta + 180^\circ$). This is highly likely to be optimal due to the tree's triangular shape (interlocking).
- **Strategy:**
    1.  Optimize the "Unit Cell" (1 or 2 trees) to minimize area.
    2.  Variables: Rotation $\theta$, Lattice vectors $\vec{v}_1, \vec{v}_2$.
    3.  Generate $N$ trees using this lattice.
    4.  Crop/adjust the lattice to fit a square aspect ratio.

### 2. Global Optimization (Small/Medium $N$)
- **Simulated Annealing (SA):**
    -   State: Positions $(x_i, y_i)$ and Rotations $\theta_i$.
    -   Moves: Translate single tree, Rotate single tree, Swap two trees.
    -   Objective: Minimize bounding box + Penalty for overlap.
    -   Cooling: Slow cooling allows settling into dense configurations.
- **Guided Local Search (GLS):** Penalize specific overlaps to force the solver to explore new configurations.

### 3. Physics-Based "Shaking" (Refinement)
- **Jostle Heuristic:**
    -   Apply "gravity" towards the center.
    -   Resolve overlaps by moving trees apart (repulsion).
    -   Iterate until stable.
    -   Use this to "tighten" a loose lattice packing into a square box.

## Technical Implementation
- **Collision Detection:** The kernel uses `shapely.strtree.STRtree`. This is efficient enough for $N=200$. Stick with it.
- **No-Fit Polygon (NFP):** Conceptually useful for understanding valid placements, but exact computation might be complex. Use `STRtree` for practical collision checking.
- **Precision:** Use `Decimal` as in the kernel to avoid floating point errors, or high-precision float libraries if performance allows.

## Recommended Experiments
1.  **Lattice Search:** Write a script to find the optimal density for:
    -   Same rotation (0 deg).
    -   Alternating rotation (0 and 180 deg).
    -   Free rotation (optimize $\theta$).
2.  **SA Solver:** Implement a Simulated Annealing solver using `shapely` to solve for $N=1..50$ where boundary effects dominate.
3.  **Hybrid:** For $N=51..200$, generate a lattice patch, then compress it using the "Jostle" method.

## Data Insights
- Tree shape has "tiers". Interlocking is key.
- Inverted trees (180 deg) likely fit into the gaps of upright trees.
- The problem asks for a *square* box, so we must arrange the lattice to form a square (e.g., $\sqrt{N} \times \sqrt{N}$ grid).
