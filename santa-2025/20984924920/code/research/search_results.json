{
  "query": "how to handle floating point precision overlap in polygon packing competition",
  "results": [
    {
      "title": "ANSWER",
      "text": "**How to avoid floating\u2011point overlap errors in a polygon\u2011packing competition**\u202f([Managing Rounding Error](https://www.pbr-book.org/4ed/Shapes/Managing_Rounding_Error),\u202f[JTS FAQ \u2013 Robustness and Precision](https://locationtech.github.io/jts/jts-faq.html),\u202f[Shapely Polygons that should touch don\u2019t](https://stackoverflow.com/questions/59936859/shapely-polygons-that-should-touch-dont))  \n\n1. **Adopt a fixed\u2011precision model** \u2013 before any geometry operation, scale all input coordinates to an integer grid (e.g., multiply by\u202f10\u2076) and store them as integers. JTS/GEOS can then enforce a *PrecisionModel* that snaps every coordinate to the grid, eliminating most rounding\u2011error accumulation\u202f([JTS FAQ](https://locationtech.github.io/jts/jts-faq.html)).  \n\n2. **Apply a tiny \u201cepsilon\u201d buffer** to each polygon when testing for overlaps. A positive buffer (e.g.,\u202f`polygon.buffer(1e\u20119)`) expands the shape just enough to compensate for tiny numerical gaps, while a negative buffer can shrink it to detect spurious contacts\u202f([Managing Rounding Error](https://www.pbr-book.org/4ed/Shapes/Managing_Rounding_Error)).  \n\n3. **Use robust predicates from a proven library** (JTS, GEOS, Shapely). Call `intersects`, `overlaps`, or `touches` on the buffered, integer\u2011scaled geometries; these libraries implement exact arithmetic for the overlay step and respect the chosen precision model\u202f([JTS FAQ \u2013 Robustness](https://locationtech.github.io/jts/jts-faq.html)).  \n\n4. **Treat \u201coverlap\u201d as a non\u2011zero intersection area**. After a predicate returns true, compute `intersection.area`. If the area is \u2264\u202f\u03b5 (the same epsilon used for buffering), treat the polygons as merely touching and discard the overlap; otherwise, reject the placement\u202f([Shapely example](https://stackoverflow.com/questions/59936859/shapely-polygons-that-should-touch-dont)).  \n\n5. **Integrate the check into the packing loop** \u2013 each time a polygon is placed, run steps\u202f2\u20114 against all already\u2011placed polygons. If an illegal overlap is detected, backtrack or apply a local\u2011search move (e.g., differential evolution, tabu search) to relocate the offending piece\u202f([General Heuristic Approach for Maximum Polygon Packing](https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.86/LIPIcs.SoCG.2024.86.pdf)).  \n\n6. **Validate the final solution with the official validator** (e.g., the CG:SHOP 2024 validator) to ensure that any remaining contacts are within the allowed tolerance. Adjust the scaling factor or epsilon if the validator reports false overlaps.  \n\nFollowing these steps\u2014fixed\u2011precision scaling, epsilon buffering, and robust library predicates\u2014keeps floating\u2011point rounding from turning legitimate contacts into false overlaps during polygon packing.",
      "url": ""
    },
    {
      "title": "Managing Rounding Error",
      "text": "Managing Rounding Error\n[**](#)\n## 6.8 Managing Rounding Error**\nThus far, we have been discussing ray&ndash;shape intersection algorithms with respect to idealized arithmetic operations based on the real numbers.\nThis approach has gotten us far, although the fact that computers can only\nrepresent finite quantities and therefore cannot actually represent all\nthe real numbers is important. In place of real numbers, computers use\nfloating-point numbers, which have fixed storage requirements. However,\nerror may be introduced each time a floating-point operation is performed,\nsince the result may not be representable in the designated amount of memory.\nThe accumulation of this error has several implications for the accuracy of\nintersection tests. First, it is possible that it will cause valid\nintersections to be missed completely&mdash;for example, if a computed\nintersection&rsquo;stvalue is negative even though the precise value is positive.\nFurthermore, computed ray&ndash;&ndash;shape intersection points may be above or below\nthe actual surface of the shape. This leads to a problem: when new rays are traced\nstarting from computed intersection points for shadow rays and reflection\nrays, if the ray origin is below the actual surface, we may find an\nincorrect reintersection with the surface. Conversely, if the origin is\ntoo far above the surface, shadows and reflections may appear\ndetached. (See Figure[6.38](#fig:fp-isect-errors).)\n[![](pha06f38.svg)](pha06f38.svg)\nFigure 6.38: Geometric Settings for Rounding-Error Issues That Can Cause\nVisible Errors in Images.The incident ray on the\nleft intersects the surface. On the left, the computed intersection\npoint (black circle) is slightly below the surface and a too-low\n&ldquo;epsilon&rdquo; offsetting the origin of the shadow ray leads to an incorrect\nself-intersection, as the shadow ray origin (white circle) is still below\nthe surface; thus the light is incorrectly determined to be occluded. On\nthe right, a too-high &ldquo;epsilon&rdquo; causes a valid intersection to be\nmissed as the ray&rsquo;s origin is past the occluding surface.\nTypical practice to address this issue in ray tracing is to offset spawned\nrays by a fixed &ldquo;ray epsilon&rdquo; value, ignoring any intersections along the raynormal p Subscript Baseline plus t bold dcloser than somet Subscript normal m normal i normal nvalue.\nFigure[6.39](#fig:tmin-bad)shows why this approach requires fairly hight Subscript normal m normal i normal nvalues to work effectively: if the spawned ray is oblique to\nthe surface, incorrect ray intersections may occur quite some distance from\nthe ray origin. Unfortunately, larget Subscript normal m normal i normal nvalues cause ray origins to\nbe relatively far from the original intersection points, which in turn can\ncause valid nearby intersections to be missed, leading to loss of fine\ndetail in shadows and reflections.\n[![](pha06f39.svg)](pha06f39.svg)\nFigure 6.39:If the computed intersection point (filled\ncircle) is below the surface and the spawned ray is oblique, incorrect\nreintersections may occur some distance from the ray origin (open\ncircle). If a minimumtvalue along the ray is used to discard nearby\nintersections, a relatively larget Subscript normal m normal i normal nis needed to handle oblique\nrays well.\nIn this section, we will introduce the ideas underlying floating-point\narithmetic and describe techniques for analyzing the error in\nfloating-point computations. We will then apply these methods to the\nray&ndash;shape algorithms introduced earlier in this chapter and show how to\ncompute ray intersection points with bounded error. This will allow us to\nconservatively position ray origins so that incorrect self-intersections\nare never found, while keeping ray origins extremely close to the actual\nintersection point so that incorrect misses are minimized. In turn, no\nadditional &ldquo;ray epsilon&rdquo; values are needed.\n[**](#Floating-PointArithmetic)\n### 6.8.1 Floating-Point Arithmetic\nComputation must be performed on a finite representation of numbers that\nfits in a finite amount of memory; the infinite set of real numbers cannot\nbe represented on a computer. One such finite representation is\nfixed point, where given a 16-bit integer, for example, one might\nmap it to positive real numbers by dividing by 256. This would allow us to\nrepresent the rangeleft-bracket 0 comma 65535 slash 256 right-bracket equals left-bracket 0 comma 255 plus 255 slash 256 right-bracketwith equal\nspacing of1 slash 256between values. Fixed-point numbers can be implemented\nefficiently using integer arithmetic operations (a property that made them\npopular on early PCs that did not support floating-point computation), but\nthey suffer from a number of shortcomings; among them, the maximum number\nthey can represent is limited, and they are not able to accurately represent\nvery small numbers near zero.\nAn alternative representation for real numbers on computers is\nfloating-point numbers. These are based on representing numbers\nwith a sign, a significand,&dagger;and an exponent:\nessentially, the same representation as scientific notation but with a\nfixed number of digits devoted to significand and exponent. (In the\nfollowing, we will assume base-2 digits exclusively.) This representation\nmakes it possible to represent and perform computations on numbers with a\nwide range of magnitudes while using a fixed amount of storage.\nProgrammers using floating-point arithmetic are generally aware that\nfloating-point values may be inaccurate; this understanding sometimes leads to a belief\nthat floating-point arithmetic is unpredictable. In this section we will see\nthat floating-point arithmetic has a carefully designed foundation that in\nturn makes it possible to compute conservative bounds on the error\nintroduced in a particular computation. For ray-tracing calculations, this\nerror is often surprisingly small.\nModern CPUs and GPUs nearly ubiquitously implement a model of\nfloating-point arithmetic based on a standard promulgated by the Institute\nof Electrical and Electronics Engineers ([1985](Further_Reading.html#cite:IEEE1985),[2008](Further_Reading.html#cite:IEEE2008)). (Henceforth\nwhen we refer to floats, we will specifically be referring to 32-bit\nfloating-point numbers as specified by IEEE 754.) The IEEE 754 technical\nstandard specifies the format of floating-point numbers in memory as well\nas specific rules for precision and rounding of floating-point\ncomputations; it is these rules that make it possible to reason rigorously\nabout the error present in a computed floating-point value.\n[**](#x1-Floating-PointRepresentation)\n#### Floating-Point Representation\nThe IEEE standard specifies that 32-bit floats are represented with a sign\nbit, 8 bits for the exponent, and 23 bits for the significand. The\nexponent stored in a float ranges from0 to 255. We will denote it bye Subscript normal b, with the subscript indicating that it is biased; the actual exponent\nused in computation,e, is computed as\ne equals e Subscript normal b Baseline minus 127 period\n([6.17](#eq:float-exponent-bias))\nThe significand actually has24bits of precision when a*normalized*floating-point value is stored. When a number expressed\nwith significand and exponent is normalized, there are no leading0s in\nthe significand. In binary, this means that the leading digit of the\nsignificand must be one; in turn, there is no need to store this value\nexplicitly. Thus, the implicit leading1 digit with the 23 digits\nencoding the fractional part of the\nsignificand gives a total of 24 bits of precision.\nGiven a signs equals plus-or-minus 1, significandm, and biased exponente Subscript normal b, the corresponding floating-point value is\ns times 1 period m times 2 Superscript e Super Subscript normal b Superscript minus 127 Baseline period\nFor example, with a normalized significand, the floating-point number 6.5\nis written as1.101 Subscript 2 Baseline times 2 squared, where the 2 subscript ...",
      "url": "https://www.pbr-book.org/4ed/Shapes/Managing_Rounding_Error"
    },
    {
      "title": "A General Heuristic Approach for Maximum Polygon Packing",
      "text": "A General Heuristic Approach for Maximum\nPolygon Packing\nCanhui Luo #\nHuazhong University of Science and Technology, Wuhan, China\nZhouxing Su1 #\nHuazhong University of Science and Technology, Wuhan, China\nZhipeng L\u00fc #\nHuazhong University of Science and Technology, Wuhan, China\nAbstract\nThis work proposes a general heuristic packing approach to address the Maximum Polygon Packing\nProblem introduced by the CG:SHOP 2024 Challenge. Our solver primarily consists of two steps:\n(1) Partitioning the container and polygons to form a series of small-scale subproblems; (2) For each\nsubproblem, sequentially placing polygons into the container and attempting to eliminate overlaps.\n2012 ACM Subject Classification Theory of computation \u2192 Computational geometry; Computing\nmethodologies \u2192 Search methodologies\nKeywords and phrases packing, polygon, heuristic, differential evolution, local search, tabu search\nDigital Object Identifier 10.4230/LIPIcs.SoCG.2024.86\nCategory CG Challenge\nFunding This work was supported in part by the National Natural Science Foundation of China\n(NSFC) under Grant 72101094 and the Special Project for Knowledge Innovation of Hubei Province\nunder Grant 2022013301015175.\nAcknowledgements We want to thank the organizers of CG:SHOP 2024 and all other participants\nfor creating such an engaging challenge. We also want to thank Dominik Krupke for providing a\nhelpful official validator for solutions.\n1 Introduction\nThe recent CG:SHOP 2024 Challenge introduced a variant of irregular packing problems\nknown as the Maximum Polygon Packing (MPP) problem. The MPP problem involves a\nconvex polygonal container C and a polygon set P = {p1, p2, ..., pN }, where polygon piis\nassociated with a value vi. It seeks for a non-overlapping packing with the maximum total\nvalue. The challenge presents a total of 180 instances whose number of polygons ranges from\n28 to 50,000. The official document [4] gives a detailed description of the challenge.\nOur proposed algorithm employs a general process to solve these instances indiscriminately,\nand the overall framework is presented in Figure 1. We first partition a large-scale problem\ninto multiple small-scale subproblems (Section 2) and then solve each subproblem using\nupper-level polygon ordering (Section 3.1) and lower-level packing optimization techniques\n(Section 3.2). Section 4 presents our experimental results, followed by conclusions.\n1 Corresponding author: Zhouxing Su\n\u00a9 Canhui Luo, Zhouxing Su, and Zhipeng L\u00fc;\nlicensed under Creative Commons License CC-BY 4.0\n40th International Symposium on Computational Geometry (SoCG 2024).\nEditors: Wolfgang Mulzer and Jeff M. Phillips; Article No. 86; pp. 86:1\u201386:9\nLeibniz International Proceedings in Informatics\nSchloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik, Dagstuhl Publishing, Germany\n86:2 A General Heuristic Approach for Maximum Polygon Packing\nInput polygon set P and container C\nUpper-level polygon ordering\nLower-level packing optimization\nFinished?\n \nPacking\nAssemble and return the complete solution\nMPP1 MPP2 MPPm\n( ) 0? Overlap Scurr== ( ) Update Sbest best\nReturn S\nPartitioning\nYes\nNo\nYes\nNo\nSelect next one\nFigure 1 The framework of our proposed algorithm.\n2 Partitioning\nIn this section, we present the decomposition of the original large-scale problem into a series\nof smaller MPP subproblems. It involves two components: partitioning the container C into\nmultiple regions and assigning polygons to each region.\n2.1 Container Partitioning\nThe container partitioning process consists of two steps, as shown in Figure 2. Initially, we\narrange two-dimensional square grids starting from the bottom-left corner of the bounding\nbox until the entire container is covered. The subregions formed by the intersection of the\ncontainer with all the grids constitute its partition C = C1 \u222a C2 \u222a ... \u222a Cm. Subsequently,\nwe merge the small subregions with adjacent grids, which are difficult to be used effectively.\nThe grid is dimensioned to keep the scale of each subproblem at approximately 300 polygons,\nmaking a trade-off between effectiveness and efficiency of lower-level packing optimization.\n2.2 Polygon Assignment\nWe adopt a simple approach of randomly assigning polygons to each subregion. Specifically, for\neach subregion Ci, we randomly select a polygon pj from P until\nP\nj\narea(pj )\narea(Ci) \u2265\nPN\ni=0\narea(pi)\narea(C)\n.\nThe advantage of random assignment lies in ensuring that the overall characteristics of each\nsubproblem align with the original problem.\nC. Luo, Z. Su, and Z. L\u00fc 86:3\nFigure 2 The partitioning process for the instance jigsaw_cf1_4fd4c46e. Step 1 (left): Cover the\ncontainer with squares; Step 2: Intersect and merge small regions (from the middle to the right).\nminimum translation\nminimum translation\nIFP\nContainer\nFigure 3 Examples of NFP between two polygons and IFP between container and polygon.\n3 Packing\n3.1 Upper-Level Polygon Ordering\nWe define a priority for each polygon. We repeatedly select one remaining polygon with the\nhighest priority (ties are broken by value) and try to insert it into the current solution. If the\ninsertion with lower-level packing optimization fails, we skip the current polygon and turn to\nthe next one. For the majority of instances, the priority is defined as the value-to-area ratio\nof a polygon (we also call it unit value). Polygons with higher unit values are prioritized\nfor putting in the container, which is called the Unit Value First (UVF) strategy. For\nsmall-scale instances (N < 100), we employ the \u03b1\u03b2-random strategy. It randomly selects\n\u03b1% and \u03b2% of the polygons and reassigns their UVF-based priority to the highest and the\nlowest, respectively. These instances are run for multiple times to ensure comprehensive\noptimization, with \u03b1 and \u03b2 set to 10 in our implementation.\n3.2 Lower-Level Packing Optimization\nThe position of a polygon can be represented by the coordinates l = (x, y) of a reference point,\nsuch as the bottom-left corner of the boundary. Then, the translation of a polygon can be\nrepresented by a vector pointing from its original position to its new position. Given a feasible\npacking S and a polygon p to be placed, it is impossible to find a non-overlapping position\nfor p without moving other polygons in most cases. This section introduces the algorithm for\neliminating overlaps for an invalid packing, which involves solving an unconstrained nonlinear\nproblem and heuristic polygon movement.\nS o C G 2 0 2 4\n86:4 A General Heuristic Approach for Maximum Polygon Packing\n3.2.1 Overlap Minimization\nTo determine the appropriate translation for the polygons, we utilized the no-fit polygon\n(NFP) and inner-fit polygon (IFP), which are fundamental in algorithmic approaches to\ngeometric design and optimization challenges. For a fixed polygon pi and a movable polygon\npj , NFP(pi, pj ) describes their non-overlapping positions with boundaries in contact precisely,\nwhich can be utilized to determine the minimum translation for pj to avoid overlap. Similarly,\nIFP(pi, pj ) is employed to determine the minimum translation to place pj inside pi. Figure 3\nillustrates the polygon translations determined using NFP (left) and IFP (right). The readers\nmay refer to Burke et al. [2] for a more detailed description.\nFor a packing S, based on NFP and IFP, we define the overlap between polygons pi\nand pj as fij (S), representing the minimum translation to separate them, and f0i(S) as the\nminimum translation for moving pi to fit into the container. Subsequently, we employ the\nseparation algorithm proposed by Imamichi et al. [7] to minimize the overlap, which involves\nsolving an unconstrained nonlinear programming problem as follows:\nmin\nS\nF(S) = X\n0\u2264i<j\u2264N\nf\n2\nij (S) (1)\nThe model relaxes the non-overlapping constraint but introduces repulsion forces between\nany two overlapped polygons. We use the classic L-BFGS (limited memory BFGS) method\nto solve this problem. It makes the packing S converge to a local optimum but strongly\ndepends on the initial layout. ...",
      "url": "https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.86/LIPIcs.SoCG.2024.86.pdf"
    },
    {
      "title": "Shapely Polygons that should touch don't",
      "text": "##### Collectives\u2122 on Stack Overflow\n\nFind centralized, trusted content and collaborate around the technologies you use most.\n\n[Learn more about Collectives](https://stackoverflow.com/collectives)\n\n**Teams**\n\nQ&A for work\n\nConnect and share knowledge within a single location that is structured and easy to search.\n\n[Learn more about Teams](https://stackoverflow.co/teams/)\n\nGet early access and see previews of new features.\n\n[Learn more about Labs](https://stackoverflow.co/labs/)\n\n# [Shapely Polygons that should touch don't](https://stackoverflow.com/questions/59936859/shapely-polygons-that-should-touch-dont)\n\n[Ask Question](https://stackoverflow.com/questions/ask)\n\nAsked4 years, 5 months ago\n\nModified [4 years, 5 months ago](https://stackoverflow.com/questions/59936859/shapely-polygons-that-should-touch-dont?lastactivity)\n\nViewed\n545 times\n\n2\n\nHere is some Shapely code that creates three square polygons, `p1`, `p2`, and `p3`. `p2` is positioned immediately to the right of `p1`, and `p3` is positioned immediately underneath.\n\nThe problem is that Shapely tells me `p1` and `p2` don't touch, whereas `p1` and `p3` do. I can't see what is going wrong here.\n\n```\nfrom shapely.geometry import Polygon\n\nDELTA = 0.2\n\ndef polygonFromPoint(p):\n    return Polygon([(p[0]-DELTA*0.5, p[1]-DELTA*0.5),\n                    (p[0]-DELTA*0.5, p[1]+DELTA*0.5),\n                    (p[0]+DELTA*0.5, p[1]+DELTA*0.5),\n                    (p[0]+DELTA*0.5, p[1]-DELTA*0.5)])\n\np1 = polygonFromPoint([-118.8,35.0])\np2 = polygonFromPoint([-118.6,35.0])\np3 = polygonFromPoint([-118.8,34.8])\n\nprint(p1)\nprint(p2)\nprint(p3)\n\nprint(p1.overlaps(p2), p1.intersects(p2), p1.crosses(p2), p1.contains(p2),\n      p1.disjoint(p2), p1.touches(p2))\nprint(p1.overlaps(p3), p1.intersects(p3), p1.crosses(p3), p1.contains(p3),\n      p1.disjoint(p3), p1.touches(p3))\n\n```\n\nRunning this produces the following output:\n\n```\nPOLYGON ((-118.9 34.9, -118.9 35.1, -118.7 35.1, -118.7 34.9, -118.9 34.9))\nPOLYGON ((-118.7 34.9, -118.7 35.1, -118.5 35.1, -118.5 34.9, -118.7 34.9))\nPOLYGON ((-118.9 34.7, -118.9 34.9, -118.7 34.9, -118.7 34.7, -118.9 34.7))\nFalse False False False True False\nFalse True False False False True\n\n```\n\nWhich shows that Shapely thinks `p1` and `p2` don't intersect or touch, whereas `p1` and `p3` intersect and touch.\n\nEDIT: As Gilles-Philippe Paill\u00e9 and others remarked, this is a precision problem with the polygon coordinates. Using the following tweak fixes the issue in this case:\n\n```\ndef polygonFromPoint(p):\n    return Polygon( [(round(p[0]-DELTA*0.5,1), round(p[1]-DELTA*0.5,1)),\n                        (round(p[0]-DELTA*0.5,1), round(p[1]+DELTA*0.5,1)),\n                        (round(p[0]+DELTA*0.5,1), round(p[1]+DELTA*0.5,1)),\n                        (round(p[0]+DELTA*0.5,1), round(p[1]-DELTA*0.5,1))] )\n\n```\n\n- [python](https://stackoverflow.com/questions/tagged/python)\n- [geometry](https://stackoverflow.com/questions/tagged/geometry)\n- [shapely](https://stackoverflow.com/questions/tagged/shapely)\n\n[Share](https://stackoverflow.com/q/59936859)\n\n[Improve this question](https://stackoverflow.com/posts/59936859/edit)\n\nFollow\n\n[edited Jan 27, 2020 at 21:40](https://stackoverflow.com/posts/59936859/revisions)\n\nJulian\n\nasked Jan 27, 2020 at 18:27\n\n[![Julian's user avatar](https://www.gravatar.com/avatar/a1d8cda3fecf1ee84f178c98b04bb628?s=64&d=identicon&r=PG)](https://stackoverflow.com/users/1750794/julian)\n\n[Julian](https://stackoverflow.com/users/1750794/julian) Julian\n\n17511 gold badge22 silver badges88 bronze badges\n\n8\n\n- 1\n\n\n\n\n\nComputers can only represent an approximation of most floating point numbers, so you cannot expect comparisons of values calculated from them to be exact. You may be able to work around this limitation by using only integer coordinates.\n\n\u2013\u00a0[martineau](https://stackoverflow.com/users/355230/martineau)\n\nCommentedJan 27, 2020 at 18:54\n\n- See related [Is floating point math broken?](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)\n\n\u2013\u00a0[martineau](https://stackoverflow.com/users/355230/martineau)\n\nCommentedJan 27, 2020 at 21:03\n\n- Thanks - your point is well taken! However, I am not making any comparisons in my code, I am asking the Shapely library to do whatever math is required to determine if the polygons are touching etc., based on the precise coordinates given. Should it not take care of handling the precision of its own calculations? Edit: perhaps I'm not giving it as precise coordinates as I think, as Paille shows below.\n\n\u2013\u00a0[Julian](https://stackoverflow.com/users/1750794/julian)\n\nCommentedJan 27, 2020 at 21:31\n\n- Yes, I understand that\u2026and it sounds to me like it's due to a bug in Shapely's implementation of `touches()` \u2014 it's a Comp Sci 101 kind of mistake (and your mention of \"precise coordinates\" makes me suspect you may still not get that there's no such thing on a computer, either).\n\n\u2013\u00a0[martineau](https://stackoverflow.com/users/355230/martineau)\n\nCommentedJan 27, 2020 at 21:37\n\n- 2\n\n\n\n\n\nDoes this answer your question? [How to deal with rounding errors in Shapely](https://stackoverflow.com/questions/28028910/how-to-deal-with-rounding-errors-in-shapely)\n\n\u2013\u00a0[Georgy](https://stackoverflow.com/users/7851470/georgy)\n\nCommentedJan 27, 2020 at 22:51\n\n\n\\|\u00a0[Show **3** more comments](https://stackoverflow.com/questions/59936859/shapely-polygons-that-should-touch-dont)\n\n## 1 Answer 1\n\nSorted by:\n[Reset to default](https://stackoverflow.com/questions/59936859/shapely-polygons-that-should-touch-dont?answertab=scoredesc#tab-top)\n\nHighest score (default)Trending (recent votes count more)Date modified (newest first)Date created (oldest first)\n\n3\n\nEven if the string representation of the polygon show that the coordinates are the same, the underlying floating point representation is not exactly what is printed and may include some imprecision. Using your coordinates and the same calculation, I get:\n\n```\nDELTA = 0.5\n\na = -118.6 - 0.2 * DELTA\nb = -118.8 + 0.2 * DELTA\nprint(a)\nprint(b)\nprint(a <= b)\n\na = 35.0 - 0.2 * DELTA\nb = 34.8 + 0.2 * DELTA\nprint(a)\nprint(b)\nprint(a <= b)\n\n```\n\nwhich gives the following output:\n\n```\n-118.69999999999999\n-118.7\nFalse\n34.9\n34.9\nTrue\n\n```\n\n[Share](https://stackoverflow.com/a/59937254)\n\n[Improve this answer](https://stackoverflow.com/posts/59937254/edit)\n\nFollow\n\n[edited Jan 27, 2020 at 19:01](https://stackoverflow.com/posts/59937254/revisions)\n\nanswered Jan 27, 2020 at 18:57\n\n[![Gilles-Philippe Paill\u00e9's user avatar](https://i.sstatic.net/Cucr6.jpg?s=64)](https://stackoverflow.com/users/11292489/gilles-philippe-paill%c3%a9)\n\n[Gilles-Philippe Paill\u00e9](https://stackoverflow.com/users/11292489/gilles-philippe-paill%c3%a9) Gilles-Philippe Paill\u00e9\n\n3,26511 gold badge99 silver badges2222 bronze badges\n\n0\n\n[Add a comment](https://stackoverflow.com/questions/59936859/shapely-polygons-that-should-touch-dont)\u00a0\\|\n\n## Your Answer\n\n**Reminder:** Answers generated by artificial intelligence tools are not allowed on Stack Overflow. [Learn more](https://stackoverflow.com/help/gen-ai-policy)\n\nDraft saved\n\nDraft discarded\n\n### Sign up or [log in](https://stackoverflow.com/users/login?ssrc=question_page&returnurl=https%3a%2f%2fstackoverflow.com%2fquestions%2f59936859%2fshapely-polygons-that-should-touch-dont%23new-answer)\n\nSign up using Google\n\nSign up using Email and Password\n\nSubmit\n\n### Post as a guest\n\nName\n\nEmail\n\nRequired, but never shown\n\nPost Your Answer\n\nDiscard\n\nBy clicking \u201cPost Your Answer\u201d, you agree to our [terms of service](https://stackoverflow.com/legal/terms-of-service/public) and acknowledge you have read our [privacy policy](https://stackoverflow.com/legal/privacy-policy).\n\n## Not the answer you're looking for? Browse other questions tagged  - [python](https://stackoverflow.com/questions/tagged/python) - [geometry](https://stackoverflow.com/questions/tagged/geometry) - [shapely](https://stackoverflow.com/questions/tagged/shapely)   or [ask your own question](https://stackoverflow.com/questions/ask).\n\n- The Overflow Blog\n- [Co...",
      "url": "https://stackoverflow.com/questions/59936859/shapely-polygons-that-should-touch-dont"
    },
    {
      "title": "JTS Frequently Asked Questions",
      "text": "JTS | FAQ\n![](jts_logo.png)\nJTS Topology Suite - FAQ\n# JTS Frequently Asked Questions\nLast Update: September 8, 2020\n1. [General](#general)\n1. [What Java versions does JTS work with?](#A1)\n2. [Design and Structure](#design)\n1. [How can I use JTS algorithms with a different\ngeometry model?](#B1)\n2. [Why does JTS allow geometries to be constructed with\ninvalid topology?](#B2)\n3. [What is the difference between a Point and a\nCoordinate?](#B3)\n4. [Does JTS support 3D operations?](#B4)\n5. [What coordinate system and/or units does JTS use?](#B5)\n6. [Geometry Predicates](#predicates)\n1. [How are spatial predicates computed?](#C1)\n2. [Why does relate(POINT(20 20), POINT(20 30),\n\"FF0FFF0F2\") = true?](#C2)\n3. [Why is the result of a predicate different in JTS\nthan in another software application/library?](#C3)\n4. [Robustness and Precision](#robustness)\n1. [Why is a TopologyException thrown?](#D1)\n2. [Why does the coordinate given in a TopologyException\nnot appear in the input data?](#D2)\n3. [What is a \"robustness failure\"?](#D3)\n4. [What is a \"topology collapse\"?](#D4)\n5. [What is the PrecisionModel for?](#D5)\n6. [Why does JTS not enforce the specified\nPrecisionModel when creating new geometry?](#D6)\n7. [Why do the overlay operations not obey the axioms of\nset theory?](#D7)\n8. [Why is the result of`intersects`inconsistent with the result of`intersection`?](#D8)\n9. [How can I prevent TopologyExceptions or incorrect\nresults in overlay operations?](#D9)\n10. [Algorithms](#algorithms)\n1. [Are there any references which describe the\nalgorithms used in JTS?](#E1)\n2. [Is there a skeletonization algorithm which works\nwith JTS?](#E2)\n3. [How can JTS split a polygon with a linestring?](#E3)\n4. [Geodetic Operations](#geodetic_operations)\n1. [Does JTS support computation on the geodetic\nellipsoid?](#F1)\n2. [Can JTS be used to compute a geographically accurate\nrange circle?](#F2)\n3. [Geometry Cleaning and Conflation](#geometry_cleaning)\n1. [How can I correct the topology of a Polygon that JTS\nis reporting as invalid?](#G1)\n## A. General\n### 1. What Java versions does JTS work with?\nJTS is developed using Java 8. It should work with all newer versions.\nWith a small amount of work the library can be made to work with almost\nall previous Java versions as well.\n## B. Design and Structure\n### 1. How can I use JTS algorithms with a different geometry model?\nThe solution to this is to use Facade objects which wrap the non-JTS\ngeometry model classes. In order to avoid having to create and copy large\nnumbers of[Coordinate](./javadoc/org/locationtech/jts/geom/Coordinate.html)objects, JTS provides the[CoordinateSequence](./javadoc/index.html?org/locationtech/jts/geom/CoordinateSequence.html)interface. A CoordinateSequence-based adapter can be written for whatever\nstructure the foreign model uses to represent sequences of points. JTS[Geometry](./javadoc/org/locationtech/jts/geom/Geometry.html)objects will still need to be created to represent the\nstructure of the geometries containing the points, but these are\nrelatively lightweight in comparison.\n### 2. Why does JTS allow geometries to be constructed with invalid\ntopology?\nJTS intentionally allows topologically invalid geometries to be\nconstructed for the following reasons:\n1. It allows a wider set of geometry to be read, stored and written\nfrom external data sources\n2. It allows geometries to be constructed and then validated\n3. It avoids the costly overhead of validating topology every time a\ngeometry is constructed### 3. What is the difference between a Point and a Coordinate?\nA[Coordinate](./javadoc/org/locationtech/jts/geom/Coordinate.html)is a relatively simple class which represents a location on the Cartesian\nplane (optionally with an associated height value).[Coordinate](./javadoc/org/locationtech/jts/geom/Coordinate.html)s\nare usually treated as mutable objects, in order to simplify certain\nalgorithms.\nA[Point](./javadoc/org/locationtech/jts/geom/Point.html)is a subclass of[Geometry](./javadoc/org/locationtech/jts/geom/Geometry.html)that also represents a location on the Cartesian plane. It\nis a \"heavy-weight\" object (which for instance may contain an envelope)\nwhich support all methods that apply to[Geometry](./javadoc/org/locationtech/jts/geom/Geometry.html)s.\n### 4. Does JTS support 3D operations?\nJTS does not provide support for true 3D[Geometry](./javadoc/org/locationtech/jts/geom/Geometry.html)and operations. However, JTS does allow[Coordinate](./javadoc/org/locationtech/jts/geom/Coordinate.html)s\nto carry an elevation or Z value. This does not provide true 3D support,\nbut does allow \"2.5D\" uses which are required in some geospatial\napplications.\n### 5. What coordinate system and/or units does JTS use?\nJTS uses the implicit coordinate system of the input data. The only\nassumption it makes is that the coordinate system is infinite, planar and\nEuclidean (i.e. rectilinear and obeying the standard Euclidean distance\nmetric). In the same way JTS does not specify any particular units for\ncoordinates and geometries. Instead, the units are implicitly defined by\nthe input data provided. This implies that in most cases input geometries\nto operations should be defined with the same coordinate system.\n## C. Geometry Predicates\n### 1. How are spatial predicates computed?\nThe two input geometries are decomposed into labelled topology graphs ([GeometryGraph](./javadoc/org/locationtech/jts/geomgraph/GeometryGraph.html)s).\nThe labels are on the nodes and edges of the graphs. They contain full\ninformation about the topology of the node/edge in the\npoints/lines/polygons of the original geometry. The labelled topology\ngraphs are merged. This includes merging the labels wherever there is\ncommon nodes or edges. For each geometry at each node, the label\ninformation is propagated to all edges incident on that node. The\nresulting relationship (Intersection Matrix, or IM) is determined by the\nmerged label information at the nodes of the merged graph. The labelling\nof each node and its incident edges is inspected, and the topological\nrelationship information it contributes is added to the overall IM. At the\nend of this process the IM has been completely determined.\n### 2. Why does relate(POINT(20 20), POINT(20 30), \"FF0FFF0F2\") = true?\nAccording to the SFS 1.1, section 2.1.3:\n*The boundary of a Point is the\nempty set*\nSince points do not have boundaries, all the intersection matrix entries\nrelating to the geometry boundaries are \"F\".\nIn some situations it is desirable to use a different definition for\ndetermining whether geometry endpoints are on their boundary. To support\nthis, JTS provides the ability to specify a custom[BoundaryNodeRule](./javadoc/org/locationtech/jts/algorithm/BoundaryNodeRule.html)to the[RelateOp](./javadoc/org/locationtech/jts/operation/relate/RelateOp.html)class.\n### 3. Why is the result of a predicate different in JTS than in another\nsoftware application/library?\nThis is usually due to the fact that JTS predicates are computed exactly,\nusing the full precision of the double-precision coordinates. Other\ngeometry engines sometimes compute in lower precision, or round input\ncoordinates, or use a tolerance when determining whether two lines\nintersect or cross.\nAs a specific example, in the following case:\nA: POLYGON ((1368.62186660165 17722.3281808793, -1653 9287.5,\n4038.14058906538 8613.02390521266, 1368.62186660165 17722.3281808793))\nB: POLYGON ((-5846 9287.5, 7453 8380, 9082 16600, -6326.5 18842,\n-5846 9287.5))\nJTS reports`A.overlaps(B) = true`, whereas another\napplication reports false. The[Overlaps](./javadoc/org/locationtech/jts/geom/Geometry.html#overlaps(org.locationtech.jts.geom.Geometry))result is correct - the bottom right point in the triangle B lies outside\nthe quadrilateral A. This is demonstrated by intersecting the bottom edge\nof A\nLINESTRING (-5846 9287.5, 7453 8380)\nwith B. The value of the intersection is a line segment:\nLINESTRING (4038.140589065375 8613.02390521266, 4038.14058906538\n8613.02390521266)\nw...",
      "url": "https://locationtech.github.io/jts/jts-faq.html"
    },
    {
      "title": "A provably robust algorithm for triangle-triangle intersections in floating-point arithmetic",
      "text": "A provably robust algorithm for triangle-triangle\nintersections in floating-point arithmetic\nCONOR MCCOID and MARTIN J. GANDER, University of Geneva, Switzerland\nMotivated by the unexpected failure of the triangle intersection component of the Projection Algorithm for\nNonmatching Grids (PANG), this article provides a robust version with proof of backward stability. The new\ntriangle intersection algorithm ensures consistency and parsimony across three types of calculations. The set\nof intersections produced by the algorithm, called representations, is shown to match the set of geometric\nintersections, called models. The article concludes with a comparison between the old and new intersection\nalgorithms for PANG using an example found to reliably generate failures in the former.\nCCS Concepts: \u2022 Mathematics of computing \u2192 Graph enumeration; Computation of transforms; \u2022 Soft\u0002ware and its engineering \u2192 Consistency; Software reliability; \u2022 Computing methodologies \u2192 Mesh\nmodels.\nAdditional Key Words and Phrases: mesh intersection, advancing front algorithms, non-matching grids,\npolygon clipping, floating-point arithmetic, robustness\nACM Reference Format:\nConor McCoid and Martin J. Gander. 2021. A provably robust algorithm for triangle-triangle intersections in\nfloating-point arithmetic. 1, 1 (July 2021), 30 pages. https://doi.org/10.1145/nnnnnnn.nnnnnnn\n1 INTRODUCTION\nIn 2013 Gander and Japhet [11, 12] presented an algorithm to resolve a mesh intersection problem\n(also known as intergrid communication problem or grid transfer problem [12]) for two triangular\nor tetrahedral meshes. The algorithm is named PANG (Projection Algorithm for Nonmatching\nGrids). An important component of this algorithm is the calculation of the polygon representing\nthe intersection of two triangles in 2D, hereafter referred to as the polygon of intersection. This\ncomponent is the focus of this article. The algorithm also makes use of an advancing front algorithm\nto reduce the cost of computing the intersection of arbitrary meshes to linear complexity. A similar\nadvancing front algorithm was independently developed in [8].\nCalculating the intersection of two polygons is well-studied as the polygon clipping problem,\nprimarily in the field of computer graphics where one wishes to know when a given \u2019subject\u2019\npolygon U is hidden from an observer by a second \u2019clipping\u2019 polygon V . Speed is valued over\naccuracy in these applications and glitches of varying severity are commonplace in video games\nand computer-generated imagery.\nA number of algorithms have been proposed for the intersection of polygons. One may classify\nthem by considering how they handle each of the three types of vertices found in the polygon of\nintersection: vertices of U lying inside V ; the intersections between the edges of U and those of V ;\nand the vertices of V lying inside U .\nAuthors\u2019 address: Conor McCoid, conor.mccoid@unige.ch; Martin J. Gander, martin.gander@unige.ch, University of Geneva,\nRue du Conseil-G\u00e9n\u00e9ral 7-9, 1205 Geneva, Switzerland.\nPermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee\nprovided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and\nthe full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored.\nAbstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires\nprior specific permission and/or a fee. Request permissions from permissions@acm.org.\n\u00a9 2021 Association for Computing Machinery.\nXXXX-XXXX/2021/7-ART $15.00\nhttps://doi.org/10.1145/nnnnnnn.nnnnnnn\n, Vol. 1, No. 1, Article . Publication date: July 2021.\n2 Conor McCoid and Martin J. Gander\nSome algorithms divide the plane into sections based on the edges of V [16, 18, 19, 22]. Each\nedge defines an infinite reference line of which the edge is a finite interval. This line then defines a\nparameter that is positive on one side and negative on the other. If all parameters associated with\nall edges are positive for a vertex of U then it lies inside V .\nAn alternative approach is to consider the projection of vectors between vertices and edges and\nthe respective normal vectors [6, 21]. The goal is to find a vector projection whose sign indicates\nwhether a vertex is in V . The calculation of an intersection would then reduce to finding where the\nprojection is zero.\nA third option is to trace out the polygon of intersection [13, 25]. One computes all intersections\nbetween all edges of U and V , then chooses an intersection and marches along the vertices of U ,\nadding each to the polygon of intersection. Once this trace reaches another intersection between U\nand V it switches to march along the vertices of V . This is repeated until the first intersection is\nreached. Such a procedure encounters problems when U and V share vertices [12].\nOne can reduce the cost of calculating the intersections between U and V by first determining\nwhich edges intersect. This can be done on an edge-by-edge basis [16, 21, 22] or considering the\npolygons as a whole [13, 18].\nIn computer graphics, the polygon clipping problem often reduces to a line clipping problem\n[6, 16, 21]. As such, vertices of V lying inside U are often irrelevant. These can be dealt with by\nrepeating the process for vertices of U inside V , swapping U and V . Algorithms using a trace\nprocedure [13, 25] make no distinction between U and V and find such vertices in the same manner\nas those of U in V .\nThe Sutherland-Hodgman algorithm [22] has a unique method for finding vertices of V in U . The\nalgorithm takes a given edge of V and finds the corresponding reference line, defining a positive\nside of the line which contains V and a negative side which does not. It then discards all vertices\nof U on the negative side of the line and calculates intersections with the line for each edge of U\nthat had one of its vertices removed in this way. The result is a new polygon lying entirely on one\nside of the reference line. The process is repeated with a new edge of V until all edges of V have\nbeen used. In this way, a vertex of V in U is the last of a sequence of intersections of the edges of\nintermediary polygons with reference lines extending from edges of V .\nThe triangle intersection algorithm in PANG from 2013 [12] favours vector projections for\nfinding each type of vertex of the polygon of intersection, similar to the Cyrus-Beck algorithm\n[6]. The authors in [12, Remark B.1] stated for the floating-point arithmetic implementation of the\ntriangle-triangle intersection part of PANG that\n\"[i]n all the tests over the past years, the routine above never failed to compute the\ncorrect intersection. There is however no proof using a detailed floating-point analysis\nof this.\"\nOn February 21st 2019, Jer\u00f3nimo Rodriguez Garcia from the Universidade de Santiago de Compostela\nsent an example found by his PhD student Jorge Albella Mart\u00ednez to the second author of the\npresent article where the floating-point implementation of the intersection algorithm part of PANG\nfailed.\nThe left of Figure 1 shows this example: The algorithm identifies two vertices of the blue triangle\nas being inside the red triangle (apex and left base). As well, PANG identifies the left base vertex\nof the red triangle as being inside the blue triangle, as the two left base vertices are coincident.\nHowever, PANG then calculates only one intersection: the left base vertex of both triangles. As\nonly two points are found for the intersection, no volume is calculated. The right of Figure 1 shows\nthat a slight perturbation in all vertices of the small triangle leads to the correct result.\n, Vol. 1, No. 1, Article . Publication date: July 2021.\nA robust triangle intersection algorithm in floating-point arithmetic 3\nFig. 1. Left: example of a triangle intersection where an intersection is not calculated despi...",
      "url": "https://www.unige.ch/~mccoid/pubs/PRE_mccoid2021provably.pdf"
    },
    {
      "title": "ST_Overlaps in return TRUE for adjacent polygons - PostGIS",
      "text": "**Teams**\n\nQ&A for work\n\nConnect and share knowledge within a single location that is structured and easy to search.\n\n[Learn more about Teams](https://stackoverflow.co/teams/)\n\n# [ST\\_Overlaps in return TRUE for adjacent polygons - PostGIS](https://gis.stackexchange.com/questions/383952/st-overlaps-in-return-true-for-adjacent-polygons-postgis)\n\n[Ask Question](https://gis.stackexchange.com/questions/ask)\n\nAsked3 years, 5 months ago\n\nModified [3 years, 5 months ago](https://gis.stackexchange.com/questions/383952/st-overlaps-in-return-true-for-adjacent-polygons-postgis?lastactivity)\n\nViewed\n630 times\n\n7\n\nI'm trying to find overlapping polygons with `ST_Overlaps` function. Everything works fine but there are cases when `ST_Overlaps` returns `TRUE` for adjacent polygons.\n\nExample:\n\n```\nPOLYGON((145053.95 167055.18,145054.85 167047.42,145058.81 167047.84,145059.07 167045.82,145059.91 167045.93,145060.01 167045.13,145062.05 167045.42,145074.27 167047.52,145061.74 167118.48,145060.33 167127.09,145034.52 167123.21,145031.66 167122.69,145032.15 167119.98,145022.81 167118.28,145028.33 167087.92,145048.3 167091.55,145049.01 167087.67,145053.95 167055.18))\n\nPOLYGON((145024.07 167111.35,145028.33 167087.92,145048.3 167091.55,145049.01 167087.67,145053.95 167055.18,145050.8 167054.73,145031.31 167067.47,145028.87 167084.01,145018.97 167082.72,145014.59 167109.69,145024.07 167111.35))\n\n```\n\n[![adjacent polygons with ST_Overlaps = true](https://i.sstatic.net/1YCF8.png)](https://i.sstatic.net/1YCF8.png)\n\nI tested this polygons with `ST_Intersection` \\- result is a `MULTILINESTRING`.\n\n[![enter image description here](https://i.sstatic.net/aBtbz.png)](https://i.sstatic.net/aBtbz.png)\n\nBut as far as I understand if `ST_Overlaps` returns `TRUE` that means `ST_Intersection` should return `POLYGON`.\n\nSo the question - is this an issue with PostGIS or I just misunderstood the way `ST_Overlaps` works.\n\nPostGIS version: postgis 3.1 for docker (postgis/postgis image)\n\n- [postgis](https://gis.stackexchange.com/questions/tagged/postgis)\n- [overlapping-features](https://gis.stackexchange.com/questions/tagged/overlapping-features)\n\n[Share](https://gis.stackexchange.com/q/383952)\n\n[Improve this question](https://gis.stackexchange.com/posts/383952/edit)\n\nFollow\n\n[edited Jan 10, 2021 at 18:08](https://gis.stackexchange.com/posts/383952/revisions)\n\n[![Kadir \u015eahbaz's user avatar](https://i.sstatic.net/KzelY.jpg?s=64)](https://gis.stackexchange.com/users/29431/kadir-%c5%9eahbaz)\n\n[Kadir \u015eahbaz](https://gis.stackexchange.com/users/29431/kadir-%c5%9eahbaz)\n\n77.2k5656 gold badges249249 silver badges391391 bronze badges\n\nasked Jan 10, 2021 at 17:56\n\n[![Yura  Miranovich's user avatar](https://graph.facebook.com/3412216075556488/picture?type=large)](https://gis.stackexchange.com/users/175495/yura-miranovich)\n\n[Yura Miranovich](https://gis.stackexchange.com/users/175495/yura-miranovich) Yura Miranovich\n\n7333 bronze badges\n\n2\n\n- 3\n\n\n\n\n\nThis may be floating point rounding/precision error; check if `ST_Relate(a.geom, b.geom, '2*T***T**')` is falsey. If not then you may need to `ST_SnapToGrid` with a tiny tolerance, or `ST_QuantizeCoordinates` \\- anything, really, to reduce precision to guaranteed `0` s, which may or may not help...\n\n\u2013\u00a0[geozelot](https://gis.stackexchange.com/users/93656/geozelot)\n\nCommentedJan 10, 2021 at 19:16\n\n- You could use also use ST\\_Buffer with a very small negative radius to shrink your polygons slightly and avoid overlaps due to floating point imprecision.\n\n\u2013\u00a0[amball](https://gis.stackexchange.com/users/30756/amball)\n\nCommentedJan 10, 2021 at 20:43\n\n\n[Add a comment](https://gis.stackexchange.com/questions/383952/st-overlaps-in-return-true-for-adjacent-polygons-postgis)\u00a0\\|\n\n## 2 Answers 2\n\nSorted by:\n[Reset to default](https://gis.stackexchange.com/questions/383952/st-overlaps-in-return-true-for-adjacent-polygons-postgis?answertab=scoredesc#tab-top)\n\nHighest score (default)Date modified (newest first)Date created (oldest first)\n\n6\n\nResolving spatial relationships between adjacent geometries which do not share exactly same vertices tends to be a bit unreliable because of inaccuracy of floating point computing. In this case the first polygon (on the right) does not have a vertex around the top-right corner of the second polygon.\n\n[![enter image description here](https://i.sstatic.net/wzM6X.png)](https://i.sstatic.net/wzM6X.png)\n\nThe ST\\_Overlaps and ST\\_Intersection must create an additional virtual vertex to the first polygon.\n\nHowever, the MultiLinestring geometry that PostGIS returns is odd. The real vertices of the both polygons are exactly same and I think that the lower part of the intersection geometry is any way wrong. There should be no intersection there.\n\nThe overlap segments that OpenJUMP shows make more sense even also OpenJUMP reports that the overlap geometry does not have any area.\n\n[![enter image description here](https://i.sstatic.net/cTPbL.png)](https://i.sstatic.net/cTPbL.png)\n\nThere is overlap only around the virtual vertex.\n\nBy adding the \"missing\" vertex into the first polygon at coordinates `(145024.07 167111.35)` the overlap disappears.\n\n```\nselect ST_Overlaps(\nST_GeomFromText(\n'POLYGON (( 145053.95 167055.18, 145054.85 167047.42, 145058.81 167047.84, 145059.07 167045.82, 145059.91 167045.93, 145060.01 167045.13, 145062.05 167045.42, 145074.27 167047.52, 145061.74 167118.48, 145060.33 167127.09, 145034.52 167123.21, 145031.66 167122.69, 145032.15 167119.98, 145022.81 167118.28, 145024.07 167111.35, 145028.33 167087.92, 145048.3 167091.55, 145049.01 167087.67, 145053.95 167055.18 ))'),\nST_GeomFromText(\n'POLYGON((145024.07 167111.35,145028.33 167087.92,145048.3 167091.55,145049.01 167087.67,145053.95 167055.18,145050.8 167054.73,145031.31 167067.47,145028.87 167084.01,145018.97 167082.72,145014.59 167109.69,145024.07 167111.35))')\n);\n\n```\n\n[Share](https://gis.stackexchange.com/a/383964)\n\n[Improve this answer](https://gis.stackexchange.com/posts/383964/edit)\n\nFollow\n\nanswered Jan 10, 2021 at 20:40\n\n[![user30184's user avatar](https://www.gravatar.com/avatar/063085813056f3bb7d9d29894ba5c248?s=64&d=identicon&r=PG&f=y&so-version=2)](https://gis.stackexchange.com/users/30184/user30184)\n\n[user30184](https://gis.stackexchange.com/users/30184/user30184) user30184\n\n66.8k44 gold badges6767 silver badges122122 bronze badges\n\n[Add a comment](https://gis.stackexchange.com/questions/383952/st-overlaps-in-return-true-for-adjacent-polygons-postgis)\u00a0\\|\n\n3\n\nThis is a classic example revealing the (slight) inconsistency of the spatial predicates compared to the spatial overlay operations (in PostGIS, and the underlying GEOS and JTS geometry libraries). The reason for this is due to numerical precision issues with finite floating-point representation of real numbers. Because the spatial predicates return boolean values, they can be evaluated more accurately than overlay operations, which require some snapping heuristics in order to avoid robustness failures.\n\nIn cases like this where two line segments are \"co-incident\", but one line contains a vertex not on the other, it is almost never the case that the vertex lies exactly on the other line. In this case we can see that the vertex actually lies inside the other polygon, and hence `ST_Overlaps = true`. (Diagram below from the JTS TestBuilder Reveal Topology mode).\n\n[![Polygon B overlaps Polygon A](https://i.sstatic.net/fTk6o.png)](https://i.sstatic.net/fTk6o.png)\n\nHowever, the line segments are so close that `ST_Intersection` snaps them together, to ensure numerical robustness, and thus produces a linear result.\n\nIt sounds like from your use case that you should trust the `ST_Overlaps` result to correctly report overlapping polygons.\n\n[Share](https://gis.stackexchange.com/a/384129)\n\n[Improve this answer](https://gis.stackexchange.com/posts/384129/edit)\n\nFollow\n\nanswered Jan 12, 2021 at 18:36\n\n[![dr_jts's user avatar](https://www.gravatar.com/avatar/ede7c48b6cb1a6797125cfb794894f1d?s=64&d=identicon&r=PG)](https://gis.st...",
      "url": "https://gis.stackexchange.com/questions/383952/st-overlaps-in-return-true-for-adjacent-polygons-postgis"
    },
    {
      "title": "Priority-Driven Nesting of Irregular Polygonal Shapes Within a Convex Polygonal Container Based on a Hierarchical Integer Grid (CG Challenge)",
      "text": "Document\n\n`https://doi.org/10.4230/LIPIcs.SoCG.2024.85`\n\n- [Export XML](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SoCG.2024.85/metadata/xml)\n- [Export ACM-XML](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SoCG.2024.85/metadata/acm-xml)\n- [Export DOAJ-XML](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SoCG.2024.85/metadata/doaj-xml)\n- [Export Schema.org](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SoCG.2024.85/metadata/schema-org)\n- [Export BibTeX](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SoCG.2024.85/metadata/bibtex)\n\n# Priority-Driven Nesting of Irregular Polygonal Shapes Within a Convex Polygonal Container Based on a Hierarchical Integer Grid (CG Challenge)\n\n### Author [Martin Held](https://drops.dagstuhl.de/search/documents?author=Held, Martin)\n\n- Part of:Volume:\n[40th International Symposium on Computational Geometry (SoCG 2024)](https://drops.dagstuhl.de/entities/volume/LIPIcs-volume-293) Part of:Series:\n[Leibniz International Proceedings in Informatics (LIPIcs)](https://drops.dagstuhl.de/entities/series/LIPIcs) Part of:Conference:\n[Symposium on Computational Geometry (SoCG)](https://drops.dagstuhl.de/entities/conference/SoCG)\n- License: \u00a0 [Creative Commons Attribution 4.0 International license](https://creativecommons.org/licenses/by/4.0/legalcode)\n- Publication Date: 2024-06-06\n\n[PDF](https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.85/LIPIcs.SoCG.2024.85.pdf)\n\n## File\n\n[PDF\\\nLIPIcs.SoCG.2024.85.pdf](https://drops.dagstuhl.de/storage/00lipics/lipics-vol293-socg2024/LIPIcs.SoCG.2024.85/LIPIcs.SoCG.2024.85.pdf)\n\n- Filesize: 0.59 MB\n- 6 pages\n\n## Document Identifiers\n\n- **DOI:** [10.4230/LIPIcs.SoCG.2024.85](https://doi.org/10.4230/LIPIcs.SoCG.2024.85)\n- **URN:** [urn:nbn:de:0030-drops-200306](https://nbn-resolving.org/urn:nbn:de:0030-drops-200306)\n\n## Subject Classification\n\n##### ACM Subject Classification\n\n- Theory of computation \u2192 Computational geometry\n\n##### Keywords\n\n- Computational Geometry\n- geometric optimization\n- nesting\n- packing\n- algorithm engineering\n\n## Metrics\n\n- [Access Statistics](https://drops.dagstuhl.de/drops.dagstuhl.de)\n- Total Accesses (updated on a weekly basis)\n\n\n\n\n0\n\n\n\nPDF Downloads\n\n\n\n\n\n\n\n0\n\n\n\nMetadata Views\n\n\n## Abstract\n\n```\nOur work on nesting polygons is based on two key components: (1) a hierarchy of uniform integer grids for maintaining free space within the container during the nesting such that placement queries can be answered reasonably efficiently, and (2) priority heuristics for choosing the order in which the polygons are tested for placement. We discuss our approach and shed a light on the results obtained.\n```\n\n## Cite As Get BibTex\n\nMartin Held. Priority-Driven Nesting of Irregular Polygonal Shapes Within a Convex Polygonal Container Based on a Hierarchical Integer Grid (CG Challenge). In 40th International Symposium on Computational Geometry (SoCG 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 293, pp. 85:1-85:6, Schloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik (2024)\n[https://doi.org/10.4230/LIPIcs.SoCG.2024.85](https://doi.org/10.4230/LIPIcs.SoCG.2024.85)\n\n## Author Details\n\n**Martin Held**\n\n- FB Informatik, Universit\u00e4t Salzburg, Austria\n\n## References\n\n1. Alkan Atak, Kevin Buchin, Mart Hagedoorn, Jona Heinrichs, Karsten Hogreve, Guangping Li, and Patrick Pawelczyk. Computing maximum polygonal packings in convex polygons using best-fit, genetic algorithms and ILPs. In Symposium on Computational Geometry (SoCG), volume 293 of LIPIcs, pages 83:1-83:9, 2024. URL: [https://doi.org/10.4230/LIPIcs.SoCG.2024.83](https://doi.org/10.4230/LIPIcs.SoCG.2024.83).\n2. Guilherme Dias da Fonseca and Yan Gerard. Shadoks approach to knapsack polygonal packing. In Symposium on Computational Geometry (SoCG), volume 293 of LIPIcs, pages 84:1-84:9, 2024. URL: [https://doi.org/10.4230/LIPIcs.SoCG.2024.84](https://doi.org/10.4230/LIPIcs.SoCG.2024.84).\n3. Canhui Luo, Zhouxing Su, and Zhipeng L\u00fc. A general heuristic approach for maximum polygon packing. In Symposium on Computational Geometry (SoCG), volume 293 of LIPIcs, pages 86:1-86:9, 2024. URL: [https://doi.org/10.4230/LIPIcs.SoCG.2024.86](https://doi.org/10.4230/LIPIcs.SoCG.2024.86).\n4. S\u00e1ndor P. Fekete, Phillip Keldenich, Dominik Krupke, and Stefan Schirra. Maximum polygon packing: The CG:SHOP Challenge 2024, 2024. URL: [https://arxiv.org/abs/2403.16203](https://arxiv.org/abs/2403.16203).\n\n[Any Issues?](https://drops.dagstuhl.de/drops.dagstuhl.de)\n\n[X](https://drops.dagstuhl.de/drops.dagstuhl.de)\n\nFeedback on the Current Page\n\nSend\n\nSubmit\n\n### Thanks for your feedback!\n\nFeedback submitted to Dagstuhl Publishing\n\nOK\n\n### Could not send message\n\nPlease try again later or send an [E-mail](mailto:publishing@dagstuhl.de)\n\nOK\n\n\u00a9 2023-2025 [Schloss Dagstuhl \u2013 LZI GmbH](https://www.dagstuhl.de) [About\u00a0DROPS](https://drops.dagstuhl.de/docs/about) [Imprint](https://drops.dagstuhl.de/docs/imprint) [Privacy](https://drops.dagstuhl.de/docs/privacy) [Contact](https://www.dagstuhl.de/en/publishing/team)",
      "url": "https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SoCG.2024.85"
    },
    {
      "title": "A new algorithm for the two-polygon containment problem",
      "text": "A new algorithm for the two-polygon containment problem - ScienceDirect\n[Skip to main content](#screen-reader-main-content)[Skip to article](#screen-reader-main-title)\n[![Elsevier logo](https://www.sciencedirect.com/shared-assets/24/images/elsevier-non-solus-new-grey.svg)ScienceDirect](https://www.sciencedirect.com/)\n[My account](https://www.sciencedirect.com/user/login?targetURL=/science/article/pii/S0305054896000500&amp;from=globalheader)\n[Sign in](https://www.sciencedirect.com/user/institution/login?targetURL=/science/article/pii/S0305054896000500)\n* [Access through**your organization**](https://www.sciencedirect.com/user/institution/login?targetUrl=/science/article/pii/S0305054896000500)\n* [Purchase PDF](https://www.sciencedirect.com/getaccess/pii/S0305054896000500/purchase)\nSearch ScienceDirect\n## Article preview\n* [Abstract](#preview-section-abstract)\n* [References (15)](#preview-section-references)\n* [Cited by (8)](#preview-section-cited-by)\n[![Elsevier](https://www.sciencedirect.com/eu-west-1/prod/7011aa897fbfe387ccc2c1046f0809c7aebd80a9/image/elsevier-non-solus.svg)](https://www.sciencedirect.com/journal/computers-and-operations-research)\n## [Computers &amp; Operations Research](https://www.sciencedirect.com/journal/computers-and-operations-research)\n[Volume 24, Issue 3](https://www.sciencedirect.com/journal/computers-and-operations-research/vol/24/issue/3),March 1997, Pages 231-251\n[![Computers &amp; Operations Research](https://ars.els-cdn.com/content/image/1-s2.0-S0305054825X00125-cov150h.gif)](https://www.sciencedirect.com/journal/computers-and-operations-research/vol/24/issue/3)\n# A new algorithm for the two-polygon containment problem\nAuthor links open overlay panelRoger B.Grinde1\u2021,Tom M.Cavalier2\u00a7\nShow more\nAdd to Mendeley\nShare\nCite\n[https://doi.org/10.1016/S0305-0548(96)00050-0](https://doi.org/10.1016/S0305-0548(96)00050-0)[Get rights and content](https://s100.copyright.com/AppDispatchServlet?publisherName=ELS&amp;contentID=S0305054896000500&amp;orderBeanReset=true)\n## Abstract\nThis article addresses the two-polygon containment problem. The problem is to determine if two polygons, denoted*P*1, and*P*2, can fit inside a fixed polygon*Q*without overlap. The case when*P*1and*P*2are allowed to translate and rotate and all three polygons are convex, is considered. After characterizing the solution space, an approach utilizing mathematical programming is introduced. An efficient algorithm is developed and implemented for the special case when sides of*P*1and*P*2are matching. The problem is solved by viewing it as a parametric programming problem with a nonlinear parameter. As the algorithm proceeds, optimality conditions (primal feasibility, dual feasibility, and complementary slackness) are maintained continuously. The complexity of the algorithm is O(*b*(*p*1 +*p*2)*q*), where*p*1,*p*2, and*q*are the numbers of vertices in the polygons, and*b*is the number of dual bases encountered (switches in combinations of contacts being maintained) as the angle of rotation ranges through 2\u03c0 radians. The detailed algebraic development, an example, and computational experience are included.\nRecommended articles\n## References(15)\n* K.A.Dowsland*et al.*### [Solution approaches to irregular nestings problems](https://www.sciencedirect.com/science/article/pii/037722179500019M)\n### Eur. J. Opl Res.\n(1995)\n* B.S.Baker*et al.*### [Polygon containment under translation](https://www.sciencedirect.com/science/article/pii/0196677486900179)\n### J. Algorithms\n(1986)\n* R.R.Martin*et al.*### [Putting objects into boxes](https://www.sciencedirect.com/science/article/pii/0010448588900401)\n### Comp. Aided Design\n(1988)\n* R.B.Grinde*et al.*### [Containment of a single polygon using mathematical programming](https://www.sciencedirect.com/science/article/pii/0377221794002797)\n### Eur. J. Opl Res.\n(1996)\n* H.Hooper### Nesting and marking of ship parts from steel plate\n### J. Ship Prod.\n(1986)\n* F.P.Preparata*et al.*### Computational Geometry, An Introduction\n(1985)\n* S.J.Fortune### A fast algorithm for polygon containment by translation\n### Lecture Notes in Comp. Sci.\n(1985)\nThere are more references available in the full text version of this article.\n## Cited by (8)\n* ### [Rotational polygon containment and minimum enclosure using only robust 2D constructions](https://www.sciencedirect.com/science/article/pii/S0925772199000061)\n1999, Computational Geometry Theory and Applications\nShow abstract\nAn algorithm and a robust floating point implementation is given for*rotational polygon containment*: given polygons*P*1,*P*2,*P*3,\u2026,*P**k*and a container polygon C, find rotations and translations for the k polygons that place them into the container without overlapping. A version of the algorithm and implementation also solves*rotational minimum enclosure*: given a classCof container polygons, find a containerC\u2208Cof minimum area for which containment has a solution. The minimum enclosure is approximate: it bounds the minimum area between (1\u2212*\u03b5*)*A*and A. Experiments indicate that finding the minimum enclosure is practical for*k*=2,3 but not larger unless optimality is sacrificed or angles ranges are limited (although these solutions can still be useful). Important applications for these algorithm to industrial problems are discussed. The paper also gives practical algorithms and numerical techniques for robustly calculating polygon set intersection, Minkowski sum, and*range intersection*: the intersection of a polygon with itself as it rotates through a range of angles. In particular, it introduces*nearest pair rounding*, which allows all these calculations to be carried out in rounded floating point arithmetic.\n* ### [Rotational polygon overlap minimization and compaction](https://www.sciencedirect.com/science/article/pii/S0925772198000121)\n1998, Computational Geometry Theory and Applications\nShow abstract\nAn effective and fast algorithm is given for*rotational overlap minimization*: given an overlapping layout of polygons*P*1,*P*2,*P*3, \u2026,*P**k*in a container polygon*Q*, translate and rotate the polygons to diminish their overlap to a local minimum. A (local) overlap minimum has the property that any perturbation of the polygons increases the overlap. Overlap minimization is modified to create a practical algorithm for*compaction*: starting with a non-overlapping layout in a rectangular container, plan a non-overlapping motion that diminishes the length or area of the container to a local minimum. Experiments show that both overlap minimization and compaction work well in practice and are likely to be useful in industrial applications.\n* ### [Draft layout generation of building drawings on real urban scenes with boundary particle method and priority solver](https://doi.org/10.1007/s11042-021-10659-9)\n2021, Multimedia Tools and Applications\n* ### [Surface Mosaic Synthesis with Irregular Tiles](https://doi.org/10.1109/TVCG.2015.2498620)\n2016, IEEE Transactions on Visualization and Computer Graphics\n* ### [Optimal clustering of a pair of irregular objects](https://doi.org/10.1007/s10898-014-0192-0)\n2015, Journal of Global Optimization\n* ### [Finding failures from passed test cases: Improving the pattern classification approach to the testing of mesh simplification programs](https://doi.org/10.1002/stvr.408)\n2010, Software Testing Verification and Reliability\n[View all citing articles on Scopus](http://www.scopus.com/scopus/inward/citedby.url?partnerID=10&amp;rel=3.0.0&amp;eid=2-s2.0-0042045203&amp;md5=792314949d92cf6821f0969ba951d4)\n[\u2021](#bFN1)\nRoger B. Grinde is an Assistant Professor of Management Science in the Whittemore School of Business and Economics at the University of New Hampshire. He received his B.A. in mathematics from Carroll College (MT), M.S. in industrial engineering from Oregon State University, and Ph.D. in industrial engineering and operations research from the Pennsylvania State University. His research interests are in applied optimization, especially probl...",
      "url": "https://www.sciencedirect.com/science/article/abs/pii/S0305054896000500"
    }
  ]
}