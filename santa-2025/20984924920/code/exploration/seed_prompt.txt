## Problem Definition
- **Goal:** Pack $N$ identical "Christmas tree" polygons (irregular non-convex shapes) into the smallest possible square.
- **Independence:** The score is a sum over $N=1$ to $200$. Each $N$ is an **independent optimization problem**. You can solve them in parallel or sequentially.
- **Metric:** Minimize $\sum_{n=1}^{200} \frac{s_n^2}{n}$. This means for each $N$, you want to minimize the bounding square side $s_n$.
- **Constraints:** No overlap. Trees can be rotated. Coordinates in [-100, 100].
- **Tree Shape:** Defined in `ChristmasTree` class (starter notebook). Non-convex, but can be decomposed into simpler shapes if needed.

## Data & Code References
- **Starter Notebook:** `../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb`
  - **Key Class:** `ChristmasTree` (defines vertices).
  - **Key Logic:** Greedy placement with random trials. Uses `shapely` for collision detection (`intersects`).
  - **Visualization:** `plot_results` function.

## Algorithmic Approaches
### 1. Optimization Metaheuristics (Recommended)
- **Simulated Annealing (SA):** Very effective for irregular packing.
  - *State:* Positions $(x_i, y_i)$ and rotations $\theta_i$ for $i=1..N$.
  - *Energy:* Max dimension of bounding box + penalty for overlap.
  - *Moves:* Perturb one tree's position/rotation.
- **Basin Hopping:** A global optimization technique (available in `scipy.optimize`) that combines random perturbation (hopping) with local minimization. Mentioned in discussions as effective.
- **Genetic Algorithms (GA):** Evolve populations of layouts. Harder to handle strict non-overlap constraints.

### 2. Constructive Heuristics
- **Bottom-Left-Fill (BLF):** Place trees one by one in the lowest, leftmost valid position.
- **Maximum Hole Degree:** Place next item where it touches the most existing items (densest packing).
- **Symmetry vs. Asymmetry:** Discussions suggest symmetric patterns might be optimal for some $N$, but asymmetric for others. Don't enforce symmetry, but maybe initialize with it.

### 3. Geometry & Collision Detection
- **Shapely:** Robust but can be slow for thousands of checks.
  - *Optimization:* Use `STRtree` (spatial index) as in starter code.
  - *Approximation:* Use simpler bounding shapes (circles/rectangles) for quick rejection before exact polygon check.
- **No-Fit Polygon (NFP):** Advanced technique. Precompute the region where a tree *cannot* go relative to another. Allows instant validity checks.
  - *Note:* Hard to implement for non-convex rotating shapes. Stick to `shapely` unless performance is critical.

## Execution Strategy
1. **Baseline:** Run the starter code to get a score.
2. **Iterative Improvement:**
   - Focus on small $N$ first to test algorithms.
   - For each $N$, run an optimizer (e.g., SA or Basin Hopping) starting from a greedy initialization.
   - Save the best result for each $N$ independently.
3. **Parallelization:** Since $N$ are independent, run multiple scripts/kernels for different ranges of $N$.
