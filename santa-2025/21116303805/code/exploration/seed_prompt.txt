# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D polygon packing optimization problem. The goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding box for each configuration of N trees (N=1 to 200).

**Scoring:** score = Σ(s_n² / n) for n=1 to 200, where s_n is the side length of the bounding square for n trees. Lower is better.

**Target Score:** Beat 68.922808

## Tree Geometry
Each Christmas tree is a 15-vertex polygon with:
- Trunk: width 0.15, height 0.2
- Base tier: width 0.7
- Middle tier: width 0.4
- Top tier: width 0.25
- Tip at y=0.8

The tree can be positioned (x, y) and rotated by angle (deg).

## Top Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (Primary Approach)
**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`

The bbox3.cpp optimizer is the core engine used by top solutions. Key features:
- Complex Number Vector Coordination for position calculations
- Fluid Dynamics simulation for tree movement
- Hinge Pivot mechanism for rotation optimization
- Density Gradient Flow for compaction
- Global Boundary Tension for edge optimization
- OpenMP parallelization for speed

**Key Parameters:**
- `-n <iterations>`: Number of optimization iterations (try 5000-20000)
- `-r <rounds>`: Number of rounds (try 16-256)

**Usage:**
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp
./bbox3 -n 10000 -r 64
```

### 2. tree_packer_v21 (Alternative Optimizer)
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Features:
- Swap moves between trees
- Multi-angle restarts
- Higher temperature simulated annealing
- Squeeze, compaction, and local search phases
- Uses long double precision

### 3. fix_direction Post-Processing (CRITICAL)
**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

After optimization, apply rotation to the entire configuration to minimize bounding box:
- Uses scipy.optimize.minimize_scalar to find optimal rotation angle
- Rotates all trees around the centroid
- Can reduce score significantly

### 4. Backward Propagation (bp.cpp)
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Improves smaller N configurations by removing trees from larger ones:
- Start from N=200, work down to N=2
- For each config, try removing boundary-touching trees
- If resulting (N-1) config is better than stored, save it

## Recommended Experiment Pipeline

### Phase 1: Reproduce Best Kernel Score
1. Download pre-optimized submission from top kernel datasets
2. Run fix_direction on it
3. Validate no overlaps
4. Submit to verify baseline score

### Phase 2: Extended Optimization
1. Compile bbox3.cpp with OpenMP
2. Run with higher iterations: `./bbox3 -n 20000 -r 128`
3. Apply fix_direction post-processing
4. Run backward propagation
5. Validate and submit

### Phase 3: Novel Improvements

**Per-N Optimization:**
- Identify N values with worst efficiency (highest s²/n contribution)
- Focus optimization time on those specific configurations
- Small improvements on bad N values help more than good ones

**Multi-Start Strategy:**
- Run optimizer multiple times with different random seeds
- Keep best result for each N
- Combine best configurations from different runs

**Ensemble Approach:**
- Run both bbox3 and tree_packer_v21
- For each N, keep whichever gives smaller bounding box
- Apply fix_direction to final combined result

**Fine-Grained Position Adjustment:**
- After main optimization, try micro-adjustments (0.0001 units)
- Focus on boundary-touching trees
- Use gradient descent for final polish

## Key Techniques

### Overlap Detection
Use Shapely library with STRtree for efficient collision detection:
```python
from shapely.strtree import STRtree
tree_index = STRtree(placed_polygons)
possible_indices = tree_index.query(candidate_poly)
```

### Overlap Repair
If overlaps detected, replace problematic configurations with donor file:
```python
if has_overlap(trees):
    replace_group(target_file, donor_file, group_id)
```

### Scoring Function
```python
def get_score(trees, n):
    xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])
    min_x, min_y = xys.min(axis=0)
    max_x, max_y = xys.max(axis=0)
    side_length = max(max_x - min_x, max_y - min_y)
    return side_length**2 / n
```

## Validation Checklist
1. No overlapping trees (use has_overlap function)
2. All coordinates within [-100, 100]
3. All 200 configurations present
4. Values prefixed with 's' in submission

## External Datasets
Top kernels use pre-optimized submissions as starting points:
- Look for datasets like "santa-2025-csv", "bucket-of-chump"
- These contain partially optimized solutions to build upon

## Optimization Time Budget
- Kaggle notebooks have ~12 hour limit
- bbox3 with -n 10000 -r 64 takes ~1-2 hours
- fix_direction takes ~10-15 minutes
- backward_propagation takes ~5-10 minutes
- Plan for multiple optimization passes

## Important Notes
1. Always validate for overlaps before submission
2. Use Decimal precision for coordinates to avoid floating point errors
3. The 's' prefix on values is required to preserve precision
4. Symmetric solutions may be optimal for small N but asymmetric for large N
5. Focus optimization effort on N values with worst efficiency
