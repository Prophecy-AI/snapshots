# Santa 2025 - Evolved Strategy (Loop 2)

## Current Status
- Best CV score: 70.676099 from exp_001 (002_preoptimized)
- Best LB score: N/A (no submissions yet)
- Target: 68.922808 | Gap to target: 1.75 points

## Public Kernel Status (CRITICAL!)
- Have we implemented the best kernel yet? **NO** - We've only used pre-optimized submissions
- Top kernels identified:
  1. jonathanchan/santa25-ensemble-sa-fractional-translation (174 votes) - **KEY KERNEL**
  2. egortrushin/santa25-simulated-annealing-with-translations (126 votes)
  3. chistyakov/santa-2025-simple-optimization-new-slow-version (128 votes)
- Kernels we've implemented: None (only used pre-optimized CSVs)
- Kernels still to implement: **ALL OF THEM**

## Response to Evaluator
The evaluator correctly identified that:
1. **bbox3 perturbations are too coarse** (0.01-0.1 units) - CONFIRMED
2. **Need fractional translation** with micro-adjustments (0.001-0.00001 units) - AGREED
3. **Ensemble approach** - PARTIALLY USEFUL (all submissions are similar, santa-2025.csv is best for all N)
4. **Per-N analysis** - DONE (worst N values identified: N=1,2,3,5,4,7,6,9,8,15)

The key insight is that the pre-optimized submission is already at a local optimum for the simple bbox3 optimizer. We need the **sa_v1_parallel.cpp** from the jonathanchan kernel which has:
- Proper simulated annealing with temperature schedule (1.0 → 0.000005)
- Fractional translation with step sizes: 0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001
- Population-based optimization (keeps top 3 candidates)
- Multiple generations with early stopping

## Key Data Findings
1. All available pre-optimized submissions score 70.68 or worse
2. santa-2025.csv is best for all 200 N values
3. Gap to target is 1.75 points
4. Reducing each side by 0.01 saves only 0.33 points - need more aggressive optimization
5. Worst-performing N values: N=1 (0.66), N=2 (0.45), N=3 (0.43), N=5 (0.42), N=4 (0.42)

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Implement sa_v1_parallel.cpp from jonathanchan kernel
The kernel at `research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation/` contains:
- `sa_v1_parallel.cpp` - Full C++ optimizer with:
  - Simulated annealing: `sa_v3()` with temp 1.0 → 0.000005, cooling 0.25
  - Local search: `ls_v3()` with 300 iterations
  - Fractional translation: `fractional_translation()` with micro-adjustments
  - Population-based: `opt_v3()` keeps top 3 candidates

**Steps:**
1. Extract the C++ code from the notebook
2. Compile with: `g++ -O3 -march=native -std=c++17 -fopenmp -o sa_v1_parallel sa_v1_parallel.cpp`
3. Run: `./sa_v1_parallel -i santa-2025.csv -n 15000 -r 5`
4. Apply fix_direction post-processing

### 2. **[HIGH PRIORITY]** Implement fractional translation in Python as backup
If C++ compilation fails, implement in Python:
```python
def fractional_translation(trees, max_iter=200):
    frac_steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]
    directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (1,-1), (-1,1), (-1,-1)]
    # ... (see evaluator feedback for full implementation)
```

### 3. **[MEDIUM PRIORITY]** Focus on worst-performing N values
The N values with highest score contribution are:
- N=1: 0.661250 (side=0.8132) - Single tree, optimal angle is 45°
- N=2: 0.450779 (side=0.9495)
- N=3: 0.434745 (side=1.1420)

For small N (1-20), run more iterations and rounds.

### 4. **[LOWER PRIORITY]** Try egortrushin's SA with translations
If jonathanchan's approach doesn't work, try the simpler egortrushin kernel.

## What NOT to Try
- Running more rounds of the simple bbox3 optimizer (already at local optimum)
- Ensemble approach (all submissions are similar)
- Building from scratch (use proven kernel code)

## Validation Notes
- Score = Σ(s_n² / n) for n=1 to 200
- Lower is better
- No overlaps allowed
- Coordinates must be within [-100, 100]

## SUBMISSION STRATEGY
- Remaining submissions: 94
- **SUBMIT AFTER THIS EXPERIMENT** - We have abundant submissions and need LB feedback
- Even if score doesn't improve much, LB feedback calibrates our CV-LB relationship
