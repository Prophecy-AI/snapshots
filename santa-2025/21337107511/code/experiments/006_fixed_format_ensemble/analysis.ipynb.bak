{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "4a98a4c7",
   "metadata": {},
   "source": [
    "# Fixed Format Ensemble - Exclude ALL Bad Snapshots\n",
    "\n",
    "exp_005 has 201 rows with missing 's' prefix.\n",
    "Bad snapshots to exclude:\n",
    "- 21145963314 (wrong ID + no 's')\n",
    "- 21337107511 (wrong ID + no 's')\n",
    "- 21145965159 (no 's' prefix)\n",
    "- 21336527339 (no 's' prefix)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "3e9fc075",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T21:37:57.407447Z",
     "iopub.status.busy": "2026-01-25T21:37:57.406893Z",
     "iopub.status.idle": "2026-01-25T21:37:57.573465Z",
     "shell.execute_reply": "2026-01-25T21:37:57.573020Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Bad snapshots to exclude: {'21145963314', '21336527339', '21337107511', '21145965159'}\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "import json\n",
    "from shapely.geometry import Polygon\n",
    "from shapely import affinity\n",
    "from shapely.ops import unary_union\n",
    "\n",
    "# ALL bad snapshots to exclude\n",
    "BAD_SNAPSHOTS = {'21145963314', '21337107511', '21145965159', '21336527339'}\n",
    "\n",
    "# Tree polygon vertices for score calculation\n",
    "TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]\n",
    "TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]\n",
    "\n",
    "def create_tree_polygon(x, y, angle):\n",
    "    poly = Polygon(zip(TX, TY))\n",
    "    poly = affinity.rotate(poly, angle, origin=(0, 0))\n",
    "    poly = affinity.translate(poly, x, y)\n",
    "    return poly\n",
    "\n",
    "def calculate_side(trees):\n",
    "    polys = [create_tree_polygon(*t) for t in trees]\n",
    "    union = unary_union(polys)\n",
    "    bounds = union.bounds\n",
    "    return max(bounds[2] - bounds[0], bounds[3] - bounds[1])\n",
    "\n",
    "def calculate_score_for_n(trees, n):\n",
    "    side = calculate_side(trees)\n",
    "    return (side ** 2) / n\n",
    "\n",
    "print(f\"Bad snapshots to exclude: {BAD_SNAPSHOTS}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "3100ab23",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T21:37:57.574685Z",
     "iopub.status.busy": "2026-01-25T21:37:57.574527Z",
     "iopub.status.idle": "2026-01-25T21:37:57.580422Z",
     "shell.execute_reply": "2026-01-25T21:37:57.580025Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Loading functions with full validation defined!\n"
     ]
    }
   ],
   "source": [
    "def load_snapshot_with_full_validation(path):\n",
    "    \"\"\"Load snapshot with BOTH ID format AND 's' prefix validation.\"\"\"\n",
    "    rows_by_n = {}\n",
    "    with open(path, 'r') as f:\n",
    "        next(f)  # Skip header\n",
    "        for line in f:\n",
    "            parts = line.strip().split(',')\n",
    "            if len(parts) != 4:\n",
    "                continue\n",
    "            id_val, x, y, deg = parts\n",
    "            \n",
    "            # Validate ID format\n",
    "            try:\n",
    "                n_str, idx_str = id_val.split('_')\n",
    "                n = int(n_str)\n",
    "                idx = int(idx_str)\n",
    "                expected_id = f\"{n:03d}_{idx}\"\n",
    "                if id_val != expected_id:\n",
    "                    return None  # Wrong ID format\n",
    "            except:\n",
    "                return None\n",
    "            \n",
    "            # Validate 's' prefix on coordinates\n",
    "            if not (x.startswith('s') and y.startswith('s') and deg.startswith('s')):\n",
    "                return None  # Missing 's' prefix\n",
    "            \n",
    "            if n not in rows_by_n:\n",
    "                rows_by_n[n] = []\n",
    "            rows_by_n[n].append(parts)\n",
    "    return rows_by_n\n",
    "\n",
    "def parse_row_to_tuple(row):\n",
    "    \"\"\"Parse a row to (x, y, angle) tuple for score calculation.\"\"\"\n",
    "    x_str = row[1]\n",
    "    y_str = row[2]\n",
    "    deg_str = row[3]\n",
    "    x = float(x_str[1:] if x_str.startswith('s') else x_str)\n",
    "    y = float(y_str[1:] if y_str.startswith('s') else y_str)\n",
    "    angle = float(deg_str[1:] if deg_str.startswith('s') else deg_str)\n",
    "    return (x, y, angle)\n",
    "\n",
    "def calculate_score_from_rows(rows, n):\n",
    "    \"\"\"Calculate score from raw string rows.\"\"\"\n",
    "    trees = [parse_row_to_tuple(row) for row in rows]\n",
    "    return calculate_score_for_n(trees, n)\n",
    "\n",
    "print(\"Loading functions with full validation defined!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "3580576f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T21:37:57.581457Z",
     "iopub.status.busy": "2026-01-25T21:37:57.581335Z",
     "iopub.status.idle": "2026-01-25T21:38:01.922972Z",
     "shell.execute_reply": "2026-01-25T21:38:01.922526Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Baseline total score: 70.572798\n",
      "Baseline N=2 rows: [['002_0', 's0.154097069621355887', 's-0.038540742694794648', 's144.272760863123583164'], ['002_1', 's-0.154097069621372845', 's-0.561459257305224058', 's324.272760863123533426']]\n"
     ]
    }
   ],
   "source": [
    "# Load baseline (exp_001 which passed Kaggle) as raw strings\n",
    "baseline_path = '/home/nonroot/snapshots/santa-2025/21145966992/submission/submission.csv'\n",
    "baseline_raw = load_snapshot_with_full_validation(baseline_path)\n",
    "\n",
    "if baseline_raw is None:\n",
    "    print(\"ERROR: Baseline has format issues!\")\n",
    "else:\n",
    "    # Calculate baseline scores\n",
    "    baseline_scores = {n: calculate_score_from_rows(baseline_raw[n], n) for n in range(1, 201)}\n",
    "    baseline_total = sum(baseline_scores.values())\n",
    "    print(f\"Baseline total score: {baseline_total:.6f}\")\n",
    "    print(f\"Baseline N=2 rows: {baseline_raw[2]}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "a8db3bc5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T21:38:01.924129Z",
     "iopub.status.busy": "2026-01-25T21:38:01.924014Z",
     "iopub.status.idle": "2026-01-25T21:38:01.927161Z",
     "shell.execute_reply": "2026-01-25T21:38:01.926779Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Initialized with baseline\n"
     ]
    }
   ],
   "source": [
    "# Initialize best_per_n with baseline\n",
    "best_per_n = {\n",
    "    n: {\n",
    "        'score': baseline_scores[n],\n",
    "        'rows': baseline_raw[n],\n",
    "        'source': 'baseline'\n",
    "    } for n in range(1, 201)\n",
    "}\n",
    "\n",
    "print(\"Initialized with baseline\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "d5307a94",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T21:38:01.928170Z",
     "iopub.status.busy": "2026-01-25T21:38:01.928064Z",
     "iopub.status.idle": "2026-01-25T21:43:42.524064Z",
     "shell.execute_reply": "2026-01-25T21:43:42.523629Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Found 114 snapshot directories\n",
      "Excluding bad snapshots: {'21145963314', '21336527339', '21337107511', '21145965159'}\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Processed 20 snapshots, 2 improvements...\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Processed 40 snapshots, 178 improvements...\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Processed 60 snapshots, 419 improvements...\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Processed 80 snapshots, 466 improvements...\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Total: 84 snapshots processed\n",
      "Snapshots skipped (format issues): 4\n",
      "Improvements found: 467\n"
     ]
    }
   ],
   "source": [
    "# Load all snapshots and find improvements (excluding ALL bad snapshots)\n",
    "snapshot_base = '/home/nonroot/snapshots/santa-2025/'\n",
    "snapshot_dirs = sorted(os.listdir(snapshot_base))\n",
    "print(f\"Found {len(snapshot_dirs)} snapshot directories\")\n",
    "print(f\"Excluding bad snapshots: {BAD_SNAPSHOTS}\")\n",
    "\n",
    "improvements_found = 0\n",
    "snapshots_processed = 0\n",
    "snapshots_skipped = 0\n",
    "\n",
    "for snap_dir in snapshot_dirs:\n",
    "    # Skip known bad snapshots\n",
    "    if snap_dir in BAD_SNAPSHOTS:\n",
    "        snapshots_skipped += 1\n",
    "        continue\n",
    "    \n",
    "    sub_path = os.path.join(snapshot_base, snap_dir, 'submission', 'submission.csv')\n",
    "    if not os.path.exists(sub_path):\n",
    "        continue\n",
    "    \n",
    "    try:\n",
    "        snap_raw = load_snapshot_with_full_validation(sub_path)\n",
    "        \n",
    "        if snap_raw is None:\n",
    "            # This snapshot has format issues\n",
    "            snapshots_skipped += 1\n",
    "            continue\n",
    "        \n",
    "        # Check each N\n",
    "        for n in range(1, 201):\n",
    "            if n not in snap_raw:\n",
    "                continue\n",
    "            \n",
    "            rows = snap_raw[n]\n",
    "            score = calculate_score_from_rows(rows, n)\n",
    "            \n",
    "            # Only accept if better score\n",
    "            if score < best_per_n[n]['score'] - 1e-10:\n",
    "                best_per_n[n]['score'] = score\n",
    "                best_per_n[n]['rows'] = rows  # Keep original string rows!\n",
    "                best_per_n[n]['source'] = snap_dir\n",
    "                improvements_found += 1\n",
    "        \n",
    "        snapshots_processed += 1\n",
    "        if snapshots_processed % 20 == 0:\n",
    "            print(f\"Processed {snapshots_processed} snapshots, {improvements_found} improvements...\")\n",
    "                    \n",
    "    except Exception as e:\n",
    "        snapshots_skipped += 1\n",
    "\n",
    "print(f\"\\nTotal: {snapshots_processed} snapshots processed\")\n",
    "print(f\"Snapshots skipped (format issues): {snapshots_skipped}\")\n",
    "print(f\"Improvements found: {improvements_found}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "172bd54d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T21:43:42.525458Z",
     "iopub.status.busy": "2026-01-25T21:43:42.525328Z",
     "iopub.status.idle": "2026-01-25T21:43:42.528848Z",
     "shell.execute_reply": "2026-01-25T21:43:42.528454Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "New total score: 70.522682\n",
      "Baseline total: 70.572798\n",
      "Improvement: 0.050116\n",
      "\n",
      "Unique sources used: 9\n"
     ]
    }
   ],
   "source": [
    "# Calculate new total score\n",
    "new_total = sum(best_per_n[n]['score'] for n in range(1, 201))\n",
    "print(f\"New total score: {new_total:.6f}\")\n",
    "print(f\"Baseline total: {baseline_total:.6f}\")\n",
    "print(f\"Improvement: {baseline_total - new_total:.6f}\")\n",
    "\n",
    "# Count unique sources\n",
    "sources = set(best_per_n[n]['source'] for n in range(1, 201))\n",
    "print(f\"\\nUnique sources used: {len(sources)}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "6612fd21",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T21:43:42.529903Z",
     "iopub.status.busy": "2026-01-25T21:43:42.529788Z",
     "iopub.status.idle": "2026-01-25T21:43:42.533878Z",
     "shell.execute_reply": "2026-01-25T21:43:42.533446Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Top 20 improvements:\n",
      "  N=57: improved by 0.004536 from 21322576827\n",
      "  N=87: improved by 0.003050 from 21322576827\n",
      "  N=43: improved by 0.002975 from 21191209482\n",
      "  N=128: improved by 0.002525 from 21322576827\n",
      "  N=15: improved by 0.002254 from 21322576827\n",
      "  N=65: improved by 0.002184 from 21322576451\n",
      "  N=88: improved by 0.002050 from 21322576827\n",
      "  N=100: improved by 0.002017 from 21322576827\n",
      "  N=76: improved by 0.002008 from 21322576827\n",
      "  N=101: improved by 0.001733 from 21322577324\n",
      "  N=157: improved by 0.001674 from 21191209482\n",
      "  N=64: improved by 0.001667 from 21322576827\n",
      "  N=74: improved by 0.001430 from 21191209482\n",
      "  N=162: improved by 0.001311 from 21191209482\n",
      "  N=136: improved by 0.001301 from 21322576827\n",
      "  N=94: improved by 0.001194 from 21322577324\n",
      "  N=123: improved by 0.001173 from 21322576827\n",
      "  N=14: improved by 0.001026 from 21165872902\n",
      "  N=91: improved by 0.000987 from 21322576827\n",
      "  N=75: improved by 0.000875 from 21165872902\n",
      "\n",
      "Total N values improved: 116\n"
     ]
    }
   ],
   "source": [
    "# Show top improvements\n",
    "print(\"\\nTop 20 improvements:\")\n",
    "improved_n = []\n",
    "for n in range(1, 201):\n",
    "    if best_per_n[n]['source'] != 'baseline':\n",
    "        old_score = baseline_scores[n]\n",
    "        new_score = best_per_n[n]['score']\n",
    "        improved_n.append((n, old_score - new_score, best_per_n[n]['source']))\n",
    "\n",
    "for n, improvement, source in sorted(improved_n, key=lambda x: -x[1])[:20]:\n",
    "    print(f\"  N={n}: improved by {improvement:.6f} from {source}\")\n",
    "\n",
    "print(f\"\\nTotal N values improved: {len(improved_n)}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "c04ffb07",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T21:43:42.534985Z",
     "iopub.status.busy": "2026-01-25T21:43:42.534872Z",
     "iopub.status.idle": "2026-01-25T21:43:42.542512Z",
     "shell.execute_reply": "2026-01-25T21:43:42.542135Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Saved ensemble to /home/submission/submission.csv\n"
     ]
    }
   ],
   "source": [
    "# Write ensemble preserving original string precision\n",
    "def write_ensemble(best_per_n, output_path):\n",
    "    \"\"\"Write ensemble using original string rows (preserves precision).\"\"\"\n",
    "    with open(output_path, 'w') as f:\n",
    "        f.write('id,x,y,deg\\n')\n",
    "        for n in range(1, 201):\n",
    "            for row in best_per_n[n]['rows']:\n",
    "                f.write(','.join(row) + '\\n')\n",
    "\n",
    "write_ensemble(best_per_n, '/home/submission/submission.csv')\n",
    "print(\"Saved ensemble to /home/submission/submission.csv\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "8e3b8fb5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T21:43:42.543416Z",
     "iopub.status.busy": "2026-01-25T21:43:42.543301Z",
     "iopub.status.idle": "2026-01-25T21:43:42.568628Z",
     "shell.execute_reply": "2026-01-25T21:43:42.568217Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Validating submission format...\n",
      "✅ All format requirements passed!\n"
     ]
    }
   ],
   "source": [
    "# MANDATORY: Validate ALL format requirements before submission\n",
    "def validate_submission(path):\n",
    "    \"\"\"Verify ALL format requirements.\"\"\"\n",
    "    errors = []\n",
    "    with open(path, 'r') as f:\n",
    "        next(f)  # Skip header\n",
    "        for line_num, line in enumerate(f, 2):\n",
    "            parts = line.strip().split(',')\n",
    "            if len(parts) != 4:\n",
    "                errors.append(f\"Line {line_num}: wrong columns\")\n",
    "                continue\n",
    "            id_val, x, y, deg = parts\n",
    "            \n",
    "            # Check ID format\n",
    "            try:\n",
    "                n_str, idx_str = id_val.split('_')\n",
    "                n = int(n_str)\n",
    "                idx = int(idx_str)\n",
    "                expected_id = f\"{n:03d}_{idx}\"\n",
    "                if id_val != expected_id:\n",
    "                    errors.append(f\"Line {line_num}: ID '{id_val}' should be '{expected_id}'\")\n",
    "            except:\n",
    "                errors.append(f\"Line {line_num}: Invalid ID format '{id_val}'\")\n",
    "            \n",
    "            # Check 's' prefix\n",
    "            if not x.startswith('s'):\n",
    "                errors.append(f\"Line {line_num}: x missing 's' prefix: {x[:20]}\")\n",
    "            if not y.startswith('s'):\n",
    "                errors.append(f\"Line {line_num}: y missing 's' prefix: {y[:20]}\")\n",
    "            if not deg.startswith('s'):\n",
    "                errors.append(f\"Line {line_num}: deg missing 's' prefix: {deg[:20]}\")\n",
    "    \n",
    "    return errors\n",
    "\n",
    "print(\"Validating submission format...\")\n",
    "errors = validate_submission('/home/submission/submission.csv')\n",
    "if errors:\n",
    "    print(f\"ERRORS FOUND ({len(errors)}):\")\n",
    "    for e in errors[:20]:\n",
    "        print(f\"  {e}\")\n",
    "    print(\"\\n❌ SUBMISSION HAS FORMAT ERRORS - DO NOT SUBMIT!\")\n",
    "else:\n",
    "    print(\"✅ All format requirements passed!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "bcc6e9a1",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T21:43:42.569761Z",
     "iopub.status.busy": "2026-01-25T21:43:42.569405Z",
     "iopub.status.idle": "2026-01-25T21:43:46.826785Z",
     "shell.execute_reply": "2026-01-25T21:43:46.826327Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Verified score: 70.522682\n",
      "Expected score: 70.522682\n",
      "Match: True\n"
     ]
    }
   ],
   "source": [
    "# Verify the score by re-loading\n",
    "verify_raw = load_snapshot_with_full_validation('/home/submission/submission.csv')\n",
    "if verify_raw:\n",
    "    verify_total = sum(calculate_score_from_rows(verify_raw[n], n) for n in range(1, 201))\n",
    "    print(f\"Verified score: {verify_total:.6f}\")\n",
    "    print(f\"Expected score: {new_total:.6f}\")\n",
    "    print(f\"Match: {abs(verify_total - new_total) < 1e-10}\")\n",
    "else:\n",
    "    print(\"ERROR: Verification failed - format issues in output!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "37499abc",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T21:43:46.827941Z",
     "iopub.status.busy": "2026-01-25T21:43:46.827829Z",
     "iopub.status.idle": "2026-01-25T21:43:46.831689Z",
     "shell.execute_reply": "2026-01-25T21:43:46.831291Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Metrics saved.\n",
      "CV Score: 70.522682\n"
     ]
    }
   ],
   "source": [
    "# Save metrics\n",
    "metrics = {\n",
    "    'cv_score': new_total,\n",
    "    'baseline_score': baseline_total,\n",
    "    'improvement': baseline_total - new_total,\n",
    "    'improvements_found': improvements_found,\n",
    "    'unique_sources': len(sources),\n",
    "    'n_values_improved': len(improved_n),\n",
    "    'snapshots_skipped': snapshots_skipped,\n",
    "    'format_errors': len(errors) if errors else 0,\n",
    "    'notes': 'Fixed format ensemble excluding ALL 4 bad snapshots with ID and s-prefix validation.'\n",
    "}\n",
    "\n",
    "with open('/home/code/experiments/006_fixed_format_ensemble/metrics.json', 'w') as f:\n",
    "    json.dump(metrics, f, indent=2)\n",
    "\n",
    "print(\"Metrics saved.\")\n",
    "print(f\"CV Score: {new_total:.6f}\")"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}
