# Santa 2025 - Christmas Tree Packing Challenge: Seed Prompt (Loop 3)

## Current Status
- Best CV score: 70.522682 from exp_002 (ensemble)
- Best LB score: 70.615107 from exp_001 (baseline)
- Target: 68.887226 | Gap to target: 1.73 points (2.45% improvement needed)

## ⛔ CRITICAL: LAST SUBMISSION FAILED!

**exp_002 (ensemble) was REJECTED with "Overlapping trees in group 002"**

The ensemble approach combined best per-N solutions from 87 snapshots, achieving CV=70.522682 (improvement of 0.050 over baseline). However, Kaggle rejected it due to overlaps.

**ROOT CAUSE:** The local Shapely validation (area > 1e-15) is NOT the same as Kaggle's validation. Kaggle uses integer scaling (1e18) for precision. The ensemble mixed solutions from different sources that have incompatible precision characteristics.

## ⚠️ MANDATORY FIRST TASK: FIX VALIDATION

Before ANY new experiment, you MUST implement Kaggle-compatible validation using the ChristmasTree class from evolver_loop2_analysis.ipynb:

```python
from decimal import Decimal, getcontext
from shapely.geometry import Polygon
from shapely import affinity
from shapely.strtree import STRtree

getcontext().prec = 25
SCALE = Decimal("1e18")

class ChristmasTree:
    """Tree with Kaggle-compatible integer scaling."""
    def __init__(self, center_x="0", center_y="0", angle="0"):
        self.center_x = Decimal(center_x)
        self.center_y = Decimal(center_y)
        self.angle = Decimal(angle)
        
        trunk_w = Decimal("0.15")
        trunk_h = Decimal("0.2")
        base_w = Decimal("0.7")
        mid_w = Decimal("0.4")
        top_w = Decimal("0.25")
        tip_y = Decimal("0.8")
        tier_1_y = Decimal("0.5")
        tier_2_y = Decimal("0.25")
        base_y = Decimal("0.0")
        trunk_bottom_y = -trunk_h
        
        initial_polygon = Polygon([
            (Decimal("0.0") * SCALE, tip_y * SCALE),
            (top_w / Decimal("2") * SCALE, tier_1_y * SCALE),
            (top_w / Decimal("4") * SCALE, tier_1_y * SCALE),
            (mid_w / Decimal("2") * SCALE, tier_2_y * SCALE),
            (mid_w / Decimal("4") * SCALE, tier_2_y * SCALE),
            (base_w / Decimal("2") * SCALE, base_y * SCALE),
            (trunk_w / Decimal("2") * SCALE, base_y * SCALE),
            (trunk_w / Decimal("2") * SCALE, trunk_bottom_y * SCALE),
            (-(trunk_w / Decimal("2")) * SCALE, trunk_bottom_y * SCALE),
            (-(trunk_w / Decimal("2")) * SCALE, base_y * SCALE),
            (-(base_w / Decimal("2")) * SCALE, base_y * SCALE),
            (-(mid_w / Decimal("4")) * SCALE, tier_2_y * SCALE),
            (-(mid_w / Decimal("2")) * SCALE, tier_2_y * SCALE),
            (-(top_w / Decimal("4")) * SCALE, tier_1_y * SCALE),
            (-(top_w / Decimal("2")) * SCALE, tier_1_y * SCALE),
        ])
        
        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))
        self.polygon = affinity.translate(
            rotated,
            xoff=float(self.center_x * SCALE),
            yoff=float(self.center_y * SCALE)
        )

def has_overlap_kaggle(trees):
    """Check overlaps using Kaggle's method."""
    if len(trees) <= 1:
        return False, []
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    overlapping_pairs = []
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx <= i:
                continue
            if poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                overlapping_pairs.append((i, idx))
    return len(overlapping_pairs) > 0, overlapping_pairs

def load_trees_for_n(n, df):
    """Load all trees for a given N from the submission DataFrame."""
    group_data = df[df["id"].str.startswith(f"{n:03d}_")]
    trees = []
    for _, row in group_data.iterrows():
        x = str(row["x"]).lstrip('s')
        y = str(row["y"]).lstrip('s')
        deg = str(row["deg"]).lstrip('s')
        if x and y and deg:
            trees.append(ChristmasTree(x, y, deg))
    return trees
```

**USE THIS VALIDATION FOR EVERY N BEFORE SUBMISSION!**

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- Submitting without Kaggle-compatible validation - FORBIDDEN

## ✅ REQUIRED EXPERIMENT: SAFE ENSEMBLE WITH STRICT VALIDATION

### Step 1: Load the VALID baseline
Use snapshot 21337353543 which has 0 overlaps with Kaggle method and score 70.615107.

### Step 2: Build safe ensemble
For each N from 1 to 200:
1. Load candidate solution from each snapshot
2. Validate with Kaggle method (integer scaling)
3. If valid AND better than baseline, accept
4. If invalid OR worse, keep baseline

### Step 3: Validate ENTIRE submission
Before saving, validate ALL 200 N values with Kaggle method. If ANY N fails, fall back to baseline for that N.

### Step 4: Save and submit
Only save submission.csv if ALL 200 N values pass Kaggle validation.

## Per-N Analysis

Top 10 N values by contribution to score:
- N=1: 0.661250 (OPTIMAL - no improvement possible)
- N=2: 0.450779
- N=3: 0.434745
- N=5: 0.416850
- N=4: 0.416545
- N=7: 0.399897
- N=6: 0.399610
- N=9: 0.387415
- N=8: 0.385407
- N=15: 0.376949

## SUBMISSION STRATEGY
- Remaining submissions: 93
- Submit after this experiment? YES - we need to verify the safe ensemble passes Kaggle validation
- Even if score is worse than exp_001, we need to confirm our validation method works