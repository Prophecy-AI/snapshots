# Santa 2025 - Christmas Tree Packing Challenge: Seed Prompt

## Current Status
- Best CV score: 70.522682 from exp_004 (FAILED submission - ID format mismatch)
- Best LB score: 70.615107 from exp_001
- Target: 68.887226 | Gap to target: 1.73 points (2.51%)

## ⚠️ CRITICAL: exp_004 SUBMISSION FAILED

**Error:** "Solution and submission values for id do not match"

**Root Cause:** Some snapshots use wrong ID format:
- Expected: `013_0`, `013_1`, etc.
- Found: `013_000`, `013_001`, etc.

**Bad Snapshots (MUST EXCLUDE):**
- 21145963314
- 21337107511

**N values affected:** 13, 23, 29, 42, 44, 50

**FIX REQUIRED:** When building ensemble, either:
1. Filter out bad snapshots entirely, OR
2. Normalize IDs when loading (convert `013_000` to `013_0`)

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast_v2, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any tool - FORBIDDEN
- Loading solutions then running optimizer on them - FORBIDDEN

## ✅ EXPERIMENT 005: FIX ENSEMBLE + FRACTIONAL TRANSLATION

### STEP 1: Fix the Ensemble (MANDATORY)

Create a VALID ensemble by:
1. Exclude bad snapshots: 21145963314, 21337107511
2. Preserve original string precision (18+ decimal places)
3. Verify all IDs match expected format before writing

```python
# Bad snapshots to exclude
BAD_SNAPSHOTS = {'21145963314', '21337107511'}

def load_snapshot_raw(path):
    """Load snapshot preserving original string precision."""
    rows_by_n = {}
    with open(path, 'r') as f:
        next(f)  # Skip header
        for line in f:
            parts = line.strip().split(',')
            if len(parts) != 4:
                continue
            id_val = parts[0]
            n_str, idx_str = id_val.split('_')
            n = int(n_str)
            
            # Verify ID format is correct
            expected_id = f"{n:03d}_{int(idx_str)}"
            if id_val != expected_id:
                print(f"WARNING: Wrong ID format {id_val}, expected {expected_id}")
                return None  # Skip this snapshot
            
            if n not in rows_by_n:
                rows_by_n[n] = []
            rows_by_n[n].append(parts)
    return rows_by_n

# When scanning snapshots:
for snap_dir in snapshot_dirs:
    if snap_dir in BAD_SNAPSHOTS:
        continue  # Skip bad snapshots
    # ... rest of loading code
```

### STEP 2: Implement Fractional Translation (NOVEL ALGORITHM)

This is from the top kernel - implementable in pure Python:

```python
import numpy as np
from shapely.geometry import Polygon
from shapely import affinity
from shapely.ops import unary_union

# Tree polygon vertices
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def create_tree_polygon(x, y, angle):
    poly = Polygon(zip(TX, TY))
    poly = affinity.rotate(poly, angle, origin=(0, 0))
    poly = affinity.translate(poly, x, y)
    return poly

def calculate_side(trees):
    polys = [create_tree_polygon(*t) for t in trees]
    union = unary_union(polys)
    bounds = union.bounds
    return max(bounds[2] - bounds[0], bounds[3] - bounds[1])

def check_overlap(trees):
    """Check if any trees overlap."""
    polys = [create_tree_polygon(*t) for t in trees]
    for i in range(len(polys)):
        for j in range(i+1, len(polys)):
            if polys[i].intersects(polys[j]) and not polys[i].touches(polys[j]):
                return True
    return False

def fractional_translation(trees, n):
    """Apply fractional translation to improve solution."""
    step_sizes = [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), 
                  (1, 1), (1, -1), (-1, 1), (-1, -1)]
    
    best_trees = list(trees)
    best_side = calculate_side(best_trees)
    improved = True
    
    while improved:
        improved = False
        for tree_idx in range(len(best_trees)):
            for step in step_sizes:
                for dx, dy in directions:
                    # Try moving this tree
                    new_trees = list(best_trees)
                    x, y, angle = new_trees[tree_idx]
                    new_trees[tree_idx] = (x + dx * step, y + dy * step, angle)
                    
                    # Check if valid and better
                    if not check_overlap(new_trees):
                        new_side = calculate_side(new_trees)
                        if new_side < best_side - 1e-10:
                            best_trees = new_trees
                            best_side = new_side
                            improved = True
                            print(f"N={n}, tree {tree_idx}: improved to {best_side:.6f}")
    
    return best_trees, best_side

# Apply to small N first (highest impact)
for n in range(2, 21):  # N=2 to N=20
    trees = load_trees_for_n(n)
    improved_trees, new_side = fractional_translation(trees, n)
    # Save if improved
```

### STEP 3: Validate Before Submission

```python
# Verify all IDs are correct format
def validate_submission(path):
    with open(path, 'r') as f:
        next(f)  # Skip header
        for line in f:
            parts = line.strip().split(',')
            id_val = parts[0]
            n_str, idx_str = id_val.split('_')
            n = int(n_str)
            expected_id = f"{n:03d}_{int(idx_str)}"
            if id_val != expected_id:
                print(f"ERROR: Wrong ID format {id_val}")
                return False
    return True

# Run before every submission
assert validate_submission('/home/submission/submission.csv'), "ID format validation failed!"
```

## Per-N Score Analysis (from baseline)

Top contributors to score:
- N=1: 0.661250 (OPTIMAL - no improvement possible)
- N=2: 0.437328 (24% gap from theoretical)
- N=3: 0.434745 (49% gap)
- N=4: 0.411056 (60% gap)
- N=5: 0.394109 (66% gap)

**Focus on N=2-20 for biggest impact!**

## Validation Requirements

1. **ID Format:** `NNN_I` where NNN is zero-padded N, I is tree index (NOT zero-padded)
   - Correct: `013_0`, `013_12`
   - Wrong: `013_000`, `013_012`

2. **Precision:** Preserve 18+ decimal places from original strings

3. **Overlap Detection:** Kaggle uses integer scaling (1e18)

## Expected Outcome

1. Fixed ensemble should achieve CV ~70.52 and PASS Kaggle validation
2. Fractional translation on N=2-20 could improve by 0.1-0.5 points
3. Submit after EVERY experiment - we have 93 submissions remaining!

## What NOT to Try
- Running bbox3/sa_fast/any binary (produces ~70.6, can't reach 68.89)
- Using snapshots 21145963314 or 21337107511 (wrong ID format)
- Re-serializing floats (loses precision)
