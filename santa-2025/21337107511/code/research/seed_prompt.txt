# Santa 2025 - Christmas Tree Packing Challenge: Seed Prompt

## Current Status
- Best CV score: 70.522682 from exp_002 (ensemble) - BUT FAILED KAGGLE VALIDATION
- Best LB score: 70.615107 from exp_001 (baseline)
- Target: 68.887226 | Gap to target: 1.728 points (2.51% improvement needed)

## CRITICAL DISCOVERY: PRECISION LOSS ISSUE

**exp_002 failed with "Overlapping trees in group 002" because of PRECISION LOSS!**

When parsing coordinates with `float()` and re-saving:
- Original: `s0.154097069621355887` (18 decimal places)
- After float(): `s0.1540970696213559` (16 decimal places)

This precision loss causes Kaggle's overlap detection to fail!

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with binaries - FORBIDDEN

## ✅ MANDATORY EXPERIMENT: PRECISION-PRESERVING ENSEMBLE

**This is the HIGHEST PRIORITY task. Do this FIRST.**

The ensemble approach (exp_002) showed 0.05 improvement but failed validation.
We need to preserve original string precision when combining solutions.

### Implementation:

```python
def load_snapshot_raw(path):
    """Load snapshot preserving original string precision."""
    rows_by_n = {}
    with open(path, 'r') as f:
        next(f)  # Skip header
        for line in f:
            parts = line.strip().split(',')
            if len(parts) != 4:
                continue
            id_val = parts[0]
            n = int(id_val.split('_')[0])
            if n not in rows_by_n:
                rows_by_n[n] = []
            rows_by_n[n].append(parts)  # Keep as strings!
    return rows_by_n

def calculate_score_from_strings(rows, n):
    """Calculate score by parsing floats (for comparison only)."""
    trees = []
    for parts in rows:
        x = float(parts[1][1:] if parts[1].startswith('s') else parts[1])
        y = float(parts[2][1:] if parts[2].startswith('s') else parts[2])
        angle = float(parts[3][1:] if parts[3].startswith('s') else parts[3])
        trees.append((x, y, angle))
    return calculate_score_for_n(trees, n)

# CRITICAL: When writing ensemble, use original string rows!
def write_ensemble(best_per_n, output_path):
    """Write ensemble using original string rows (preserves precision)."""
    with open(output_path, 'w') as f:
        f.write('id,x,y,deg\n')
        for n in range(1, 201):
            for row in best_per_n[n]['rows']:
                f.write(','.join(row) + '\n')
```

### Steps:
1. Load baseline (exp_001 which passed Kaggle) as raw strings
2. Load all 114 snapshots as raw strings
3. For each N (1-200):
   - Calculate score for each snapshot's N solution (using float parsing for comparison ONLY)
   - Track the best score AND the original string rows
4. Build ensemble using original string rows (NOT re-serialized floats)
5. Write directly to CSV without any float conversion

### Expected Improvement:
- exp_002 showed CV improvement of 0.05 (70.572798 → 70.522682)
- With precision preservation, this should pass Kaggle validation

## ✅ SECONDARY TASK: FRACTIONAL TRANSLATION IN PYTHON

After the ensemble is working, implement fractional translation to further improve solutions.

**Algorithm from top kernel:**
```python
# Step sizes to try (from smallest to largest impact)
frac_steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]

# 8 directions: N, S, E, W, NE, NW, SE, SW
dx = [0, 0, 1, -1, 1, 1, -1, -1]
dy = [1, -1, 0, 0, 1, -1, 1, -1]

def fractional_translation(trees, n, max_iter=200):
    """Improve solution by small translations."""
    best_trees = trees.copy()
    best_score = calculate_score_for_n(best_trees, n)
    
    for iteration in range(max_iter):
        improved = False
        for i in range(len(best_trees)):
            for step in frac_steps:
                for d in range(8):
                    # Try moving tree i by (dx[d]*step, dy[d]*step)
                    new_trees = best_trees.copy()
                    x, y, angle = new_trees[i]
                    new_trees[i] = (x + dx[d]*step, y + dy[d]*step, angle)
                    
                    # Check for overlaps
                    if not has_overlap(new_trees):
                        new_score = calculate_score_for_n(new_trees, n)
                        if new_score < best_score - 1e-12:
                            best_score = new_score
                            best_trees = new_trees
                            improved = True
        
        if not improved:
            break
    
    return best_trees, best_score
```

**IMPORTANT:** This must be implemented in pure Python, NOT using any binary!

## Tree Geometry (15 vertices)

```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## Overlap Detection (Kaggle-Compatible)

Use integer scaling (1e18) for Kaggle-compatible overlap detection:

```python
from decimal import Decimal, getcontext
getcontext().prec = 25
SCALE = Decimal("1e18")

# When creating polygons for overlap detection, scale coordinates to integers
# This matches Kaggle's validation method
```

## Baseline Solutions

Pre-optimized solutions exist in `/home/nonroot/snapshots/santa-2025/`. There are 114 snapshot directories.

**IMPORTANT:** The baseline (exp_001, snapshot 21145966992) passed Kaggle with LB=70.615107.
Use this as the starting point for the ensemble.

## Key Insights

1. **N=1 is already optimal** at 45° rotation (score=0.661250). Don't try to improve it.
2. **Precision is critical** - coordinates have 18+ decimal places for a reason!
3. **Ensemble approach works** - exp_002 showed 0.05 improvement, just need to preserve precision
4. **Fractional translation** is a simple local search that can improve solutions further

## Experiment Workflow

1. **exp_004: Precision-Preserving Ensemble**
   - Load all snapshots as raw strings
   - Build ensemble preserving original precision
   - Validate with Kaggle-compatible method
   - Submit to verify it passes

2. **exp_005+: Fractional Translation**
   - Implement fractional translation in Python
   - Apply to ensemble to further improve
   - Track per-N improvements

## Gap Analysis

- Target: 68.887226
- Best LB: 70.615107
- Gap: 1.728 points (2.51% improvement needed)

**Potential Improvements:**
- Precision-preserving ensemble: ~0.05 (from exp_002)
- Fractional translation: unknown, but top kernels use it
- Additional optimization: unknown

The gap is significant (1.73 points), so we need multiple improvements to reach the target.
