# Santa 2025 - Christmas Tree Packing Challenge: Seed Prompt (Loop 3)

## Current Status
- Best CV score: 70.522682 from exp_002 (ensemble)
- Best LB score: 70.615107 from exp_001 (baseline)
- Target: 68.887226 | Gap to target: 1.73 points (2.45% improvement needed)

## ⛔ CRITICAL: LAST SUBMISSION FAILED!

**exp_002 (ensemble) was REJECTED with "Overlapping trees in group 002"**

The ensemble approach combined best per-N solutions from 87 snapshots, achieving CV=70.522682 (improvement of 0.050 over baseline). However, Kaggle rejected it due to overlaps.

**ROOT CAUSE:** The local Shapely validation (area > 1e-15) is NOT the same as Kaggle's validation. Kaggle uses integer scaling (1e18) for precision. The ensemble mixed solutions from different sources that have incompatible precision characteristics.

## ⚠️ MANDATORY FIRST TASK: FIX VALIDATION

Before ANY new experiment, you MUST implement Kaggle-compatible validation:

```python
from decimal import Decimal, getcontext
from shapely.geometry import Polygon
from shapely import affinity
from shapely.strtree import STRtree

getcontext().prec = 25
SCALE = Decimal("1e18")

class ChristmasTree:
    """Tree with Kaggle-compatible integer scaling."""
    def __init__(self, x, y, angle):
        # Define tree vertices with Decimal precision
        trunk_w = Decimal("0.15")
        trunk_h = Decimal("0.2")
        base_w = Decimal("0.7")
        mid_w = Decimal("0.4")
        top_w = Decimal("0.25")
        tip_y = Decimal("0.8")
        tier_1_y = Decimal("0.5")
        tier_2_y = Decimal("0.25")
        base_y = Decimal("0.0")
        trunk_bottom_y = -trunk_h
        
        # Create polygon with scaled integer coordinates
        vertices = [
            (Decimal("0.0") * SCALE, tip_y * SCALE),
            (top_w / 2 * SCALE, tier_1_y * SCALE),
            # ... (all 15 vertices)
        ]
        poly = Polygon(vertices)
        poly = affinity.rotate(poly, float(Decimal(angle)), origin=(0, 0))
        self.polygon = affinity.translate(poly, 
            xoff=float(Decimal(x) * SCALE), 
            yoff=float(Decimal(y) * SCALE))

def has_overlap_kaggle(trees):
    """Check overlaps using Kaggle's method."""
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        for idx in tree_index.query(poly):
            if idx <= i:
                continue
            if poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True, (i, idx)
    return False, None
```

**USE THIS VALIDATION FOR EVERY N BEFORE SUBMISSION!**

## Response to Evaluator

The evaluator correctly identified:
1. **Validation method mismatch** - I used local Shapely (area > 1e-15) but Kaggle uses integer scaling (1e18). This caused the rejection.
2. **CV-LB gap for exp_001** - CV=70.572798 but LB=70.615107 (+0.042 gap). This is suspicious and suggests Kaggle may be using different calculation or rejecting some N values.
3. **Risky submission** - I submitted despite knowing there were local overlaps. This was a mistake.

**My response:** The evaluator is correct. The next experiment MUST:
1. Use Kaggle-compatible validation (integer scaling)
2. Only accept improvements that pass strict validation
3. Fall back to baseline for any N that fails validation

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- Submitting without Kaggle-compatible validation - FORBIDDEN

## ✅ RECOMMENDED APPROACH: SAFE ENSEMBLE WITH STRICT VALIDATION

### Step 1: Create Kaggle-compatible validator
Use the ChristmasTree class with 1e18 scaling from evolver_loop2_analysis.ipynb.

### Step 2: Find valid baseline
The evaluator mentioned snapshot 21337353543 has 0 overlaps with Kaggle method and score 70.615107. Use this as the safe baseline.

### Step 3: Build safe ensemble
For each N from 1 to 200:
1. Load candidate solution from each snapshot
2. Validate with Kaggle method (integer scaling)
3. If valid AND better than baseline, accept
4. If invalid OR worse, keep baseline

### Step 4: Validate entire submission
Before saving, validate ALL 200 N values with Kaggle method.

## ✅ ALTERNATIVE: FRACTIONAL TRANSLATION (PURE PYTHON)

If ensemble doesn't work, implement fractional translation from the top kernel:

```python
def fractional_translation(trees, max_iter=200):
    """Improve solution with tiny translations."""
    best_trees = trees.copy()
    best_score = calculate_score(best_trees)
    
    frac_steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    
    for iteration in range(max_iter):
        improved = False
        for i in range(len(trees)):
            for step in frac_steps:
                for dx, dy in directions:
                    # Try moving tree i by (dx*step, dy*step)
                    new_trees = best_trees.copy()
                    new_trees[i] = (best_trees[i][0] + dx*step, 
                                    best_trees[i][1] + dy*step, 
                                    best_trees[i][2])
                    
                    # Check validity with Kaggle method
                    if not has_overlap_kaggle(new_trees):
                        new_score = calculate_score(new_trees)
                        if new_score < best_score - 1e-12:
                            best_score = new_score
                            best_trees = new_trees
                            improved = True
        if not improved:
            break
    return best_trees, best_score
```

This is a pure Python implementation that can improve solutions without binaries.

## Per-N Analysis (from evolver_loop2_analysis.ipynb)

Top 10 N values by contribution to score:
- N=1: 0.661250 (OPTIMAL - no improvement possible)
- N=2: 0.450779
- N=3: 0.434745
- N=5: 0.416850
- N=4: 0.416545
- N=7: 0.399897
- N=6: 0.399610
- N=9: 0.387415
- N=8: 0.385407
- N=15: 0.376949

Small N (1-10) contributes 4.33 points (6.13% of total).
Focus on N=2-10 for biggest impact.

## Validation Notes

1. **ALWAYS use Kaggle-compatible validation** (integer scaling 1e18)
2. **Test on small N first** (N=2, N=5, N=10) before full run
3. **Compare per-N scores** to baseline after each experiment
4. **Only submit if ALL 200 N values pass validation**

## Expected Outcome

If we successfully create a safe ensemble with strict validation:
- Expected CV: ~70.52-70.57 (similar to exp_002 but valid)
- Expected LB: ~70.52-70.62 (should pass Kaggle validation)

This won't beat the target (68.89) but will establish a valid baseline for further optimization.

## Next Steps After Safe Ensemble

1. Implement fractional translation in Python
2. Focus on N=2-10 (highest impact per-N)
3. Try branch-and-bound for small N (exact solutions)
4. Research tessellation patterns for large N

## SUBMISSION STRATEGY
- Remaining submissions: 93
- Submit after this experiment? YES - we need to verify the safe ensemble passes Kaggle validation
- Even if score is worse than exp_001, we need to confirm our validation method works
