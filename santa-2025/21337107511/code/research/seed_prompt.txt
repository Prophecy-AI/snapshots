# Santa 2025 - Evolved Seed Prompt (Loop 2)

## Current Status
- Best CV score: 70.615107 from snapshot 21337353543 (VALID - 0 overlaps with Kaggle method)
- Best LB score: PENDING (first submission failed due to overlaps)
- Target: 68.887744 | Gap to target: 1.727 points (2.45% improvement needed)

## ⚠️ CRITICAL: OVERLAP VALIDATION FIXED

**BREAKTHROUGH: Found the correct validation method!**

Kaggle uses **integer scaling (1e18)** for overlap detection. The key code from top kernels:

```python
from decimal import Decimal, getcontext
getcontext().prec = 25
scale_factor = Decimal("1e18")

# Create polygon with scaled integer coordinates
initial_polygon = Polygon([
    (Decimal("0.0") * scale_factor, tip_y * scale_factor),
    ...
])
```

**Results of validation analysis:**
- Snapshot 21145966992 (score 70.572798): 72 N values with overlaps - INVALID
- Snapshot 21331543270 (score 70.615791): 1 N value with overlap (N=40) - INVALID  
- Snapshot 21337353543 (score 70.615107): 0 overlaps - VALID ✅

The current submission file is from snapshot 21337353543 and is VALID.

## Response to Evaluator

The evaluator correctly identified:
1. The previous submission (21145966992) has 72 N values with overlaps - CONFIRMED
2. Need to use Kaggle-compatible validation - IMPLEMENTED
3. N=1 is already optimal at 45° - CONFIRMED

**Action taken:** Replaced submission with best VALID snapshot (21337353543, score 70.615107).

## ✅ MANDATORY FIRST TASK: SUBMIT VALID BASELINE

**The submission file is ready and validated. Submit it NOW to get LB feedback.**

```bash
# Current submission is from snapshot 21337353543
# Score: 70.615107
# Overlaps: 0 (validated with Kaggle method)
```

After submission, we'll have a confirmed valid baseline to improve upon.

## Recommended Approaches (Priority Order)

### 1. **[IMMEDIATE]** Submit Current Baseline
- File: /home/submission/submission.csv (from snapshot 21337353543)
- Expected LB: ~70.615 (should pass validation)
- This gives us a confirmed baseline

### 2. **[HIGH PRIORITY]** Implement Per-N Ensemble Strategy
The key to winning is accumulating improvements across many experiments:
- Track best solution for EACH N separately
- After each experiment, compare per-N scores
- Keep only N values where you improved
- Final submission = best per-N from all sources

```python
# Per-N tracking infrastructure
best_per_n = {}  # {n: (score, solution_source)}

def update_best_per_n(new_solution, source_name):
    for n in range(1, 201):
        new_score = calculate_score_for_n(new_solution, n)
        if n not in best_per_n or new_score < best_per_n[n][0]:
            best_per_n[n] = (new_score, source_name)
            print(f"✅ N={n}: IMPROVED to {new_score:.6f} from {source_name}")
```

### 3. **[HIGH PRIORITY]** Implement N=2-10 Optimization
Small N values have the most room for improvement:
- N=2: Current 0.450779, theoretical min ~0.246 (gap 0.205)
- N=3: Current 0.434745, theoretical min ~0.246 (gap 0.189)
- N=4-10: Similar gaps

**Approach for N=2:**
```python
def optimize_n2():
    """Find optimal placement for 2 trees."""
    best_score = float('inf')
    best_config = None
    
    # Try different relative positions and angles
    for angle1 in range(0, 360, 1):  # 1 degree increments
        for angle2 in range(0, 360, 1):
            for dx in np.linspace(-1, 1, 100):
                for dy in np.linspace(-1, 1, 100):
                    config = [(0, 0, angle1), (dx, dy, angle2)]
                    if not has_overlap(config):
                        score = calculate_bbox_score(config)
                        if score < best_score:
                            best_score = score
                            best_config = config
    return best_config
```

### 4. **[MEDIUM PRIORITY]** Implement Bottom-Left Constructive Heuristic
For N > 10, use constructive placement:
```python
def bottom_left_fill(n, existing_trees=None):
    trees = existing_trees or []
    while len(trees) < n:
        best_pos = None
        best_score = float('inf')
        
        # Try many positions and rotations
        for angle in range(0, 360, 5):
            for pos in candidate_positions(trees, angle):
                if not has_overlap(trees + [(pos[0], pos[1], angle)]):
                    score = evaluate_bbox(trees + [(pos[0], pos[1], angle)])
                    if score < best_score:
                        best_score = score
                        best_pos = (pos[0], pos[1], angle)
        
        if best_pos:
            trees.append(best_pos)
        else:
            raise ValueError(f"Cannot place tree {len(trees)+1}")
    
    return trees
```

### 5. **[LOWER PRIORITY]** Custom Local Search
After constructive placement, refine with local search:
```python
def local_search(trees, iterations=10000):
    best_trees = trees.copy()
    best_score = calculate_score(trees)
    
    for _ in range(iterations):
        # Random move: translate or rotate one tree
        i = random.randint(0, len(trees)-1)
        move_type = random.choice(['translate', 'rotate'])
        
        if move_type == 'translate':
            dx = random.uniform(-0.01, 0.01)
            dy = random.uniform(-0.01, 0.01)
            new_tree = (trees[i][0]+dx, trees[i][1]+dy, trees[i][2])
        else:
            da = random.uniform(-5, 5)
            new_tree = (trees[i][0], trees[i][1], trees[i][2]+da)
        
        new_trees = trees.copy()
        new_trees[i] = new_tree
        
        if not has_overlap(new_trees):
            new_score = calculate_score(new_trees)
            if new_score < best_score:
                best_score = new_score
                best_trees = new_trees.copy()
                trees = new_trees.copy()
    
    return best_trees
```

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast_v2, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- Generating solutions without Kaggle-compatible overlap validation - FORBIDDEN

## ✅ MANDATORY: Kaggle-Compatible Validation

**EVERY solution MUST be validated with this code before submission:**

```python
from decimal import Decimal, getcontext
from shapely import affinity
from shapely.geometry import Polygon
from shapely.strtree import STRtree

getcontext().prec = 25
scale_factor = Decimal("1e18")

class ChristmasTree:
    def __init__(self, center_x="0", center_y="0", angle="0"):
        self.center_x = Decimal(center_x)
        self.center_y = Decimal(center_y)
        self.angle = Decimal(angle)
        
        trunk_w = Decimal("0.15")
        trunk_h = Decimal("0.2")
        base_w = Decimal("0.7")
        mid_w = Decimal("0.4")
        top_w = Decimal("0.25")
        tip_y = Decimal("0.8")
        tier_1_y = Decimal("0.5")
        tier_2_y = Decimal("0.25")
        base_y = Decimal("0.0")
        trunk_bottom_y = -trunk_h
        
        initial_polygon = Polygon([
            (Decimal("0.0") * scale_factor, tip_y * scale_factor),
            (top_w / Decimal("2") * scale_factor, tier_1_y * scale_factor),
            (top_w / Decimal("4") * scale_factor, tier_1_y * scale_factor),
            (mid_w / Decimal("2") * scale_factor, tier_2_y * scale_factor),
            (mid_w / Decimal("4") * scale_factor, tier_2_y * scale_factor),
            (base_w / Decimal("2") * scale_factor, base_y * scale_factor),
            (trunk_w / Decimal("2") * scale_factor, base_y * scale_factor),
            (trunk_w / Decimal("2") * scale_factor, trunk_bottom_y * scale_factor),
            (-(trunk_w / Decimal("2")) * scale_factor, trunk_bottom_y * scale_factor),
            (-(trunk_w / Decimal("2")) * scale_factor, base_y * scale_factor),
            (-(base_w / Decimal("2")) * scale_factor, base_y * scale_factor),
            (-(mid_w / Decimal("4")) * scale_factor, tier_2_y * scale_factor),
            (-(mid_w / Decimal("2")) * scale_factor, tier_2_y * scale_factor),
            (-(top_w / Decimal("4")) * scale_factor, tier_1_y * scale_factor),
            (-(top_w / Decimal("2")) * scale_factor, tier_1_y * scale_factor),
        ])
        
        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))
        self.polygon = affinity.translate(
            rotated,
            xoff=float(self.center_x * scale_factor),
            yoff=float(self.center_y * scale_factor)
        )

def has_overlap_kaggle(trees):
    """Check if any two ChristmasTree polygons overlap - KAGGLE METHOD."""
    if len(trees) <= 1:
        return False
    
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx == i:
                continue
            if poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False

# VALIDATE BEFORE EVERY SUBMISSION!
def validate_submission(csv_path):
    df = pd.read_csv(csv_path)
    invalid_ns = []
    for n in range(1, 201):
        group_data = df[df["id"].str.startswith(f"{n:03d}_")]
        trees = []
        for _, row in group_data.iterrows():
            x = str(row["x"]).lstrip('s')
            y = str(row["y"]).lstrip('s')
            deg = str(row["deg"]).lstrip('s')
            trees.append(ChristmasTree(x, y, deg))
        if has_overlap_kaggle(trees):
            invalid_ns.append(n)
    return invalid_ns
```

## Per-N Score Analysis

From baseline (70.615107):
- N=1: 0.661250 (OPTIMAL - no improvement possible)
- N=2: 0.450779 (theoretical min ~0.246, gap = 0.205)
- N=3: 0.434745 (gap = 0.189)
- N=4: 0.416545 (gap = 0.171)
- N=5: 0.416850 (gap = 0.171)
- N=6-10: Similar gaps

**Small N (1-10) contribute 4.329 points (6.13% of total).**
**Even 10% improvement on N=2-10 = 0.37 points toward target!**

## Submission Strategy
- Remaining submissions: 94 (ABUNDANT!)
- **Submit after EVERY experiment** to get LB feedback
- LB feedback is FREE information - use it!
- Track CV-LB relationship to calibrate expectations

## What NOT to Try
- Running bbox3/sa_fast binaries (produces same ~70.6 score)
- Optimizing existing CSV files with binaries
- Solutions without Kaggle-compatible validation

## Tree Geometry (15 vertices)

```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

# Tree dimensions:
# - Height: 1.0 (from trunk bottom at -0.2 to tip at 0.8)
# - Max width: 0.7 (at base tier)
# - Trunk: 0.15 wide, 0.2 tall
```

## Existing Valid Snapshots

Best valid snapshots (0 overlaps with Kaggle method):
- 21337353543: 70.615744 (BEST - currently in submission)
- 21329068588: 70.622435
- 21222392487: 70.626088
- 21191211160: 70.627582
- 21165874980: 70.630478

Use these as baselines for per-N comparison.
