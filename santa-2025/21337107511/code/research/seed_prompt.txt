# Santa 2025 - Christmas Tree Packing: Evolved Seed Prompt (Loop 7)

## Current Status
- **Best CV score**: 70.615107 (valid baseline from snapshot 21337353543)
- **Best LB score**: 70.615107 (exp_001)
- **Target**: 68.887226
- **Gap to target**: 1.73 points (2.5%)
- **Submissions used**: 5/100 (95 remaining)

## ⚠️ CRITICAL DISCOVERY FROM LOOP 7

**The ensemble approach is EXHAUSTED:**
1. The valid baseline (21337353543) has score 70.615107 with ZERO overlaps
2. The snapshot 21145966992 we used in exp_002-006 has MASSIVE overlaps (N=2 has 0.149 overlap area!)
3. When filtering for overlap-free solutions, only 30 improvements exist with total gain ~1e-8 (numerical noise)
4. **All 4 ensemble submissions failed because they used the WRONG baseline**

**The only path forward is to GENERATE BETTER SOLUTIONS from scratch.**

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast_v2, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- More ensemble attempts - EXHAUSTED, no more gains possible
- Using snapshot 21145966992 as baseline - HAS OVERLAPS

## ✅ REQUIRED: Use the CORRECT baseline

The ONLY valid baseline is snapshot 21337353543:
```python
VALID_BASELINE = '/home/nonroot/snapshots/santa-2025/21337353543/submission/submission.csv'
# Score: 70.615107 (matches LB exactly)
# Overlaps: 0 (verified)
```

## ✅ MANDATORY FIRST TASK: Implement Fractional Translation

The top kernel uses fractional translation to improve solutions. Implement this in pure Python:

```python
from shapely.geometry import Polygon
from shapely import affinity
from shapely.ops import unary_union

TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def create_tree(x, y, angle):
    poly = Polygon(zip(TX, TY))
    poly = affinity.rotate(poly, angle, origin=(0, 0))
    poly = affinity.translate(poly, x, y)
    return poly

def calculate_side(trees):
    polys = [create_tree(*t) for t in trees]
    union = unary_union(polys)
    bounds = union.bounds
    return max(bounds[2] - bounds[0], bounds[3] - bounds[1])

def has_overlap(trees):
    polys = [create_tree(*t) for t in trees]
    for i in range(len(polys)):
        for j in range(i+1, len(polys)):
            if polys[i].intersects(polys[j]) and not polys[i].touches(polys[j]):
                return True
    return False

def fractional_translation(trees, n, step_sizes=[0.001, 0.0005, 0.0002, 0.0001]):
    """Improve solution by small translations in 8 directions."""
    directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (1,-1), (-1,1), (-1,-1)]
    best_side = calculate_side(trees)
    best_trees = list(trees)
    
    improved = True
    while improved:
        improved = False
        for i in range(len(trees)):
            for step in step_sizes:
                for dx, dy in directions:
                    new_trees = list(best_trees)
                    x, y, angle = new_trees[i]
                    new_trees[i] = (x + dx*step, y + dy*step, angle)
                    
                    if not has_overlap(new_trees):
                        new_side = calculate_side(new_trees)
                        if new_side < best_side - 1e-10:
                            best_side = new_side
                            best_trees = new_trees
                            improved = True
    
    return best_trees, best_side
```

## ✅ REQUIRED: Test on Small N First

Before running on all N=1-200, test on small N values:

```python
# Test on N=10, N=20, N=30
for n in [10, 20, 30]:
    baseline_trees = load_n_from_baseline(n)
    baseline_side = calculate_side(baseline_trees)
    
    improved_trees, improved_side = fractional_translation(baseline_trees, n)
    
    improvement = baseline_side - improved_side
    print(f"N={n}: baseline={baseline_side:.6f}, improved={improved_side:.6f}, gain={improvement:.6f}")
```

If fractional translation shows improvement on small N, then scale up to all N.

## ✅ REQUIRED: Overlap Validation Before Submission

EVERY solution must pass overlap validation before submission:

```python
def validate_no_overlap(trees):
    """Validate using standard Shapely (matches Kaggle)."""
    polys = [create_tree(*t) for t in trees]
    for i in range(len(polys)):
        for j in range(i+1, len(polys)):
            if polys[i].intersects(polys[j]) and not polys[i].touches(polys[j]):
                return False, f"Trees {i} and {j} overlap"
    return True, "OK"

# Before saving submission:
for n in range(1, 201):
    ok, msg = validate_no_overlap(solution[n])
    if not ok:
        print(f"N={n}: {msg} - FALLING BACK TO BASELINE")
        solution[n] = baseline[n]
```

## Experiment Structure

Create: `experiments/007_fractional_translation/`

1. Load valid baseline (21337353543)
2. Implement fractional_translation() in pure Python
3. Test on N=10, N=20, N=30 first
4. If improvements found, run on all N=1-200
5. Validate ALL solutions for overlaps
6. Save submission and log experiment

## Expected Outcome

- Fractional translation should find small improvements (0.001-0.01 per N)
- Total improvement: 0.01-0.1 points
- This is incremental progress toward the 1.73 point gap

## After This Experiment

If fractional translation works:
- Submit to get LB feedback
- Implement rotation optimization (try small angle changes)
- Implement "squeeze" operation (scale trees toward center)

If fractional translation doesn't work:
- Implement genetic algorithm with custom crossover
- Try constructive heuristics (bottom-left fill)
- Research what top teams actually did differently

## Key Metrics to Track

For each N, track:
- Baseline score
- Improved score
- Improvement amount
- Whether overlap validation passed

Only count improvements where validation passed.
