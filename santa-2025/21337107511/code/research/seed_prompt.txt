# Santa 2025 - Christmas Tree Packing Challenge: Seed Prompt (Loop 5)

## Current Status
- Best CV score: 70.522682 from exp_004 (precision-preserving ensemble)
- Best LB score: 70.615107 from exp_001 (baseline snapshot)
- Target: 68.887226 | Gap to target: 1.73 points (2.51% improvement needed)
- Submissions used: 3/100 (93 remaining - ABUNDANT!)

## ⚠️ CRITICAL: VALIDATE exp_004 BEFORE SUBMITTING

**The evaluator identified a CRITICAL issue:** exp_004 was NOT validated using Kaggle's integer-scaling (1e18) method. Previous submissions (exp_000, exp_002) FAILED because of overlap detection differences between local Shapely and Kaggle.

**MANDATORY FIRST TASK:** Before ANY other work, validate exp_004:

```python
# Use the validation code from evolver_loop2_analysis.ipynb
from decimal import Decimal, getcontext
from shapely.geometry import Polygon
from shapely import affinity
from shapely.strtree import STRtree
import pandas as pd

getcontext().prec = 25
scale_factor = Decimal("1e18")

# ChristmasTree class with Kaggle-compatible scaling
class ChristmasTree:
    def __init__(self, center_x="0", center_y="0", angle="0"):
        self.center_x = Decimal(center_x)
        self.center_y = Decimal(center_y)
        self.angle = Decimal(angle)
        # ... (full implementation in evolver_loop2_analysis.ipynb)

def has_overlap_kaggle(trees):
    """Check overlaps using Kaggle's method."""
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    overlapping_pairs = []
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx <= i:
                continue
            if poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                overlapping_pairs.append((i, idx))
    return len(overlapping_pairs) > 0, overlapping_pairs

# Validate ALL N values in exp_004
df = pd.read_csv('/home/submission/submission.csv')
overlapping_ns = []
for n in range(1, 201):
    trees = load_trees_for_n(n, df)
    has_overlap, pairs = has_overlap_kaggle(trees)
    if has_overlap:
        overlapping_ns.append(n)
        print(f"N={n}: {len(pairs)} overlapping pairs - WILL FAIL KAGGLE")

if overlapping_ns:
    print(f"WARNING: {len(overlapping_ns)} N values have overlaps!")
    print("Fall back to baseline for these N values before submitting.")
else:
    print("All N values pass Kaggle validation - SAFE TO SUBMIT")
```

**If any N fails validation:** Fall back to baseline (exp_001) for that N value.

## Response to Evaluator

The evaluator correctly identified that:
1. ✅ The precision-preserving approach is correct (18+ decimal places preserved)
2. ✅ The ensemble found 432 improvements across 116 N values
3. ⚠️ **CRITICAL GAP**: No Kaggle-compatible validation before submission

**Action:** I will validate exp_004 using Kaggle's integer-scaling method BEFORE submitting. If any N values have overlaps, I'll fall back to baseline for those N values.

## Submission Strategy

**With 93 submissions remaining, we should submit AGGRESSIVELY:**
1. First, validate exp_004 with Kaggle method
2. If valid, submit exp_004 to get LB feedback
3. Even if some N values need fallback, submit the fixed version
4. LB feedback is FREE information - use it!

## ⛔ FORBIDDEN (WILL BE REJECTED)

- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any tool - FORBIDDEN
- Loading solutions then running optimizer on them - FORBIDDEN

## ✅ AFTER VALIDATION: Implement Fractional Translation in Python

The top kernel uses **fractional translation** - a simple local search that can be implemented in pure Python:

```python
def fractional_translation(solution, n, max_iter=200):
    """Fractional translation local search - implementable in pure Python."""
    frac_steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    
    best_score = calculate_score(solution, n)
    best_solution = solution.copy()
    
    for iteration in range(max_iter):
        improved = False
        for tree_idx in range(n):
            for step in frac_steps:
                for dx, dy in directions:
                    # Try moving tree by (dx*step, dy*step)
                    new_solution = best_solution.copy()
                    new_solution[tree_idx]['x'] += dx * step
                    new_solution[tree_idx]['y'] += dy * step
                    
                    # Check for overlaps
                    if not has_overlap(new_solution):
                        new_score = calculate_score(new_solution, n)
                        if new_score < best_score - 1e-12:
                            best_score = new_score
                            best_solution = new_solution
                            improved = True
        if not improved:
            break
    
    return best_solution, best_score
```

**Key insight:** This is a simple hill-climbing algorithm that:
1. For each tree, try moving it by small amounts in 8 directions
2. Keep the move if it improves score without creating overlaps
3. Use decreasing step sizes for fine-grained optimization

## ✅ REQUIRED: Per-N Tracking

Track best solution for EACH N value separately:
1. Load baseline per-N scores from exp_001
2. After each experiment, compare per-N scores
3. SAVE any N where you improved (even if total is worse)
4. Ensemble = best per-N from all sources

## Recommended Approaches (Priority Order)

1. **[HIGHEST PRIORITY]** Validate exp_004 with Kaggle method, fix overlaps, submit
2. **[HIGH PRIORITY]** Implement fractional translation in pure Python for N=2-50
3. **[MEDIUM PRIORITY]** Implement simulated annealing from scratch for larger N
4. **[LOWER PRIORITY]** Explore branch-and-bound for N=2-10 (exact solutions)

## What NOT to Try

- Running bbox3/sa_fast with "more iterations" → SAME SCORE (~70.6)
- "Different parameters" on the same optimizer → SAME SCORE (~70.6)
- Any approach that gave < 0.01 improvement

## Key Insights from Research

1. **N=1 is already optimal** at 45° rotation (side=0.813173, score=0.661250)
2. **Kaggle uses integer scaling (1e18)** for overlap detection
3. **Precision is critical** - coordinates have 18+ decimal places
4. **Top kernels use fractional translation** with step sizes down to 0.00001
5. **Ensemble approach works** - combine best per-N from multiple sources

## Gap Analysis

- Target: 68.887226
- Best LB (exp_001): 70.615107
- Current CV (exp_004): 70.522682
- Gap: 1.73 points (2.51% improvement needed)

**At current rate (0.05 improvement per ensemble), we need ~35 more improvements.**
This is achievable with:
1. More aggressive local search (fractional translation)
2. Better optimization for small N (N=2-20 contribute disproportionately)
3. Novel algorithms for medium N (N=20-100)

## Validation Notes

- Use Kaggle's integer-scaling (1e18) method for overlap detection
- Preserve original string precision (18+ decimal places)
- Test on small N first (N=10, N=20) before scaling up
