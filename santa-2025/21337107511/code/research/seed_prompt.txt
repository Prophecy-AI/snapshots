# Santa 2025 - Christmas Tree Packing Challenge: Evolved Seed Prompt (Loop 3)

## Current Status
- Best CV score: 70.522682 from exp_002 (ensemble_best_per_n)
- Best LB score: 70.615107 from exp_001 (better_baseline)
- Target: 68.887226 | Gap to target: 1.73 points (2.45% improvement needed)
- Submissions used: 2/100 (93 remaining - ABUNDANT!)

## ⚠️ CRITICAL ISSUE: CV-LB GAP ANALYSIS

**exp_001 had CV=70.572798 but LB=70.615107 (+0.042 gap)**

This is SUSPICIOUS because:
1. The LB score matches snapshot 21337353543 exactly (70.615107)
2. This suggests Kaggle may be rejecting some N values with overlaps
3. The ensemble (exp_002) has 57 N values with local overlaps - IT MAY FAIL KAGGLE!

**BEFORE SUBMITTING exp_002:**
1. Validate with Kaggle's integer-scaling method (1e18 scale factor)
2. For any N with overlaps, fall back to baseline
3. Create a "safe ensemble" that passes strict validation

## Response to Evaluator

The evaluator correctly identified:
1. **Validation method mismatch** - The ensemble was validated with local Shapely (area > 1e-15) but Kaggle uses integer-scaling (1e18). I agree this is CRITICAL.
2. **CV-LB gap is suspicious** - The +0.042 gap suggests Kaggle may be rejecting some N values. I agree this needs investigation.
3. **Risky to submit invalid ensemble** - I agree. We should validate with Kaggle's method first.

**My decision:** Before submitting exp_002, we MUST validate with Kaggle's integer-scaling method. If it fails, create a safe version.

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast_v2, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any tool - FORBIDDEN

## ✅ EXPERIMENT 003: VALIDATE AND FIX ENSEMBLE

**MANDATORY FIRST TASK:**

1. Load the ensemble submission from exp_002
2. Validate EVERY N value using Kaggle's integer-scaling method:
```python
from decimal import Decimal, getcontext
getcontext().prec = 25
scale_factor = Decimal("1e18")

# Use ChristmasTree class from evolver_loop2_analysis.ipynb
# Check each N for overlaps with Kaggle method
```

3. For any N with overlaps, fall back to the VALID baseline (snapshot 21337353543)
4. Calculate the new "safe ensemble" score
5. Save and submit

**Expected outcome:** A valid ensemble that passes Kaggle validation with score between 70.52 and 70.62.

## ✅ EXPERIMENT 004+: IMPLEMENT NOVEL ALGORITHM FOR SMALL N

After fixing the ensemble, focus on SMALL N optimization:

**Why small N matters:**
- N=1-10 contribute ~4.33 points (6.1% of total score)
- N=1 is already optimal (0.661250)
- N=2-10 have significant room for improvement

**For N=2-10, implement branch-and-bound or exhaustive search:**
```python
# For N=2: Try all combinations of positions and rotations
# Theoretical minimum for N=2 is ~0.246 (current is 0.451)
# That's 0.205 points of potential improvement from N=2 alone!

for angle1 in range(0, 360, 1):  # 1 degree steps
    for angle2 in range(0, 360, 1):
        for dx in np.linspace(-0.5, 0.5, 50):
            for dy in np.linspace(-0.5, 0.5, 50):
                # Test configuration
                if no_overlap(tree1, tree2):
                    score = compute_bbox_score(tree1, tree2)
                    if score < best_score:
                        best_score = score
```

**Test on small N FIRST:**
- If you can beat baseline for N=2, N=3, N=4, the approach works
- Use RecordFinding to log small N test results
- Only scale up if small N shows improvement

## ✅ REQUIRED: PER-N TRACKING

Track best solution for EACH N separately:
```python
# Load baseline per-N scores
baseline_per_n = load_baseline_scores()

# After each experiment, compare per-N
for n in range(1, 201):
    my_score = compute_score_for_n(my_solution, n)
    if my_score < baseline_per_n[n] - 1e-10:
        print(f"✅ N={n}: IMPROVED by {baseline_per_n[n] - my_score:.6f}")
        save_improvement(n, my_solution[n])
```

## Key Insights from Research

1. **N=1 is already optimal** at 45° rotation (side=0.813173, score=0.661250)
2. **Kaggle uses integer scaling (1e18)** for overlap detection
3. **Top kernels ensemble from multiple sources** - this is the right approach
4. **Asymmetric solutions outperform symmetric** for most N values
5. **Backward propagation** (N+1 → N) can improve smaller N configurations

## What NOT to Try
- Running bbox3/sa_fast with more iterations (produces ~70.6)
- Optimizing N=1 (already optimal)
- Submitting without Kaggle-compatible validation

## Validation Notes
- Use ChristmasTree class with 1e18 scaling from evolver_loop2_analysis.ipynb
- Validate ALL 200 N values before submission
- If any N has overlaps, fall back to valid baseline for that N

## SUBMISSION STRATEGY
- Remaining submissions: 93 (ABUNDANT!)
- **SUBMIT exp_002 AFTER fixing validation issues**
- LB feedback is FREE - use it to calibrate CV-LB relationship
- Even if score is worse, we learn what works/doesn't work

## Priority Order
1. **HIGHEST:** Fix exp_002 validation and submit safe ensemble
2. **HIGH:** Implement exhaustive search for N=2-10
3. **MEDIUM:** Implement local search in Python for N=11-50
4. **LOW:** Backward propagation from N=200 down
