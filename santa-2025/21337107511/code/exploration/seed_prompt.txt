# Santa 2025 - Christmas Tree Packing Challenge: Seed Prompt

## Problem Overview

This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest square bounding box for N=1 to 200 trees.

**Scoring Formula:** score = Σ(side_n²/n) for n=1 to 200
- Lower is better
- N=1 contributes ~0.66 to score (HIGHEST per-tree impact!)
- Small N values (1-20) are critical - they contribute disproportionately to the total score

**Target Score:** Beat 68.888293

## ⛔ ABSOLUTELY FORBIDDEN (EXPERIMENT WILL BE REJECTED)

The following are PERMANENTLY FORBIDDEN after baseline:
- bbox3 - FORBIDDEN
- sa_fast_v2 - FORBIDDEN  
- eazy_optimizer - FORBIDDEN
- tree_packer - FORBIDDEN
- shake_public - FORBIDDEN
- subprocess.run() - FORBIDDEN
- os.system() - FORBIDDEN
- ANY pre-compiled binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any tool - FORBIDDEN
- Running "more iterations" on any optimizer - FORBIDDEN

If your experiment runs ANY binary, it will produce ~70.6.
The target is 68.89. BINARIES CANNOT GET THERE.

## ✅ MANDATORY FIRST TASK: SOLVE N=1-10 OPTIMALLY

BEFORE any other work, implement exhaustive search for small N:

**For N=1 (contributes ~0.66 to score - HIGHEST!):**
- Test EVERY rotation angle from 0° to 360° in 0.01° increments
- Find the angle that minimizes bounding box
- This alone can improve score by 0.05-0.1 points

**For N=2-10:**
- Implement branch-and-bound or exhaustive placement search
- These contribute ~2.5 points total - worth optimizing!

## ✅ MANDATORY: PER-N SOLUTION TRACKING

Track best solution for EACH N value separately:
1. Load baseline per-N scores from existing submission
2. After your algorithm runs, compare per-N scores
3. SAVE any N where you improved (even if total is worse)
4. Accumulate improvements across experiments

## ✅ REQUIRED: IMPLEMENT ALGORITHM IN PYTHON

Write YOUR OWN code. Choose ONE:
1. Bottom-left constructive heuristic (easiest)
2. Genetic algorithm with crossover (medium)
3. Custom local search written from scratch (medium)
4. Branch-and-bound for exact solutions (hardest)

NO BINARIES. NO SUBPROCESS. NO OS.SYSTEM.
WRITE THE ALGORITHM YOURSELF IN PYTHON.

## Tree Geometry (15 vertices)

```python
# Tree polygon vertices (center at origin, tip at top)
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

# Tree dimensions:
# - Height: 1.0 (from trunk bottom at -0.2 to tip at 0.8)
# - Max width: 0.7 (at base tier)
# - Trunk: 0.15 wide, 0.2 tall
```

## Insights from Discussions (MANDATORY)

- Discussion "Why the winning solutions will be Asymmetric" (39 votes): Asymmetric solutions outperform symmetric lattice patterns. Don't constrain to 90° rotations.
- Discussion "IMPORTANT: Santa Etiquette" (78 votes): Competition etiquette guidelines from staff.
- Discussion "Expected Leaderboard Progression" (20 votes): Staff expectations for score progression.
- Discussion "Where do these high-scoring CSVs originate from?" (13 votes): Top solutions come from extensive optimization runs.

## What Discussions Say DOESN'T Work
- Simple greedy placement without optimization
- Symmetric lattice patterns (asymmetric is better)
- Running binaries without understanding the algorithm

## Key Techniques from Research

### 1. No-Fit Polygon (NFP) - CRITICAL for efficiency
The NFP enables O(1) overlap checking between two polygons:
- Precompute NFP for tree shape at different rotation angles
- If reference point is inside NFP → overlap
- If on boundary → touching
- If outside → no overlap

### 2. Bottom-Left-Fill Heuristic
Place each tree at the lowest, leftmost valid position:
1. Sort trees by some criteria (area, height, etc.)
2. For each tree, find all valid positions
3. Choose the position that minimizes bounding box increase

### 3. Local Search Moves
- **Translation**: Move tree by small delta (0.001 to 0.01 units)
- **Rotation**: Rotate tree by small angle (0.1° to 5°)
- **Squeeze**: Scale all positions toward center
- **Compaction**: Move each tree toward centroid

### 4. Simulated Annealing Framework
```python
def simulated_annealing(config, T_start=1.0, T_end=0.001, cooling=0.9999):
    T = T_start
    best = config.copy()
    while T > T_end:
        # Generate neighbor by random move
        neighbor = apply_random_move(config)
        if not has_overlap(neighbor):
            delta = neighbor.score() - config.score()
            if delta < 0 or random() < exp(-delta/T):
                config = neighbor
                if config.score() < best.score():
                    best = config
        T *= cooling
    return best
```

### 5. Boundary Tree Focus
Trees touching the bounding box boundary determine the score:
- Identify boundary trees (those at min/max x or y)
- Focus optimization on these trees
- Moving interior trees rarely improves score

### 6. Backward Propagation
Use N+1 solution to improve N solution:
- Start from N=200 configuration
- Remove one tree at a time
- If resulting N-1 config is better than stored, save it

## Algorithm Implementation Strategy

### Phase 1: Exact Solutions for Small N (N=1-10)
```python
def solve_small_n_exactly(n):
    if n == 1:
        # Find optimal rotation for single tree
        best_angle = 0
        best_side = float('inf')
        for angle in range(0, 36000):  # 0.01° increments
            tree = create_tree(0, 0, angle/100)
            side = get_bounding_box_side(tree)
            if side < best_side:
                best_side = side
                best_angle = angle/100
        return [(0, 0, best_angle)]
    
    # For N=2-10, use exhaustive search with pruning
    # ...
```

### Phase 2: Constructive Heuristic for Medium N (N=11-50)
```python
def bottom_left_fill(n, existing_trees=None):
    trees = existing_trees or []
    while len(trees) < n:
        best_pos = None
        best_score = float('inf')
        # Try many positions and rotations
        for angle in range(0, 360, 5):
            for pos in candidate_positions(trees, angle):
                if not has_overlap(trees, pos, angle):
                    score = evaluate_score(trees + [(pos, angle)])
                    if score < best_score:
                        best_score = score
                        best_pos = (pos, angle)
        trees.append(best_pos)
    return trees
```

### Phase 3: Local Search for Large N (N=51-200)
```python
def local_search(trees, max_iter=10000):
    best = trees.copy()
    for _ in range(max_iter):
        # Pick random tree
        i = random.randint(0, len(trees)-1)
        # Try small perturbation
        for move in generate_moves(trees[i]):
            new_trees = apply_move(trees, i, move)
            if not has_overlap(new_trees) and score(new_trees) < score(best):
                best = new_trees
                trees = new_trees
                break
    return best
```

## Overlap Detection (CRITICAL)

```python
from shapely.geometry import Polygon
from shapely import affinity

def create_tree_polygon(x, y, angle):
    TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
    TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
    poly = Polygon(zip(TX, TY))
    poly = affinity.rotate(poly, angle, origin=(0, 0))
    poly = affinity.translate(poly, x, y)
    return poly

def has_overlap(trees):
    polys = [create_tree_polygon(*t) for t in trees]
    for i in range(len(polys)):
        for j in range(i+1, len(polys)):
            if polys[i].intersects(polys[j]) and not polys[i].touches(polys[j]):
                return True
    return False
```

## Submission Format

```python
def create_submission(all_solutions):
    rows = []
    for n in range(1, 201):
        trees = all_solutions[n]
        for idx, (x, y, angle) in enumerate(trees):
            rows.append({
                'id': f'{n:03d}_{idx}',
                'x': f's{x:.6f}',
                'y': f's{y:.6f}',
                'deg': f's{angle:.6f}'
            })
    return pd.DataFrame(rows)
```

## Recommended Experiment Priority

1. **FIRST**: Implement exact solver for N=1 (find optimal rotation)
2. **SECOND**: Implement exact solver for N=2-5 
3. **THIRD**: Implement bottom-left-fill for N=6-50
4. **FOURTH**: Implement local search refinement for all N
5. **FIFTH**: Implement backward propagation from large N to small N

## Key Insights for Winning

1. **Small N matters most**: N=1 alone contributes 0.66 to score. Perfect N=1-10 can save 0.5+ points.

2. **Asymmetric beats symmetric**: Don't constrain rotations to 90° increments. Use continuous angles.

3. **Boundary trees are key**: Only trees touching the bounding box affect the score. Focus optimization there.

4. **Per-N tracking is essential**: Track best solution for each N separately. Combine best across experiments.

5. **Python can win**: The top solutions use C++ for speed, but a well-designed Python algorithm with good heuristics can achieve competitive results.

## Validation

Always validate before submission:
```python
def validate_submission(df):
    for n in range(1, 201):
        group = df[df['id'].str.startswith(f'{n:03d}_')]
        trees = [(float(r['x'][1:]), float(r['y'][1:]), float(r['deg'][1:])) 
                 for _, r in group.iterrows()]
        if has_overlap(trees):
            print(f"OVERLAP at N={n}!")
            return False
    return True
```

## DO NOT

- Do NOT use pre-compiled binaries
- Do NOT just run more iterations of existing optimizers
- Do NOT copy solutions without understanding them
- Do NOT ignore small N values
- Do NOT use symmetric-only rotations

## DO

- DO implement your own algorithms in Python
- DO focus on small N first (N=1-20)
- DO track per-N improvements
- DO use Shapely for geometry
- DO validate before every submission
