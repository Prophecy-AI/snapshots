# Santa 2025 - Evolved Seed Prompt (Loop 1)

## Current Status
- Best CV score: 70.615745 from snapshot 21328310479
- Best LB score: FAILED (previous submission rejected with "Overlapping trees in group 040")
- Target: 68.888293 | Gap to target: ~1.73 points

## ⚠️ CRITICAL ISSUE: OVERLAP VALIDATION MISMATCH

**The first submission FAILED because Kaggle's overlap detection is STRICTER than Shapely.**

Key findings:
1. Local Shapely validation shows NO overlaps in the baseline
2. Kaggle rejected with "Overlapping trees in group 040"
3. When coordinates are rounded to 6 decimals, 161/200 N values develop overlaps
4. The original coordinates are EXTREMELY precisely tuned

**BEFORE ANY SUBMISSION, you MUST:**
1. Use a snapshot that has been validated by Kaggle (if available)
2. OR implement stricter overlap validation matching Kaggle's precision

## Response to Evaluator

The evaluator correctly identified that:
1. N=1 is ALREADY OPTIMAL at 45° (confirmed - no improvement possible)
2. The code directory is empty - no algorithm implementation yet
3. Per-N tracking infrastructure is needed

However, the evaluator missed the critical overlap validation issue that caused the submission to fail. This must be addressed FIRST before any optimization work.

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Fix Overlap Validation & Get Valid Baseline
- Use snapshot 21328310479 (score 70.615745) which passed local validation
- Submit to verify it passes Kaggle's validation
- If it fails, we need to understand Kaggle's exact validation algorithm

### 2. **[HIGH PRIORITY]** Implement Stricter Overlap Validation
Before generating ANY new solutions, implement validation that matches Kaggle:
```python
# Use buffer-based validation with small negative buffer
def validate_no_overlap_strict(trees, buffer=-1e-9):
    polys = [create_tree_polygon(*t).buffer(buffer) for t in trees]
    for i in range(len(polys)):
        for j in range(i+1, len(polys)):
            if polys[i].intersects(polys[j]) and not polys[i].touches(polys[j]):
                return False, f"Trees {i} and {j} overlap"
    return True, "OK"
```

### 3. **[MEDIUM PRIORITY]** Implement N=2-10 Optimization
Once we have a valid baseline, optimize small N values:
- N=2-10 contribute ~3.67 points total
- Even 10% improvement = 0.37 points (significant!)
- Use exhaustive search with pruning for N=2-5
- Use local search for N=6-10

### 4. **[LOWER PRIORITY]** Implement Novel Algorithms
After small N optimization:
- Bottom-left constructive heuristic
- Custom simulated annealing (NOT using binaries)
- Genetic algorithm with crossover

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast_v2, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- Generating solutions without strict overlap validation - FORBIDDEN

## ✅ MANDATORY FIRST TASK

**Submit the new baseline (snapshot 21328310479) to verify it passes Kaggle validation.**

If it passes:
- We have a valid baseline at 70.615745
- We can proceed with optimization

If it fails:
- We need to investigate Kaggle's exact validation algorithm
- May need to use sample_submission.csv as fallback (score ~173.6)

## Per-N Score Analysis

From baseline analysis:
- N=1: 0.661250 (ALREADY OPTIMAL - no improvement possible)
- N=2: 0.450779 (theoretical min ~0.246, gap = 0.205)
- N=3: 0.434745 (theoretical min ~0.246, gap = 0.189)
- N=4: 0.416545 (theoretical min ~0.246, gap = 0.171)
- N=5: 0.416850 (theoretical min ~0.246, gap = 0.171)

**Focus on N=2-10 where there's significant gap to theoretical minimum.**

## Validation Code (MANDATORY)

```python
from shapely.geometry import Polygon
from shapely import affinity

TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def create_tree_polygon(x, y, angle):
    poly = Polygon(zip(TX, TY))
    poly = affinity.rotate(poly, angle, origin=(0, 0))
    poly = affinity.translate(poly, x, y)
    return poly

def validate_solution(trees):
    """Validate that trees don't overlap."""
    polys = [create_tree_polygon(*t) for t in trees]
    for i in range(len(polys)):
        for j in range(i+1, len(polys)):
            if polys[i].intersects(polys[j]):
                intersection = polys[i].intersection(polys[j])
                if intersection.area > 1e-15:  # Very strict threshold
                    return False, f"Trees {i} and {j} overlap (area={intersection.area:.2e})"
    return True, "OK"

# ALWAYS validate before submission!
for n in range(1, 201):
    ok, msg = validate_solution(solutions[n])
    if not ok:
        raise ValueError(f"N={n}: {msg}")
```

## Submission Strategy
- Remaining submissions: 94
- Submit the new baseline IMMEDIATELY to verify it passes Kaggle
- If it passes, we have a valid starting point
- If it fails, investigate further before any optimization work
