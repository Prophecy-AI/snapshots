# Santa 2025 - Evolved Seed Prompt (Loop 1)

## Current Status
- **Best CV score**: 70.615791 from exp_000 (baseline)
- **Best LB score**: NOT YET SUBMITTED - SUBMIT BASELINE FIRST!
- **Target**: 68.888293 | **Gap to target**: 1.727 points (lower is better)
- **Submissions remaining**: 94/100

## ⚠️ CRITICAL FINDING: N=1 IS ALREADY OPTIMAL!

Analysis in `exploration/evolver_loop1_analysis.ipynb` shows:
- N=1 at 45° rotation gives side=0.813173, score=0.661250
- This IS the optimal angle - exhaustive search confirms no improvement possible
- **DO NOT waste time optimizing N=1** - focus on N=2+

## Response to Evaluator

The evaluator correctly identified that:
1. ✅ Baseline is solid (70.615791)
2. ✅ Per-N analysis is valuable
3. ⚠️ N=1 optimization was suggested, but analysis shows it's ALREADY optimal
4. ✅ No LB submission yet - MUST submit baseline to verify CV-LB alignment

**Key disagreement**: The evaluator suggested N=1 optimization as priority. However, my analysis proves N=1 is already at the global optimum (45°). The real opportunity is in N=2-200.

## ⛔ ABSOLUTELY FORBIDDEN

- bbox3, sa_fast_v2, eazy_optimizer, tree_packer, shake_public - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- ANY pre-compiled binary - FORBIDDEN
- "Optimizing" existing CSV files with any binary tool - FORBIDDEN

**WHY**: These binaries produce ~70.6. The target is 68.89. BINARIES CANNOT GET THERE.

## ✅ MANDATORY FIRST ACTION: SUBMIT BASELINE

Before ANY optimization work:
1. Submit the baseline (exp_000) to verify CV-LB alignment
2. This uses 1 submission but provides critical calibration data
3. We have 94 submissions remaining - this is worth it

## ✅ EXPERIMENT 001: IMPLEMENT SMALL N SOLVER (N=2-10)

Since N=1 is optimal, focus on N=2-10 where there's significant room for improvement:

**Per-N gaps (baseline vs theoretical minimum):**
- N=2: baseline=0.451 vs theoretical≈0.246 → gap=0.205
- N=3: baseline=0.435 vs theoretical≈0.246 → gap=0.189
- N=4: baseline=0.417 vs theoretical≈0.246 → gap=0.171
- N=5: baseline=0.417 vs theoretical≈0.246 → gap=0.171

**Implementation approach:**
```python
def solve_n2_exhaustive():
    """For N=2, try all angle combinations and positions."""
    best_score = float('inf')
    best_config = None
    
    # Try all angle combinations (5° increments = 72 angles each)
    for angle1 in range(0, 360, 5):
        for angle2 in range(0, 360, 5):
            # For each angle pair, find optimal placement
            tree1 = create_tree(0, 0, angle1)
            # Try placing tree2 at various positions around tree1
            for offset_angle in range(0, 360, 10):
                for distance in np.arange(0.5, 2.0, 0.1):
                    x2 = distance * cos(radians(offset_angle))
                    y2 = distance * sin(radians(offset_angle))
                    tree2 = create_tree(x2, y2, angle2)
                    if not overlaps(tree1, tree2):
                        score = compute_bbox_score([tree1, tree2], n=2)
                        if score < best_score:
                            best_score = score
                            best_config = [(0, 0, angle1), (x2, y2, angle2)]
    return best_config, best_score
```

**For N=3-10**: Use similar exhaustive search with pruning, or implement branch-and-bound.

## ✅ EXPERIMENT 002+: IMPLEMENT CONSTRUCTIVE HEURISTIC

For N > 10, implement a bottom-left-fill heuristic:

```python
def bottom_left_fill(n, existing_trees=None):
    """Place trees using bottom-left-fill strategy."""
    trees = existing_trees or []
    
    while len(trees) < n:
        best_pos = None
        best_score = float('inf')
        
        # Try many positions and rotations
        for angle in range(0, 360, 5):
            for candidate_pos in generate_candidate_positions(trees):
                if not has_overlap(trees, candidate_pos, angle):
                    new_trees = trees + [(candidate_pos[0], candidate_pos[1], angle)]
                    score = compute_bbox_score(new_trees, n)
                    if score < best_score:
                        best_score = score
                        best_pos = (candidate_pos[0], candidate_pos[1], angle)
        
        if best_pos:
            trees.append(best_pos)
        else:
            raise ValueError(f"Could not place tree {len(trees)+1}")
    
    return trees
```

## ✅ MANDATORY: PER-N TRACKING

Track best solution for EACH N separately:

```python
# Load baseline per-N scores
with open('experiments/000_baseline/metrics.json') as f:
    baseline = json.load(f)['per_n_scores']

# After each experiment, compare per-N
def compare_and_save_improvements(my_solutions, baseline):
    improvements = {}
    for n in range(1, 201):
        my_score = compute_score_for_n(my_solutions[n], n)
        base_score = float(baseline[str(n)])
        if my_score < base_score - 0.0001:  # Improved!
            improvements[n] = {
                'old_score': base_score,
                'new_score': my_score,
                'improvement': base_score - my_score,
                'solution': my_solutions[n]
            }
            print(f"✅ N={n}: IMPROVED by {base_score - my_score:.6f}")
    return improvements
```

## Key Insights from Research

1. **Asymmetric solutions outperform symmetric** - Don't constrain to 90° rotations
2. **Backward propagation** - Use N+1 solution to improve N solution
3. **Boundary tree focus** - Trees touching bounding box determine score
4. **No-Fit Polygon (NFP)** - Enables O(1) overlap checks (advanced)

## What NOT to Try

- ❌ Optimizing N=1 (already optimal at 45°)
- ❌ Running any binary optimizer
- ❌ Simple greedy without local search
- ❌ Symmetric lattice patterns (asymmetric is better)

## Validation Notes

- Use Shapely for overlap detection with integer scaling (1e15) for precision
- Verify no overlaps before saving any solution
- Score = Σ(side²/n) for n=1 to 200

## Success Criteria

- **Immediate**: Submit baseline, verify CV-LB alignment
- **Short-term**: Improve at least one N value (N=2-10) by implementing exhaustive search
- **Medium-term**: Accumulate per-N improvements across experiments
- **Target**: Beat 68.888293 through accumulated improvements

## SUBMISSION STRATEGY

With 94 submissions remaining:
1. **SUBMIT BASELINE NOW** - Get LB calibration
2. **SUBMIT AFTER EACH EXPERIMENT** - LB feedback is valuable
3. Don't hoard submissions - use them for learning
