# Santa 2025 Christmas Tree Packing - Seed Prompt

## Problem Overview
This is a 2D polygon packing optimization problem. The goal is to fit N Christmas tree toys (N=1 to 200) into the smallest possible square bounding box for each N. 

**Scoring:** score = Σ(side_n² / n) for n=1 to 200. Lower is better.
**Target:** Beat 68.931058

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Tip at (0, 0.8)
- Three tiers of branches
- Trunk: width 0.15, height 0.2
- Base width: 0.7
- Total height: 1.0 (from trunk bottom at -0.2 to tip at 0.8)

Trees can be positioned (x, y) and rotated (deg). The reference point is the center of the top of the trunk.

## Top Approaches from Public Kernels

### 1. bbox3 Binary Optimizer (Most Important)
**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

The bbox3 binary is the key optimization tool used by top solutions:
```bash
./bbox3 -n <iterations> -r <restarts>
```
- `-n`: Number of iterations (try 1000-10000+)
- `-r`: Number of restarts (try 30-256)
- Higher values = better results but longer runtime

**Usage pattern:**
1. Start with a baseline submission.csv
2. Run bbox3 to optimize
3. Apply fix_direction post-processing
4. Validate for overlaps and repair if needed

### 2. fix_direction Post-Processing (Critical)
**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

After bbox3 optimization, rotate the entire configuration to minimize bounding box:
- Uses scipy.optimize.minimize_scalar
- Searches rotation angles 0-90 degrees
- Can reduce score significantly
- Apply multiple passes for better results

### 3. C++ Tree Packer with OpenMP
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Features:
- Parallel processing with OpenMP
- Simulated annealing with temperature scheduling
- Local search with 8-directional moves
- Squeeze operation (scale towards center)
- Compaction (move trees towards center)
- Swap moves between trees
- Multi-angle restarts

Compile: `g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer.cpp`

### 4. Backward Propagation
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Improve smaller N configurations by removing trees from larger N configs:
- Start from N=200, go down to N=2
- For each N, try removing boundary-touching trees
- If resulting (N-1) config is better than stored, save it
- This propagates good packing patterns downward

### 5. Overlap Repair Strategy
**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`

When optimization creates overlaps:
1. Validate submission for overlaps
2. For each N with overlap, replace with known-good baseline
3. This ensures valid submission while keeping improvements

## Recommended Experiment Strategy

### Phase 1: Reproduce Best Kernel (First 1-2 experiments)
1. Download bbox3 binary and baseline submission from Kaggle datasets
2. Run bbox3 with moderate parameters: `-n 2000 -r 96`
3. Apply fix_direction with 1-2 passes
4. Validate and repair overlaps
5. Target: Match ~69-70 score

### Phase 2: Extended Optimization (Experiments 3-5)
1. Run bbox3 with higher parameters: `-n 5000 -r 128` or higher
2. Apply fix_direction with 3+ passes
3. Try backward propagation
4. Ensemble: Keep best N configs from multiple runs

### Phase 3: Advanced Techniques (Experiments 6+)
1. **Per-N optimization:** Focus on N values with worst efficiency (highest s²/n)
2. **Multi-start:** Run from different initial configurations
3. **Hybrid approach:** Combine bbox3 + tree_packer results
4. **Fine-grained rotation:** Optimize individual tree rotations
5. **Genetic crossover:** Breed configurations from different runs

## Key Implementation Details

### Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s-0.541068,s0.259317,s51.66348
```
- Values prefixed with 's' to preserve precision
- id format: `{n:03d}_{tree_index}`
- Coordinates constrained to -100 ≤ x, y ≤ 100

### Collision Detection
Use Shapely library:
- STRtree for efficient spatial queries
- `polygon.intersects()` and `polygon.touches()` for overlap check
- Two polygons overlap if they intersect but don't just touch

### Scoring Function
```python
def get_score(trees, n):
    # Get bounding box of all tree polygons
    bounds = unary_union([t.polygon for t in trees]).bounds
    side = max(bounds[2]-bounds[0], bounds[3]-bounds[1])
    return side**2 / n
```

## External Resources Needed
1. bbox3 binary - available from Kaggle datasets (e.g., "santa-2025-csv", "bucket-of-chump")
2. Baseline submission.csv - from same datasets
3. These contain pre-optimized solutions to build upon

## Validation Checklist
Before submitting:
1. Check all N=1 to 200 configurations present
2. Validate no overlaps (intersects but not touches)
3. Verify coordinates within bounds (-100 to 100)
4. Calculate expected score locally

## Novel Techniques to Try (Beyond Public Kernels)
1. **Lattice-based initialization:** Trees often pack in alternating orientations
2. **Gradient-based optimization:** Use automatic differentiation for position/rotation
3. **Reinforcement learning:** Train agent to place trees sequentially
4. **Simulated annealing with adaptive temperature:** Longer cooling schedule
5. **Beam search for tree removal:** Try multiple removal sequences in backward propagation
