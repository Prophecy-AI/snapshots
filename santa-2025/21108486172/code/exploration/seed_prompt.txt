# Santa 2025 Christmas Tree Packing - Seed Prompt

## Problem Overview
This is a 2D polygon packing optimization problem. The goal is to fit N Christmas tree toys (N=1 to 200) into the smallest possible square bounding box for each N. 

**Scoring:** score = Σ(side_n² / n) for n=1 to 200. Lower is better.
**Target:** Beat 68.931058

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Tip at (0, 0.8)
- Three tiers of branches (widths: 0.25, 0.4, 0.7)
- Trunk: width 0.15, height 0.2
- Total height: 1.0 (from trunk bottom at -0.2 to tip at 0.8)

Trees can be positioned (x, y) and rotated (deg). The reference point is the center of the top of the trunk.

## Top Approaches from Public Kernels

### 1. bbox3 Binary Optimizer (Most Important)
**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

The bbox3 binary is the key optimization tool used by top solutions:
```bash
./bbox3 -n <iterations> -r <restarts>
```
- `-n`: Number of iterations (try 1000-10000+)
- `-r`: Number of restarts (try 30-256)
- Higher values = better results but longer runtime

**Usage pattern:**
1. Start with a baseline submission.csv
2. Run bbox3 to optimize
3. Apply fix_direction post-processing
4. Validate for overlaps and repair if needed

### 2. fix_direction Post-Processing (Critical)
**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

After bbox3 optimization, rotate the entire configuration to minimize bounding box:
- Uses scipy.optimize.minimize_scalar
- Searches rotation angles 0-90 degrees
- Can reduce score significantly
- Apply multiple passes for better results

### 3. C++ Tree Packer with OpenMP
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Features:
- Parallel processing with OpenMP
- Simulated annealing with temperature scheduling
- Local search with 8-directional moves
- Squeeze operation (scale towards center)
- Compaction (move trees towards center)
- Swap moves between trees
- Multi-angle restarts

Compile: `g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer.cpp`

### 4. Backward Propagation
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Improve smaller N configurations by removing trees from larger N configs:
- Start from N=200, go down to N=2
- For each N, try removing boundary-touching trees
- If resulting (N-1) config is better than stored, save it
- This propagates good packing patterns downward

### 5. Overlap Repair Strategy
**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`

When optimization creates overlaps:
1. Validate submission for overlaps
2. For each N with overlap, replace with known-good baseline
3. This ensures valid submission while keeping improvements

## Simulated Annealing Best Practices (from research)

### Temperature Schedule
- **Initial temperature:** Set to achieve 80-90% acceptance rate for random moves
- **Cooling schedule:** Geometric (exponential) with α = 0.95-0.99
- **Inner iterations:** c × N where N = number of polygons, c ≈ 100-200
- **Stopping:** When temperature falls below threshold or no improvement for several temperatures

### Adaptive Neighborhood
- **Crystallization factor feedback:** Increase step size after accepted moves, decrease after rejections
- **Anisotropic search:** Different step sizes for different directions
- **Step sizes:** Start large (0.01-0.02), decrease to fine (0.0001-0.001)

### Move Types
1. **Translation:** Move tree in 8 directions (cardinal + diagonal)
2. **Rotation:** Rotate individual tree by small angles (±0.1° to ±5°)
3. **Swap:** Exchange positions of two trees
4. **Compaction:** Move towards center of mass

## Recommended Experiment Strategy

### Phase 1: Reproduce Best Kernel (First 1-2 experiments)
1. Download bbox3 binary and baseline submission from Kaggle datasets
2. Run bbox3 with moderate parameters: `-n 2000 -r 96`
3. Apply fix_direction with 1-2 passes
4. Validate and repair overlaps
5. Target: Match ~69-70 score

### Phase 2: Extended Optimization (Experiments 3-5)
1. Run bbox3 with higher parameters: `-n 5000 -r 128` or higher
2. Apply fix_direction with 3+ passes
3. Try backward propagation
4. Ensemble: Keep best N configs from multiple runs

### Phase 3: Advanced Techniques (Experiments 6+)
1. **Per-N optimization:** Focus on N values with worst efficiency (highest s²/n)
2. **Multi-start:** Run from different initial configurations
3. **Hybrid approach:** Combine bbox3 + tree_packer results
4. **Fine-grained rotation:** Optimize individual tree rotations
5. **Genetic crossover:** Breed configurations from different runs

## Key Implementation Details

### Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s-0.541068,s0.259317,s51.66348
```
- Values prefixed with 's' to preserve precision
- id format: `{n:03d}_{tree_index}`
- Coordinates constrained to -100 ≤ x, y ≤ 100

### Collision Detection
Use Shapely library:
- STRtree for efficient spatial queries
- `polygon.intersects()` and `polygon.touches()` for overlap check
- Two polygons overlap if they intersect but don't just touch

### Scoring Function
```python
def get_score(trees, n):
    # Get bounding box of all tree polygons
    bounds = unary_union([t.polygon for t in trees]).bounds
    side = max(bounds[2]-bounds[0], bounds[3]-bounds[1])
    return side**2 / n
```

## External Resources Needed
1. bbox3 binary - available from Kaggle datasets (e.g., "santa-2025-csv", "bucket-of-chump")
2. Baseline submission.csv - from same datasets
3. These contain pre-optimized solutions to build upon

## Validation Checklist
Before submitting:
1. Check all N=1 to 200 configurations present
2. Validate no overlaps (intersects but not touches)
3. Verify coordinates within bounds (-100 to 100)
4. Calculate expected score locally

## Novel Techniques to Try (Beyond Public Kernels)

### From Research Literature
1. **No-fit polygon (NFP):** Precompute collision-free regions for faster placement
2. **Hierarchical SA:** Outer loop adjusts container size, inner loop optimizes placement
3. **Genetic-LP hybrid:** Use linear programming to solve relaxed placement subproblem
4. **Differential evolution:** Population-based optimization with crossover/mutation

### Competition-Specific Ideas
1. **Lattice-based initialization:** Trees often pack in alternating orientations (observed in kernels)
2. **Per-tree rotation optimization:** After global fix_direction, fine-tune individual rotations
3. **Beam search for tree removal:** Try multiple removal sequences in backward propagation
4. **Score-weighted optimization:** Spend more time on N values with highest s²/n contribution
5. **Configuration breeding:** Take best trees from multiple runs for each N

## Critical Success Factors
1. **Use bbox3 binary** - This is the core optimizer used by top solutions
2. **Apply fix_direction** - Post-processing rotation optimization is essential
3. **Validate overlaps** - Invalid submissions are rejected
4. **Iterate and ensemble** - Multiple runs with different parameters improve results
5. **Focus on high-N values** - N=100-200 contribute most to score

## Reference Kernels
- `../research/kernels/saspav_santa-submission/` - bbox3 + fix_direction workflow
- `../research/kernels/smartmanoj_santa-claude/` - C++ tree_packer with backward propagation
- `../research/kernels/jazivxt_why-not/` - Overlap repair strategy
- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - Multi-phase optimization
- `../research/kernels/inversion_santa-2025-getting-started/` - Basic greedy baseline
