# Santa 2025 Christmas Tree Packing - Evolved Seed Prompt (Loop 2)

## Current Status
- Best CV score: 70.734327 from exp_001 (002_extended_optimization)
- Best LB score: N/A (no submissions yet - SUBMIT IMMEDIATELY!)
- Target: 68.931058 | Gap: 1.803269 (2.6%)

## CRITICAL DISCOVERY: THE PATH TO VICTORY IS CLEAR!

**The ensemble of best configs scores 67.77 - BELOW the target of 68.93!**

But these configs have overlaps. The breakdown:
- 30 N values have overlaps (ALL 2.96 points of improvement is here)
- 170 N values have no overlaps (same as baseline)
- If overlaps can be repaired, we beat the target by 1.16 points!

The overlap structure is SEVERE:
- N=3: 3 overlapping pairs (all 3 trees overlap each other)
- N=4: 6 overlapping pairs (all 4 trees overlap each other)
- N=5: 10 overlapping pairs (all 5 trees overlap each other)
- etc.

This suggests the cpp_parallel_sa optimizer found very compact configurations but ignored collision constraints.

## Response to Evaluator

**FULLY AGREE with the evaluator's analysis.** The evaluator correctly identified:
1. Better configs EXIST (67.77 score) but have overlaps
2. The baseline is NOT "well-optimized" - it's just the best VALID config
3. Overlap repair is the key, not more optimization

The evaluator's suggested approach is correct. The next experiment should focus on OVERLAP REPAIR.

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY] Overlap Repair via Local Search**

For each N with overlaps (30 N values total):
1. Load the better config from ensemble (has overlaps)
2. Identify overlapping tree pairs
3. Apply local search to separate overlapping trees:
   - Try small translations (0.001-0.01) in 8 directions
   - Try small rotations (±1°, ±5°, ±10°)
   - Accept moves that reduce overlap count without creating new overlaps
4. If repair succeeds → keep improved config
5. If repair fails after many attempts → fall back to baseline

**Implementation approach:**
```python
def repair_overlaps(xs, ys, degs, tx, ty, max_iter=10000):
    """Repair overlaps via local search"""
    step_sizes = [0.01, 0.005, 0.002, 0.001, 0.0005]
    rot_steps = [10, 5, 2, 1, 0.5]
    
    for iteration in range(max_iter):
        pairs = find_overlapping_pairs(xs, ys, degs, tx, ty)
        if not pairs:
            return xs, ys, degs, True  # Success!
        
        # Pick a random overlapping pair
        i, j = random.choice(pairs)
        
        # Try moves to separate them
        for tree_idx in [i, j]:
            for step in step_sizes:
                for dx, dy in [(step, 0), (-step, 0), (0, step), (0, -step), 
                               (step, step), (step, -step), (-step, step), (-step, -step)]:
                    new_xs = xs.copy()
                    new_ys = ys.copy()
                    new_xs[tree_idx] += dx
                    new_ys[tree_idx] += dy
                    
                    # Check if this reduces overlaps
                    new_pairs = find_overlapping_pairs(new_xs, new_ys, degs, tx, ty)
                    if len(new_pairs) < len(pairs):
                        xs, ys = new_xs, new_ys
                        break
            
            # Also try rotation
            for rot_step in rot_steps:
                for drot in [rot_step, -rot_step]:
                    new_degs = degs.copy()
                    new_degs[tree_idx] += drot
                    
                    new_pairs = find_overlapping_pairs(xs, ys, new_degs, tx, ty)
                    if len(new_pairs) < len(pairs):
                        degs = new_degs
                        break
    
    return xs, ys, degs, False  # Failed to repair
```

### 2. **[HIGH PRIORITY] Constrained Re-optimization**

For N values where repair fails, try re-running optimization WITH collision constraints:
- Use the better config as starting point
- Run simulated annealing that REJECTS moves creating overlaps
- This may find a valid config close to the better score

### 3. **[MEDIUM PRIORITY] Hybrid Ensemble**

Create a hybrid submission:
- For N values where repair succeeds: use repaired config
- For N values where repair fails: use baseline
- Track which N values need more work

## What NOT to Try
- Running more optimization on the baseline (already optimal for valid configs)
- Searching for better valid configs in snapshots (already done - baseline is best)
- Fractional translation on baseline (already tried - no improvement)

## Validation Notes
- Always validate for overlaps before saving
- Use Shapely STRtree for efficient overlap detection
- Score = sum of (side^2 / N) for N=1 to 200

## SUBMISSION STRATEGY
- Remaining submissions: 96 (ABUNDANT!)
- **SUBMIT IMMEDIATELY** to get LB feedback
- Even if score doesn't improve, we need LB calibration
- Submit after EVERY experiment

## Key Files
- Ensemble with overlaps: `/home/nonroot/snapshots/santa-2025/21108486172/code/experiments/001_baseline/ensemble_submission.csv`
- Baseline (no overlaps): `/home/nonroot/snapshots/santa-2025/21105319338/code/datasets/santa-2025-csv/santa-2025.csv`
- cpp_parallel_sa configs: `/home/nonroot/snapshots/santa-2025/21090949260/code/experiments/009_cpp_parallel_sa/`

## Success Criteria
- If we can repair overlaps in even SOME of the 30 N values, we improve
- Each N value repaired contributes ~0.1-0.24 points of improvement
- We only need to repair enough N values to gain 1.8 points total
- The top 10 N values with overlaps have 2.0 points of improvement potential
