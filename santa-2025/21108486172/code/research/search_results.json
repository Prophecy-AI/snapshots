{
  "query": "What is the No-Fit Polygon (NFP) approach for 2D polygon packing and how can it be used to find optimal non-overlapping configurations?",
  "results": [
    {
      "title": "ANSWER",
      "text": "The No\u2011Fit Polygon (NFP) is a geometric construct that represents **all relative positions at which two polygons can be placed without intersecting**.  For a given pair of pieces\u202fA\u202fand\u202fB, the NFP is the region traced by the reference point of\u202fB while A is held fixed and B is moved until its boundary just touches A; any point inside the NFP corresponds to a feasible, non\u2011overlapping placement of\u202fB\u202frelative to\u202fA\u202f([NestProfessor](https://nestprofessor.com/articles/An%20improved%20method%20for%20calculating%20the%20no-fit%20polygon(Automatic%20nesting%20software).pdf); [Computers\u202f&\u202fOperations\u202fResearch](https://www.sciencedirect.com/science/article/abs/pii/S0305054806000669)).  The concept is also known as a configuration\u2011space obstacle or the Minkowski sum of the two shapes, and it is a cornerstone of irregular 2\u2011D cutting and packing formulations.\n\nRobust generation of NFPs can be achieved without case\u2011by\u2011case handling.  An \u201corbital\u201d method builds the NFP in two simple geometric stages, automatically coping with degenerate situations such as holes, interlocking concavities, or jigsaw\u2011type pieces ([Burke\u202fet\u202fal., 2006](https://www.graham-kendall.com/papers/bhkw2007.pdf)).  A complementary approach computes the NFP directly from the **Minkowski sum** of the polygons, using sorted edge lists to efficiently traverse the combined boundary ([Bennell\u202f&\u202fSong, 2008](https://www.sciencedirect.com/science/article/abs/pii/S0305054806000669)).  Both techniques produce the exact feasible region in a time\u2011effective manner, even when both polygons are non\u2011convex.\n\nIn practice the NFP is used to **search for optimal non\u2011overlapping configurations**.  By pre\u2011computing the NFP for every pair of items, a packing algorithm can treat each feasible placement as a point on the NFP boundary and explore the combinatorial space with branch\u2011and\u2011bound, heuristic, or exact integer\u2011programming methods.  The NFP thus reduces the continuous geometry problem to a discrete set of candidate positions, enabling algorithms to quickly test overlap, enforce rotation constraints, and ultimately minimise waste or the number of bins in 2\u2011D polygon packing problems ([Burke\u202fet\u202fal., 2006](https://www.graham-kendall.com/papers/bhkw2007.pdf); [Dean\u202fet\u202fal., 2004](https://nestprofessor.com/articles/An%20improved%20method%20for%20calculating%20the%20no-fit%20polygon(Automatic%20nesting%20software).pdf)).",
      "url": ""
    },
    {
      "title": "A comprehensive and robust procedure for obtaining the nofit polygon using Minkowski sums",
      "text": "Typesetting math: 100%\n\n[Skip to main content](https://www.sciencedirect.com/www.sciencedirect.com#screen-reader-main-content) [Skip to article](https://www.sciencedirect.com/www.sciencedirect.com#screen-reader-main-title)\n\n- [Access through\u00a0**your organization**](https://www.sciencedirect.com/user/institution/login?targetUrl=%2Fscience%2Farticle%2Fpii%2FS0305054806000669)\n- [Purchase PDF](https://www.sciencedirect.com/getaccess/pii/S0305054806000669/purchase)\n\nSearch ScienceDirect\n\n## Article preview\n\n- [Abstract](https://www.sciencedirect.com/www.sciencedirect.com#preview-section-abstract)\n- [Introduction](https://www.sciencedirect.com/www.sciencedirect.com#preview-section-introduction)\n- [Section snippets](https://www.sciencedirect.com/www.sciencedirect.com#preview-section-snippets)\n- [References (24)](https://www.sciencedirect.com/www.sciencedirect.com#preview-section-references)\n- [Cited by (80)](https://www.sciencedirect.com/www.sciencedirect.com#preview-section-cited-by)\n\n## [Computers & Operations Research](https://www.sciencedirect.com/journal/computers-and-operations-research)\n\n[Volume 35, Issue 1](https://www.sciencedirect.com/journal/computers-and-operations-research/vol/35/issue/1), January 2008, Pages 267-281\n\n# A comprehensive and robust procedure for obtaining the nofit polygon using Minkowski sums\n\nAuthor links open overlay panel [Julia ABennell](https://www.sciencedirect.com/author/14627316400/julia-a-bennell), XiangSong\n\nShow more\n\nAdd to Mendeley\n\nShare\n\nCite\n\n[https://doi.org/10.1016/j.cor.2006.02.026](https://doi.org/10.1016/j.cor.2006.02.026) [Get rights and content](https://s100.copyright.com/AppDispatchServlet?publisherName=ELS&contentID=S0305054806000669&orderBeanReset=true)\n\n## Abstract\n\nThe nofit polygon is a powerful and effective tool for handling the geometric requirements of solution approaches to irregular cutting and [packing problems](https://www.sciencedirect.com/topics/social-sciences/packing-problem). Although the concept was first described in 1966, it was not until the early 90s that the general trend of research moved away from direct trigonometry to favour the nofit polygon. Since then, the ability to calculate the nofit polygon has practically become a pre-requisite for researching irregular packing problems. However, realization of this concept in the form of a robust algorithm is a highly challenging task with few instructive approaches published. In this paper, a procedure using the [mathematical concept](https://www.sciencedirect.com/topics/earth-and-planetary-sciences/mathematical-concept) of Minkowski sums for the calculation of the nofit polygon is presented. The described procedure is more robust than other approaches using Minkowski sum knowledge and includes details of the removal of internal edges to find holes, slits and lock and key positions. The procedure is tested on benchmark data sets and gives examples of complicated cases.\n\n### Scope and purpose\n\nCutting and packing problems involving irregular shapes feature in a wide variety of manufacturing processes. Automated solution techniques that can generate packing arrangements more efficiently than current technology that employs user intervention, must be able to handle the complex geometry that arises from these problems. The nofit polygon has been demonstrated to be an effective tool in providing efficient handling of the geometric characteristics of these problems. The paper presents a new algorithmic procedure for deriving this tool.\n\n## Introduction\n\nCutting and packing problems involving irregular shapes are common in a variety of manufacturing processes. They occur whenever a piece of irregular shape is to be cut from a sheet of stock material. Examples include dye-cutting in the engineering sector, parts nesting for shipbuilding, marker layout in the garment industry, and leather cutting for shoes, furniture and other goods. The paper specifically addresses the geometric calculations required for tackling these problems. Here we consider that shapes are irregular if they are; polygonal, i.e no arcs; simple, i.e. non-self-intersecting; and non-rectangular. Even when all the components are rectangular the problem of finding layouts that minimize waste is known to be NP-hard. Where irregular components are involved an extra dimension of complexity is generated by the geometry.\n\nThe precise requirements of a good layout will differ from industry to industry and this has led to a variety of algorithmic approaches. In spite of their differences, all the methods have a common requirement in which they need to be able to identify whether a layout is feasible or not, i.e. do any of the pieces overlap. Early research handled this problem in a number of ways. Adamowicz and Albano \\[1\\] chose to nest pieces into simpler shapes where the geometry can be more easily calculated. If the shapes are used directly then the intersection of pieces can be handled by direct trigonometric approaches such as the D function \\[2\\], \\[3\\]. Alternatively the stock sheet and the pieces can be approximated as grid squares, often referred to as the raster method. Hence, if a piece occupies, fully or partially, a grid square it is coded as occupied \\[4\\], \\[5\\].\n\nAlthough all these approaches have merit, it is widely recognized that the nofit polygon (NFP) is more efficient, provided you have a robust and efficient NFP generator, and has become the principle approach for handling the geometry in nesting problems. Unfortunately, some researchers believe that despite the value of this tool, its introduction may have stifled research into this variant of packing problems. W\u00e4scher et al. \\[6\\] report that there have been only 21 publications in irregular problems in the last 10 years. Researchers attribute this to the fact that the realization of the NFP as a robust algorithm is, in itself, a highly challenging task. Those considering embarking on research into irregular shaped packing may be discouraged by the significant investment of time required in first developing an NFP generator. Hence, it is essential that robust and easily realizable algorithms are available in order to facilitate new interest into this important problem.\n\nThe primary purpose of this paper is to introduce a new procedure for calculating the NFP. The method is developed from the theory of Minkowski sums \\[7\\] and builds on the principles proposed by Ghosh \\[8\\], \\[9\\] and by Bennell et al. \\[10\\]. Further, the paper includes an algorithmic procedure for eliciting the true boundary of the NFP, including holes, slits and exact fits. It should be noted that the polygons considered in this paper are two-dimensional and restricted to translational motion i.e. rotations are not considered. The next section outlines the most commonly cited approaches for calculating the NFP and points out their positive features and disadvantages. Section 3 reviews in more detail the Minkowski sum approach. This is followed by a description of our new procedure based on Minkowski sums. Section 5, develops our approach for removing redundant internal points and therefore identifying the true boundary. In both cases the full algorithmic steps are provided. Finally, we develop some theoretical and empirical analysis of the approach to demonstrate its robustness with respect to being capable of handling all combinations of simple polygons.\n\n## Section snippets\n\n## Documented approaches for generating the nofit polygon\n\nThe NFP is a combination of the properties of two component polygons that, as a result, represents all the relative positions of the two polygons in which they either touch or overlap. It is well documented that the NFP can reduce the complexity of detecting overlap between two pieces from O(nm+n+m), where n and m are the number of edges in each polygon, obtained from direct trigonometry, to a simple point inclusion test of O(k), where k is the number of edges in the NFP. Full explanations of\n\n## Approache...",
      "url": "https://www.sciencedirect.com/science/article/abs/pii/S0305054806000669"
    },
    {
      "title": "",
      "text": "Discrete Optimization\nComplete and robust no-fit polygon generation\nfor the irregular stock cutting problem\nE.K. Burke, R.S.R. Hellier, G. Kendall, G. Whitwell *\nUniversity of Nottingham, School of Computer Science & IT, Jubilee Campus, Nottingham NG8 1BB, UK\nReceived 22 April 2005; accepted 8 March 2006\nAvailable online 27 April 2006\nAbstract\nThe no-fit polygon is a construct that can be used between pairs of shapes for fast and efficient handling of geometry\nwithin irregular two-dimensional stock cutting problems. Previously, the no-fit polygon (NFP) has not been widely applied\nbecause of the perception that it is difficult to implement and because of the lack of generic approaches that can cope with\nall problem cases without specific case-by-case handling. This paper introduces a robust orbital method for the creation of\nno-fit polygons which does not suffer from the typical problem cases found in the other approaches from the literature.\nFurthermore, the algorithm only involves two simple geometric stages so it is easily understood and implemented. We\ndemonstrate how the approach handles known degenerate cases such as holes, interlocking concavities and jigsaw type\npieces and we give generation times for 32 irregular packing benchmark problems from the literature, including real world\ndatasets, to allow further comparison with existing and future approaches.\n\u0002 2006 Elsevier B.V. All rights reserved.\nKeywords: Cutting; Packing; No-fit polygon; Orbital approach\n1. Introduction\nThe irregular two-dimensional variant of the cutting and packing problem impacts upon several important\nmanufacturing industries such as textiles, plastics, metal cutting and others. These problems usually consist of\na number of irregular pieces that are to be placed onto one or more sheets of material in the most efficient\nlayout possible, so that all pieces are assigned and do not overlap. Additionally, there are usually rotational\nconstraints enforced on the pieces due to the physical properties of the problem such as grain on the material,\npatterns on textiles and the cutting technology being employed. Sometimes rotational constraints may be used\nfor non-physical reasons such as to restrict pieces to a finite set of rotations thus simplifying layout construc\u0002tion procedures and allowing for faster solutions to be obtained. The two-dimensional stock cutting problem\n0377-2217/$ - see front matter \u0002 2006 Elsevier B.V. All rights reserved.\ndoi:10.1016/j.ejor.2006.03.011\n* Corresponding author. Tel.: +44 115 9514210.\nE-mail addresses: ekb@cs.nott.ac.uk (E.K. Burke), rsh@cs.nott.ac.uk (R.S.R. Hellier), gxk@cs.nott.ac.uk (G. Kendall), gxw@cs.nott.\nac.uk (G. Whitwell).\nEuropean Journal of Operational Research 179 (2007) 27\u201349\nwww.elsevier.com/locate/ejor\nhas been shown to be NP hard and is therefore intrinsically difficult to solve (Garey and Johnson, 1979). There\nhave been many different strategies for producing solutions to the irregular stock cutting problem. These\ninclude linear programming approaches, heuristic placement methods, metaheuristic guided search techniques\nand other novel approaches such as the iterative jostling of pieces (Dowsland et al., 1998). Survey papers can\nbe found in (Dowsland and Dowsland, 1992; Sweeney and Paternoster, 1992; Dyckhoff, 1990). However, the\nfeature that connects all of the approaches is that they are all required to cope with the geometry of the prob\u0002lem. This can be especially complicated when highly irregular shapes are used which may include holes or con\u0002cavities. The implementation of robust and efficient geometry routines can be laborious and can often take\nconsiderably longer than the packing strategies themselves. In particular, the geometry must handle all of\nthe interactions between shapes such as detecting whether two shapes are overlapping and calculating the\ntranslation distance required in a given direction so that the overlap is resolved. As we show in the following\nsection, although these tests can be implemented using trigonometric techniques, the no-fit polygon represents\na considerably more efficient solution.\nWhilst the generation of the no-fit polygon is academically challenging, it is a \u2018tool\u2019 and not a \u2018solution\u2019 and\nthis is perhaps one of the reasons why there are many publications in the literature which state that the no-fit\npolygon is used but which provide relatively little or no details on its implementation. In this paper we con\u0002centrate specifically on the no-fit polygon and provide an overview of the previous techniques that have been\nused for its creation. Furthermore, we describe and provide full implementation details for a new robust orbi\u0002tal approach that can cope with the traditional problem cases that many other approaches cannot handle.\nHopefully this will help in the further dissemination of the benefits of using the no-fit polygon (as opposed\nto traditional trigonometry based approaches) within both the industrial and the academic communities.\n2. The no-fit polygon \u2013 an overview\nIn this section we describe the functionality of the no-fit polygon and we compare it to the more traditional\ntrigonometric based overlap and intersection tests. We also give brief overviews of the many techniques that\nhave been used to generate no-fit polygons within the previous literature.\n2.1. The no-fit polygon\nThe first application of no-fit polygon techniques within the field of cutting and packing was presented by\nArt (1966), although the term \u2018\u2018shape envelop\u2019\u2019 was used. It was ten years later that the term \u2018\u2018no-fit polygon\u2019\u2019\nwas introduced by Adamowicz and Albano who approached the irregular stock cutting problem by using no\u0002fit polygons to pack shapes together using their minimum enclosing rectangles (Adamowicz and Albano,\n1976). The term \u2018\u2018configuration space obstacle\u2019\u2019 is often used to denote the NFP within the field of engineering\nand robot motion planning but the term has also been used with respect to cutting and packing in (Cuningh\u0002ame-Green, 1989). The \u2018\u2018hodograph\u2019\u2019 is often used to describe the no-fit polygon within the mathematics com\u0002munity (Stoyan and Ponomarenko, 1977; Scheithauer and Terno, 1993; Bennell et al., 2001). The main\nfunction of the no-fit polygon is to describe the region in which two polygons intersect. The following example\ngives an overview of the NFP construct.\nGiven two polygons, A and B, the no-fit polygon can be found by tracing one shape around the boundary\nof another. One of the polygons remains fixed in position and the other traverses around the fixed polygon\u2019s\nedges whilst ensuring that the polygons always touch but never intersect. Throughout this paper we adopt the\nconvention of the first polygon being fixed and the second being the traversing/orbiting polygon. Therefore,\nwhen polygon B traces around the fixed polygon A, the resulting no-fit polygon is denoted by NFPAB. In order\nto create the NFPAB object we must choose a reference point from B which will be traced as B moves around\nA. In our implementations we use the first vertex, within the shape vertex list, as the reference point (see\nFig. 1). The reference point can be any arbitrary point providing it follows the movements of the orbiting poly\u0002gon. It is also important to maintain the relative position of the reference point with respect to polygon B as\nthis is required when using the NFP to test for overlap.\nIn order to test whether polygon B overlaps polygon A we use NFPAB and B\u2019s reference point. If polygon B\nis positioned so that its reference point is inside the polygon NFPAB then it overlaps with polygon A. If the\n28 E.K. Burke et al. / European Journal of Operational Research 179 (2007) 27\u201349\nreference point is on the boundary of NFPAB then polygon B touches polygon A. Finally, if the reference point\nis outside of NFPAB then polygons A and B do not overlap or touch (see Fig. 2). The no-fit polygon is used\nwithin the following papers from the literature (Grinde and Cavalier, 1995; Ramkumar, 1996; Cheng and Rao,...",
      "url": "https://www.graham-kendall.com/papers/bhkw2007.pdf"
    },
    {
      "title": "",
      "text": "Computers & Operations Research 33 (2006) 1521 \u2013 1539\nwww.elsevier.com/locate/cor\nAn improved method for calculating the no-fit polygon\nHamish T. Dean , Yiliu Tu, John F. Raffensperger\n200 Armagh Street, P.O. Box 13-761, Christchurch, New Zealand\nAbstract\nThe no-fit polygon (NFP) is the set of feasible locations that one polygon may take with respect to another polygon,\nsuch that the polygons do not overlap. Feasible locations are required for most of the solutions to two-dimensional\npacking problems, and also for other problems such as robot motion planning.\nEfficient methods to calculate the NFP of two convex polygons, or one convex and one non-convex polygon\nhave been developed by other researchers. However, when both polygons are non-convex, the current methods of\ncalculation are inefficient or difficult to implement. This paper presents an extension of Ghosh\u2019s (CVGIP: Image\nUnderstanding 54(1991)119) NFP algorithm, and uses manipulation of sorted lists of polygon edges to find the NFP\nefficiently.\n2004 Elsevier Ltd. All rights reserved.\nKeywords: No-fit polygon; Two-dimensional packing; Minkowski sum\n1. Introduction\nAn issue in two-dimensional packing is determining the set of feasible locations that one polygon\nmay take with respect to another polygon, such that the polygons do not overlap. This set of locations is\nknown as a no-fit polygon (NFP). The terms Minkowski sum, -function, hodograph, dilation, envelope\nand configuration space obstacle have also been used by other researchers.\nLet each polygon be represented by an ordered list of edges. The location of each polygon i in the\ntwo-dimensional plane is represented by a reference point, . The reference point is located at point (0,\n0) of a polygon\u2019s local coordinate system (see Fig. 1).\nCorresponding author. Tel.: +64 3 377 3140.\nE-mail address: hamish@shapeshifter.net.nz (H.T. Dean).\n0305-0548/$ - see front matter 2004 Elsevier Ltd. All rights reserved.\ndoi:10.1016/j.cor.2004.11.005\nH.T. Dean et al. / Computers & Operations Research 33 (2006) 1521 \u2013 1539 1523\nFig. 3. Minkowski sum of , and NFP .\nA0\nA1\nA2\nA3\nA4\nB\n\u2013B\nB1 B2\nB0\nA0\nA1\nA4\nA3, B0\nA2\nB1\nB2\nB1\nA4\nB0 A3\nA2\nB2\nA1\nA0\nNFP[A, B]\nFig. 4. Polygon edge slope order is equivalent to NFP edge order.\nCunninghame-Green [2] showed that for the case when polygons A and B are convex, NFP[A, B] can\nbe created by ordering the edges of A and in increasing slope order. NFP[A, B]\u2019s edges correspond\nexactly to this slope order (see Fig. 4).\nWhen one or more of the polygons are non-convex, an obvious way of calculating the relevant NFP\nis to decompose each polygon i into a set of convex sub-polygons CSP 1 CSP . Overlap\nwill occur between the two polygons if any sub-polygon of A overlaps any sub-polygon of B. NFP[A, B]\nis the union of NFP CSP CSP , where 1 and 1 . There are two drawbacks to the polygon subdivision approach. Firstly, efficient algorithms are required\nfor polygon decomposition and polygon composition. Secondly, it is possible that a non-convex polygon\nthat has N edges in cavities (see Fig. 5) can be decomposed into no less than N CSPs. The NFP of two\nof these polygons would require the composition of 2 sub-NFPs. Polygons used in industries such as\ngarment manufacturing often have large numbers of edges in their curve-like cavities, and the sub-division\nH.T. Dean et al. / Computers & Operations Research 33 (2006) 1521 \u2013 1539 1525\nDefinition 2.2. An edge i of a polygon is a turning point if the sign of is opposite to the sign of\n1 . Bennell et al. [7] states that a polygon is convex if and only if it does not contain any turning points.\nOtherwise it is non-convex. The initial stage of Ghosh\u2019s approach is to sort all the edges of polygon A and polygon B by slope into\none list which we will call MergeList. If both polygon A and B are convex, then MergeList gives the edge\norder for NFP[A, B], and the method is equivalent to that of Cunninghame-Green [2]. Assuming polygon A is non-convex, and polygon B is convex, the method proceeds as follows:\nStarting in MergeList at the first edge of polygon A, visit the edges of A in order, and add them to\nthe list of edges (NFPList) which make up NFP[A, B]. If edge A is a turning point, then the direction of\ntravel along MergeList is reversed. Any edges of B which are passed are added to NFPList. B edges are\npositive if the direction of travel forward, and negative if the direction is backward. This continues until\nthe first edge of polygon A has been returned to. The resulting NFPList we will call GhoshList. The above\nalgorithm is given in Pseudocode 2.1.\nPosition in MergeList which corresponds to 0\n0\nDir 1\nLoop{\nIf MergeList PolygonType Then\nIf MergeList PolygonIndex Then\nGhoshList GhoshList MergeList\nIf MergeList IsTurningPoint True Then Dir Dir 1\n1 If Size Then 0)\nEnd If\nElse\nGhoshList GhoshList MergeList Dir\nEnd If\nDir\n}While( 0)\nPseudocode 2.1: Algorithm to find GhoshList\nThe process of finding GhoshList is seen easily with what Ghosh calls a slope diagram (see Fig. 6).\nThe points on the diagram are at the slope of the edges of polygons A and B. Following around the slope diagram, starting and finishing at 0, mimics the process of traversing\nover MergeList. The outer envelope of NFPList gives NFP[A, B] (see Fig. 7).\nGhosh\u2019s method works for all simple polygons (no holes) when polygon A is non-convex and polygon\nB is convex. The method also works when both polygons are non-convex, as long as no two cavities from\neither polygon interfere which each other. This occurs when an interval of MergeList has wrongly ordered\nedges from both polygons. When this does occur, this interval must be traversed in two or more parallel\npaths. Although the theory of traversal by parallel paths holds true for complex non-convex cases, there\nare considerable implementation problems in sorting out the paths. These difficulties led Bennell et al.\n[7] to seek a different approach.\nH.T. Dean et al. / Computers & Operations Research 33 (2006) 1521 \u2013 1539 1527\nThe calculation difficulties of Bennell\u2019s method has motivated development of a more robust and\nefficient method of calculating NFPs. Like Bennell\u2019s method, it exploits the fact that the NFP of a non\u0002convex polygon and a convex polygon can be easily and efficiently found by Ghosh\u2019s method. However,\nthe new method does not use dummy edges to replace cavities of B.\n3. A new method\nIntuitively, it would seem a good idea to modify Bennell\u2019s method to start \u201clooking\u201d for the next B\nedge of a cavity once an occurrence of the current B edge has been found, instead of continuing to look\nfor the furthest occurrence of that B edge. However, if there is more than one occurrence of a B edge in\nany given segment then this approach will run into difficulties.\nA solution to this is to make sure that each traversal segment contains only positive or negative occur\u0002rences of each B edge of a particular cavity. Replacing a B cavity with a dummy edge D will not guarantee\nthis (see Fig. 8).\nFig. 8 shows a dummy edge D, whose cavity is composed of edges 1 and 2. In this example, Bennell\u2019s\nmethod would require only one segment which would contain a single occurrence of D. However, this\nsegment contains both positive and negative occurrences of 1.\nTo guarantee that there is only positive or negative occurrences of a given cavity B edge, we split the\ntraversal of GhoshList using the algorithm given in Pseudo-code 3.1:\nThe position in GhoshList which corresponds to 0.\nTravelDir 1\nCurrentSign 1\nTravelSign 1\n1\nLoop1{\nTravelDir\nIf GhoshList PolygonType Then\nIf GhoshList PolygonIndex 0 And TravelDir 1 Then\nSeg i End\nExit Algorithm\nElse If GhoshList IsTurningPoint True Then\nTravelSign TravelSign 1\nSeg Start\nEnd If\nElse If GhoshList IsInCavity True And CurrentSign TravelSign\nThen\nTravelDir TravelDir 1\nSeg Start\nTravelSign TravelSign 1\nExit Loop1\nEnd If\n}\nH.T. Dean et al. / Computers & Operations Research 33 (2006) 1521 \u2013 1539 1529\nB\n\u2013B\nB0\nB7 B8\nB6\nB5\nB4\nB3\nB2 B1\nB7 B5\nB2\nB4\nB0\nB3\nB1\nB8\nB6\nB2\nB7 B5\nB4\nCav...",
      "url": "https://nestprofessor.com/articles/An%20improved%20method%20for%20calculating%20the%20no-fit%20polygon(Automatic%20nesting%20software).pdf"
    },
    {
      "title": "Discrete Optimization Complete and robust no-fit polygon generation for the irregular stock cutting problem",
      "text": "Complete and robust no-fit polygon generation for the irregular stock cutting problem - ScienceDirect\n[Skip to main content](#screen-reader-main-content)[Skip to article](#screen-reader-main-title)\n[![Elsevier logo](https://www.sciencedirect.com/shared-assets/24/images/elsevier-non-solus-new-grey.svg)ScienceDirect](https://www.sciencedirect.com/)\n[My account](https://www.sciencedirect.com/user/login?targetURL=/science/article/pii/S0377221706001639&amp;from=globalheader)\n[Sign in](https://www.sciencedirect.com/user/institution/login?targetURL=/science/article/pii/S0377221706001639)\n* [Access through**your organization**](https://www.sciencedirect.com/user/institution/login?targetUrl=/science/article/pii/S0377221706001639)\n* [Purchase PDF](https://www.sciencedirect.com/getaccess/pii/S0377221706001639/purchase)\nSearch ScienceDirect\n## Article preview\n* [Abstract](#preview-section-abstract)\n* [Introduction](#preview-section-introduction)\n* [Section snippets](#preview-section-snippets)\n* [References (34)](#preview-section-references)\n* [Cited by (136)](#preview-section-cited-by)\n[![Elsevier](https://www.sciencedirect.com/us-east-1/prod/216a598ba584ec7107ee673c5b628e3ab9d74d3b/image/elsevier-non-solus.svg)](https://www.sciencedirect.com/journal/european-journal-of-operational-research)\n## [European Journal of Operational Research](https://www.sciencedirect.com/journal/european-journal-of-operational-research)\n[Volume 179, Issue 1](https://www.sciencedirect.com/journal/european-journal-of-operational-research/vol/179/issue/1),16 May 2007, Pages 27-49\n[![European Journal of Operational Research](https://ars.els-cdn.com/content/image/1-s2.0-S0377221706X05556-cov150h.gif)](https://www.sciencedirect.com/journal/european-journal-of-operational-research/vol/179/issue/1)\n# Discrete Optimization\nComplete and robust no-fit polygon generation for the irregular stock cutting problem\nAuthor links open overlay panelE.K.Burke,R.S.R.Hellier,G.Kendall,G.Whitwell\nShow more\nAdd to Mendeley\nShare\nCite\n[https://doi.org/10.1016/j.ejor.2006.03.011](https://doi.org/10.1016/j.ejor.2006.03.011)[Get rights and content](https://s100.copyright.com/AppDispatchServlet?publisherName=ELS&amp;contentID=S0377221706001639&amp;orderBeanReset=true)\n## Abstract\nThe no-fit polygon is a construct that can be used between pairs of shapes for fast and efficient handling of geometry within irregular two-dimensional stock cutting problems. Previously, the no-fit polygon (NFP) has not been widely applied because of the perception that it is difficult to implement and because of the lack of generic approaches that can cope with all problem cases without specific case-by-case handling. This paper introduces a robust orbital method for the creation of no-fit polygons which does not suffer from the typical problem cases found in the other approaches from the literature. Furthermore, the algorithm only involves two simple geometric stages so it is easily understood and implemented. We demonstrate how the approach handles known degenerate cases such as holes, interlocking concavities and jigsaw type pieces and we give generation times for 32 irregular packing benchmark problems from the literature, including real world datasets, to allow further comparison with existing and future approaches.\n## Introduction\nThe irregular two-dimensional variant of the cutting and packing problem impacts upon several important manufacturing industries such as textiles, plastics, metal cutting and others. These problems usually consist of a number of irregular pieces that are to be placed onto one or more sheets of material in the most efficient layout possible, so that all pieces are assigned and do not overlap. Additionally, there are usually rotational constraints enforced on the pieces due to the physical properties of the problem such as grain on the material, patterns on textiles and the cutting technology being employed. Sometimes rotational constraints may be used for non-physical reasons such as to restrict pieces to a finite set of rotations thus simplifying layout construction procedures and allowing for faster solutions to be obtained. The two-dimensional stock cutting problem has been shown to be NP hard and is therefore intrinsically difficult to solve (Garey and Johnson, 1979). There have been many different strategies for producing solutions to the irregular stock cutting problem. These include linear programming approaches, heuristic placement methods, metaheuristic guided search techniques and other novel approaches such as the iterative jostling of pieces (Dowsland et al., 1998). Survey papers can be found in (Dowsland and Dowsland, 1992, Sweeney and Paternoster, 1992, Dyckhoff, 1990). However, the feature that connects all of the approaches is that they are all required to cope with the geometry of the problem. This can be especially complicated when highly irregular shapes are used which may include holes or concavities. The implementation of robust and efficient geometry routines can be laborious and can often take considerably longer than the packing strategies themselves. In particular, the geometry must handle all of the interactions between shapes such as detecting whether two shapes are overlapping and calculating the translation distance required in a given direction so that the overlap is resolved. As we show in the following section, although these tests can be implemented using trigonometric techniques, the no-fit polygon represents a considerably more efficient solution.\nWhilst the generation of the no-fit polygon is academically challenging, it is a \u2018tool\u2019 and not a \u2018solution\u2019 and this is perhaps one of the reasons why there are many publications in the literature which state that the no-fit polygon is used but which provide relatively little or no details on its implementation. In this paper we concentrate specifically on the no-fit polygon and provide an overview of the previous techniques that have been used for its creation. Furthermore, we describe and provide full implementation details for a new robust orbital approach that can cope with the traditional problem cases that many other approaches cannot handle. Hopefully this will help in the further dissemination of the benefits of using the no-fit polygon (as opposed to traditional trigonometry based approaches) within both the industrial and the academic communities.\n## Section snippets\n## The no-fit polygon \u2013an overview\nIn this section we describe the functionality of the no-fit polygon and we compare it to the more traditional trigonometric based overlap and intersection tests. We also give brief overviews of the many techniques that have been used to generate no-fit polygons within the previous literature.\n## The new no-fit polygon construction algorithm\nWe now describe our new approach for robust no-fit polygon generation through the use of orbital methods utilising standard trigonometrical techniques. For the intersection calculations within our presented implementation, it is important to use a robust geometry library. It is also beneficial to implement routines that are as fast and as close to optimal as possible in order to promote fast no-fit polygon generation and packing algorithms. We have implemented such a library. Although this can\n## Problem cases\nIn this section we discuss each of the problem cases that cause difficulties with other methods and show why our approach is able to handle them without specific case-by-case implementations. In each figure of this section we identify the stationary and orbiting polygons in dark and light grey shading respectively and we show the reference point of the orbiting polygon by a black dot. This is used to trace the loops of the no-fit polygon (which we number). We present the data for these problem\n## Generation times on the benchmark problems\nIn order to demonstrate the speed and capabilities of our new no-fit polygon procedure, we report the generation times for 32 benchmark pr...",
      "url": "https://www.sciencedirect.com/science/article/abs/pii/S0377221706001639"
    },
    {
      "title": "Bin packing problem",
      "text": "Bin packing problem - Wikipedia\n[Jump to content](#bodyContent)\n[![](https://en.wikipedia.org/static/images/icons/wikipedia.png)![Wikipedia](https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg)![The Free Encyclopedia](https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg)](https://en.wikipedia.org/wiki/Main_Page)\n[Search](https://en.wikipedia.org/wiki/Special:Search)\nSearch\n# Bin packing problem\n11 languages\n* [Deutsch](https://de.wikipedia.org/wiki/Beh\u00e4lterproblem)\n* [Espa\u00f1ol](https://es.wikipedia.org/wiki/Problema_de_empaquetado_en_contenedores)\n* [\u0641\u0627\u0631\u0633\u06cc](https://fa.wikipedia.org/wiki/\u0645\u0633\u0626\u0644\u0647_\u0628\u0633\u062a\u0647\u200c\u0628\u0646\u062f\u06cc)\n* [Fran\u00e7ais](https://fr.wikipedia.org/wiki/Probl\u00e8me_de_bin_packing)\n* [\u05e2\u05d1\u05e8\u05d9\u05ea](https://he.wikipedia.org/wiki/\u05d1\u05e2\u05d9\u05d9\u05ea_\u05d0\u05e8\u05d9\u05d6\u05d4_\u05d1\u05d3\u05dc\u05d9\u05d9\u05dd)\n* [\u65e5\u672c\u8a9e](https://ja.wikipedia.org/wiki/\u30d3\u30f3\u30d1\u30c3\u30ad\u30f3\u30b0\u554f\u984c)\n* [Portugu\u00eas](https://pt.wikipedia.org/wiki/Problema_do_empacotamento_em_contentores)\n* [\u0420\u0443\u0441\u0441\u043a\u0438\u0439](https://ru.wikipedia.org/wiki/\u0417\u0430\u0434\u0430\u0447\u0430_\u043e\u0431_\u0443\u043f\u0430\u043a\u043e\u0432\u043a\u0435_\u0432_\u043a\u043e\u043d\u0442\u0435\u0439\u043d\u0435\u0440\u044b)\n* [\u0421\u0440\u043f\u0441\u043a\u0438 / srpski](https://sr.wikipedia.org/wiki/\u041f\u0440\u043e\u0431\u043b\u0435\u043c_\u043f\u0430\u043a\u043e\u0432\u0430\u045a\u0430_\u0443_\u043f\u0440\u043e\u0441\u0442\u043e\u0440\u0443)\n* [\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430](https://uk.wikipedia.org/wiki/\u0417\u0430\u0434\u0430\u0447\u0430_\u043f\u0440\u043e_\u043f\u0430\u043a\u0443\u0432\u0430\u043d\u043d\u044f_\u0432_\u0454\u043c\u043d\u043e\u0441\u0442\u0456)\n* [\u4e2d\u6587](https://zh.wikipedia.org/wiki/\u96c6\u88c5\u4f18\u5316)\n[Edit links](https://www.wikidata.org/wiki/Special:EntityPage/Q814581#sitelinks-wikipedia)\nFrom Wikipedia, the free encyclopedia\nMathematical and computational problem\nNot to be confused with[Bin picking](https://en.wikipedia.org/wiki/Bin_picking).\n|[Covering/packing-problem pairs](https://en.wikipedia.org/wiki/Linear_programming#Covering/packing_dualities)|\n[Covering problems](https://en.wikipedia.org/wiki/Covering_problems)|[Packing problems](https://en.wikipedia.org/wiki/Packing_problems)|\n[Minimum set cover](https://en.wikipedia.org/wiki/Set_cover_problem)|[Maximum set packing](https://en.wikipedia.org/wiki/Set_packing)|\n[Minimum edge cover](https://en.wikipedia.org/wiki/Edge_cover)|[Maximum matching](https://en.wikipedia.org/wiki/Matching_(graph_theory))|\n[Minimum vertex cover](https://en.wikipedia.org/wiki/Vertex_cover)|[Maximum independent set](https://en.wikipedia.org/wiki/Independent_set_(graph_theory))|\n[Bin covering](https://en.wikipedia.org/wiki/Bin_covering_problem)|Bin packing|\n[Polygon covering](https://en.wikipedia.org/wiki/Polygon_covering)|[Rectangle packing](https://en.wikipedia.org/wiki/Rectangle_packing)|\n|\n* [v](https://en.wikipedia.org/wiki/Template:Covering/packing-problem_pairs)\n* [t](https://en.wikipedia.org/wiki/Template_talk:Covering/packing-problem_pairs)\n* [e](https://en.wikipedia.org/wiki/Special:EditPage/Template:Covering/packing-problem_pairs)\n|\nThe**bin packing problem[&#91;1&#93;](#cite_note-1)[&#91;2&#93;](#cite_note-2)[&#91;3&#93;](#cite_note-3)[&#91;4&#93;](#cite_note-:0-4)**is an[optimization problem](https://en.wikipedia.org/wiki/Optimization_problem), in which items of different sizes must be packed into a finite number of bins or containers, each of a fixed given capacity, in a way that minimizes the number of bins used. The problem has many applications, such as filling up containers, loading trucks with weight capacity constraints, creating file[backups](https://en.wikipedia.org/wiki/Backup)in media, splitting a network prefix into multiple subnets,[&#91;5&#93;](#cite_note-5)and technology mapping in[FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array)[semiconductor chip](https://en.wikipedia.org/wiki/Semiconductor_chip)design.\nComputationally, the problem is[NP-hard](https://en.wikipedia.org/wiki/NP-hard), and the corresponding[decision problem](https://en.wikipedia.org/wiki/Decision_problem), deciding if items can fit into a specified number of bins, is[NP-complete](https://en.wikipedia.org/wiki/NP-complete). Despite its worst-case hardness, optimal solutions to very large instances of the problem can be produced with sophisticated algorithms. In addition, many[approximation algorithms](https://en.wikipedia.org/wiki/Approximation_algorithms)exist. For example, the[first fit](https://en.wikipedia.org/wiki/First-fit_bin_packing)algorithm provides a fast but often non-optimal solution, involving placing each item into the first bin in which it will fit. It requires*[\u0398](https://en.wikipedia.org/wiki/Big_O_notation)*(*n*&#160;log&#160;*n*) time, where*n*is the number of items to be packed. The algorithm can be made much more effective by first[sorting](https://en.wikipedia.org/wiki/Sorting)the list of items into decreasing order (sometimes known as the first-fit decreasing algorithm), although this still does not guarantee an optimal solution and for longer lists may increase the running time of the algorithm. It is known, however, that there always exists at least one ordering of items that allows first-fit to produce an optimal solution.[&#91;6&#93;](#cite_note-6)\nThere are many[variations](https://en.wikipedia.org/wiki/Packing_problem)of this problem, such as 2D packing, linear packing, packing by weight, packing by cost, and so on. The bin packing problem can also be seen as a special case of the[cutting stock problem](https://en.wikipedia.org/wiki/Cutting_stock_problem). When the number of bins is restricted to 1 and each item is characterized by both a volume and a value, the problem of maximizing the value of items that can fit in the bin is known as the[knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem).\nA variant of bin packing that occurs in practice is when items can share space when packed into a bin. Specifically, a set of items could occupy less space when packed together than the sum of their individual sizes. This variant is known as VM packing[&#91;7&#93;](#cite_note-7)since when[virtual machines](https://en.wikipedia.org/wiki/Virtual_machines)(VMs) are packed in a server, their total[memory requirement](https://en.wikipedia.org/wiki/Memory_management)could decrease due to[pages](https://en.wikipedia.org/wiki/Page_(computer_memory))shared by the VMs that need only be stored once. If items can share space in arbitrary ways, the bin packing problem is hard to even approximate. However, if space sharing fits into a hierarchy, as is the case with memory sharing in virtual machines, the bin packing problem can be efficiently approximated.\nAnother variant of bin packing of interest in practice is the so-called[online](https://en.wikipedia.org/wiki/Online_algorithm)bin packing. Here the items of different volume are supposed to arrive sequentially, and the decision maker has to decide whether to select and pack the currently observed item, or else to let it pass. Each decision is without recall. In contrast, offline bin packing allows rearranging the items in the hope of achieving a better packing once additional items arrive. This of course requires additional storage for holding the items to be rearranged.\n## Formal statement\n[[edit](https://en.wikipedia.org/w/index.php?title=Bin_packing_problem&amp;action=edit&amp;section=1)]\nIn*[Computers and Intractability](https://en.wikipedia.org/wiki/Computers_and_Intractability)*[&#91;8&#93;](#cite_note-GareyJohnson2-8)&#58;&#8202;226&#8202;Garey and Johnson list the bin packing problem under the reference [SR1]. They define its decision variant as follows.\nInstance: Finite setI{\\\\displaystyle I}![{\\displaystyle I}](https://wikimedia.org/api/rest_v1/media/math/render/svg/535ea7fc4134a31cbe2251d9d3511374bc41be9f)of items, a sizes(i)&#x2208;Z+{\\\\displaystyle s(i)\\\\in \\\\mathbb {Z} ^{+}}![{\\displaystyle s(i)\\in \\mathbb {Z} ^{+}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3aa77286f9a6b2c0637c92e98c322dd17a9c44eb)for eachi&#x2208;I{\\\\displaystyle i\\\\in I}![{\\displaystyle i\\in I}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2d740fe587228ce31b71c9628e089d1a9b37c6be), a positive integer bin capacityB{\\\\displaystyle B}![{\\displaystyle B}](https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a), and a positive integerK{\\\\displaystyle K}![{\\displaystyle K}](https://wikimedia.org/api/rest_v1/...",
      "url": "https://en.wikipedia.org/wiki/Bin_packing_problem"
    },
    {
      "title": "The Bin Packing Problem \n\n    \n    \n       \n    \n\n     \n      \n      Stay organized with collections\n     \n     \n      \n      Save and categorize content based on your preferences.",
      "text": "The Bin Packing Problem | OR-Tools | Google for Developers[Skip to main content](#main-content)\n[\n![Google OR-Tools](https://developers.google.com/static/optimization/images/orLogo.png)\n](https://developers.google.com/optimization)\n* [GoogleOR-Tools](https://developers.google.com/optimization)\n/\n* English\n* Deutsch\n* Espa\u00f1ol\n* Espa\u00f1ol \u2013Am\u00e9rica Latina\n* Fran\u00e7ais\n* Indonesia\n* Italiano\n* Polski\n* Portugu\u00eas \u2013Brasil\n* Ti\u00ea\u0301ng Vi\u00ea\u0323t\n* T\u00fcrk\u00e7e\n* \u0420\u0443\u0441\u0441\u043a\u0438\u0439* \u05e2\u05d1\u05e8\u05d9\u05ea* \u0627\u0644\u0639\u0631\u0628\u064a\u0651\u0629* \u0641\u0627\u0631\u0633\u06cc* \u0939\u093f\u0902\u0926\u0940* \u09ac\u09be\u0982\u09b2\u09be* \u0e20\u0e32\u0e29\u0e32\u0e44\u0e17\u0e22* \u4e2d\u6587\u2013\u7b80\u4f53* \u4e2d\u6587\u2013\u7e41\u9ad4* \u65e5\u672c\u8a9e* \ud55c\uad6d\uc5b4Sign in\n* [OR-Tools](https://developers.google.com/optimization)\n* [Home](https://developers.google.com/)\n* [Products](https://developers.google.com/products)\n* [OR-Tools](https://developers.google.com/optimization)\n* [Guides](https://developers.google.com/optimization/introduction)\nSend feedback# The Bin Packing ProblemStay organized with collectionsSave and categorize content based on your preferences.\n![Spark icon](https://developers.google.com/_static/images/icons/spark.svg)\n## Page Summary\noutlined\\_flag\n* The bin packing problem aims to pack items into the minimum number of bins, each with a fixed capacity, without considering item values.\n* A Mixed Integer Programming (MIP) model is used, with binary variables representing item-bin assignments and bin usage.\n* Constraints ensure each item is assigned to one bin and that bin capacities are respected.\n* The objective function minimizes the total number of bins used in the packing solution.\n* The solution provides the optimal assignment of items to bins, minimizing the total bins used and detailing the items and weights in each bin.\nLike the multiple knapsack problem, the bin packing problem also involves\npacking items into bins. However, the bin packing problem has a different\nobjective: find the fewest bins that will hold all the items.\nThe following summarizes the differences between the two problems:\n* Multiple knapsack problem: Pack a subset of the items into a fixed number of\nbins, with varying capacities, so that the total value of the packed items\nis a maximum.\n* Bin packing problem: Given as many bins with a common capacity as necessary,\nfind the fewest that will hold all the items. In this problem, the items\naren&#39;t assigned values, because the objective doesn&#39;t involve value.\nThe next example shows how to solve a bin packing problem.\n## Example\nIn this example, items of various weights need to be packed into a set of bins\nwith a common capacity. Assuming that there are enough bins to hold all the\nitems, the problem is to find the fewest that will suffice.\nThe following sections present programs that solve this problem. For the full\nprograms, see[Complete programs](#complete_programs).\nThis example uses the[MPSolver wrapper](https://developers.google.com/optimization/lp/mpsolver).\n### Import the libraries\nThe code below imports the required libraries.\n### Python\n```\nfromortools.linear\\_solverimportpywraplp\n```\n### C++\n```\n#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;vector&gt;#include\"ortools/linear\\_solver/linear\\_expr.h\"#include\"ortools/linear\\_solver/linear\\_solver.h\"\n```\n### Java\n```\nimportcom.google.ortools.Loader;importcom.google.ortools.linearsolver.MPConstraint;importcom.google.ortools.linearsolver.MPObjective;importcom.google.ortools.linearsolver.MPSolver;importcom.google.ortools.linearsolver.MPVariable;\n```\n### C#\n```\nusingSystem;usingGoogle.OrTools.LinearSolver;\n```\n### Create the data\nThe code below creates the data for the example.\n### Python\n```\ndefcreate\\_data\\_model():\"\"\"Create the data for the example.\"\"\"data={}weights=[48,30,19,36,36,27,42,42,36,24,30]data[\"weights\"]=weightsdata[\"items\"]=list(range(len(weights)))data[\"bins\"]=data[\"items\"]data[\"bin\\_capacity\"]=100returndata\n```\n### C++\n```\nstructDataModel{conststd::vector&lt;double&gt;weights={48,30,19,36,36,27,42,42,36,24,30};constintnum\\_items=weights.size();constintnum\\_bins=weights.size();constintbin\\_capacity=100;};\n```\n### Java\n```\nstaticclassDataModel{publicfinaldouble[]weights={48,30,19,36,36,27,42,42,36,24,30};publicfinalintnumItems=weights.length;publicfinalintnumBins=weights.length;publicfinalintbinCapacity=100;}\n```\n### C#\n```\nclassDataModel{publicstaticdouble[]Weights={48,30,19,36,36,27,42,42,36,24,30};publicintNumItems=Weights.Length;publicintNumBins=Weights.Length;publicdoubleBinCapacity=100.0;}\n```\nThe data includes the following:\n* `weights`: A vector containing the weights of the items.\n* `bin\\_capacity`: A single number giving the capacity of the bins.\nThere are no values assigned to the items because the goal of minimizing the\nnumber of bins doesn&#39;t involve value.\nNote that`num\\_bins`is set to the number of items. This is because if the\nproblem has a solution, then the weight of every item must be less than or equal\nto the bin capacity. In that case, the maximum number of bins you could need is\nthe number of items, because you could always put each item in a separate bin.\n### Declare the solver\nThe following code declares the solver.\n### Python\n```\n# Create the mip solver with the SCIP backend.solver=pywraplp.Solver.CreateSolver(\"SCIP\")ifnotsolver:return\n```\n### C++\n```\n// Create the mip solver with the SCIP backend.std::unique\\_ptr&lt;&lt;MPSolver&gt;&gt;solver(MPSolver::CreateSolver(\"SCIP\"));if(!solver){LOG(WARNING)&lt;&lt;\"SCIP solver unavailable.\";return;}\n```\n### Java\n```\n// Create the linear solver with the SCIP backend.MPSolversolver=MPSolver.createSolver(\"SCIP\");if(solver==null){System.out.println(\"Could not create solver SCIP\");return;}\n```\n### C#\n```\n// Create the linear solver with the SCIP backend.Solversolver=Solver.CreateSolver(\"SCIP\");if(solverisnull){return;}\n```\n### Create the variables\nThe following code creates the variables for the program.\n### Python\n```\n# Variables# x[i, j] = 1 if item i is packed in bin j.x={}foriindata[\"items\"]:forjindata[\"bins\"]:x[(i,j)]=solver.IntVar(0,1,\"x\\_%i\\_%i\"%(i,j))# y[j] = 1 if bin j is used.y={}forjindata[\"bins\"]:y[j]=solver.IntVar(0,1,\"y[%i]\"%j)\n```\n### C++\n```\nstd::vector&lt;std::vector&lt;constMPVariable\\*&gt;&gt;x(data.num\\_items,std::vector&lt;constMPVariable\\*&gt;(data.num\\_bins));for(inti=0;i&lt;data.num\\_items;++i){for(intj=0;j&lt;data.num\\_bins;++j){x[i][j]=solver-&gt;MakeIntVar(0.0,1.0,\"\");}}// y[j] = 1 if bin j is used.std::vector&lt;constMPVariable\\*&gt;y(data.num\\_bins);for(intj=0;j&lt;data.num\\_bins;++j){y[j]=solver-&gt;MakeIntVar(0.0,1.0,\"\");}\n```\n### Java\n```\nMPVariable[][]x=newMPVariable[data.numItems][data.numBins];for(inti=0;i&lt;data.numItems;++i){for(intj=0;j&lt;data.numBins;++j){x[i][j]=solver.makeIntVar(0,1,\"\");}}MPVariable[]y=newMPVariable[data.numBins];for(intj=0;j&lt;data.numBins;++j){y[j]=solver.makeIntVar(0,1,\"\");}\n```\n### C#\n```\nVariable[,]x=newVariable[data.NumItems,data.NumBins];for(inti=0;i&lt;data.NumItems;i++){for(intj=0;j&lt;data.NumBins;j++){x[i,j]=solver.MakeIntVar(0,1,$\"x\\_{i}\\_{j}\");}}Variable[]y=newVariable[data.NumBins];for(intj=0;j&lt;data.NumBins;j++){y[j]=solver.MakeIntVar(0,1,$\"y\\_{j}\");}\n```\nAs in the multiple knapsack example, you define an array of variables`x[(i,\nj)]`, whose value is 1 if item`i`is placed in bin`j`, and 0 otherwise.\nFor bin packing, you also define an array of variables,`y[j]`, whose value is 1\nif bin`j`is used&mdash;that is, if any items are packed in it&mdash;and 0\notherwise. The sum of the`y[j]`will be the number of bins used.\n### Define the constraints\nThe following code defines the constraints for the problem:\n### Python\n```\n# Constraints# Each item must be in exactly one bin.foriindata[\"items\"]:solver.Add(sum(x[i,j]forjindata[\"bins\"])==1)# The amount packed in each bin cannot exceed its capacity.forjindata[\"bins\"]:solver.Add(sum(x[(i,j)]\\*data[\"weights\"][i]foriindata[\"items\"])&lt;=y[j]\\*data[\"bin\\_capacity\"])\n```\n### C++\n```\n// Create the constraints.// Each item is in exactly one bin.for(inti=0;i&lt;data.num\\_items;++i){LinearExprsum;for(intj=0;j&lt;data.num\\_bins;++j){sum+=x[i][j];}solver-&g...",
      "url": "https://developers.google.com/optimization/pack/bin_packing"
    },
    {
      "title": "- YouTube",
      "text": "None\n| view_count: 20,830 views | short_view_count: 20K views | num_likes: 346 | num_subscribers: 3.9K",
      "url": "https://youtube.com/watch?v=R76aAh_li50"
    },
    {
      "title": "- YouTube",
      "text": "In this Video, We have Covered\\n1. Bin Packing Algorithm and its types\\n2. First Fit Algorithm \\u0026 Best Fit Algorithm\\n3.Solved Example\\n#daalectures #easyexplanation \\n\\nFor Video Lecture Notes, Download from link given Below:\\nhttps://drive.google.com/drive/folder...\\n\\nSocial Media Handles\\n\\nFollow Me on Instagram: @chirag_sharma1510 \\nFollow Me on Linkedin : /\u00a0chirag-sh. .\\n\\n\\n#designandanalysisofalgorithms #DAAlectures\\n\\nFor any doubts and Queries Comment Below\\n\\nKindly Like, Share and Subscribe on the Channel, Your Support is valuable in this initiative.\n| view_count: 26,778 views | short_view_count: 26K views | num_likes: 287 likes | num_subscribers: 10.6 thousand | duration: 7 minutes 15 seconds",
      "url": "https://youtube.com/watch?v=ffkD5g5aMq4"
    }
  ]
}