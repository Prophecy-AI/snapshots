# Santa 2025 Christmas Tree Packing - Seed Prompt (Loop 5)

## Current Status
- Best CV score: 70.734327 from exp_000 (baseline)
- Best LB score: 70.734327 (verified)
- Target: 68.931058 | Gap to target: 1.803269 (2.5%)
- Experiments run: 5 (ALL at same score - no improvement)

## Public Kernel Status (CRITICAL!)
- Have we implemented the best kernel yet? **NO - not properly**
- Top kernels identified:
  1. jonathanchan: Ensemble + C++ SA (20000 iter, 80 restarts, multiple generations)
  2. egortrushin: SA with translations (structured packing for large N)
  3. saspav: bbox3 binary + fix_direction
- Kernels we've implemented: Basic SA, basic structured packing (both failed)
- **CRITICAL GAP**: jonathanchan uses 20000 iterations, 80 restarts, MULTIPLE GENERATIONS
  - Our approach: 15000 iterations, 5-6 restarts, SINGLE PASS
  - This is a 4-10x difference in compute!

## Response to Evaluator
The evaluator correctly identified that:
1. All 5 experiments achieved the EXACT SAME score (70.734327)
2. The overlapping configs cannot be repaired - they're fundamentally broken
3. The jonathanchan C++ optimizer has sophisticated techniques not being used
4. We need to PIVOT to a fundamentally different approach

**I agree with the evaluator's assessment.** The key insight is that we've been running with insufficient compute. The jonathanchan kernel runs:
- 20000 iterations (vs our 15000)
- 80 restarts (vs our 5-6)
- Multiple generations until no improvement (vs our single pass)

This is a 10-20x difference in total compute. We need to match this.

## Key Findings from Analysis
1. **Only 3 CSVs score better than baseline** - ALL have overlaps (67.73, 67.77, 67.77)
2. **The baseline is at a strong local optimum** - simple SA cannot escape it
3. **jonathanchan approach is fundamentally different**:
   - Uses population-based search (keeps top 3 solutions)
   - Runs in endless loop until no improvement for 3 generations
   - Much higher iterations and restarts
4. **egortrushin approach for large N**:
   - Uses structured grid translations
   - 2 base trees at different angles
   - SA optimizes translation parameters, not tree positions

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Run C++ Optimizer with HIGH Parameters
The sa_v3_parallel binary exists at `/home/code/experiments/sa_v3_parallel`.

**Run with:**
```bash
./sa_v3_parallel -i /path/to/baseline.csv -o output.csv -n 30000 -r 32
```

**Key parameters:**
- `-n 30000`: 30000 iterations (2x our previous)
- `-r 32`: 32 restarts (5x our previous)
- Run MULTIPLE TIMES until no improvement

**Expected outcome:** Even small improvements compound across 200 N values.

### 2. **[HIGH PRIORITY]** Implement Proper Egortrushin Structured Packing
For large N (>50), use grid-based translations:
1. Start with 2 base trees at optimal angles (e.g., 0° and 180°)
2. Use SA to optimize translation parameters (delta_x, delta_y)
3. Generate N trees by translating the base pattern
4. Apply backward propagation to improve smaller N from larger N

**Key insight:** For large N, structured packings may be mathematically superior.

### 3. **[MEDIUM PRIORITY]** Multi-Generation Optimization Loop
Implement the jonathanchan endless loop approach:
```python
while True:
    improved = False
    for n in range(1, 201):
        new_score = optimize(n)
        if new_score < best_score[n]:
            improved = True
            best_score[n] = new_score
    if not improved:
        break
```

### 4. **[LOWER PRIORITY]** Targeted N-Value Optimization
Identify N values with most room for improvement:
- Small N (1-20): Highest per-N contribution to score
- Large N (>150): May benefit from structured packing

## What NOT to Try
- ❌ Overlap repair (configs are fundamentally broken)
- ❌ Simple Python SA (too slow, already tried)
- ❌ Single-pass optimization (need multiple generations)
- ❌ Low iteration counts (<20000)

## SUBMISSION STRATEGY
- Remaining submissions: 95
- Submit after this experiment? **YES** - we have abundant submissions
- Even if score doesn't improve, LB feedback is valuable

## Validation Notes
- CV = LB for this problem (deterministic optimization)
- Always validate for overlaps before submission
- Use Shapely for accurate overlap detection

## Technical Notes
- C++ optimizer location: `/home/code/experiments/sa_v3_parallel`
- Baseline CSV: `/home/nonroot/snapshots/santa-2025/21105319338/code/datasets/santa-2025-csv/santa-2025.csv`
- The optimizer includes:
  - sa_v3: SA with 8 move types
  - ls_v3: Local search with 8-directional moves
  - fractional_translation: Fine-grained position optimization
  - Population-based search (keeps top 3)
  - Backward propagation

## Concrete Next Experiment
**Experiment 006: High-Parameter C++ Optimization**

1. Run sa_v3_parallel with high parameters:
   ```bash
   cd /home/code/experiments
   ./sa_v3_parallel -i /home/nonroot/snapshots/santa-2025/21105319338/code/datasets/santa-2025-csv/santa-2025.csv -o optimized.csv -n 30000 -r 32
   ```

2. If no improvement, run again with even higher parameters:
   ```bash
   ./sa_v3_parallel -i optimized.csv -o optimized2.csv -n 50000 -r 64
   ```

3. Validate output for overlaps

4. If improved, submit to get LB feedback

**The target of 68.931058 IS ACHIEVABLE.** We just need to run with sufficient compute.