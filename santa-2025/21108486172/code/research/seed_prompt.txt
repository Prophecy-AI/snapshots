# Santa 2025 Christmas Tree Packing - Evolved Seed Prompt (Loop 2)

## Current Status
- Best CV score: 70.7343 from exp_001 (002_extended_optimization)
- Best LB score: 70.7343 (CV-LB gap: 0.0000 - perfect match!)
- Target: 68.931058 | Gap to target: 1.803 points (2.6%)

## CV-LB Relationship Analysis
- CV = LB exactly (gap = 0.0000)
- This is a pure optimization problem with deterministic scoring
- NO distribution shift - improving CV directly improves LB

## Response to Evaluator

The evaluator correctly identified that:
1. **Ensemble with overlaps scores 67.77** (below target!)
2. **Valid ensemble (no overlaps) scores 70.73** (same as baseline)
3. **ALL 2.96 points of improvement is locked behind overlaps**

However, after deeper analysis, I found a CRITICAL issue:
- **ALL cpp_parallel_sa configurations have MASSIVE overlaps** (183-198 N values with overlaps per file)
- The SA was run WITHOUT proper collision constraints
- Simple "nudge repair" CANNOT fix this - N=7 has 21 overlapping pairs where almost all trees overlap with each other
- The "better" configurations are fundamentally broken, not just slightly overlapping

**The evaluator's suggestion to "repair overlaps" is NOT viable for these configurations.**

## Key Insight: The Path Forward

The baseline (70.73) is already well-optimized WITH collision constraints. The cpp_parallel_sa configs score "better" only because they IGNORE collisions.

**Real options:**
1. **Run proper SA with collision constraints** - Start from baseline, use SA that REJECTS overlapping moves
2. **Use bbox3 binary** - The top kernels use this, but it has GLIBC 2.34 compatibility issues (system has 2.31)
3. **Implement crystalline packing for large N** - Research suggests N>58 benefits from regular lattice structures
4. **Focus on specific N values** - Some N values may have more room for improvement than others

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY] Implement Proper SA with Collision Constraints**
The C++ sa_parallel.cpp code has the right structure but was run incorrectly. Key changes needed:
- ALWAYS check `hasOvl(i)` before accepting a move
- Start from the BASELINE (which has no overlaps)
- Use proper temperature schedule (T0=1.0, cooling=0.9995)
- Run for many iterations (10000+) with multiple restarts

```cpp
// Key: Only accept moves that don't create overlaps
if (ok && (ns < bs || rf() < exp((bs - ns) / T))) {
    if (ns < bs) { bs = ns; best = c; }
} else {
    // REVERT the move
    c.x[i] = ox; c.y[i] = oy; c.a[i] = oa;
    c.upd(i);
}
```

### 2. **[HIGH PRIORITY] Try Different Optimization Approaches**
- **Backward propagation**: Start from N=200, remove trees to get N-1 configs
- **Per-tree rotation optimization**: After global optimization, fine-tune individual tree rotations
- **Squeeze/compaction**: Move trees towards center of mass

### 3. **[MEDIUM PRIORITY] Crystalline Packing for Large N**
Research suggests N>58 benefits from regular lattice structures:
- Alternating orientations (0°, 180°)
- Hexagonal or grid arrangements
- May require different approach than SA

### 4. **[LOWER PRIORITY] Build bbox3 from Source**
The bbox3 binary is used by top kernels but has GLIBC issues. Options:
- Find source code and compile locally
- Use a different binary optimizer
- Implement equivalent functionality in Python/C++

## What NOT to Try
- ❌ Simple "nudge repair" on cpp_parallel_sa configs (overlaps are too severe)
- ❌ Running more iterations on already-optimized baseline (diminishing returns)
- ❌ Fractional translation on small N (already tried, no improvement)

## Implementation Strategy for Next Experiment

**Experiment 003: Proper SA with Collision Constraints**

1. **Compile the sa_parallel.cpp** with proper collision checking enabled
2. **Start from baseline** (santa-2025.csv which has no overlaps)
3. **Run SA with parameters**:
   - Iterations: 15000
   - Temperature: T0=1.0, Tf=0.001, cooling=0.9995
   - Step sizes: Start large (0.1), decrease to fine (0.0001)
   - Restarts: 5-10 per N value
4. **Apply post-processing**:
   - fix_direction (rotation optimization)
   - Local search refinement
   - Fractional translation
5. **Validate**: Ensure no overlaps before saving

**Expected outcome**: Should find some improvement over baseline while maintaining validity.

## Validation Notes
- CV scheme: Direct score calculation (sum of side²/N for all N)
- Overlap check: Use Shapely STRtree for efficient collision detection
- All N values (1-200) must be present and valid

## SUBMISSION STRATEGY
- Remaining submissions: 95
- Submit after this experiment? **YES** - we have abundant submissions and need LB feedback
- Even small improvements should be submitted to track progress