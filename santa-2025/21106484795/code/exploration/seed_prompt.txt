# Santa 2025 Christmas Tree Packing - Seed Prompt

## Problem Overview
This is a 2D packing optimization problem. The goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest square bounding box for N=1 to 200 trees. 

**Scoring:** score = sum(side_length^2 / N) for all N from 1 to 200. Lower is better.
**Target:** Beat 68.931058

## Tree Shape
Each tree is a 15-vertex polygon with:
- Trunk: width 0.15, height 0.2
- Base tier: width 0.7
- Middle tier: width 0.4
- Top tier: width 0.25
- Tip at y=0.8

Trees can be rotated (0-360 degrees) and positioned at any (x, y) coordinates.

## Top Kernel Approaches

### 1. bbox3 Binary Optimizer (CRITICAL - Used by all top kernels)
The `bbox3` binary is the core optimizer used by top solutions. It takes parameters:
- `-n`: Number of iterations (typical: 1000-10000)
- `-r`: Rotation/refinement parameter (typical: 4-256)

**Usage pattern from top kernels:**
```bash
./bbox3 -n 5000 -r 96
./bbox3 -n 10000 -r 256  # Longer runs for better results
```

The bbox3 binary must be obtained from a Kaggle dataset (e.g., "bucket-of-chump", "santa-2025-csv").

### 2. fix_direction Rotation Optimization
After bbox3 optimization, rotate the entire configuration to minimize bounding box:
- Extract convex hull of all tree polygons
- Use scipy.optimize.minimize_scalar to find optimal rotation angle (0-90 degrees)
- Apply rotation to all trees
- Multiple passes improve results (passes=1-3)

### 3. Overlap Repair
bbox3 may create overlapping configurations. Repair by:
- Validate each N configuration for overlaps using Shapely
- Replace overlapping configs with known good ones from donor file
- Keep best valid submission

### 4. Santa Claude C++ Optimizer (Alternative approach)
Custom C++ optimizer with:
- Simulated annealing with high temperature
- Local search (8-directional moves + rotations)
- Compaction (move trees toward center)
- Squeeze (scale configuration toward center)
- Swap moves between trees
- Multi-start from different initial angles
- Backward propagation (remove trees from N to improve N-1)

Compile: `g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer.cpp`

## Recommended Experiment Strategy

### Phase 1: Baseline (Match top kernels ~69-70)
1. Download bbox3 binary and best submission from Kaggle datasets
2. Run bbox3 with moderate parameters: `-n 2000 -r 60`
3. Apply fix_direction with 1-2 passes
4. Validate and repair overlaps
5. Submit to verify baseline score

### Phase 2: Extended Optimization (Beat 68.931)
1. **Longer bbox3 runs:**
   - `-n 10000 -r 200` or higher
   - Multiple runs with different seeds
   
2. **Multi-pass fix_direction:**
   - Run fix_direction after every bbox3 pass
   - Use 3+ passes for better rotation optimization

3. **Per-N optimization:**
   - Identify N values with worst efficiency (highest side^2/N contribution)
   - Focus optimization on those specific N values
   - Small improvements on bad N values help more

4. **Ensemble approach:**
   - Run multiple optimization strategies
   - Keep best configuration for each N across all runs
   - Combine best-of-each-N into final submission

### Phase 3: Advanced Techniques
1. **Backward propagation:**
   - Start from N=200, remove boundary trees
   - If resulting N-1 config is better than current, keep it
   - Propagate improvements down to smaller N

2. **Per-tree rotation optimization:**
   - After global optimization, fine-tune individual tree rotations
   - Small angle adjustments (0.1-1 degree) can reduce bounding box

3. **Fractional translation:**
   - Very fine position adjustments (0.001 units)
   - Move trees toward center while avoiding overlaps

4. **Multi-start optimization:**
   - Run from 10+ different initial configurations
   - Different random seeds, different initial angles
   - Keep best result for each N

## Key Implementation Details

### Collision Detection
Use Shapely library with STRtree for efficient spatial queries:
```python
from shapely.strtree import STRtree
tree_index = STRtree(polygons)
# Check: poly.intersects(other) and not poly.touches(other)
```

### Precision
Use Decimal with high precision (25-30 digits) for coordinates.
Scale factor of 1e15 or 1e18 for polygon operations.

### Submission Format
- Values prefixed with 's': `s0.123456`
- Coordinates constrained: -100 <= x, y <= 100
- Format: `id,x,y,deg` where id is `NNN_T` (N=tree count, T=tree index)

## Files and Resources
- Sample submission: `/home/data/sample_submission.csv`
- Top kernels in: `../research/kernels/`
  - `saspav_santa-submission/` - bbox3 + fix_direction workflow
  - `yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - 3-phase optimization
  - `smartmanoj_santa-claude/` - C++ optimizer with SA and local search
  - `jazivxt_why-not/` - bbox3 runner with validation
  - `inversion_santa-2025-getting-started/` - Basic greedy algorithm

## Critical Success Factors
1. **Get bbox3 binary** - Essential for competitive scores
2. **Run long optimizations** - More iterations = better results
3. **Always apply fix_direction** - Rotation optimization is crucial
4. **Validate before submit** - Check for overlaps
5. **Focus on worst N values** - Biggest improvement potential
6. **Ensemble multiple runs** - Keep best of each N
