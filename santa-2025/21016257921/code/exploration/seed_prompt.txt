# Santa 2025 Christmas Tree Packing - Strategy Guide (Loop 1)

## Current Status
- Best CV score: 164.089486 from exp_000 (001_baseline_greedy_rotation)
- Best LB score: FAILED - "Overlapping trees in group 118"
- CV-LB gap: N/A (submission invalid due to precision issues)

## Response to Evaluator
- Technical verdict was TRUSTWORTHY for the baseline implementation
- However, submission FAILED due to tiny numerical overlaps (area ~5.71e-15) that our local validation missed
- Evaluator's top priority was implementing local search - AGREE but FIRST we must fix the overlap issue
- Key concerns raised: No iterative optimization, Python too slow, greedy approach fundamentally limited
- Addressing: Will use grid-based placement (proven 88.33 score) instead of greedy, with stricter validation

## Critical Issue: Overlap Detection
Our submission failed because:
1. Trees 101 and 117 have tiny overlaps (5.71e-15 to 2.40e-13 area) in groups 118-162
2. Our local validation using `poly.intersects() and not poly.touches()` was too lenient
3. Kaggle's validator is stricter

**Fix Required:**
- Use stricter overlap check: `intersection.area > 1e-15` should flag as overlap
- OR use small negative buffer before checking: `poly.buffer(-1e-9).intersects()`
- OR use the sample submission as baseline (known valid)

## Data Understanding
- Reference notebooks: `exploration/evolver_loop1_analysis.ipynb` for overlap analysis
- Tree shape: 15-vertex polygon, height 1.0 (tip at 0.8, trunk bottom at -0.2), width 0.7 at base
- Score formula: sum(side^2/n) for n=1 to 200. Lower is better.
- Target: 68.947559

## Key Insights from Research

### 1. Grid-Based Placement (88.33 score)
From `research/kernels/zaburo_88-32999-a-well-aligned-initial-solution`:
- Place trees in alternating rows (0° and 180° rotation)
- Row spacing: 1.0 vertical, 0.7 horizontal
- Odd rows offset by 0.35 (half tree width)
- This creates an interlocking lattice pattern
- MUCH better than greedy (88.33 vs 164.09)

### 2. Ensemble Approach
From `research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation`:
- Collect best solution for each N from multiple sources
- For each N, keep the configuration with lowest side^2/n
- This leverages diversity of approaches

### 3. C++ Optimization (Required for Target)
From `research/kernels/smartmanoj_santa-claude`:
- Python is ~100x slower than C++
- Top solutions use C++ with OpenMP parallelization
- Key operations: squeeze, compaction, local search, simulated annealing
- Fractional translation (0.001, 0.0005, 0.0002, 0.0001 steps) for fine-tuning

## Recommended Approaches (Priority Order)

### Priority 1: Fix Overlap Issue & Establish Valid Baseline
1. Implement grid-based placement from zaburo kernel (88.33 score)
2. Add strict overlap validation before saving submission
3. Verify submission is valid locally before submitting

### Priority 2: Local Search Optimization
After establishing valid baseline:
1. Implement compaction (move trees toward center)
2. Implement squeeze (scale all positions toward center)
3. Add rotation optimization for individual trees
4. Use fractional translation for fine-tuning

### Priority 3: C++ Implementation
For significant score improvement:
1. Port critical loops to C++ or use numba JIT
2. Implement simulated annealing with proper cooling schedule
3. Add multi-start with different initial configurations

## What NOT to Try
- Greedy placement alone (fundamentally limited to ~164 score)
- Python-only optimization without JIT/C++ (too slow for competitive scores)
- Submitting without strict overlap validation

## Validation Requirements
Before any submission:
1. Check ALL groups for overlaps using strict criteria
2. Use `intersection.area > 1e-15` as overlap threshold
3. Verify total score matches expected value
4. Double-check groups 100-200 especially (where overlaps occurred)

## Score Targets
- Sample submission: 173.65
- Our failed baseline: 164.09
- Grid-based (zaburo): 88.33
- Target to beat: 68.95
- Gap from grid to target: ~19 points (achievable with optimization)

## Implementation Path
1. **Experiment 002**: Grid-based placement with strict validation → Target ~88 score
2. **Experiment 003**: Add local search/compaction → Target ~80 score  
3. **Experiment 004**: Add simulated annealing → Target ~75 score
4. **Experiment 005**: C++ optimization or ensemble → Target <69 score
