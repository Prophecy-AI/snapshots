# 2D Polygon Packing Optimization - Christmas Tree Challenge

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack N Christmas tree shapes (N=1 to 200) into the smallest possible square bounding box. The score is the sum of (s_n^2 / n) for all configurations, where s_n is the side length of the square box for N trees.

**Target Score: 68.95** (current best working: ~88.33 from grid placement)

## Critical Validation Requirement
**ZERO TOLERANCE FOR OVERLAPS** - This is the most critical requirement:
- Previous experiments FAILED because overlap threshold (1e-15) was too lenient
- Kaggle's validation detected overlaps as small as 3.47e-13
- Use proper polygon intersection checking: `poly_i.intersects(poly_j) and not poly_i.touches(poly_j)`
- If ANY optimization creates overlap, REVERT to previous valid state
- A working 88.33 is better than a failing 87.36

## Tree Geometry
- 15-vertex polygon shape
- Base width: 0.7, Total height: 1.0
- Trunk: width 0.15, height 0.2
- Three tiers with varying widths (0.7, 0.4, 0.25)
- Reference point: center of top of trunk (x, y coordinates)
- Rotation: degrees (0-360)

## Data Understanding
**Reference notebooks for data characteristics:**
- `exploration/eda.ipynb` - Contains EDA: submission format, N range (1-200), total 20,100 trees
- Score weight by N: N=1 has weight 1.0, N=200 has weight 0.005 - optimize small N first!

## Recommended Approaches (Priority Order)

### 1. Simulated Annealing (Primary Optimization)
SA is the most effective approach for 2D polygon packing. Research-backed parameters:

**Temperature Schedule:**
- Initial temperature: Calibrate to ~80% acceptance rate of random moves
- Geometric cooling: α ≈ 0.85-0.95 (T_{k+1} = α * T_k)
- Inner loop: 10 × N moves per temperature level
- Stop when T < threshold or no improvement for several temperatures

**Adaptive Neighborhood (Crystallization Factor):**
- After ACCEPTED move: Increase step size (positive feedback) - explore more
- After REJECTED move: Decrease step size (negative feedback) - refine locally
- This dramatically improves convergence vs fixed step sizes

**8 Move Types** (from top kernels):
1. Random translation: x,y += random * move_scale * (T/T0)
2. Centroid move: Move tree toward centroid of all trees
3. Random rotation: angle += random * rotation_scale * (T/T0)
4. Combined translation + rotation
5. Swap positions of two trees
6. Bbox center move: Move tree toward bounding box center
7. Corner tree focus: Prioritize moving trees that define bbox corners
8. Coordinated move: Shift two adjacent trees together

**Reheat Strategy:**
- If stagnant for 600 iterations, reheat to T * 3.0 (max T0 * 0.7)
- This helps escape local minima

### 2. No-Fit Polygon (NFP) / Collision-Free Region (CFR)
Advanced technique from research literature:
- NFP defines forbidden translations for placing one polygon relative to another
- CFR = container minus all NFPs = valid placement region
- Place polygons on CFR vertices for guaranteed feasible placements
- Dramatically increases acceptance ratio in SA

### 3. Local Search Refinement
After SA, apply local search with decreasing step sizes:
- Position steps: [0.02, 0.01, 0.005, 0.002, 0.001, 0.0005, 0.0002]
- Rotation steps: [15.0, 10.0, 5.0, 2.0, 1.0, 0.5, 0.25]
- 8 directions: [1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]

### 4. Initial Placement Strategies
Good initial placement is crucial for optimization:

**Grid Placement** (baseline ~88.33):
- Alternating rows with trees at 0° and 180°
- Horizontal spacing: 0.7 (tree base width)
- Vertical spacing: 1.0 (tree height)
- Try different n_even/n_odd combinations per row

**Symmetric Arrangements** (for small N):
- Small N (1-20) benefit from symmetric/optimal arrangements
- N=1: Single tree at 45° rotation is optimal
- Search for symmetric patterns that minimize bbox

### 5. Ensemble Strategy
Top solutions collect best configurations from multiple sources:
- Run multiple optimization passes with different seeds
- Collect best solutions from public kernels/datasets
- For each N, keep the configuration with smallest bbox
- Combine best-per-N into final submission

### 6. C++ Implementation (High Performance)
For maximum iterations, implement in C++:
- Use OpenMP for parallelization
- Implement efficient polygon overlap checking with bounding box pre-filter
- Point-in-polygon test + segment intersection for overlap detection
- Can achieve 10-100x speedup over Python

## Overlap Detection (Critical)
Efficient and correct overlap detection:
```
1. Bounding box pre-filter: if boxes don't overlap, polygons don't overlap
2. Point-in-polygon test: check if any vertex of A is inside B (and vice versa)
3. Segment intersection: check if any edges of A and B intersect
4. If any of (2) or (3) is true AND polygons don't just touch -> OVERLAP
```

## Bounding Box Optimization Techniques
From research literature:
- **Rotating Calipers**: Smallest enclosing rectangle has a side collinear with convex hull edge
- **Residual-space-maximized packing**: Place items to maximize remaining space
- **Corner tree focus**: Trees at bbox corners have most impact on score
- **Branch-and-bound**: Use wasted-space lower bounds for pruning

## Score Optimization Strategy
Score = sum(s_n^2 / n), so:
- Small N has MUCH higher weight (N=1: 1.0, N=10: 0.1, N=100: 0.01, N=200: 0.005)
- Prioritize optimization for small N (1-50)
- For large N (150-200), grid placement may be near-optimal
- Allocate more SA iterations to small N

## What NOT to Do
- ❌ Using lenient overlap thresholds (1e-15 or similar) - PROVEN TO FAIL
- ❌ Rotation tightening without strict validation - creates precision issues
- ❌ Submitting without local validation against Kaggle's metric
- ❌ Optimizing only large N (they have less score impact)
- ❌ Fixed step sizes in SA - use adaptive neighborhood instead

## Validation Checklist
Before submission:
1. Run local overlap check with ZERO tolerance
2. Verify all coordinates are within [-100, 100]
3. Check score calculation matches expected format
4. Test on a few N values manually

## Expected Score Progression
- Grid placement baseline: ~88.33
- With SA optimization: ~80-85
- With aggressive SA + local search: ~75-80
- With C++ optimizer + ensemble: ~70-75
- Target: 68.95

## Key Insight
The gap from 88.33 to 68.95 (~19 points) requires:
1. First: Ensure valid submissions (no overlaps)
2. Then: Apply SA with proper move types and adaptive neighborhood
3. Finally: Ensemble best configurations from multiple runs

Focus on correctness first, then optimization. A valid submission is always better than an invalid one.

## Reference Kernels
- `jonathanchan_santa25-ensemble-sa-fractional-translation` - C++ SA with 8 move types, ensemble strategy
- `zaburo_88-32999-a-well-aligned-initial-solution` - Grid placement baseline
- `inversion_santa-2025-getting-started` - Basic greedy algorithm and visualization

## Implementation Priority
1. **Fix overlap validation** - Use ZERO tolerance, proper polygon intersection
2. **Implement SA with adaptive neighborhood** - 8 move types, crystallization factor
3. **Prioritize small N** - More iterations for N=1-50
4. **Ensemble from multiple sources** - Collect best per N
5. **C++ for speed** - If Python too slow for sufficient iterations
