# 2D Polygon Packing Optimization - Christmas Tree Challenge

## Current Status
- Best CV score: 88.33 from exp_000 (Grid Placement Baseline)
- Best LB score: Not yet submitted (0 submissions used)
- CV-LB gap: Unknown - need first submission to calibrate

## Response to Evaluator
- Technical verdict was **TRUSTWORTHY**. The grid baseline is solid with proper ZERO tolerance overlap validation.
- Evaluator's top priority: **Implement SA with strict overlap validation, prioritizing small N**. I agree - this is the correct next step.
- Key concerns raised:
  1. N=1 uses 0° rotation but 45° is optimal → **Will fix in next experiment** (quick win: ~0.02 points)
  2. No special handling for small N → **Will prioritize N=1-50 in SA**
  3. Ensemble from public sources is high-leverage → **Will implement after SA baseline**

## Data Understanding
- Reference notebooks: `exploration/eda.ipynb` for submission format, `exploration/evolver_loop1_analysis.ipynb` for overlap debugging
- Tree geometry: 15-vertex polygon, 0.7 base width, 1.0 total height
- Score formula: sum(s_n² / n) - small N has MUCH higher weight
- Score breakdown from baseline:
  - N=1-10: 6.81 points (7.7% of total, 28x leverage per tree)
  - N=11-50: 19.36 points (21.9%)
  - N=51-100: 21.46 points (24.3%)
  - N=101-150: 20.59 points (23.3%)
  - N=151-200: 20.12 points (22.8%)

## Recommended Approaches (Priority Order)

### 1. Quick Wins First (Immediate)
- **Fix N=1 rotation**: Use 45° instead of 0° → saves ~0.02 points
- **Optimize N=2-10 rotations**: Search rotation angles for each small N configuration
- These are free improvements with no risk

### 2. Simulated Annealing (Primary Optimization)
Implement SA with the following specifications:

**Temperature Schedule:**
- Initial temperature: Calibrate to ~80% acceptance rate
- Geometric cooling: α ≈ 0.85-0.95
- Inner loop: 10 × N moves per temperature
- Stop when T < 1e-6 or no improvement for 50 temperatures

**8 Move Types** (from jonathanchan kernel):
1. Random translation: x,y += random * move_scale * (T/T0)
2. Centroid move: Move tree toward centroid of all trees
3. Random rotation: angle += random * rotation_scale * (T/T0)
4. Combined translation + rotation
5. Swap positions of two trees
6. Bbox center move: Move tree toward bounding box center
7. Corner tree focus: Prioritize moving trees that define bbox corners
8. Coordinated move: Shift two adjacent trees together

**Adaptive Neighborhood (Crystallization Factor):**
- After ACCEPTED move: increase step size (explore more)
- After REJECTED move: decrease step size (refine locally)

**Prioritization by N:**
- N=1-20: 3x iterations (highest leverage)
- N=21-50: 2x iterations
- N=51-100: 1.5x iterations
- N=101-200: 1x iterations

**CRITICAL**: Use ZERO TOLERANCE overlap checking for all moves:
```python
if poly_i.intersects(poly_j) and not poly_i.touches(poly_j):
    # OVERLAP - reject move
```

### 3. Local Search Refinement (After SA)
After SA converges, apply local search with decreasing step sizes:
- Position steps: [0.02, 0.01, 0.005, 0.002, 0.001, 0.0005]
- Rotation steps: [15.0, 10.0, 5.0, 2.0, 1.0, 0.5]
- 8 directions: [1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]

### 4. Ensemble Strategy (High Leverage)
After SA optimization, collect best solutions from multiple sources:
- Run SA with different random seeds (5-10 runs)
- For each N, keep the configuration with smallest bbox
- This is proven to work - top solutions use 15+ sources

## What NOT to Try
- ❌ Lenient overlap thresholds (1e-15 or similar) - PROVEN TO FAIL
- ❌ Rotation tightening without strict validation - creates precision issues
- ❌ Optimizing only large N - they have less score impact
- ❌ Fixed step sizes in SA - use adaptive neighborhood instead

## Validation Checklist
Before any submission:
1. Run local overlap check with ZERO tolerance on ALL 200 configurations
2. Verify submission format: 's' prefix, correct id format, 20,100 rows
3. Calculate score locally and verify it matches expected

## Expected Score Progression
- Grid placement baseline: 88.33 ✓ (achieved)
- With N=1-10 rotation optimization: ~88.0
- With SA optimization: ~80-85
- With aggressive SA + local search: ~75-80
- With ensemble from multiple runs: ~72-75
- Target: 68.95

## Implementation Notes
- Start from grid placement baseline (exp_000)
- Use Decimal precision with scale_factor = 1e15 for polygon operations
- Use Shapely for polygon intersection checking
- Consider C++ implementation if Python is too slow for sufficient iterations

## Reference Code
- Grid placement: `/home/code/experiments/001_grid_baseline/baseline.ipynb`
- Kernel references: `/home/code/research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation/`
- Zaburo baseline: `/home/code/research/kernels/zaburo_88-32999-a-well-aligned-initial-solution/`
