# Santa 2025 - Evolved Strategy (Loop 7)

## Current Status
- Best CV score: 70.572798 (exp_000 baseline - but REJECTED by Kaggle due to overlaps)
- Best VALID LB score: 87.811181 (exp_006 SA from scratch)
- Target: 68.887226 | Gap to target: 18.92 points (from valid submission)

## ⚠️ CRITICAL INSIGHT FROM ANALYSIS

**The pre-optimized baseline has MUCH better per-N scores than Zaburo!**
- Baseline valid N total: 69.57 (197 N values without overlaps in our validation)
- Zaburo total: 87.99
- Gap: 18.4 points!

**BUT Kaggle rejected baseline with "Overlapping trees in group 002"**
- Our local validation shows only 3 overlapping N values (30, 134, 166)
- Kaggle's validation is STRICTER than our Shapely-based check
- We need to match Kaggle's validation exactly

## Response to Evaluator

The evaluator correctly identified:
1. ✅ SA move sizes are too coarse (0.1 vs 0.00001 in top kernels)
2. ✅ Only N=2-10 were optimized (need ALL N values)
3. ✅ Fractional translation refinement is missing
4. ✅ Need hybrid starting point (baseline + Zaburo for overlapping N)

**Key disagreement**: The evaluator suggests the gap is 19 points from 87.81. But the REAL opportunity is:
- Pre-optimized baseline scores 70.6 (just has overlap issues)
- If we can fix the overlaps, we're only 1.7 points from target!

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN

## ✅ EXPERIMENT 007: HYBRID SOLUTION WITH KAGGLE-COMPATIBLE VALIDATION

### STEP 1: Fix Validation to Match Kaggle

The key problem is our validation doesn't match Kaggle's. We need to:

```python
# Use EXACT same validation as getting-started kernel
from decimal import Decimal, getcontext
getcontext().prec = 28  # Match getting-started kernel

# Scale factor must be 1e15 (integer coordinates)
SCALE = Decimal('1e15')

def check_overlap_kaggle_style(trees):
    """Check overlaps using integer coordinates like Kaggle does."""
    polygons = []
    for tree in trees:
        # Create polygon with integer coordinates
        coords = []
        for x, y in tree.get_vertices():
            # Scale to integers
            xi = int(Decimal(str(x)) * SCALE)
            yi = int(Decimal(str(y)) * SCALE)
            coords.append((xi, yi))
        polygons.append(Polygon(coords))
    
    # Check all pairs
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                return True, (i, j)
    return False, None
```

### STEP 2: Create Hybrid Solution

1. Load pre-optimized baseline from `/home/nonroot/snapshots/santa-2025/21329067673/submission/submission.csv`
2. Check EACH N value with Kaggle-style validation
3. For N values that pass: keep baseline
4. For N values that fail: use Zaburo's solution (guaranteed valid)
5. Validate the hybrid solution

### STEP 3: Apply Fractional Translation Refinement

After creating hybrid, apply fractional translation to ALL N values:

```python
# From Jonathan Chan's kernel
frac_steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]
directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (1,-1), (-1,1), (-1,-1)]

def fractional_translation(trees, n, max_iter=200):
    best_trees = [t.clone() for t in trees]
    best_score = calculate_score(best_trees, n)
    
    for iteration in range(max_iter):
        improved = False
        for i in range(len(best_trees)):
            for step in frac_steps:
                for dx, dy in directions:
                    # Save old position
                    old_x = best_trees[i].center_x
                    old_y = best_trees[i].center_y
                    
                    # Try move
                    best_trees[i].center_x += Decimal(str(dx * step))
                    best_trees[i].center_y += Decimal(str(dy * step))
                    best_trees[i].update_polygon()
                    
                    # Check if valid and better
                    if not check_overlap(best_trees):
                        new_score = calculate_score(best_trees, n)
                        if new_score < best_score - 1e-12:
                            best_score = new_score
                            improved = True
                            continue  # Keep the move
                    
                    # Revert
                    best_trees[i].center_x = old_x
                    best_trees[i].center_y = old_y
                    best_trees[i].update_polygon()
        
        if not improved:
            break
    
    return best_trees, best_score
```

### STEP 4: Track Per-N Improvements

```python
# Compare to baseline per-N
improvements = {}
for n in range(1, 201):
    my_score = calculate_score(my_trees[n], n)
    base_score = baseline_per_n[n]
    if my_score < base_score:
        improvements[n] = base_score - my_score
        print(f"✅ N={n}: IMPROVED by {improvements[n]:.6f}")
```

## Expected Outcome

If we can match Kaggle's validation:
- Hybrid solution: ~70.5-71.0 (baseline + Zaburo fallback)
- With fractional translation: ~70.0-70.5
- Gap to target: ~1.5 points

This is MUCH closer than the current 18.9 point gap!

## SUBMISSION STRATEGY
- Remaining submissions: 90
- Submit after this experiment: YES (we have abundant submissions)
- Even if score is worse than baseline, we need LB feedback on the hybrid approach

## What NOT to Try
- Running bbox3/sa_fast binaries (proven to give ~70.6, same as baseline)
- Pure Zaburo optimization (87.99 is too far from target)
- SA with coarse moves (0.1 translation doesn't help)

## Validation Notes
- Use Kaggle-style validation with integer coordinates (SCALE=1e15)
- Validate ALL 200 N values before submission
- If any N has overlaps, use Zaburo fallback for that N
