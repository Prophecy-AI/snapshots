# Santa 2025 - Evolved Strategy (Loop 5)

## Current Status
- Best CV score: 70.615745 from exp_001 (valid_baseline) - BUT REJECTED BY KAGGLE
- Best LB score: 169.458990 from exp_003 (greedy_from_scratch) - ACCEPTED
- Target: 68.887226 | Gap to target: 100.57 points (from best accepted LB)
- **CRITICAL**: All pre-optimized baselines have overlaps that Kaggle rejects!

## ⛔⛔⛔ CRITICAL DISCOVERY ⛔⛔⛔

**Our overlap validation was WRONG!**

Analysis in `exploration/evolver_loop5_analysis.ipynb` revealed:
- exp_004's N=2 has REAL overlaps (intersection area = 7e17)
- Our validation showed "0 overlaps" but Kaggle correctly detected them
- The pre-optimized baseline trees are positioned too close together
- **We CANNOT use pre-optimized baselines directly - they ALL have overlaps!**

## Response to Evaluator

The evaluator correctly identified that the greedy fallback was expensive. However, the deeper issue is that our overlap validation was fundamentally broken. The pre-optimized baseline has overlaps that we weren't detecting.

**Key insight from analysis:**
- N=2 in exp_004 shows intersection area of 7e17 (HUGE overlap!)
- Our validation code was checking `intersects() and not touches()` but the polygons DO intersect
- The issue is that we were loading the pre-optimized baseline which has subtle overlaps

**The evaluator's suggestion to use Zaburo's row-based approach is CORRECT** - it's the only guaranteed-valid approach we have.

## ✅ MANDATORY NEXT EXPERIMENT: Zaburo's Row-Based Approach

**exp_005: Implement Zaburo's row-based placement from scratch**

This is the ONLY safe path forward because:
1. Trees are placed on a grid with known spacing (0.7 horizontal, 1.0 vertical)
2. Alternating rows have 0° and 180° angles
3. **GUARANTEED no overlaps by construction**
4. Expected score: ~88.33 (worse than baseline but VALID)

```python
def find_best_trees_zaburo(n):
    """Zaburo's row-based placement - guaranteed no overlaps"""
    best_score, best_trees = float("inf"), None
    for n_even in range(1, n + 1):
        for n_odd in [n_even, n_even - 1]:
            all_trees = []
            rest = n
            r = 0
            while rest > 0:
                m = min(rest, n_even if r % 2 == 0 else n_odd)
                rest -= m
    
                angle = 0 if r % 2 == 0 else 180
                x_offset = Decimal('0') if r % 2 == 0 else Decimal('0.7') / 2
                y = r // 2 * Decimal('1.0') if r % 2 == 0 else (Decimal('0.8') + (r - 1) // 2 * Decimal('1.0'))
                row_trees = [ChristmasTree(
                    center_x=str(Decimal('0.7') * i + x_offset), 
                    center_y=str(y), 
                    angle=str(angle)
                ) for i in range(m)]
                all_trees.extend(row_trees)
                r += 1
            
            # Calculate bounding box and score
            # ... (see research/kernels/zaburo_88-32999-a-well-aligned-initial-solution)
```

**SUBMIT exp_005 to verify Kaggle accepts it!** Expected LB: ~88.33

## ✅ AFTER exp_005: Implement Simulated Annealing FROM SCRATCH

Once we have a valid baseline (Zaburo's ~88.33), implement SA to optimize:

```python
def simulated_annealing(trees, T_start=1.0, T_end=0.001, cooling=0.9999):
    """
    SA moves:
    1. Small translation: move tree by small delta (dx, dy)
    2. Small rotation: rotate tree by small angle
    3. Swap: exchange positions of two trees
    
    Accept move if:
    - New score is better, OR
    - exp((old_score - new_score) / T) > random()
    """
    current_trees = copy.deepcopy(trees)
    current_score = calculate_score(current_trees)
    best_trees = copy.deepcopy(current_trees)
    best_score = current_score
    
    T = T_start
    while T > T_end:
        # Generate neighbor
        new_trees = generate_neighbor(current_trees)
        
        # Check for overlaps FIRST
        if has_overlap(new_trees):
            continue  # Reject invalid moves
        
        new_score = calculate_score(new_trees)
        
        # Accept or reject
        delta = new_score - current_score
        if delta < 0 or random.random() < math.exp(-delta / T):
            current_trees = new_trees
            current_score = new_score
            
            if current_score < best_score:
                best_trees = copy.deepcopy(current_trees)
                best_score = current_score
        
        T *= cooling
    
    return best_trees, best_score
```

## ⛔ FORBIDDEN (WILL BE REJECTED)

- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN (pre-compiled binaries)
- subprocess.run() or os.system() - FORBIDDEN
- Loading pre-optimized baselines directly - FORBIDDEN (they have overlaps!)
- Assuming our overlap validation is correct - FORBIDDEN (it's broken!)

## Recommended Approaches (Priority Order)

1. **[HIGHEST PRIORITY]** exp_005: Implement Zaburo's row-based approach
   - Pure Python, guaranteed valid
   - Expected score: ~88.33
   - SUBMIT to verify Kaggle accepts

2. **[HIGH PRIORITY]** exp_006: Implement simulated annealing from scratch
   - Start from Zaburo's valid solution
   - Apply SA moves: translation, rotation, swap
   - Check overlaps BEFORE accepting any move
   - Target: Improve from 88.33 toward 70.0

3. **[MEDIUM PRIORITY]** Optimize small N (N=1-10) exhaustively
   - N=1 is already optimal at 45°
   - N=2-10 can be optimized with exhaustive search
   - These contribute ~3 points to total score

## Per-N Score Targets

From analysis, Zaburo's approach gives:
- N=2: 0.72 (vs baseline 0.45) - need SA to improve
- N=10: 0.48 (vs baseline 0.38) - need SA to improve
- N=30: 0.49 (vs baseline 0.89 greedy) - BETTER than greedy!
- N=100: 0.40 (vs baseline 0.34) - need SA to improve
- N=200: 0.41 (vs baseline 0.34) - need SA to improve

## Validation Notes

**CRITICAL: Use this validation code:**
```python
def check_overlap(trees):
    """Check for overlaps - must match Kaggle's validation"""
    for i in range(len(trees)):
        for j in range(i+1, len(trees)):
            p1, p2 = trees[i].polygon, trees[j].polygon
            if p1.intersects(p2) and not p1.touches(p2):
                return True  # HAS OVERLAP
    return False  # No overlap

# ALWAYS validate before submission
for n in range(1, 201):
    if check_overlap(trees_by_n[n]):
        raise ValueError(f"N={n} has overlaps!")
```

## Submission Strategy

- Remaining submissions: 92
- **SUBMIT exp_005 immediately** to verify Zaburo's approach is accepted
- Then iterate with SA improvements
- Each valid improvement should be submitted for LB feedback

## What NOT to Try

- Loading pre-optimized baselines (they have overlaps)
- Trying to "fix" overlaps in existing solutions (our validation is broken)
- Running any pre-compiled binary
- Assuming our local validation matches Kaggle's

## Path to Target (68.89)

1. exp_005: Zaburo baseline → ~88.33 (VALID)
2. exp_006: SA optimization → ~80.0 (estimated)
3. exp_007+: More SA iterations → ~75.0
4. exp_008+: Small N optimization → ~72.0
5. exp_009+: Advanced techniques → ~70.0
6. exp_010+: Fine-tuning → 68.89

The gap from 88.33 to 68.89 is 19.44 points (22%). This is achievable with proper SA optimization because:
- Zaburo's approach uses simple grid placement
- SA can find much tighter packings
- The pre-optimized baselines (70.6) prove tighter packings exist