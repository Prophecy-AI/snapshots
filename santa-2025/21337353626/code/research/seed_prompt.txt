# Santa 2025 - Evolved Strategy (Loop 4)

## Current Status
- Best CV score: 70.615745 from exp_001 (REJECTED by Kaggle - overlaps)
- Best LB score: 169.459 from exp_003 (greedy - ACCEPTED but terrible)
- Target: 68.887226 | Gap from best valid: 100.57 points (146%!)

## CRITICAL SITUATION ANALYSIS

**The Problem:**
- Pre-optimized snapshots score ~70.6 (only 2.4% from target) but are REJECTED due to subtle overlaps
- Our greedy solution scores 169.5 (valid but 146% from target)
- We're stuck between "good but invalid" and "valid but terrible"

**The Solution Path:**
1. **FIRST PRIORITY**: Try to fix overlaps in pre-optimized solutions
2. **BACKUP**: Implement row-based + SA from scratch

## Response to Evaluator

The evaluator correctly identified that:
1. The greedy algorithm (169.5) is far too simplistic
2. Pre-optimized solutions (70.6) are MUCH better but have subtle overlaps
3. We should investigate and fix the overlap issue FIRST

**I AGREE with this assessment.** The fastest path to a competitive score is fixing the overlap issue in pre-optimized solutions. If that fails, we implement proper optimization from scratch.

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with binaries - FORBIDDEN

## ✅ EXPERIMENT 004: FIX OVERLAP ISSUE IN PRE-OPTIMIZED SOLUTIONS

**This is the HIGHEST PRIORITY experiment.**

### Step 1: Load the rejected snapshot
```python
import pandas as pd
from decimal import Decimal, getcontext
from shapely import affinity
from shapely.geometry import Polygon

getcontext().prec = 25
scale_factor = Decimal('1e18')  # Use higher precision!

# Load the snapshot that was rejected
snapshot_path = '/home/nonroot/snapshots/santa-2025/21329067673/submission/submission.csv'
df = pd.read_csv(snapshot_path)
```

### Step 2: Find overlapping tree pairs with STRICT validation
```python
def check_overlap_strict(trees):
    """Check for overlaps using integer coordinates (like Kaggle)."""
    SCALE = 10**18
    polygons = []
    for tree in trees:
        coords = [(int(Decimal(str(x)) * SCALE), 
                   int(Decimal(str(y)) * SCALE)) 
                  for x, y in tree.polygon.exterior.coords]
        polygons.append(Polygon(coords))
    
    overlaps = []
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                overlaps.append((i, j))
    return overlaps
```

### Step 3: Separate overlapping trees
```python
def separate_trees(trees, overlap_pairs, separation=1e-6):
    """Move overlapping trees apart by a small amount."""
    for i, j in overlap_pairs:
        # Calculate direction from tree i to tree j
        dx = float(trees[j].center_x - trees[i].center_x)
        dy = float(trees[j].center_y - trees[i].center_y)
        dist = (dx**2 + dy**2)**0.5
        if dist > 0:
            # Move tree j away from tree i
            trees[j].center_x += Decimal(str(separation * dx / dist))
            trees[j].center_y += Decimal(str(separation * dy / dist))
            # Recreate polygon
            trees[j].polygon = create_polygon(trees[j])
    return trees
```

### Step 4: Re-validate and save
```python
# For each N value:
for n in range(1, 201):
    trees = load_trees_for_n(df, n)
    overlaps = check_overlap_strict(trees)
    if overlaps:
        trees = separate_trees(trees, overlaps)
        # Verify no more overlaps
        new_overlaps = check_overlap_strict(trees)
        if new_overlaps:
            print(f"N={n}: Still has overlaps after separation!")
        else:
            print(f"N={n}: Fixed {len(overlaps)} overlaps")
```

### Expected Outcome:
- If successful: Score ~70.6 (immediately competitive!)
- If unsuccessful: Move to backup plan (row-based + SA)

## ✅ BACKUP: EXPERIMENT 005 - ROW-BASED + SIMULATED ANNEALING

**Only do this if exp_004 fails.**

### Step 1: Implement Zaburo's row-based initial solution
```python
def find_best_trees(n: int) -> tuple[float, list[ChristmasTree]]:
    """Row-based grid placement with alternating angles."""
    best_score, best_trees = float("inf"), None
    for n_even in range(1, n + 1):
        for n_odd in [n_even, n_even - 1]:
            all_trees = []
            rest = n
            r = 0
            while rest > 0:
                m = min(rest, n_even if r % 2 == 0 else n_odd)
                rest -= m
                angle = 0 if r % 2 == 0 else 180
                x_offset = 0 if r % 2 == 0 else Decimal("0.7") / 2
                y = r // 2 * Decimal("1.0") if r % 2 == 0 else (Decimal("0.8") + (r - 1) // 2 * Decimal("1.0"))
                row_trees = [ChristmasTree(center_x=Decimal("0.7") * i + x_offset, center_y=y, angle=angle) for i in range(m)]
                all_trees.extend(row_trees)
                r += 1
            # Calculate score
            score = calculate_bounding_box(all_trees)
            if score < best_score:
                best_score = score
                best_trees = all_trees
    return best_score, best_trees
```

### Step 2: Implement Simulated Annealing
```python
def simulated_annealing(trees, T_start=1.0, T_end=0.001, iterations=10000):
    """SA with moves: translate, rotate."""
    import random
    import math
    
    current_score = calculate_score(trees)
    best_score = current_score
    best_trees = [t.clone() for t in trees]
    
    T = T_start
    cooling_rate = (T_end / T_start) ** (1.0 / iterations)
    
    for i in range(iterations):
        # Choose random move
        move_type = random.choice(['translate', 'rotate'])
        tree_idx = random.randint(0, len(trees) - 1)
        
        # Save old state
        old_x, old_y, old_angle = trees[tree_idx].center_x, trees[tree_idx].center_y, trees[tree_idx].angle
        
        if move_type == 'translate':
            dx = random.gauss(0, 0.01)
            dy = random.gauss(0, 0.01)
            trees[tree_idx].center_x += Decimal(str(dx))
            trees[tree_idx].center_y += Decimal(str(dy))
        else:
            da = random.gauss(0, 5)  # degrees
            trees[tree_idx].angle += Decimal(str(da))
        
        # Recreate polygon
        trees[tree_idx].polygon = create_polygon(trees[tree_idx])
        
        # Check for overlaps
        if has_overlap(trees):
            # Revert
            trees[tree_idx].center_x, trees[tree_idx].center_y, trees[tree_idx].angle = old_x, old_y, old_angle
            trees[tree_idx].polygon = create_polygon(trees[tree_idx])
            continue
        
        # Calculate new score
        new_score = calculate_score(trees)
        delta = new_score - current_score
        
        # Accept or reject
        if delta < 0 or random.random() < math.exp(-delta / T):
            current_score = new_score
            if new_score < best_score:
                best_score = new_score
                best_trees = [t.clone() for t in trees]
        else:
            # Revert
            trees[tree_idx].center_x, trees[tree_idx].center_y, trees[tree_idx].angle = old_x, old_y, old_angle
            trees[tree_idx].polygon = create_polygon(trees[tree_idx])
        
        T *= cooling_rate
    
    return best_score, best_trees
```

### Expected Outcome:
- Row-based alone: ~88 score
- With SA optimization: ~75-80 score
- With more iterations: ~70-75 score

## ✅ MANDATORY: PER-N TRACKING

Track best solution for EACH N separately:
```python
best_per_n = {}  # {n: {'score': float, 'trees': list}}

def update_best_per_n(n, score, trees):
    if n not in best_per_n or score < best_per_n[n]['score']:
        best_per_n[n] = {'score': score, 'trees': [t.clone() for t in trees]}
        print(f"✅ N={n}: NEW BEST {score:.6f}")

# After each experiment, save best_per_n to JSON
with open('best_per_n.json', 'w') as f:
    json.dump({str(n): v['score'] for n, v in best_per_n.items()}, f)
```

## ✅ VALIDATION REQUIREMENTS

**CRITICAL: Use integer coordinates for validation (like Kaggle):**
```python
from decimal import Decimal, getcontext
getcontext().prec = 30
SCALE = 10**18

def validate_no_overlap(trees):
    polygons = []
    for tree in trees:
        coords = [(int(Decimal(str(x)) * SCALE), 
                   int(Decimal(str(y)) * SCALE)) 
                  for x, y in tree.polygon.exterior.coords]
        polygons.append(Polygon(coords))
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                return False, f"Trees {i} and {j} overlap"
    return True, "OK"

# MANDATORY: Call before EVERY submission
for n in range(1, 201):
    trees = solution[n]
    ok, msg = validate_no_overlap(trees)
    if not ok:
        raise ValueError(f"N={n}: {msg}")
```

## SUBMISSION STRATEGY

- Remaining submissions: 92 (ABUNDANT!)
- **SUBMIT AFTER EVERY EXPERIMENT** - LB feedback is free information
- Even if score is worse, we learn what works/doesn't work

## PRIORITY ORDER

1. **exp_004**: Fix overlap issue in pre-optimized solutions
   - If successful → Submit immediately (expect ~70.6)
   - If unsuccessful → Move to exp_005

2. **exp_005**: Row-based + SA from scratch
   - Start with Zaburo's row-based (expect ~88)
   - Apply SA optimization (expect ~75-80)
   - Submit to get LB feedback

3. **exp_006+**: Continue optimization
   - More SA iterations
   - Backward propagation
   - Per-N specialization

## SUCCESS CRITERIA

- ✅ **SUCCESS**: Score < 75 (significant improvement from 169.5)
- ⚠️ **MARGINAL**: Score 75-85 (some improvement, keep optimizing)
- ❌ **FAILURE**: Score > 85 (approach not working, try different method)

The target of 68.887226 IS reachable. We have 92 submissions remaining. Let's use them wisely!
