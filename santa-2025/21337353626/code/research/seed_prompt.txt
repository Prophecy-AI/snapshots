# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.615745 from exp_001 (valid_baseline)
- Best LB score: NONE - Both submissions rejected with "Overlapping trees" errors!
- Target: 68.887744 | Gap to target: 1.73 points (2.5%)

## ⛔⛔⛔ CRITICAL ISSUE: OVERLAP VALIDATION MISMATCH ⛔⛔⛔

**BOTH SUBMISSIONS HAVE BEEN REJECTED BY KAGGLE:**
- exp_000: "Overlapping trees in group 002"
- exp_001: "Overlapping trees in group 151"

**Our local validation shows 0 overlaps, but Kaggle disagrees!**

This is the #1 priority to fix. Until we can submit valid solutions, we cannot make progress.

## Response to Evaluator

The evaluator correctly identified that:
1. The valid baseline hasn't been successfully submitted yet (both attempts failed)
2. No optimization has been attempted yet
3. N=1 optimization is high-impact

However, the evaluator's suggestion to "submit the valid baseline" has already been tried and FAILED. The issue is that our local overlap validation doesn't match Kaggle's validation.

**I disagree with proceeding to optimization before fixing the validation issue.** We must first ensure we can submit valid solutions.

## MANDATORY FIRST TASK: FIX OVERLAP VALIDATION

Before ANY optimization work, you MUST:

### Step 1: Understand Kaggle's Validation
The getting-started kernel uses:
- `scale_factor = Decimal('1e15')` for integer-like coordinates
- `Decimal` with precision 25 for all calculations
- Collision check: `intersects() and not touches()`

### Step 2: Create a MINIMAL Valid Submission
Create a submission from scratch using the getting-started kernel's exact approach:

```python
from decimal import Decimal, getcontext
getcontext().prec = 25
scale_factor = Decimal('1e15')

# Create trees with WIDE SPACING to guarantee no overlaps
# For N=1: single tree at origin
# For N=2: two trees far apart (e.g., x=±2.0)
# etc.

# Use the exact ChristmasTree class from getting-started kernel
```

### Step 3: Validate Using Kaggle's Exact Method
```python
def check_overlap_kaggle_style(trees):
    """Use Kaggle's exact collision detection"""
    polygons = [create_polygon_with_scale_factor(t) for t in trees]
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                return True  # OVERLAP FOUND
    return False
```

### Step 4: Submit the Minimal Valid Submission
Even if the score is terrible (e.g., 200+), we need to verify our submission format is accepted.

## Alternative Approach: Use Working Kernel Code

The ensemble kernel (jonathanchan_santa25-ensemble-sa-fractional-translation) successfully submits to Kaggle. 

**Option A:** Adapt its code to create our submission
**Option B:** Use its approach to validate our solutions before submission

Key insight from ensemble kernel:
- It manually sets N=1 to optimal values: x=0, y=0, deg=45
- It uses the same ChristmasTree class with scale_factor=1e15

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast_v2, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- Submitting solutions that haven't been validated with Kaggle-compatible code

## Recommended Experiment Sequence

### exp_002: Fix Validation and Submit Minimal Solution
1. Create experiments/002_fix_validation/
2. Implement Kaggle-compatible validation using scale_factor=1e15
3. Create a MINIMAL submission with widely-spaced trees (guaranteed no overlaps)
4. Validate locally with Kaggle-compatible code
5. Submit to verify format is accepted

### exp_003: Optimize with Validated Approach
Only after exp_002 succeeds:
1. Load the best snapshot solutions
2. Validate each N value with Kaggle-compatible code
3. For any N with overlaps, either:
   - Skip it and use a simpler configuration
   - Fix the overlaps by moving trees apart slightly
4. Submit the validated solution

### exp_004+: Implement Novel Algorithms
Only after we have a working submission pipeline:
1. Implement exhaustive N=1 optimization
2. Implement small N optimization (N=2-10)
3. Implement simulated annealing for medium N

## Tree Geometry (CRITICAL)
```python
# Tree vertices (15 points)
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

# Tree dimensions:
# - Height: 1.0 (from -0.2 to 0.8)
# - Width: 0.7 (base tier)
# - At 45° rotation, bounding box is approximately 0.813 x 0.813
```

## Validation Code Template
```python
from decimal import Decimal, getcontext
from shapely.geometry import Polygon
from shapely import affinity

getcontext().prec = 25
scale_factor = Decimal('1e15')

def create_tree_polygon(center_x, center_y, angle):
    """Create tree polygon using Kaggle's exact method"""
    cx = Decimal(str(center_x))
    cy = Decimal(str(center_y))
    ang = Decimal(str(angle))
    
    # Tree vertices with scale factor
    trunk_w = Decimal('0.15')
    trunk_h = Decimal('0.2')
    base_w = Decimal('0.7')
    mid_w = Decimal('0.4')
    top_w = Decimal('0.25')
    tip_y = Decimal('0.8')
    tier_1_y = Decimal('0.5')
    tier_2_y = Decimal('0.25')
    base_y = Decimal('0.0')
    trunk_bottom_y = -trunk_h
    
    vertices = [
        (float(Decimal('0.0') * scale_factor), float(tip_y * scale_factor)),
        (float(top_w / Decimal('2') * scale_factor), float(tier_1_y * scale_factor)),
        # ... (all 15 vertices)
    ]
    
    poly = Polygon(vertices)
    poly = affinity.rotate(poly, float(ang), origin=(0, 0))
    poly = affinity.translate(poly, xoff=float(cx * scale_factor), yoff=float(cy * scale_factor))
    return poly

def validate_no_overlap(trees):
    """Validate using Kaggle's exact collision detection"""
    polygons = [create_tree_polygon(x, y, deg) for x, y, deg in trees]
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                return False, f"Trees {i} and {j} overlap"
    return True, "OK"
```

## SUBMISSION STRATEGY
- Remaining submissions: 94
- Submit after EVERY experiment that produces a valid submission
- Even a bad score (e.g., 200+) is valuable if it confirms our format is correct
- We need LB feedback to calibrate our validation

## What NOT to Try
- Submitting more snapshots without fixing validation
- Running binaries (they produce the same ~70.6 score)
- Optimizing solutions before we can submit them

## Success Criteria for exp_002
1. Create a submission that Kaggle ACCEPTS (no overlap error)
2. Get an LB score (even if terrible)
3. Establish a working validation pipeline

Once we have a working submission, we can then focus on optimization.