# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- **Best VALID submission**: exp_005 (Zaburo row-based) = 87.99 (LB confirmed)
- **Best SA improvement**: exp_006 = 87.81 (0.18 improvement, NOT YET SUBMITTED)
- **Pre-optimized baseline**: 70.6 (has overlaps, rejected by Kaggle)
- **Target**: 68.887226
- **Gap to target**: 18.9 points from exp_006

## ⚠️ CRITICAL: SUBMIT exp_006 FIRST!
Before any new experiments, **SUBMIT exp_006** to verify the SA improvements are valid on Kaggle.
We have 91 submissions remaining - use them!

## Gap Analysis (from evolver_loop7_analysis.ipynb)
The 17.4 point gap between Zaburo (87.99) and pre-optimized baseline (70.6) comes from:
- N=1-10: 2.14 points (12%) - **HIGHEST PRIORITY**
- N=11-50: 4.66 points (27%)
- N=51-100: 3.85 points (22%)
- N=101-150: 3.45 points (20%)
- N=151-200: 3.28 points (19%)

**Top gaps by N**: N=5 (0.38), N=4 (0.35), N=2 (0.27), N=6 (0.27), N=13 (0.23)

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() with binaries - FORBIDDEN
- Running ANY pre-compiled binary - FORBIDDEN

## ✅ EXPERIMENT 007: FRACTIONAL TRANSLATION REFINEMENT

The key insight from Jonathan Chan's kernel: **fractional translation** with micro-steps.

### REQUIRED IMPLEMENTATION:

```python
def fractional_translation(trees, n, max_iter=200):
    """
    Apply fractional translation refinement.
    This is the KEY technique that top kernels use.
    """
    best_trees = [t.clone() for t in trees]
    best_score = calculate_score(best_trees, n)
    
    # Step sizes from Jonathan Chan's kernel (100-10000x finer than our SA!)
    frac_steps = [0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001]
    
    # 8 directions: N, S, E, W, NE, NW, SE, SW
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    
    for iteration in range(max_iter):
        improved = False
        for i in range(len(best_trees)):
            for step in frac_steps:
                for dx, dy in directions:
                    # Save old position
                    old_x = best_trees[i].center_x
                    old_y = best_trees[i].center_y
                    
                    # Try micro-adjustment
                    best_trees[i].center_x += Decimal(str(dx * step))
                    best_trees[i].center_y += Decimal(str(dy * step))
                    best_trees[i].update_polygon()
                    
                    # Check overlap
                    if not check_overlap(best_trees):
                        new_score = calculate_score(best_trees, n)
                        if new_score < best_score - 1e-12:
                            best_score = new_score
                            improved = True
                        else:
                            # Revert
                            best_trees[i].center_x = old_x
                            best_trees[i].center_y = old_y
                            best_trees[i].update_polygon()
                    else:
                        # Revert
                        best_trees[i].center_x = old_x
                        best_trees[i].center_y = old_y
                        best_trees[i].update_polygon()
        
        if not improved:
            break
    
    return best_trees, best_score
```

### EXPERIMENT STEPS:

1. **Load exp_006 solution** (SA-improved Zaburo, 87.81)

2. **Apply fractional translation to ALL N values**:
   - Start with N=2-10 (highest gap per tree)
   - Then N=11-50
   - Then N=51-200

3. **Track per-N improvements**:
   ```python
   for n in range(1, 201):
       old_score = calculate_score(trees[n], n)
       new_trees, new_score = fractional_translation(trees[n], n)
       if new_score < old_score:
           trees[n] = new_trees
           print(f"N={n}: {old_score:.6f} -> {new_score:.6f}")
   ```

4. **Validate and save**

### EXPECTED IMPROVEMENT:
- Fractional translation should improve N=5-10 (which SA failed to improve)
- Expected gain: 1-3 points from fractional translation alone
- Combined with SA: potentially 5-10 points total improvement

## ✅ EXPERIMENT 008: BACKWARD PROPAGATION (Chistyakov's technique)

After fractional translation, apply backward propagation:

```python
def backward_propagation(trees_by_n):
    """
    Start from N=200, remove trees touching bbox, use for N-1.
    This is a 'free' improvement technique.
    """
    for n in range(200, 1, -1):
        current_trees = trees_by_n[n]
        
        # Find trees touching the bounding box
        bounds = get_bounding_box(current_trees)
        touching_indices = get_bbox_touching_tree_indices(current_trees, bounds)
        
        if touching_indices:
            # Remove one tree touching bbox
            idx_to_remove = touching_indices[0]
            new_trees = [t for i, t in enumerate(current_trees) if i != idx_to_remove]
            
            # Check if this improves N-1
            new_score = calculate_score(new_trees, n-1)
            old_score = calculate_score(trees_by_n[n-1], n-1)
            
            if new_score < old_score:
                trees_by_n[n-1] = new_trees
                print(f"N={n-1}: Improved via backward propagation")
    
    return trees_by_n
```

## Per-N Tracking (MANDATORY)

```python
# Track best solution for EACH N separately
best_per_n = {}
for n in range(1, 201):
    best_per_n[n] = {
        'score': calculate_score(trees[n], n),
        'source': 'exp_006_sa'
    }

# After each optimization, update if improved
for n in range(1, 201):
    new_score = calculate_score(new_trees[n], n)
    if new_score < best_per_n[n]['score']:
        best_per_n[n] = {
            'score': new_score,
            'source': 'exp_007_fractional'
        }
        print(f"✅ N={n}: IMPROVED by {best_per_n[n]['score'] - new_score:.6f}")
```

## Validation (CRITICAL)

Before EVERY submission, validate with integer coordinates:

```python
from decimal import Decimal, getcontext
getcontext().prec = 30
SCALE = 10**18

def validate_no_overlap(trees):
    polygons = []
    for tree in trees:
        coords = [(int(Decimal(str(x)) * SCALE), 
                   int(Decimal(str(y)) * SCALE)) 
                  for x, y in tree.vertices]
        polygons.append(Polygon(coords))
    
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                return False, f"Trees {i} and {j} overlap"
    return True, "OK"
```

## Submission Strategy

With 91 submissions remaining:
1. **SUBMIT exp_006** immediately to verify SA improvements
2. **SUBMIT exp_007** after fractional translation
3. **SUBMIT exp_008** after backward propagation

Each submission gives us LB feedback. Use it!

## Success Criteria

- exp_007 should score < 85 (2+ point improvement from fractional translation)
- exp_008 should score < 82 (3+ point improvement from backward propagation)
- Continue until we reach target (68.89)

## What NOT to Try

- Running bbox3 or any binary optimizer
- "More iterations" of the same SA (diminishing returns)
- Ensembling without per-N tracking
