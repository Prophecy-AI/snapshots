# Santa 2025 - Evolved Strategy (Loop 1)

## Current Status
- Best CV score: 70.615745 (valid baseline from snapshot 21329067673)
- Best LB score: PENDING (previous submission failed due to overlaps)
- Target: 68.887744 | Gap to target: 1.73 points (2.5%)
- Submissions remaining: 94 (ABUNDANT - submit after EVERY experiment!)

## ⚠️ CRITICAL LESSON FROM FAILED SUBMISSION

**The previous baseline (snapshot 21145966992) had 72 out of 200 N values with overlapping trees!**

Kaggle uses STRICT validation. Our local Shapely validation missed these overlaps.

**MANDATORY: Before ANY submission, validate with integer-scaled coordinates:**
```python
from decimal import Decimal, getcontext
getcontext().prec = 30
SCALE = 10**18

def validate_no_overlap_strict(trees):
    """Validate no overlaps using integer-scaled coordinates."""
    polygons = []
    for x, y, deg in trees:
        coords = list(zip(TX, TY))
        poly = Polygon(coords)
        poly = affinity.rotate(poly, deg, origin=(0, 0))
        poly = affinity.translate(poly, x, y)
        int_coords = [(int(Decimal(str(c[0])) * SCALE), 
                       int(Decimal(str(c[1])) * SCALE)) 
                      for c in poly.exterior.coords]
        polygons.append(Polygon(int_coords))
    
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                intersection = polygons[i].intersection(polygons[j])
                if intersection.area > 0:
                    return False, f"Trees {i} and {j} overlap"
    return True, "OK"
```

## Response to Evaluator

The evaluator correctly identified that:
1. N=1 is the highest-leverage optimization target (contributes ~0.66 to score)
2. Pure Python implementation is required (binaries are forbidden)
3. Exhaustive search for N=1 is computationally trivial (36,000 evaluations)

**I agree with all points.** The next experiment MUST:
1. First, submit the VALID baseline (score 70.615745) to establish LB reference
2. Then implement exhaustive N=1 optimization
3. Validate ALL solutions with strict overlap checking before submission

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast_v2, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() with binaries - FORBIDDEN
- Running ANY pre-compiled binary - FORBIDDEN
- Submitting without strict overlap validation - FORBIDDEN

## ✅ EXPERIMENT 001: VALID BASELINE + N=1 OPTIMIZATION

### Part A: Submit Valid Baseline
The valid baseline is already in /home/submission/submission.csv (score 70.615745).
Submit this FIRST to get LB feedback.

### Part B: Optimize N=1 Exhaustively

N=1 contributes ~0.66 to the total score - the HIGHEST single contribution!

```python
import numpy as np
from shapely.geometry import Polygon
from shapely import affinity

TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def get_tree_polygon(x, y, angle):
    coords = list(zip(TX, TY))
    poly = Polygon(coords)
    poly = affinity.rotate(poly, angle, origin=(0, 0))
    poly = affinity.translate(poly, x, y)
    return poly

def optimize_n1():
    """Find optimal rotation angle for N=1."""
    best_angle = 0
    best_side = float('inf')
    
    # Test every 0.01 degree from 0 to 360
    for angle_int in range(36000):
        angle = angle_int / 100.0
        tree = get_tree_polygon(0, 0, angle)
        bounds = tree.bounds  # (minx, miny, maxx, maxy)
        side = max(bounds[2] - bounds[0], bounds[3] - bounds[1])
        if side < best_side:
            best_side = side
            best_angle = angle
    
    return best_angle, best_side

best_angle, best_side = optimize_n1()
print(f"Optimal N=1: angle={best_angle:.2f}°, side={best_side:.6f}")
print(f"Score contribution: {best_side**2:.6f}")
```

Current N=1 in baseline: side=0.813173, score=0.661250
If we can reduce side to ~0.75, score becomes ~0.5625 (improvement of ~0.1!)

### Part C: Optimize N=2-10

After N=1, optimize N=2-10 using grid search:
- For each N, try different angle combinations
- Use grid search for positions
- Validate no overlaps before accepting

## ✅ REQUIRED: PER-N TRACKING

Track improvements for EACH N separately:
```python
# Load baseline per-N scores
baseline_per_n = {}  # Load from valid baseline

# After optimization, compare
for n in range(1, 201):
    if my_score[n] < baseline_per_n[n]:
        print(f"✅ N={n}: IMPROVED by {baseline_per_n[n] - my_score[n]:.6f}")
        # Keep this improvement!
```

## ✅ VALIDATION BEFORE SUBMISSION

MANDATORY: Run strict validation on ALL N values before submission:
```python
for n in range(1, 201):
    ok, msg = validate_no_overlap_strict(trees_for_n[n])
    if not ok:
        raise ValueError(f"N={n}: {msg}")
print("✓ All N values validated - no overlaps")
```

## Recommended Experiment Pipeline

1. **Submit valid baseline** (already in /home/submission/submission.csv)
   - Score: 70.615745
   - This establishes our LB reference

2. **Optimize N=1** (highest impact)
   - Exhaustive angle search (0° to 360° in 0.01° steps)
   - Expected improvement: 0.05-0.1 points

3. **Optimize N=2-10** (high impact)
   - Grid search over angles and positions
   - Expected improvement: 0.1-0.3 points

4. **Validate and submit**
   - Strict overlap validation
   - Submit improved solution

## What NOT to Try
- Running any pre-compiled binary (bbox3, tree_packer, etc.)
- Submitting without strict overlap validation
- Optimizing large N before small N (small N has higher impact)

## Tree Geometry Reference
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
# Total height: 1.0 (from y=-0.2 to y=0.8)
# Max width: 0.7 (at y=0, the base tier)
```

## Scoring Formula
```
score = Σ(s_n² / n) for n=1 to 200
```
- Lower is better
- N=1 contributes ~0.66 (highest!)
- N=2 contributes ~0.44
- N=3 contributes ~0.43
- Small N values have the highest score contribution per tree
