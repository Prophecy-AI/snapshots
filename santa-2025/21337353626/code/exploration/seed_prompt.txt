# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D polygon packing optimization problem. The goal is to pack Christmas tree shapes (15-vertex polygons) into the smallest possible square bounding box for each configuration of N trees (N=1 to 200).

**Scoring:** score = Σ(s_n² / n) for n=1 to 200, where s_n is the side length of the bounding square for n trees. **Lower is better.**

**Target Score:** Beat 68.888293

## ⛔ ABSOLUTELY FORBIDDEN (EXPERIMENT WILL BE REJECTED)

The following are PERMANENTLY FORBIDDEN after baseline:
- bbox3 - FORBIDDEN (pre-compiled binary)
- sa_fast_v2 - FORBIDDEN
- eazy_optimizer - FORBIDDEN
- tree_packer - FORBIDDEN (pre-compiled binary)
- shake_public - FORBIDDEN (pre-compiled binary)
- subprocess.run() with binaries - FORBIDDEN
- os.system() with binaries - FORBIDDEN
- ANY pre-compiled binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any binary tool - FORBIDDEN
- Running "more iterations" on any binary optimizer - FORBIDDEN

If your experiment runs ANY binary, it will produce ~70.6.
The target is 68.888293. BINARIES CANNOT GET THERE.

**WHY THIS MATTERS:** The pre-optimized solutions from public kernels are already at local optima (~70.6). Running binaries on them finds NO improvements. You MUST implement novel algorithms in Python to beat the target.

## ✅ MANDATORY FIRST TASK: SOLVE N=1-10 OPTIMALLY

BEFORE any other work, implement exhaustive search for small N:

**For N=1 (contributes ~0.66 to score - HIGHEST!):**
- Test EVERY rotation angle from 0° to 360° in 0.01° increments
- Find the angle that minimizes bounding box
- The tree has 15 vertices - optimal angle is around 45° (diagonal orientation)
- This alone can improve score by 0.05-0.1 points

**For N=2-10:**
- Implement branch-and-bound or exhaustive placement search
- These contribute ~2.5 points total - worth optimizing!
- Try all combinations of angles (0°, 90°, 180°, 270°) for each tree
- Use grid search for positions with fine granularity

## ✅ MANDATORY: PER-N SOLUTION TRACKING

Track best solution for EACH N value separately:
1. Load baseline per-N scores from existing submission
2. After your algorithm runs, compare per-N scores
3. SAVE any N where you improved (even if total is worse)
4. Accumulate improvements across experiments

```python
# Example per-N tracking
def calculate_per_n_scores(submission_df):
    scores = {}
    for n in range(1, 201):
        trees = load_trees_for_n(submission_df, n)
        side = calculate_bounding_box_side(trees)
        scores[n] = side**2 / n
    return scores
```

## ✅ REQUIRED: IMPLEMENT ALGORITHM IN PYTHON

Write YOUR OWN code. Choose ONE approach:

### 1. Bottom-Left Constructive Heuristic (Easiest)
```python
def bottom_left_placement(trees, new_tree):
    """Place new_tree at bottom-left feasible position"""
    # Start from far away, move toward center
    # Find first position with no overlap
    # Use STRtree for efficient collision detection
```

### 2. Simulated Annealing (Medium)
```python
def simulated_annealing(config, T_start=1.0, T_end=0.001, iterations=10000):
    """SA with moves: translate, rotate, swap"""
    # Move types: small translation, rotation, swap two trees
    # Accept worse moves with probability exp(-delta/T)
    # Cool temperature gradually
```

### 3. Genetic Algorithm with Custom Operators (Medium)
```python
def genetic_algorithm(population_size=50, generations=100):
    """GA with crossover and mutation for tree configurations"""
    # Chromosome: list of (x, y, angle) for each tree
    # Crossover: swap subsets of trees between parents
    # Mutation: perturb position/angle of random tree
```

### 4. Lattice-Based Approach for Large N (Advanced)
```python
def lattice_packing(n, base_config):
    """Generate grid-based packing for large N"""
    # Start with 2 trees in optimal configuration
    # Translate in x and y to create grid pattern
    # Optimize base configuration and translation vectors
```

## Tree Geometry (CRITICAL)

Each Christmas tree is a 15-vertex polygon:
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```
- Trunk: width 0.15, height 0.2
- Base tier: width 0.7
- Middle tier: width 0.4
- Top tier: width 0.25
- Tip at y=0.8
- Total height: 1.0 (from trunk bottom at -0.2 to tip at 0.8)

## Insights from Discussions (MANDATORY)

### Discussion "Why the winning solutions will be Asymmetric" (39 votes):
- **Key insight:** Asymmetric configurations outperform symmetric ones
- For large N, don't assume grid symmetry is optimal
- Allow trees to have different angles and positions

### Discussion "Expected Leaderboard Progression" (20 votes):
- Top solutions use extensive compute time (hours, not minutes)
- Multiple optimization passes are essential
- Lattice-like patterns emerge in well-optimized configurations

### Discussion "Where do these high-scoring CSVs originate from?" (13 votes):
- Best public CSVs come from running optimizers for many hours
- The santa-2025.csv dataset is already highly optimized
- To beat it, you need novel algorithmic approaches

## What Discussions Say DOESN'T Work
- Short optimization runs (minutes) - local optima too tight
- Simple ensemble of existing CSVs - one source dominates all N values
- Running binaries on pre-optimized submissions - no improvements found

## Unexplored Ideas from Research

### 1. No-Fit Polygon (NFP) Precomputation
Academic literature suggests precomputing NFPs for O(1) overlap checks:
```python
def compute_nfp(polygon_a, polygon_b):
    """Compute no-fit polygon for two shapes"""
    # NFP defines all positions where B overlaps A
    # Placement is valid if B's reference point is outside NFP
```

### 2. Collision-Free Region (CFR) Algorithm
```python
def compute_cfr(placed_trees, new_tree):
    """Compute region where new_tree can be placed without overlap"""
    # Use Minkowski sums or direct geometric computation
    # Find degenerated vertices/edges for maximum compaction
```

### 3. Backward Propagation (Already in kernels but can be improved)
```python
def backward_propagation(configs):
    """Improve smaller N by removing trees from larger N configs"""
    for n in range(200, 1, -1):
        for tree_idx in get_boundary_trees(configs[n]):
            candidate = remove_tree(configs[n], tree_idx)
            if score(candidate) < score(configs[n-1]):
                configs[n-1] = candidate
```

## Recommended Experiment Pipeline

### Phase 1: Establish Baseline
1. Load best pre-optimized submission from snapshots
2. Calculate per-N scores
3. Identify worst-performing N values

### Phase 2: Optimize Small N (N=1-10)
1. Implement exhaustive angle search for N=1
2. Implement grid search for N=2-5
3. Use local search for N=6-10

### Phase 3: Implement Novel Algorithm
1. Choose one approach (SA, GA, or lattice)
2. Implement in pure Python
3. Test on small N first (N=10-20)
4. Scale to larger N if successful

### Phase 4: Combine and Validate
1. Merge improvements from all phases
2. Validate no overlaps
3. Submit and compare to target

## Key Implementation Details

### ChristmasTree Class
```python
from decimal import Decimal, getcontext
from shapely import affinity
from shapely.geometry import Polygon

getcontext().prec = 25
scale_factor = Decimal('1e15')

class ChristmasTree:
    def __init__(self, center_x='0', center_y='0', angle='0'):
        self.center_x = Decimal(center_x)
        self.center_y = Decimal(center_y)
        self.angle = Decimal(angle)
        
        # Build polygon with high precision
        initial_polygon = Polygon(list(zip(TX, TY)))
        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))
        self.polygon = affinity.translate(rotated, 
                                          xoff=float(self.center_x),
                                          yoff=float(self.center_y))
```

### Overlap Detection
```python
from shapely.strtree import STRtree

def has_overlap(trees):
    if len(trees) <= 1:
        return False
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

### Bounding Box Calculation
```python
import numpy as np

def calculate_side(trees):
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points = np.array(all_points)
    min_xy = points.min(axis=0)
    max_xy = points.max(axis=0)
    return max(max_xy[0] - min_xy[0], max_xy[1] - min_xy[1])
```

### Fix Direction Post-Processing
```python
from scipy.spatial import ConvexHull
from scipy.optimize import minimize_scalar

def optimize_rotation(trees):
    """Rotate entire configuration to minimize bounding box"""
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points_np = np.array(all_points)
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    def bbox_at_angle(angle_deg):
        angle_rad = np.radians(angle_deg)
        c, s = np.cos(angle_rad), np.sin(angle_rad)
        rot_matrix = np.array([[c, s], [-s, c]])
        rotated = hull_points.dot(rot_matrix)
        return max(rotated.max(0) - rotated.min(0))
    
    res = minimize_scalar(bbox_at_angle, bounds=(0, 90), method='bounded')
    return res.x, res.fun
```

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- id: `{n:03d}_{tree_index}` (e.g., 001_0, 002_0, 002_1)
- x, y, deg: prefixed with 's' to preserve precision
- Total rows: 20100 (1+2+3+...+200)

## Validation Checklist
1. No overlapping trees (use has_overlap function)
2. All coordinates within [-100, 100]
3. All 200 configurations present (20100 rows)
4. Values prefixed with 's' in submission

## Score Contribution Analysis

N=1 contributes the most to score (~0.66). Small N values (1-10) have lowest packing efficiency:
- N=1: side≈0.813, contributes 0.66
- N=2: side≈0.950, contributes 0.45
- N=3-10: combined contribution ~2.5

Focus optimization effort on:
1. Small N (1-10) - highest per-tree contribution
2. N values where current solution has poor efficiency
3. Boundary trees that define the bounding box

## Strategy to Beat Target (68.888293)

1. **Start with best snapshot** - Load pre-optimized solution (~70.6)
2. **Optimize N=1 exhaustively** - Find optimal rotation angle
3. **Implement pure Python SA** - For N=2-50
4. **Use lattice approach** - For N>50
5. **Apply backward propagation** - Improve smaller N from larger
6. **Fine-tune boundary trees** - Micro-adjustments to reduce bounding box
7. **Validate and submit** - Check for overlaps before each submission

The gap from 70.6 to 68.89 is ~1.7 points (2.4%). This requires:
- Average side reduction of ~0.05 units across all N
- OR significant improvements on worst-performing N values
- OR novel algorithmic approach that escapes local optima

**Remember:** The winning solutions came from researchers who thought from first principles, not from running existing binaries longer. IMPLEMENT YOUR OWN ALGORITHM.
