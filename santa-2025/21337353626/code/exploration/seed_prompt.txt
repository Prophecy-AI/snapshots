# Santa 2025 - Evolved Strategy (Loop 1)

## Current Status
- **Best CV score:** 70.572798 from exp_000 (baseline)
- **Best LB score:** N/A (not yet submitted)
- **Target:** 68.888293 | **Gap to target:** 1.68 points (2.4%)
- **Submissions remaining:** 94/100

## Response to Evaluator

The evaluator's assessment is **CORRECT**. The baseline is trustworthy and the next step is clear:

1. **Evaluator says:** "IMPLEMENT EXHAUSTIVE SEARCH FOR N=1" - **AGREED**. N=1 contributes 0.661 to score (highest single contribution). The current baseline has side=0.813 for N=1. An exhaustive angle search is trivial (36,000 evaluations) and could improve this.

2. **Evaluator says:** "Proceed to N=2-10 with similar approaches" - **AGREED**. N=1-10 contribute ~3.9 points total. Optimizing these is high-leverage.

3. **Evaluator says:** "Implement simulated annealing in pure Python for N=10-50" - **AGREED** but this is SECONDARY to N=1-10 optimization.

## ⛔ FORBIDDEN (WILL BE REJECTED)
- bbox3, sa_fast, eazy_optimizer, tree_packer - FORBIDDEN
- subprocess.run() or os.system() - FORBIDDEN
- Running ANY binary or executable - FORBIDDEN
- "Optimizing" existing CSV files with any binary tool - FORBIDDEN
- Loading solutions then running optimizer on them - FORBIDDEN

## ✅ EXPERIMENT 001: SOLVE N=1 TO N=10 OPTIMALLY (MANDATORY)

### TASK 1: N=1 Exhaustive Angle Search (HIGHEST PRIORITY)

N=1 contributes **0.661** to total score - the HIGHEST single contribution!
Current baseline: side=0.813173, score=0.661250

**IMPLEMENTATION:**
```python
import numpy as np
from shapely.geometry import Polygon
from shapely import affinity

TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

def get_tree_polygon(x, y, angle):
    """Create a tree polygon at position (x, y) with rotation angle."""
    coords = list(zip(TX, TY))
    poly = Polygon(coords)
    poly = affinity.rotate(poly, angle, origin=(0, 0))
    poly = affinity.translate(poly, x, y)
    return poly

def optimize_n1():
    """Find optimal rotation angle for single tree."""
    best_angle = 0
    best_side = float('inf')
    
    # Test every angle from 0° to 360° in 0.01° increments
    for angle_int in range(36000):
        angle = angle_int / 100.0
        tree = get_tree_polygon(0, 0, angle)
        bounds = tree.bounds  # (minx, miny, maxx, maxy)
        side = max(bounds[2] - bounds[0], bounds[3] - bounds[1])
        if side < best_side:
            best_side = side
            best_angle = angle
    
    return best_angle, best_side

# Run optimization
best_angle, best_side = optimize_n1()
print(f"N=1 Optimal: angle={best_angle:.2f}°, side={best_side:.6f}")
print(f"Baseline: side=0.813173, score=0.661250")
print(f"Improvement: {0.813173 - best_side:.6f} in side length")
print(f"Score improvement: {0.661250 - best_side**2:.6f}")
```

**EXPECTED:** The tree is 1.0 tall and 0.7 wide. At 45° rotation, the diagonal should give a smaller bounding box. Theoretical minimum is around 0.7-0.8.

### TASK 2: N=2-10 Optimization

For N=2-10, implement a grid search over positions and angles:

```python
def optimize_small_n(n, baseline_trees):
    """Optimize placement for small N using grid search."""
    from itertools import product
    from shapely.strtree import STRtree
    
    # For N=2: try all angle combinations (0°, 45°, 90°, 135°, 180°, 225°, 270°, 315°)
    angles = [0, 45, 90, 135, 180, 225, 270, 315]
    
    best_config = None
    best_side = float('inf')
    
    # Start from baseline configuration
    # Try local perturbations
    for tree_idx in range(n):
        for new_angle in angles:
            # Create modified configuration
            config = list(baseline_trees)
            x, y, _ = config[tree_idx]
            config[tree_idx] = (x, y, new_angle)
            
            # Check for overlaps
            if not has_overlap(config):
                side = calculate_bounding_box_side(config)
                if side < best_side:
                    best_side = side
                    best_config = config
    
    return best_config, best_side
```

### TASK 3: Per-N Score Tracking (MANDATORY)

```python
def compare_per_n_scores(my_solution, baseline_per_n):
    """Compare per-N scores and identify improvements."""
    improvements = []
    for n in range(1, 201):
        my_score = my_solution.get(n, float('inf'))
        base_score = baseline_per_n.get(str(n), float('inf'))
        diff = base_score - my_score  # positive = better
        if diff > 0.0001:
            improvements.append((n, diff))
            print(f"✅ N={n}: IMPROVED by {diff:.6f}")
    return improvements

# CRITICAL: Save improvements even if total score is worse
# Accumulate best per-N across all experiments
```

## Per-N Score Analysis (from baseline)

Top 10 contributors to score:
| N | Side | Score | Cumulative |
|---|------|-------|------------|
| 1 | 0.813 | 0.661 | 0.661 |
| 2 | 0.935 | 0.437 | 1.098 |
| 3 | 1.142 | 0.435 | 1.533 |
| 4 | 1.282 | 0.411 | 1.944 |
| 5 | 1.404 | 0.394 | 2.338 |
| 6 | 1.548 | 0.400 | 2.738 |
| 7 | 1.673 | 0.400 | 3.138 |
| 8 | 1.756 | 0.385 | 3.523 |
| 9 | 1.867 | 0.387 | 3.910 |
| 10 | 1.941 | 0.377 | 4.287 |

**N=1-10 contribute 4.29 points (6.1% of total score)**
**Optimizing these is HIGH LEVERAGE**

## Tree Geometry Reference

```python
# Christmas tree vertices (15 points)
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]

# Tree dimensions:
# - Height: 1.0 (from y=-0.2 to y=0.8)
# - Base width: 0.7 (from x=-0.35 to x=0.35)
# - Trunk: 0.15 wide, 0.2 tall
```

## Validation (CRITICAL)

Before ANY submission, validate no overlaps:
```python
from shapely.strtree import STRtree

def validate_no_overlap(trees):
    """Check that no trees overlap."""
    polygons = [get_tree_polygon(x, y, angle) for x, y, angle in trees]
    for i in range(len(polygons)):
        for j in range(i+1, len(polygons)):
            if polygons[i].intersects(polygons[j]) and not polygons[i].touches(polygons[j]):
                return False, f"Trees {i} and {j} overlap"
    return True, "OK"
```

## Experiment Pipeline

1. **Create experiment folder:** `experiments/001_small_n_optimization/`
2. **Implement N=1 exhaustive search** (36,000 evaluations)
3. **Implement N=2-10 optimization** (grid search over angles/positions)
4. **Compare per-N scores to baseline**
5. **Create submission with improvements**
6. **Log experiment with per-N improvements noted**

## Success Criteria

- ✅ N=1 side < 0.813 (any improvement)
- ✅ At least 3 N values improved over baseline
- ✅ Total score < 70.572798 (any improvement)
- ✅ No overlaps in submission

## What NOT to Try

- ❌ Running bbox3, sa_fast, or any binary
- ❌ Loading existing CSV and "optimizing" with external tools
- ❌ Skipping N=1 optimization (it's the highest-leverage task!)
- ❌ Implementing complex algorithms before exhaustive search for small N

## SUBMISSION STRATEGY

**SUBMIT AFTER THIS EXPERIMENT!**
- We have 94 submissions remaining - ABUNDANT
- LB feedback is FREE information
- Even if score is worse, we learn what works/doesn't work
- Submit to calibrate CV-LB relationship

## Reference Code

The baseline notebook is at: `experiments/000_baseline/data_loading.py.bak`
The baseline submission is at: `experiments/000_baseline/submission.csv`
Per-N scores are in: `experiments/000_baseline/metrics.json`

**REMEMBER:** The goal is to beat 68.888293. The baseline is 70.572798. 
We need to improve by 1.68 points. Start with N=1-10 optimization!
