# Santa 2025 - Christmas Tree Packing Optimization

## Current Status
- Best CV score: 70.647327 from exp_000 (001_baseline)
- Best LB score: 70.647327 (submitted, gap: 0.0000)
- Target: 68.894234 | Gap to target: 1.75 points (2.5%)

## CRITICAL DISCOVERY FROM SNAPSHOTS
Previous runs achieved **LB 70.626088** (0.021 better than current baseline)!
- Source: `/home/nonroot/snapshots/santa-2025/21198927060/`
- Method: Ensemble using `saspav_best.csv` which has 14 N values better than baseline
- Files copied to `/home/code/preoptimized/`:
  - `best_snapshot.csv` - The 70.626088 submission
  - `saspav_best.csv` - Source with better N values

## Response to Evaluator
The evaluator correctly identified that:
1. The baseline is verified and trustworthy (CV=LB=70.647327)
2. bbox3 optimizer is available but unused
3. Small N values (1-10) contribute 6.1% of score
4. N=1 already uses optimal 45° angle

**My response:**
- The evaluator's suggestion to run bbox3 is valid, but previous runs show bbox3 produces overlapping trees that fail Kaggle validation
- The REAL opportunity is the ensemble approach using saspav_best.csv which achieved 70.626088
- This is a 0.021 improvement over baseline - small but verified on LB

## Key Findings from Analysis
1. **CV-LB gap is exactly 0.0000** - scoring is deterministic
2. **N=1 already optimal** - uses 45° angle (0.661250 score)
3. **Baseline is highly optimized** - actual bounding boxes are SMALLER than theoretical estimates
4. **Previous runs exhausted many approaches:**
   - bbox3 optimization: produces overlaps, fails validation
   - SA optimization: no improvement, produces overlaps
   - Grid/tessellation: 25% worse than baseline
   - Random restart SA: worse than baseline
   - Genetic algorithms: worse than baseline

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY]** Implement Ensemble with saspav_best.csv
The snapshot shows this achieves 70.626088 on LB. Steps:
1. Load baseline submission.csv and saspav_best.csv
2. For each N=1-200, compare scores
3. Pick the configuration with smaller bounding box (if valid)
4. Validate no overlaps using Shapely
5. Expected improvement: ~0.02 points

### 2. **[HIGH PRIORITY]** Directly use best_snapshot.csv
The file `/home/code/preoptimized/best_snapshot.csv` is the exact submission that scored 70.626088.
- Verify its score locally
- If it matches, submit directly
- This is the fastest path to improvement

### 3. **[MEDIUM PRIORITY]** Try asymmetric solutions for large N
Discussion "Why the winning solutions will be Asymmetric" (38 votes) suggests:
- Asymmetric layouts outperform symmetric for large N
- This is NOT being tried in current public solutions
- Focus on N > 100 where symmetric patterns may be suboptimal

### 4. **[LOWER PRIORITY]** Extended bbox3 with validation
If trying bbox3, MUST validate each output:
- Run bbox3 with moderate parameters
- Check for overlaps using Shapely
- Only keep valid improvements
- Previous runs show most bbox3 outputs have overlaps

## What NOT to Try (Dead Ends from Previous Runs)
- Grid/tessellation approaches (25% worse)
- Random restart SA (worse than baseline)
- Genetic algorithms for small N (worse than baseline)
- bbox3 without validation (produces overlaps)
- SA without validation (produces overlaps)

## Validation Notes
- Use Shapely for overlap detection
- Check `poly.intersects(other) and not poly.touches(other)`
- All coordinates must be in [-100, 100]
- Values must be prefixed with 's'

## SUBMISSION STRATEGY
- Remaining submissions: 99
- **SUBMIT AGGRESSIVELY** - we have abundant submissions
- Submit after verifying best_snapshot.csv or implementing ensemble
- Expected score: ~70.626 (verified from previous runs)

## Technical Details

### Scoring Function
```python
@njit
def score_group(xs, ys, degs, tx, ty):
    n = xs.size
    V = tx.size
    mnx = mny = 1e300
    mxx = mxy = -1e300
    for i in range(n):
        r = degs[i] * math.pi / 180.0
        c = math.cos(r)
        s = math.sin(r)
        for j in range(V):
            X = c * tx[j] - s * ty[j] + xs[i]
            Y = s * tx[j] + c * ty[j] + ys[i]
            mnx = min(mnx, X)
            mxx = max(mxx, X)
            mny = min(mny, Y)
            mxy = max(mxy, Y)
    side = max(mxx - mnx, mxy - mny)
    return side * side / n
```

### Tree Vertices
```python
TX = np.array([0,0.125,0.0625,0.2,0.1,0.35,0.075,0.075,-0.075,-0.075,-0.35,-0.1,-0.2,-0.0625,-0.125])
TY = np.array([0.8,0.5,0.5,0.25,0.25,0,0,-0.2,-0.2,0,0,0.25,0.25,0.5,0.5])
```

## Resources
- Pre-optimized submissions: `/home/code/preoptimized/`
  - `submission.csv` - Current baseline (70.647327)
  - `best_snapshot.csv` - Best from previous runs (70.626088)
  - `saspav_best.csv` - Source with better N values
  - `smartmanoj_submission.csv` - Another source
- Research kernels: `/home/code/research/kernels/`
- Snapshots: `/home/nonroot/snapshots/santa-2025/`