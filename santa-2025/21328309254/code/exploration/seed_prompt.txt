# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
Pack Christmas tree-shaped polygons (15 vertices) into the smallest square bounding box for N=1 to N=200 trees. Score = Σ(side²/N) for all N values. Lower is better.

## Current Status
- **Target Score**: 68.894234
- **Best Baseline**: 70.647327 (bucket-of-chump/submission.csv)
- **Gap to Target**: ~1.75 points (2.5%)

## Pre-optimized Submissions Available
Location: `/home/code/preoptimized/`
- `submission.csv` - Score: 70.647327 (BEST)
- `smartmanoj_submission.csv` - Score: 70.743774
- `telegram/71.97.csv` - Score: 71.972027
- `telegram/72.49.csv` - Score: 72.495739
- `bbox3` - Compiled optimizer binary
- `ensemble.csv` - Ensemble of all sources (same as best: 70.647327)

**CRITICAL**: The ensemble equals the best single file, meaning submission.csv already dominates all N values. Standard optimization approaches have hit a local optimum.

## Key Insights from Analysis

### Score Distribution by N
- Small N values dominate score contribution
- N=1 contributes 0.661 (highest single contribution)
- N=2 contributes 0.451
- N=3 contributes 0.435
- Top 10 N values (1-9, 15) contribute ~4.0 points out of 70.65 total
- **Focus optimization effort on small N values for maximum impact**

### Tree Geometry
- 15-vertex polygon representing a Christmas tree
- Vertices: tip at (0, 0.8), trunk bottom at (±0.075, -0.2)
- Tree width: 0.7 at base, 0.4 at middle tier, 0.25 at top tier
- Trunk: 0.15 wide, 0.2 tall

## Top Approaches from Public Kernels

### 1. Ensemble Approach (jonathanchan kernel)
- Collect best configuration for each N from multiple sources
- Sources: bucket-of-chump, SmartManoj GitHub, telegram-public-shared-solution
- For each N, keep the configuration with smallest bounding box
- **FINDING**: Current ensemble doesn't help - one source dominates all N

### 2. SA with Fractional Translation (sa_v1_parallel.cpp)
- Simulated Annealing with very fine position adjustments
- Fractional steps: 0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001
- Parameters: `-n 15000 -r 80` (iterations, rounds)
- Perturb function to escape local optima
- Local search (ls_v3) after SA

### 3. bbox3.cpp Optimizer
- Complex Number Vector Coordination
- Fluid Dynamics simulation
- Hinge Pivot mechanism
- Density Gradient Flow
- Global Boundary Tension
- aggressive_repair for overlap resolution
- Parameters: `-n (iterations) -r (rounds)`

### 4. tree_packer_v21.cpp
- Swap moves between trees
- Multi-angle restarts
- Higher temperature SA
- Backward propagation (bp.cpp) - removes trees from larger configs to improve smaller ones
- squeeze, compaction, localSearch functions

## Recommended Experiment Strategy

### Phase 1: Establish Baseline (First Experiment)
1. Use pre-optimized submission.csv as starting point
2. Verify score matches ~70.65
3. **DO NOT proceed if score is significantly worse**

### Phase 2: Optimization Approaches (CRITICAL - Need Novel Approaches)

The pre-optimized submission is at a tight local optimum. Standard SA/optimization will NOT close the 1.75 point gap. Need fundamentally different approaches:

#### A. Lattice/Grid-Based Approach for Large N (N >= 58)
- Start with 2 base trees in specific configuration
- Translate in x and y directions to create grid pattern
- Optimize base configuration and translation vectors
- Can achieve tighter bounds than random optimization
- **This is NOT being tried in current solutions**

#### B. Focus on Small N Values (1-20)
- These have highest score contribution
- N=1 optimal angle is 45° (minimizes bounding box)
- For N=2-10, try exhaustive search over angles
- Try many random restarts with longer optimization

#### C. Asymmetric Solutions for Large N
- Discussion "Why the winning solutions will be Asymmetric" (38 votes)
- Symmetric layouts may not be optimal for large N
- Try breaking symmetry in initial configurations

#### D. Backward Propagation
- Start from N=200, work down to N=2
- For each N, try removing each boundary-touching tree
- If resulting (N-1) config is better than stored, save it

#### E. Extended SA Optimization (Hours, Not Minutes)
```bash
# Compile optimizer
g++ -O3 -march=native -std=c++17 -fopenmp -o sa_v1_parallel sa_v1_parallel.cpp

# Run with extended parameters (HOURS of compute)
./sa_v1_parallel -i submission.csv -o submission_optimized.csv -n 50000 -r 200
```

### Phase 3: What NOT to Try
- Simple micro-optimization of pre-optimized submission (already at local optimum)
- Short optimization runs (need hours, not minutes)
- More ensemble sources (current best dominates all N)
- Running same optimizers with slightly different parameters

## Validation Checklist
1. No overlapping trees (use overlap detection)
2. All coordinates within [-100, 100]
3. All 200 configurations present (20100 rows total)
4. Values prefixed with 's' in submission

## Submission Format
```csv
id,x,y,deg
001_0,s0.0,s0.0,s45.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```

## Key Technical Details

### Overlap Detection
```python
from shapely.geometry import Polygon
from shapely import affinity

TX = [0,0.125,0.0625,0.2,0.1,0.35,0.075,0.075,-0.075,-0.075,-0.35,-0.1,-0.2,-0.0625,-0.125]
TY = [0.8,0.5,0.5,0.25,0.25,0,0,-0.2,-0.2,0,0,0.25,0.25,0.5,0.5]

def make_tree_polygon(x, y, deg):
    p = Polygon(zip(TX, TY))
    p = affinity.rotate(p, deg, origin=(0,0))
    p = affinity.translate(p, x, y)
    return p
```

### Scoring Function (numba-optimized)
```python
@njit
def score_group(xs, ys, degs, tx, ty):
    n = xs.size
    V = tx.size
    mnx = mny = 1e300
    mxx = mxy = -1e300
    for i in range(n):
        r = degs[i] * math.pi / 180.0
        c = math.cos(r)
        s = math.sin(r)
        for j in range(V):
            X = c * tx[j] - s * ty[j] + xs[i]
            Y = s * tx[j] + c * ty[j] + ys[i]
            mnx = min(mnx, X)
            mxx = max(mxx, X)
            mny = min(mny, Y)
            mxy = max(mxy, Y)
    side = max(mxx - mnx, mxy - mny)
    return side * side / n
```

## Discussion Insights (from discussions.json)
- "Why the winning solutions will be Asymmetric" (38 votes) - Asymmetric layouts outperform symmetric for large N
- "Symmetric solutions that are apparently optimal" (43 votes) - Symmetric may be optimal for small N
- "What are the best approaches?" (6 votes) - SA, lattice packing, ensemble
- "How to improve the solution?" (10 votes) - Focus on boundary trees, fractional translation
- "Where do these high-scoring CSVs originate from?" (12 votes) - Top teams share optimized solutions

## Critical Success Factors
1. **Start from best available baseline** - Don't optimize from scratch
2. **Run optimization for HOURS, not minutes** - Local optima are tight
3. **Focus on small N values** - Highest score contribution
4. **Try fundamentally different approaches** - Lattice packing, asymmetric solutions
5. **Validate thoroughly** - No overlaps, correct format

## C++ Optimizer Compilation
```bash
# sa_v1_parallel.cpp
g++ -O3 -march=native -std=c++17 -fopenmp -o sa_v1_parallel sa_v1_parallel.cpp

# tree_packer_v21.cpp
g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer_v21 tree_packer_v21.cpp

# bbox3.cpp
g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp
```

## Resources
- Pre-optimized submissions: `/home/code/preoptimized/`
- Research kernels: `/home/code/research/kernels/`
- Sample submission format: `/home/data/sample_submission.csv`
