# Christmas Tree Packing Optimization - Seed Prompt

## Problem Overview
This is a 2D bin packing optimization problem where we need to pack Christmas tree-shaped polygons (15 vertices each) into the smallest possible square bounding box. The challenge requires finding optimal arrangements for N=1 to N=200 trees.

**Scoring Formula:** `score = Σ(side_n² / n)` for n=1 to 200, where side_n is the side length of the square bounding box for the n-tree configuration. Lower is better.

**Target Score:** Beat 68.901319

## Tree Geometry
The Christmas tree is a 15-vertex polygon with:
- Tip at (0, 0.8)
- Three tiers of branches at y=0.5, 0.25, 0
- Trunk from y=0 to y=-0.2
- Base width: 0.7, trunk width: 0.15

Tree vertices (TX, TY):
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## Top Approaches from Public Kernels

### 1. Getting Started Baseline (../research/kernels/inversion_santa-2025-getting-started/)
- Greedy placement with weighted random angles using `abs(sin(2*angle))` distribution
- Places trees by moving from far away toward center until collision
- Uses Shapely for polygon operations and STRtree for spatial indexing
- High-precision Decimal arithmetic with scale_factor=1e15

### 2. Santa-submission (../research/kernels/saspav_santa-submission/)
Key techniques:
- **bbox3 binary optimizer** with multi-phase approach (2min/10min/20min runs)
- **fix_direction rotation tightening** using ConvexHull + scipy.minimize_scalar
- **Overlap repair** by replacing invalid groups with known-good solutions
- **shake_public** binary for additional optimization
- Runs for ~11.6 hours with iterative improvement

### 3. Santa Claude (../research/kernels/smartmanoj_santa-claude/)
C++ implementation with:
- **OpenMP parallelization** for multi-core optimization
- **Swap moves** between trees
- **Multi-start SA** with higher temperature
- **Backward propagation** - removing boundary-touching trees from larger N to improve smaller N
- Local search with multiple step sizes and rotation angles
- Squeeze and compaction toward centroid

### 4. Why Not / bbox3 (../research/kernels/jazivxt_why-not/)
Advanced C++ optimizer with:
- **Complex number vector coordination** for geometric operations
- **Fluid dynamics simulation** for tree movement
- **Hinge pivot moves** with angle limits
- **Density gradient flow** toward center
- **Global boundary tension** to minimize bounding box
- **Aggressive overlap repair** using separation vectors (MTV approximation)

## Key Optimization Techniques

### Initialization
1. Start with greedy placement using weighted angles (sin(2*angle) favors diagonal orientations)
2. Place first tree at origin, add subsequent trees by moving toward center until collision
3. Try multiple random starting angles (10+ attempts) and keep best

### Local Search Moves
1. **Translation moves**: Move trees toward centroid in small steps (0.02, 0.008, 0.003, 0.001, 0.0004)
2. **8-directional moves**: Try all cardinal and diagonal directions
3. **Rotation moves**: Try rotation adjustments (±5°, ±2°, ±0.8°, ±0.3°, ±0.1°)
4. **Swap moves**: Exchange positions of two trees

### Global Optimization
1. **Squeeze/Compaction**: Scale all trees toward centroid until overlap occurs
2. **Rotation optimization**: Find optimal global rotation angle using ConvexHull + bounded minimization
3. **Simulated Annealing**: Accept worse moves with probability based on temperature
4. **Backward propagation**: Use N-tree solution to improve (N-1)-tree by removing boundary trees

### Collision Detection
1. **Bounding box pre-check**: Quick rejection if AABBs don't overlap
2. **Point-in-polygon test**: Check if any vertex is inside another polygon
3. **Segment intersection**: Check all edge pairs for intersection
4. Use Shapely's STRtree for efficient spatial queries

### Post-Processing
1. **fix_direction**: Optimize global rotation angle to minimize bounding box
2. **Overlap validation**: Check all configurations for overlaps
3. **Repair invalid groups**: Replace overlapping configurations with known-good solutions

## Additional Techniques from Research

### From Academic Literature on 2D Irregular Packing:
1. **Genetic Algorithms with Local Search Hybridization** - Combine GA for global exploration with local search for refinement
2. **Tabu Search** - Avoid revisiting recent solutions to escape local optima
3. **No-Fit Polygon (NFP)** - Precompute valid placement regions for collision-free positioning
4. **Jostle Algorithm** - Iteratively move pieces toward center while resolving overlaps
5. **Shelf Packing** - Sort objects by height/orientation for systematic placement

### Metaheuristic Strategies:
- **Multi-start optimization** - Run from multiple random initial configurations
- **Adaptive temperature scheduling** for SA - Start high, decrease slowly
- **Population-based methods** - Maintain diverse solution pool

## Implementation Strategy

### Phase 1: Initial Solution
- Start from sample_submission.csv or best known solution
- Parse CSV format: id (NNN_idx), x (sX.XXX), y (sY.YYY), deg (sD.DDD)

### Phase 2: Optimization Loop
1. Run bbox3/tree_packer optimizer with increasing time budgets
2. Apply fix_direction rotation tightening
3. Validate for overlaps
4. Replace invalid groups with backup solutions
5. Repeat until convergence or time limit

### Phase 3: Refinement
- Focus on boundary-touching trees (they define the bounding box)
- Try backward propagation from larger N to smaller N
- Fine-tune with smaller step sizes

## Critical Implementation Details

### Precision
- Use Decimal with precision 25-30 for coordinates
- Scale factor 1e15 to 1e18 for Shapely operations
- Round to 6 decimal places for submission

### Submission Format
```
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- Prepend 's' to all numeric values
- Coordinates constrained to -100 ≤ x, y ≤ 100

### Validation
- Check for overlaps using polygon intersection (not just touching)
- Overlapping submissions will throw an error

## Recommended Experiments (Priority Order)

1. **Start from best known solution** - Use pre-optimized CSV from public kernels as baseline
2. **Implement bbox3-style optimizer** - Multi-phase optimization with increasing time budgets
3. **Add rotation tightening** - Use ConvexHull + minimize_scalar to find optimal global rotation
4. **Implement backward propagation** - Improve smaller N by removing trees from larger N solutions
5. **Add swap moves** - Exchange positions of boundary trees
6. **Parallelize with OpenMP** - Critical for C++ implementations
7. **Ensemble best solutions** - Combine best configurations from multiple runs

## Performance Tips
- C++ with OpenMP is significantly faster than Python
- Pre-compute tree polygons and update only when moved
- Use spatial indexing (STRtree) for collision detection
- Focus optimization time on larger N (they contribute more to score)
- Boundary trees are most important - they define the bounding box
- Use long double precision in C++ for better numerical stability

## Score Contribution by N
The scoring formula `s²/n` means:
- Small N (1-10): Each contributes ~0.5-1.0 to total score
- Medium N (50-100): Each contributes ~0.3-0.5 to total score  
- Large N (150-200): Each contributes ~0.25-0.35 to total score

Optimizing larger N configurations has diminishing returns per-N but there are more of them. A balanced approach optimizes all N values.

## Key Code Patterns

### Polygon Creation (Python/Shapely):
```python
from shapely.geometry import Polygon
from shapely import affinity

def create_tree(cx, cy, deg):
    coords = list(zip(TX, TY))
    poly = Polygon(coords)
    poly = affinity.rotate(poly, deg, origin=(0, 0))
    poly = affinity.translate(poly, xoff=cx, yoff=cy)
    return poly
```

### Overlap Check:
```python
def has_overlap(poly1, poly2):
    return poly1.intersects(poly2) and not poly1.touches(poly2)
```

### Bounding Box Side:
```python
def get_side(trees):
    union = unary_union([t.polygon for t in trees])
    bounds = union.bounds  # (minx, miny, maxx, maxy)
    return max(bounds[2] - bounds[0], bounds[3] - bounds[1])
```
