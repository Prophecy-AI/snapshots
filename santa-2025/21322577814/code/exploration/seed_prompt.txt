# Christmas Tree Packing Optimization - Seed Prompt

## Problem Overview
This is a 2D bin packing optimization problem where we need to pack Christmas tree-shaped polygons (15 vertices each) into the smallest possible square bounding box. The challenge requires finding optimal arrangements for N=1 to N=200 trees.

**Scoring Formula:** `score = Σ(side_n² / n)` for n=1 to 200, where side_n is the side length of the square bounding box for the n-tree configuration. Lower is better.

**Target Score:** Beat 68.901319

## Tree Geometry
The Christmas tree is a 15-vertex polygon with:
- Tip at (0, 0.8)
- Three tiers of branches at y=0.5, 0.25, 0
- Trunk from y=0 to y=-0.2
- Base width: 0.7, trunk width: 0.15

## Top Approaches from Public Kernels

### 1. Getting Started Baseline (../research/kernels/inversion_santa-2025-getting-started/)
- Greedy placement with weighted random angles using `abs(sin(2*angle))` distribution
- Places trees by moving from far away toward center until collision
- Uses Shapely for polygon operations and STRtree for spatial indexing
- High-precision Decimal arithmetic with scale_factor=1e15

### 2. Santa-submission (../research/kernels/saspav_santa-submission/)
Key techniques:
- **bbox3 binary optimizer** with multi-phase approach (2min/10min/20min runs)
- **fix_direction rotation tightening** using ConvexHull + scipy.minimize_scalar
- **Overlap repair** by replacing invalid groups with known-good solutions
- **shake_public** binary for additional optimization
- Runs for ~11.6 hours with iterative improvement

### 3. Santa Claude (../research/kernels/smartmanoj_santa-claude/)
C++ implementation with:
- **OpenMP parallelization** for multi-core optimization
- **Swap moves** between trees
- **Multi-start SA** with higher temperature
- **Backward propagation** - removing boundary-touching trees from larger N to improve smaller N
- Local search with multiple step sizes and rotation angles
- Squeeze and compaction toward centroid

### 4. Why Not / bbox3 (../research/kernels/jazivxt_why-not/)
Advanced C++ optimizer with:
- **Complex number vector coordination** for geometric operations
- **Fluid dynamics simulation** for tree movement
- **Hinge pivot moves** with angle limits
- **Density gradient flow** toward center
- **Global boundary tension** to minimize bounding box
- **Aggressive overlap repair** using separation vectors (MTV approximation)

## Key Optimization Techniques

### Initialization
1. Start with greedy placement using weighted angles (sin(2*angle) favors diagonal orientations)
2. Place first tree at origin, add subsequent trees by moving toward center until collision
3. Try multiple random starting angles (10+ attempts) and keep best

### Local Search Moves
1. **Translation moves**: Move trees toward centroid in small steps (0.02, 0.008, 0.003, 0.001, 0.0004)
2. **8-directional moves**: Try all cardinal and diagonal directions
3. **Rotation moves**: Try rotation adjustments (±5°, ±2°, ±0.8°, ±0.3°, ±0.1°)
4. **Swap moves**: Exchange positions of two trees

### Global Optimization
1. **Squeeze/Compaction**: Scale all trees toward centroid until overlap occurs
2. **Rotation optimization**: Find optimal global rotation angle using ConvexHull + bounded minimization
3. **Simulated Annealing**: Accept worse moves with probability based on temperature
4. **Backward propagation**: Use N-tree solution to improve (N-1)-tree by removing boundary trees

### Collision Detection
1. **Bounding box pre-check**: Quick rejection if AABBs don't overlap
2. **Point-in-polygon test**: Check if any vertex is inside another polygon
3. **Segment intersection**: Check all edge pairs for intersection
4. Use Shapely's STRtree for efficient spatial queries

### Post-Processing
1. **fix_direction**: Optimize global rotation angle to minimize bounding box
2. **Overlap validation**: Check all configurations for overlaps
3. **Repair invalid groups**: Replace overlapping configurations with known-good solutions

## Implementation Strategy

### Phase 1: Initial Solution
- Start from sample_submission.csv or best known solution
- Parse CSV format: id (NNN_idx), x (sX.XXX), y (sY.YYY), deg (sD.DDD)

### Phase 2: Optimization Loop
1. Run bbox3/tree_packer optimizer with increasing time budgets
2. Apply fix_direction rotation tightening
3. Validate for overlaps
4. Replace invalid groups with backup solutions
5. Repeat until convergence or time limit

### Phase 3: Refinement
- Focus on boundary-touching trees (they define the bounding box)
- Try backward propagation from larger N to smaller N
- Fine-tune with smaller step sizes

## Critical Implementation Details

### Precision
- Use Decimal with precision 25-30 for coordinates
- Scale factor 1e15 to 1e18 for Shapely operations
- Round to 6 decimal places for submission

### Submission Format
```
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- Prepend 's' to all numeric values
- Coordinates constrained to -100 ≤ x, y ≤ 100

### Validation
- Check for overlaps using polygon intersection (not just touching)
- Overlapping submissions will throw an error

## Recommended Experiments (Priority Order)

1. **Implement bbox3-style optimizer** - Multi-phase optimization with increasing time budgets
2. **Add rotation tightening** - Use ConvexHull + minimize_scalar to find optimal global rotation
3. **Implement backward propagation** - Improve smaller N by removing trees from larger N solutions
4. **Add swap moves** - Exchange positions of boundary trees
5. **Parallelize with OpenMP** - Critical for C++ implementations
6. **Ensemble best solutions** - Combine best configurations from multiple runs

## Performance Tips
- C++ with OpenMP is significantly faster than Python
- Pre-compute tree polygons and update only when moved
- Use spatial indexing (STRtree) for collision detection
- Focus optimization time on larger N (they contribute more to score)
- Boundary trees are most important - they define the bounding box
