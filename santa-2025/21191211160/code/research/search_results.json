{
  "query": "What is scan-line linear packing algorithm for 2D polygon packing optimization?",
  "results": [
    {
      "title": "ANSWER",
      "text": "The scan\u2011line linear packing algorithm is a heuristic for the two\u2011dimensional free\u2011form bin\u2011packing (or nesting) problem that treats the layout as a series of one\u2011dimensional \u201cscanlines\u201d rather than as a full 2\u2011D geometry.  Each polygonal item and each bin is approximated by the set of horizontal (or vertical) line segments that intersect it, and the algorithm attempts to pack these scanlines in a first\u2011fit\u2011decreasing manner, extending the classic 1\u2011D bin\u2011packing approach to two dimensions\u202f([research.ibm.com](https://research.ibm.com/publications/a-scanline-based-algorithm-for-the-2d-free-form-bin-packing-problem)).  \n\nThe basic placement phase sorts items by size, converts them to scanline representations, and then places each item into the first bin where its scanlines fit without overlap \u2013 a direct analogue of the first\u2011fit decreasing rule.  To improve quality when items must be aligned in columns, a group\u2011placement extension recombines items into groups before scanning, allowing a limited re\u2011ordering that reduces wasted space.  Both phases run in linear time with respect to the number of scanlines, giving processing speeds far faster than manual nesting while still producing practically useful yields\u202f([research.ibm.com](https://research.ibm.com/publications/a-scanline-based-algorithm-for-the-2d-free-form-bin-packing-problem)).  \n\nIn practice the method is used for irregular cutting and packing tasks such as ship\u2011building plate nesting, textile layout, and other manufacturing processes where irregular polygons must be cut from large sheets.  The algorithm\u2019s speed and reasonable solution quality make it attractive for real\u2011time or large\u2011scale industrial applications, especially when a quick, near\u2011optimal layout is preferred over exact but computationally expensive methods.",
      "url": ""
    },
    {
      "title": "A scanline-based algorithm for the 2D free-form bin packing problem for Journal of the Operations Research Society of Japan",
      "text": "## Abstract\n\nThis paper describes a heuristic algorithm for the two-dimensional free-form bin packing (2D-FBP) problem, which is also called the irregular cutting and packing, or nesting problem. Given a set of 2D free-form bins, which in practice may be plate materials, and a set of 2D free-form items, which in practice may be plate parts to be cut out of the materials, the 2D-FBP problem is to lay out items inside one or more bins in such a way that the number of bins used is minimized, and for each bin, the yield is maximized. The proposed algorithm handles the problem as a variant of the one-dimensional bin-packing problem; i.e., items and bins are approximated as sets of scanlines, and scanlines are packed. The details of the algorithm are given, and its application to a nesting problem in a shipbuilding company is reported. The proposed algorithm consists of the basic and the group placement algorithms. The basic placement algorithm is a variant of the first-fit decreasing algorithm which is simply extended from the one-dimensional case to the two-dimensional case by a novel scanline approximation. The group placement algorithm is an extension of the basic placement algorithm with recombination of input items. A numerical study with real instances shows that the basic placement algorithm has sufficient performance for most of the instances, however, the group placement algorithm is required when items must be aligned in columns. The qualities of the resulting layouts are good enough for practical use, and the processing times required for both algorithms are much faster than those by manual nesting.\n\n## Related\n\nConference paper\n\n### [A simulation-based algorithm for supply chain optimization](https://research.ibm.com/publications/a-simulation-based-algorithm-for-supply-chain-optimization)\n\nTakayuki Yoshizuimi, Hiroyuki Okano\n\nWSC 2007\n\nPaper\n\n### [A path-exchange-type local search algorithm for vehicle routing and its efficient search strategy](https://research.ibm.com/publications/a-path-exchange-type-local-search-algorithm-for-vehicle-routing-and-its-efficient-search-strategy)\n\nNarihiro Park, Hiroyuki Okano, et al.\n\nJournal of the Operations Research Society of Japan\n\nPaper\n\n### [Finishing line scheduling in the steel industry](https://research.ibm.com/publications/finishing-line-scheduling-in-the-steel-industry)\n\nHiroyuki Okano, Andrew J. Davenport, et al.\n\nIBM J. Res. Dev\n\nConference paper\n\n### [The modal-shift transportation planning problem and its fast steepest descent algorithm](https://research.ibm.com/publications/the-modal-shift-transportation-planning-problem-and-its-fast-steepest-descent-algorithm)\n\nMasami Amano, Takayuki Yoshizumi, et al.\n\nWSC 2003\n\n[View all publications](https://research.ibm.com/publications)",
      "url": "https://research.ibm.com/publications/a-scanline-based-algorithm-for-the-2d-free-form-bin-packing-problem"
    },
    {
      "title": "Invited Review Two-dimensional packing problems: A survey",
      "text": "Two-dimensional packing problems: A survey - ScienceDirect\n[Skip to main content](#screen-reader-main-content)[Skip to article](#screen-reader-main-title)\n[![Elsevier logo](https://www.sciencedirect.com/shared-assets/24/images/elsevier-non-solus-new-grey.svg)ScienceDirect](https://www.sciencedirect.com/)\n[My account](https://www.sciencedirect.com/user/login?targetURL=/science/article/pii/S0377221702001236&amp;from=globalheader)\n[Sign in](https://www.sciencedirect.com/user/institution/login?targetURL=/science/article/pii/S0377221702001236)\n* [Access through**your organization**](https://www.sciencedirect.com/user/institution/login?targetUrl=/science/article/pii/S0377221702001236)\n* [Purchase PDF](https://www.sciencedirect.com/getaccess/pii/S0377221702001236/purchase)\nSearch ScienceDirect\n## Article preview\n* [Abstract](#preview-section-abstract)\n* [Introduction](#preview-section-introduction)\n* [Section snippets](#preview-section-snippets)\n* [References (54)](#preview-section-references)\n* [Cited by (733)](#preview-section-cited-by)\n[![Elsevier](https://www.sciencedirect.com/us-east-1/prod/bd96d51d266808527bf1018bd38b59c0b4bc6286/image/elsevier-non-solus.svg)](https://www.sciencedirect.com/journal/european-journal-of-operational-research)\n## [European Journal of Operational Research](https://www.sciencedirect.com/journal/european-journal-of-operational-research)\n[Volume 141, Issue 2](https://www.sciencedirect.com/journal/european-journal-of-operational-research/vol/141/issue/2),1 September 2002, Pages 241-252\n[![European Journal of Operational Research](https://ars.els-cdn.com/content/image/1-s2.0-S0377221725X00254-cov150h.gif)](https://www.sciencedirect.com/journal/european-journal-of-operational-research/vol/141/issue/2)\n# Invited Review\nTwo-dimensional packing problems: A survey\nAuthor links open overlay panelAndreaLodi,SilvanoMartello,MicheleMonaci\nShow more\nAdd to Mendeley\nShare\nCite\n[https://doi.org/10.1016/S0377-2217(02)00123-6](https://doi.org/10.1016/S0377-2217(02)00123-6)[Get rights and content](https://s100.copyright.com/AppDispatchServlet?publisherName=ELS&amp;contentID=S0377221702001236&amp;orderBeanReset=true)\n## Abstract\nWe consider problems requiring to allocate a set of rectangular items to larger rectangular standardized units by minimizing the waste. In*two-dimensional bin packing problems*these units are finite rectangles, and the objective is to pack all the items into the minimum number of units, while in*two-dimensional strip packing problems*there is a single standardized unit of given width, and the objective is to pack all the items within the minimum height. We discuss mathematical models, and survey lower bounds, classical approximation algorithms, recent heuristic and metaheuristic methods and exact enumerative approaches. The relevant special cases where the items have to be packed into rows forming levels are also discussed in detail.\n## Introduction\nIn several industrial applications one is required to allocate a set of rectangular items to larger rectangular standardized stock units by minimizing the waste. In wood or glass industries, rectangular components have to be cut from large sheets of material. In warehousing contexts, goods have to be placed on shelves. In newspapers paging, articles and advertisements have to be arranged in pages. In these applications, the standardized stock units are rectangles, and a common objective function is to pack all the requested items into the minimum number of units: the resulting optimization problems are known in the literature as two-dimensional bin packing problems. In other contexts, such as paper or cloth industries, we have instead a single standardized unit (a roll of material), and the objective is to obtain the items by using the minimum roll length: the problems are then referred to as two-dimensional strip packing problems. As we will see in the following, the two problems have a strict relation in almost all algorithmic approaches to their solution.\nMost of the contributions in the literature are devoted to the case where the items to be packed have a fixed orientation with respect to the stock unit(s), i.e., one is not allowed to rotate them. This case, which is the object of the present article, reflects a number of practical contexts, such as the cutting of corrugated or decorated material (wood, glass, cloth industries), or the newspapers paging. For variants allowing rotations (usually by 90\u00b0) and/or constraints on the items placement (such as the \u201cguillotine cuts\u201d), the reader is referred to Lodi et al. [41], [42], where a three-field classification of the area is also introduced. General surveys on cutting and packing problems can be found in Dyckhoff and Finke [17], Dowsland and Dowsland [16] and Dyckhoff et al. [18]. Results on the probabilistic analysis of packing algorithms can be found in Coffman and Shor [12] and Coffman and Lueker [11].\nLet us introduce the problems in a more formal way. We are given a set of*n*rectangular*items**j*\u2208*J*={1,\u2026,*n*}, each defined by a*width*,*w**j*, and a*height*,*h**j*:\n* (i)\nin the*Two-Dimensional Bin Packing Problem*(2BP), we are further given an unlimited number of identical rectangular*bins*of width*W*and height*H*, and the objective is to allocate all the items to the minimum number of bins;\n* (ii)\nin the*Two-Dimensional Strip Packing Problem*(2SP), we are further given a bin of width*W*and infinite height (hereafter called*strip*), and the objective is to allocate all the items to the strip by minimizing the height to which the strip is used.\nIn both cases, the items have to be packed with their*w*-edges parallel to the*W*-edge of the bins (or strip). We will assume, with no loss of generality, that all input data are positive integers, and that*w**j*\u2a7d*W*and*h**j*\u2a7d*H*(*j*=1,\u2026,*n*).\nBoth problems are strongly NP-hard, as is easily seen by transformation from the strongly NP-hard (one-dimensional)*Bin Packing Problem*(1BP), in which*n*items, each having an associated size*h**j*, have to be partitioned into the minimum number of subsets so that the sum of the sizes in each subset does not exceed a given capacity*H*.\nA third relevant case of rectangle packing is the following. Each item*j*has an associated profit*p**j*&gt;0, and the problem is to select a subset of items, to be packed in a single finite bin, which maximizes the total selected profit. This problem is usually denoted as (*Two-Dimensional*)*Cutting Stock*, although it had been introduced by Gilmore and Gomory [29] as (*Two-Dimensional*)*Cutting Knapsack*.\nIn this survey we concentrate on two-dimensional problems in which all items have to be packed, i.e., on 2SP and 2BP. The reader is referred to Dyckhoff et al. [18, Section 5] for an annotated bibliography on two-dimensional cutting stock problems. For both 2SP and 2BP, we also consider the special case where the items have to be packed into rows forming levels.\nIn Section 2 we discuss mathematical models for the various problems introduced above. In Section 3 we survey classical approximation algorithms as well as more recent heuristic and metaheuristic methods. In Section 4 we introduce lower bounding techniques, while in Section 5 we describe exact enumerative approaches.\n## Section snippets\n## Modeling two-dimensional problems\nThe first attempt to model two-dimensional packing problems was made by Gilmore and Gomory [29], through an extension of their approach to 1BP (see [27], [28]). They proposed a column generation approach (see [53] for a recent survey) based on the enumeration of all subsets of items (*patterns*) that can be packed into a single bin. Let*A**j*be a binary column vector of*n*elements*a**ij*(*i*=1,\u2026,*n*) taking the value 1 if item*i*belongs to the*j*th pattern, and the value 0 otherwise. The set of all\n## Approximation algorithms\nIn this section we concentrate on*off-line*algorithms, i.e., algorithms which have full knowledge of the input. For*on-line*algorithms, which pack the i...",
      "url": "https://www.sciencedirect.com/science/article/abs/pii/S0377221702001236"
    },
    {
      "title": "",
      "text": "New Improvements in Optimal Rectangle Packing\nEric Huang and Richard E. Korf\nComputer Science Department\nUniversity of California, Los Angeles\nLos Angeles, CA 90095\nehuang@cs.ucla.edu, korf@cs.ucla.edu\nAbstract\nThe rectangle packing problem consists of find\u0002ing an enclosing rectangle of smallest area that can\ncontain a given set of rectangles without overlap.\nOur algorithm picks the x-coordinates of all the\nrectangles before picking any of the y-coordinates.\nFor the x-coordinates, we present a dynamic vari\u0002able ordering heuristic and an adaptation of a prun\u0002ing algorithm used in previous solvers. We then\ntransform the rectangle packing problem into a per\u0002fect packing problem that has no empty space, and\npresent inference rules to reduce the instance size.\nFor the y-coordinates we search a space that models\nempty positions as variables and rectangles as val\u0002ues. Our solver is over 19 times faster than the pre\u0002vious state-of-the-art on the largest problem solved\nto date, allowing us to extend the known solutions\nfor a consecutive-square packing benchmark from\nN=27 to N=32.\n1 Introduction\nGiven a set of rectangles, our problem is to find all enclosing\nrectangles of minimum area that will contain them without\noverlap. We refer to an enclosing rectangle as a bounding\nbox. The optimization problem is NP-hard, while the prob\u0002lem of deciding whether a set of rectangles can be packed in\na given bounding box is NP-complete, via a reduction from\nbin-packing [Korf, 2003]. The consecutive-square packing\nbenchmark is a simple set of increasingly difficult bench\u0002marks for this problem, where the task is to find the bounding\nboxes of minimum area that contain a set of squares of sizes\n1x1, 2x2, ..., up to NxN [Korf, 2003]. For example, Figure 1\nis an optimal solution for N=32. We use this benchmark here\nbut none of the techniques introduced in this paper are spe\u0002cific to packing squares as opposed to rectangles.\nRectangle packing has many practical applications. It ap\u0002pears when loading a set of rectangular objects on a pallet\nwithout stacking them, and also in VLSI design where rect\u0002angular circuit components must be packed onto a rectangu\u0002lar chip. Various other cutting stock and layout problems also\nhave rectangle packing at their core.\nFigure 1: An optimal solution for N=32 with a bounding box\nof 85x135.\n511\n(a) Compulsory part of a 5x2 at\nx=[0,2]\n(b) Assigning a 4x2 to [0,2].\nFigure 2: Examples of compulsory parts and intervals.\n2 Previous Work\nKorf [2003] divided the rectangle packing problem into two\nsubproblems: the minimal bounding box problem and the\ncontainment problem. The former finds a bounding box of\nleast area that can contain a given set of rectangles, while the\nlatter tries to pack the given rectangles in a given bounding\nbox. The algorithm that solves the minimal bounding box\nproblem calls the algorithm that solves the containment prob\u0002lem as a subroutine.\n2.1 Minimal Bounding Box Problem\nA simple way to solve the minimal bounding box problem\nis to find the minimum and maximum areas that describe\nthe set of feasible and potentially optimal bounding boxes.\nBounding boxes of all dimensions can be generated with ar\u0002eas within this range, and then tested in non-decreasing order\nof area until all feasible solutions of smallest area are found.\nThe minimum area is the sum of the areas of the given rectan\u0002gles. The maximum area is determined by the bounding box\nof a greedy solution found by setting the bounding box height\nto that of the tallest rectangle, and then placing the rectangles\nin the first available position when scanning from left to right,\nand for each column scanning from bottom to top.\n2.2 Containment Problem\nKorf\u2019s [2003] absolute placement approach modeled rectan\u0002gles as variables and empty locations in the bounding box\nas values. Moffitt and Pollack\u2019s [2006] relative placement ap\u0002proach used a variable for every pair of rectangles to represent\nthe relations above, below, left, and right. Absolute place\u0002ment was faster than relative placement [Korf et al., 2009],\nwhich in turn was faster than the methods of Clautiaux et al.\n[2007] and Beldiceanu et al. [2008].\nSimonis and O\u2019Sullivan [2008] used Clautiaux et al.\u2019s\n[2007] variable order with additional constraints from\nBeldiceanu et al. [2008] to greatly outperform Korf et al.\u2019s\nsolver [2009]. They used Prolog\u2019s backtracking engine to\nsolve a set of constraints which they specified prior to the\nsearch effort. They first assigned the x-coordinates of all\nthe rectangles before any of the y-coordinates. Since we use\nsome of these ideas, we review them here.\nSimonis and O\u2019Sullivan [2008] used two sets of redundant\nvariables for the x-coordinates. The first set of N variables\ncorrespond to \u201cintervals\u201d where a rectangle is assigned an\ninterval of x-coordinates. Interval sizes are hand-picked for\neach rectangle prior to search, and they induce a smaller rect\u0002angle representing the common intersecting area of placing\nthe rectangle in any location in the interval [Beldiceanu et\nal., 2008]. Larger intervals result in weaker constraint prop\u0002agation (less pruning) but a smaller branching factor, while\nsmaller intervals result in stronger constraint propagation but\na larger branching factor.\nAs shown in Figure 2b, a 4x2 rectangle assigned an x\u0002interval of [0,2] consumes 2 units of area at each x-coordinate\nin [2,3], represented by the doubly-hatched area. This \u201ccom\u0002pulsory profile\u201d [Beldiceanu et al., 2008] is a constraint com\u0002mon to all positions x \u2208 [0, 2] of the original 4x2 rectan\u0002gle. If there were no feasible set of interval assignments, then\nthe constraint would save us from having to try individual x\u0002values. However, if we do find a set of interval assignments,\nthen we must search for a set of single x-coordinate val\u0002ues. Simonis and O\u2019Sullivan [2008] used a total of 4N vari\u0002ables, assigning (in order) x-intervals, single x-coordinates,\ny-intervals, and finally single y-coordinates.\n3 Overall Search Strategy\nWe separate the containment problem from the minimal\nbounding box problem, and use Korf et al.\u2019s [2009] al\u0002gorithm to solve the latter problem. Like Simonis and\nO\u2019Sullivan [2008], we assign all x-coordinates prior to any y\u0002coordinates, and use interval variables for the x-coordinates.\nWe set a rectangle\u2019s interval size to 0.35 times its width,\nwhich gave us the best performance. Finally, we do not use\ninterval variables for the y-coordinates. All of the remaining\nideas presented in this paper are our contributions.\nAlthough we use some ideas used by Simonis and\nO\u2019Sullivan [2008], we do not take a constraint programming\napproach in which all constraints are specified to a general\npurpose solver like Prolog, prior to the search effort. Instead,\nwe have implemented our program from scratch in C++, al\u0002lowing us to easily choose which constraints and inferences to\nuse at what time, and giving us more flexibility during search.\nFor example, as we will explain later, we make different in\u0002ferences depending on the partial solution.\nWe implemented a chronological backtracking algorithm\nwith dynamic variable ordering and forward checking. Our\nalgorithm works in three stages as it goes from the root of the\nsearch tree down to the leaves:\n1. It first works on the x-coordinates in a model where\nvariables are rectangles and values are x-coordinate lo\u0002cations, using dynamic variable ordering by area and a\nconstraint that detects infeasible subtrees.\n2. For each x-coordinate solution found, it conducts a per\u0002fect packing transformation, applies inference rules to\nreduce the transformed problem size, and derives conti\u0002guity constraints between rectangles.\n3. It then searches for a set of y-coordinates in a model\nwhere variables are empty corners and values are rect\u0002angles.\n4 Assigning X-Coordinates\nFor the x-coordinates, we propose a dynamic variable order\nand a constraint adapted from Korf\u2019s [2003] wasted-space\npruning heuristic. For a bounding box of size WxH we use\n512\nan array of size W representing the...",
      "url": "https://ijcai.org/Proceedings/09/Papers/092.pdf"
    },
    {
      "title": "Bin packing problem",
      "text": "Bin packing problem - Wikipedia\n[Jump to content](#bodyContent)\n[![](https://en.wikipedia.org/static/images/icons/wikipedia.png)![Wikipedia](https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg)![The Free Encyclopedia](https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg)](https://en.wikipedia.org/wiki/Main_Page)\n[Search](https://en.wikipedia.org/wiki/Special:Search)\nSearch\n# Bin packing problem\n11 languages\n* [Deutsch](https://de.wikipedia.org/wiki/Beh\u00e4lterproblem)\n* [Espa\u00f1ol](https://es.wikipedia.org/wiki/Problema_de_empaquetado_en_contenedores)\n* [\u0641\u0627\u0631\u0633\u06cc](https://fa.wikipedia.org/wiki/\u0645\u0633\u0626\u0644\u0647_\u0628\u0633\u062a\u0647\u200c\u0628\u0646\u062f\u06cc)\n* [Fran\u00e7ais](https://fr.wikipedia.org/wiki/Probl\u00e8me_de_bin_packing)\n* [\u05e2\u05d1\u05e8\u05d9\u05ea](https://he.wikipedia.org/wiki/\u05d1\u05e2\u05d9\u05d9\u05ea_\u05d0\u05e8\u05d9\u05d6\u05d4_\u05d1\u05d3\u05dc\u05d9\u05d9\u05dd)\n* [\u65e5\u672c\u8a9e](https://ja.wikipedia.org/wiki/\u30d3\u30f3\u30d1\u30c3\u30ad\u30f3\u30b0\u554f\u984c)\n* [Portugu\u00eas](https://pt.wikipedia.org/wiki/Problema_do_empacotamento_em_contentores)\n* [\u0420\u0443\u0441\u0441\u043a\u0438\u0439](https://ru.wikipedia.org/wiki/\u0417\u0430\u0434\u0430\u0447\u0430_\u043e\u0431_\u0443\u043f\u0430\u043a\u043e\u0432\u043a\u0435_\u0432_\u043a\u043e\u043d\u0442\u0435\u0439\u043d\u0435\u0440\u044b)\n* [\u0421\u0440\u043f\u0441\u043a\u0438 / srpski](https://sr.wikipedia.org/wiki/\u041f\u0440\u043e\u0431\u043b\u0435\u043c_\u043f\u0430\u043a\u043e\u0432\u0430\u045a\u0430_\u0443_\u043f\u0440\u043e\u0441\u0442\u043e\u0440\u0443)\n* [\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430](https://uk.wikipedia.org/wiki/\u0417\u0430\u0434\u0430\u0447\u0430_\u043f\u0440\u043e_\u043f\u0430\u043a\u0443\u0432\u0430\u043d\u043d\u044f_\u0432_\u0454\u043c\u043d\u043e\u0441\u0442\u0456)\n* [\u4e2d\u6587](https://zh.wikipedia.org/wiki/\u96c6\u88c5\u4f18\u5316)\n[Edit links](https://www.wikidata.org/wiki/Special:EntityPage/Q814581#sitelinks-wikipedia)\nFrom Wikipedia, the free encyclopedia\nMathematical and computational problem\nNot to be confused with[Bin picking](https://en.wikipedia.org/wiki/Bin_picking).\n|[Covering/packing-problem pairs](https://en.wikipedia.org/wiki/Linear_programming#Covering/packing_dualities)|\n[Covering problems](https://en.wikipedia.org/wiki/Covering_problems)|[Packing problems](https://en.wikipedia.org/wiki/Packing_problems)|\n[Minimum set cover](https://en.wikipedia.org/wiki/Set_cover_problem)|[Maximum set packing](https://en.wikipedia.org/wiki/Set_packing)|\n[Minimum edge cover](https://en.wikipedia.org/wiki/Edge_cover)|[Maximum matching](https://en.wikipedia.org/wiki/Matching_(graph_theory))|\n[Minimum vertex cover](https://en.wikipedia.org/wiki/Vertex_cover)|[Maximum independent set](https://en.wikipedia.org/wiki/Independent_set_(graph_theory))|\n[Bin covering](https://en.wikipedia.org/wiki/Bin_covering_problem)|Bin packing|\n[Polygon covering](https://en.wikipedia.org/wiki/Polygon_covering)|[Rectangle packing](https://en.wikipedia.org/wiki/Rectangle_packing)|\n|\n* [v](https://en.wikipedia.org/wiki/Template:Covering/packing-problem_pairs)\n* [t](https://en.wikipedia.org/wiki/Template_talk:Covering/packing-problem_pairs)\n* [e](https://en.wikipedia.org/wiki/Special:EditPage/Template:Covering/packing-problem_pairs)\n|\nThe**bin packing problem[&#91;1&#93;](#cite_note-1)[&#91;2&#93;](#cite_note-2)[&#91;3&#93;](#cite_note-3)[&#91;4&#93;](#cite_note-:0-4)**is an[optimization problem](https://en.wikipedia.org/wiki/Optimization_problem), in which items of different sizes must be packed into a finite number of bins or containers, each of a fixed given capacity, in a way that minimizes the number of bins used. The problem has many applications, such as filling up containers, loading trucks with weight capacity constraints, creating file[backups](https://en.wikipedia.org/wiki/Backup)in media, splitting a network prefix into multiple subnets,[&#91;5&#93;](#cite_note-5)and technology mapping in[FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array)[semiconductor chip](https://en.wikipedia.org/wiki/Semiconductor_chip)design.\nComputationally, the problem is[NP-hard](https://en.wikipedia.org/wiki/NP-hard), and the corresponding[decision problem](https://en.wikipedia.org/wiki/Decision_problem), deciding if items can fit into a specified number of bins, is[NP-complete](https://en.wikipedia.org/wiki/NP-complete). Despite its worst-case hardness, optimal solutions to very large instances of the problem can be produced with sophisticated algorithms. In addition, many[approximation algorithms](https://en.wikipedia.org/wiki/Approximation_algorithms)exist. For example, the[first fit](https://en.wikipedia.org/wiki/First-fit_bin_packing)algorithm provides a fast but often non-optimal solution, involving placing each item into the first bin in which it will fit. It requires*[\u0398](https://en.wikipedia.org/wiki/Big_O_notation)*(*n*&#160;log&#160;*n*) time, where*n*is the number of items to be packed. The algorithm can be made much more effective by first[sorting](https://en.wikipedia.org/wiki/Sorting)the list of items into decreasing order (sometimes known as the first-fit decreasing algorithm), although this still does not guarantee an optimal solution and for longer lists may increase the running time of the algorithm. It is known, however, that there always exists at least one ordering of items that allows first-fit to produce an optimal solution.[&#91;6&#93;](#cite_note-6)\nThere are many[variations](https://en.wikipedia.org/wiki/Packing_problem)of this problem, such as 2D packing, linear packing, packing by weight, packing by cost, and so on. The bin packing problem can also be seen as a special case of the[cutting stock problem](https://en.wikipedia.org/wiki/Cutting_stock_problem). When the number of bins is restricted to 1 and each item is characterized by both a volume and a value, the problem of maximizing the value of items that can fit in the bin is known as the[knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem).\nA variant of bin packing that occurs in practice is when items can share space when packed into a bin. Specifically, a set of items could occupy less space when packed together than the sum of their individual sizes. This variant is known as VM packing[&#91;7&#93;](#cite_note-7)since when[virtual machines](https://en.wikipedia.org/wiki/Virtual_machines)(VMs) are packed in a server, their total[memory requirement](https://en.wikipedia.org/wiki/Memory_management)could decrease due to[pages](https://en.wikipedia.org/wiki/Page_(computer_memory))shared by the VMs that need only be stored once. If items can share space in arbitrary ways, the bin packing problem is hard to even approximate. However, if space sharing fits into a hierarchy, as is the case with memory sharing in virtual machines, the bin packing problem can be efficiently approximated.\nAnother variant of bin packing of interest in practice is the so-called[online](https://en.wikipedia.org/wiki/Online_algorithm)bin packing. Here the items of different volume are supposed to arrive sequentially, and the decision maker has to decide whether to select and pack the currently observed item, or else to let it pass. Each decision is without recall. In contrast, offline bin packing allows rearranging the items in the hope of achieving a better packing once additional items arrive. This of course requires additional storage for holding the items to be rearranged.\n## Formal statement\n[[edit](https://en.wikipedia.org/w/index.php?title=Bin_packing_problem&amp;action=edit&amp;section=1)]\nIn*[Computers and Intractability](https://en.wikipedia.org/wiki/Computers_and_Intractability)*[&#91;8&#93;](#cite_note-GareyJohnson2-8)&#58;&#8202;226&#8202;Garey and Johnson list the bin packing problem under the reference [SR1]. They define its decision variant as follows.\nInstance: Finite setI{\\\\displaystyle I}![{\\displaystyle I}](https://wikimedia.org/api/rest_v1/media/math/render/svg/535ea7fc4134a31cbe2251d9d3511374bc41be9f)of items, a sizes(i)&#x2208;Z+{\\\\displaystyle s(i)\\\\in \\\\mathbb {Z} ^{+}}![{\\displaystyle s(i)\\in \\mathbb {Z} ^{+}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3aa77286f9a6b2c0637c92e98c322dd17a9c44eb)for eachi&#x2208;I{\\\\displaystyle i\\\\in I}![{\\displaystyle i\\in I}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2d740fe587228ce31b71c9628e089d1a9b37c6be), a positive integer bin capacityB{\\\\displaystyle B}![{\\displaystyle B}](https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a), and a positive integerK{\\\\displaystyle K}![{\\displaystyle K}](https://wikimedia.org/api/rest_v1/...",
      "url": "https://en.wikipedia.org/wiki/Bin_packing_problem"
    },
    {
      "title": "The Bin Packing Problem \n\n    \n    \n       \n    \n\n     \n      \n      Stay organized with collections\n     \n     \n      \n      Save and categorize content based on your preferences.",
      "text": "The Bin Packing Problem | OR-Tools | Google for Developers[Skip to main content](#main-content)\n[\n![Google OR-Tools](https://developers.google.com/static/optimization/images/orLogo.png)\n](https://developers.google.com/optimization)\n* [GoogleOR-Tools](https://developers.google.com/optimization)\n/\n* English\n* Deutsch\n* Espa\u00f1ol\n* Espa\u00f1ol \u2013Am\u00e9rica Latina\n* Fran\u00e7ais\n* Indonesia\n* Italiano\n* Polski\n* Portugu\u00eas \u2013Brasil\n* Ti\u00ea\u0301ng Vi\u00ea\u0323t\n* T\u00fcrk\u00e7e\n* \u0420\u0443\u0441\u0441\u043a\u0438\u0439* \u05e2\u05d1\u05e8\u05d9\u05ea* \u0627\u0644\u0639\u0631\u0628\u064a\u0651\u0629* \u0641\u0627\u0631\u0633\u06cc* \u0939\u093f\u0902\u0926\u0940* \u09ac\u09be\u0982\u09b2\u09be* \u0e20\u0e32\u0e29\u0e32\u0e44\u0e17\u0e22* \u4e2d\u6587\u2013\u7b80\u4f53* \u4e2d\u6587\u2013\u7e41\u9ad4* \u65e5\u672c\u8a9e* \ud55c\uad6d\uc5b4Sign in\n* [OR-Tools](https://developers.google.com/optimization)\n* [Home](https://developers.google.com/)\n* [Products](https://developers.google.com/products)\n* [OR-Tools](https://developers.google.com/optimization)\n* [Guides](https://developers.google.com/optimization/introduction)\nSend feedback# The Bin Packing ProblemStay organized with collectionsSave and categorize content based on your preferences.\n![Spark icon](https://developers.google.com/_static/images/icons/spark.svg)\n## Page Summary\noutlined\\_flag\n* The bin packing problem aims to pack items into the minimum number of bins, each with a fixed capacity, without considering item values.\n* A Mixed Integer Programming (MIP) model is used, with binary variables representing item-bin assignments and bin usage.\n* Constraints ensure each item is assigned to one bin and that bin capacities are respected.\n* The objective function minimizes the total number of bins used in the packing solution.\n* The solution provides the optimal assignment of items to bins, minimizing the total bins used and detailing the items and weights in each bin.\nLike the multiple knapsack problem, the bin packing problem also involves\npacking items into bins. However, the bin packing problem has a different\nobjective: find the fewest bins that will hold all the items.\nThe following summarizes the differences between the two problems:\n* Multiple knapsack problem: Pack a subset of the items into a fixed number of\nbins, with varying capacities, so that the total value of the packed items\nis a maximum.\n* Bin packing problem: Given as many bins with a common capacity as necessary,\nfind the fewest that will hold all the items. In this problem, the items\naren&#39;t assigned values, because the objective doesn&#39;t involve value.\nThe next example shows how to solve a bin packing problem.\n## Example\nIn this example, items of various weights need to be packed into a set of bins\nwith a common capacity. Assuming that there are enough bins to hold all the\nitems, the problem is to find the fewest that will suffice.\nThe following sections present programs that solve this problem. For the full\nprograms, see[Complete programs](#complete_programs).\nThis example uses the[MPSolver wrapper](https://developers.google.com/optimization/lp/mpsolver).\n### Import the libraries\nThe code below imports the required libraries.\n### Python\n```\nfromortools.linear\\_solverimportpywraplp\n```\n### C++\n```\n#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;vector&gt;#include\"ortools/linear\\_solver/linear\\_expr.h\"#include\"ortools/linear\\_solver/linear\\_solver.h\"\n```\n### Java\n```\nimportcom.google.ortools.Loader;importcom.google.ortools.linearsolver.MPConstraint;importcom.google.ortools.linearsolver.MPObjective;importcom.google.ortools.linearsolver.MPSolver;importcom.google.ortools.linearsolver.MPVariable;\n```\n### C#\n```\nusingSystem;usingGoogle.OrTools.LinearSolver;\n```\n### Create the data\nThe code below creates the data for the example.\n### Python\n```\ndefcreate\\_data\\_model():\"\"\"Create the data for the example.\"\"\"data={}weights=[48,30,19,36,36,27,42,42,36,24,30]data[\"weights\"]=weightsdata[\"items\"]=list(range(len(weights)))data[\"bins\"]=data[\"items\"]data[\"bin\\_capacity\"]=100returndata\n```\n### C++\n```\nstructDataModel{conststd::vector&lt;double&gt;weights={48,30,19,36,36,27,42,42,36,24,30};constintnum\\_items=weights.size();constintnum\\_bins=weights.size();constintbin\\_capacity=100;};\n```\n### Java\n```\nstaticclassDataModel{publicfinaldouble[]weights={48,30,19,36,36,27,42,42,36,24,30};publicfinalintnumItems=weights.length;publicfinalintnumBins=weights.length;publicfinalintbinCapacity=100;}\n```\n### C#\n```\nclassDataModel{publicstaticdouble[]Weights={48,30,19,36,36,27,42,42,36,24,30};publicintNumItems=Weights.Length;publicintNumBins=Weights.Length;publicdoubleBinCapacity=100.0;}\n```\nThe data includes the following:\n* `weights`: A vector containing the weights of the items.\n* `bin\\_capacity`: A single number giving the capacity of the bins.\nThere are no values assigned to the items because the goal of minimizing the\nnumber of bins doesn&#39;t involve value.\nNote that`num\\_bins`is set to the number of items. This is because if the\nproblem has a solution, then the weight of every item must be less than or equal\nto the bin capacity. In that case, the maximum number of bins you could need is\nthe number of items, because you could always put each item in a separate bin.\n### Declare the solver\nThe following code declares the solver.\n### Python\n```\n# Create the mip solver with the SCIP backend.solver=pywraplp.Solver.CreateSolver(\"SCIP\")ifnotsolver:return\n```\n### C++\n```\n// Create the mip solver with the SCIP backend.std::unique\\_ptr&lt;&lt;MPSolver&gt;&gt;solver(MPSolver::CreateSolver(\"SCIP\"));if(!solver){LOG(WARNING)&lt;&lt;\"SCIP solver unavailable.\";return;}\n```\n### Java\n```\n// Create the linear solver with the SCIP backend.MPSolversolver=MPSolver.createSolver(\"SCIP\");if(solver==null){System.out.println(\"Could not create solver SCIP\");return;}\n```\n### C#\n```\n// Create the linear solver with the SCIP backend.Solversolver=Solver.CreateSolver(\"SCIP\");if(solverisnull){return;}\n```\n### Create the variables\nThe following code creates the variables for the program.\n### Python\n```\n# Variables# x[i, j] = 1 if item i is packed in bin j.x={}foriindata[\"items\"]:forjindata[\"bins\"]:x[(i,j)]=solver.IntVar(0,1,\"x\\_%i\\_%i\"%(i,j))# y[j] = 1 if bin j is used.y={}forjindata[\"bins\"]:y[j]=solver.IntVar(0,1,\"y[%i]\"%j)\n```\n### C++\n```\nstd::vector&lt;std::vector&lt;constMPVariable\\*&gt;&gt;x(data.num\\_items,std::vector&lt;constMPVariable\\*&gt;(data.num\\_bins));for(inti=0;i&lt;data.num\\_items;++i){for(intj=0;j&lt;data.num\\_bins;++j){x[i][j]=solver-&gt;MakeIntVar(0.0,1.0,\"\");}}// y[j] = 1 if bin j is used.std::vector&lt;constMPVariable\\*&gt;y(data.num\\_bins);for(intj=0;j&lt;data.num\\_bins;++j){y[j]=solver-&gt;MakeIntVar(0.0,1.0,\"\");}\n```\n### Java\n```\nMPVariable[][]x=newMPVariable[data.numItems][data.numBins];for(inti=0;i&lt;data.numItems;++i){for(intj=0;j&lt;data.numBins;++j){x[i][j]=solver.makeIntVar(0,1,\"\");}}MPVariable[]y=newMPVariable[data.numBins];for(intj=0;j&lt;data.numBins;++j){y[j]=solver.makeIntVar(0,1,\"\");}\n```\n### C#\n```\nVariable[,]x=newVariable[data.NumItems,data.NumBins];for(inti=0;i&lt;data.NumItems;i++){for(intj=0;j&lt;data.NumBins;j++){x[i,j]=solver.MakeIntVar(0,1,$\"x\\_{i}\\_{j}\");}}Variable[]y=newVariable[data.NumBins];for(intj=0;j&lt;data.NumBins;j++){y[j]=solver.MakeIntVar(0,1,$\"y\\_{j}\");}\n```\nAs in the multiple knapsack example, you define an array of variables`x[(i,\nj)]`, whose value is 1 if item`i`is placed in bin`j`, and 0 otherwise.\nFor bin packing, you also define an array of variables,`y[j]`, whose value is 1\nif bin`j`is used&mdash;that is, if any items are packed in it&mdash;and 0\notherwise. The sum of the`y[j]`will be the number of bins used.\n### Define the constraints\nThe following code defines the constraints for the problem:\n### Python\n```\n# Constraints# Each item must be in exactly one bin.foriindata[\"items\"]:solver.Add(sum(x[i,j]forjindata[\"bins\"])==1)# The amount packed in each bin cannot exceed its capacity.forjindata[\"bins\"]:solver.Add(sum(x[(i,j)]\\*data[\"weights\"][i]foriindata[\"items\"])&lt;=y[j]\\*data[\"bin\\_capacity\"])\n```\n### C++\n```\n// Create the constraints.// Each item is in exactly one bin.for(inti=0;i&lt;data.num\\_items;++i){LinearExprsum;for(intj=0;j&lt;data.num\\_bins;++j){sum+=x[i][j];}solver-&g...",
      "url": "https://developers.google.com/optimization/pack/bin_packing"
    },
    {
      "title": "A two-level search algorithm for 2D rectangular packing problem",
      "text": "A two-level search algorithm for 2D rectangular packing problem - ScienceDirect\n[Skip to main content](#screen-reader-main-content)[Skip to article](#screen-reader-main-title)\n[![Elsevier logo](https://www.sciencedirect.com/shared-assets/24/images/elsevier-non-solus-new-grey.svg)ScienceDirect](https://www.sciencedirect.com/)\n[My account](https://www.sciencedirect.com/user/login?targetURL=/science/article/pii/S0360835207000678&amp;from=globalheader)\n[Sign in](https://www.sciencedirect.com/user/institution/login?targetURL=/science/article/pii/S0360835207000678)\n* [Access through**your organization**](https://www.sciencedirect.com/user/institution/login?targetUrl=/science/article/pii/S0360835207000678)\n* [Purchase PDF](https://www.sciencedirect.com/getaccess/pii/S0360835207000678/purchase)\nSearch ScienceDirect\n## Article preview\n* [Abstract](#preview-section-abstract)\n* [Introduction](#preview-section-introduction)\n* [Section snippets](#preview-section-snippets)\n* [References (17)](#preview-section-references)\n* [Cited by (23)](#preview-section-cited-by)\n[![Elsevier](https://www.sciencedirect.com/us-east-1/prod/bd96d51d266808527bf1018bd38b59c0b4bc6286/image/elsevier-non-solus.svg)](https://www.sciencedirect.com/journal/computers-and-industrial-engineering)\n## [Computers &amp; Industrial Engineering](https://www.sciencedirect.com/journal/computers-and-industrial-engineering)\n[Volume 53, Issue 1](https://www.sciencedirect.com/journal/computers-and-industrial-engineering/vol/53/issue/1),August 2007, Pages 123-136\n[![Computers &amp; Industrial Engineering](https://ars.els-cdn.com/content/image/1-s2.0-S0360835207X01694-cov150h.gif)](https://www.sciencedirect.com/journal/computers-and-industrial-engineering/vol/53/issue/1)\n# A two-level search algorithm for 2D rectangular packing problem\nAuthor links open overlay panelMaoChen,[WenqiHuang](https://www.sciencedirect.com/author/36065899800/wenqi-huang)\nShow more\nAdd to Mendeley\nShare\nCite\n[https://doi.org/10.1016/j.cie.2007.04.007](https://doi.org/10.1016/j.cie.2007.04.007)[Get rights and content](https://s100.copyright.com/AppDispatchServlet?publisherName=ELS&amp;contentID=S0360835207000678&amp;orderBeanReset=true)\n## Abstract\nIn this paper, we propose a two-level search algorithm to solve the two-dimensional rectangle[packing problem](https://www.sciencedirect.com/topics/mathematics/packing-problem). In our algorithm, the rectangles are placed into the container one by one and each rectangle should be packed at a position by a corner-occupying action so that it touches two items without overlapping other already packed rectangles. At the first level of our algorithm, a simple algorithm called*A*0selects and packs one rectangle according to the highest degree first rule at every iteration of packing. At the second level,*A*0is itself used to evaluate the benefit of a CCOA more globally. Computational results show that the resulted[packing algorithm](https://www.sciencedirect.com/topics/computer-science/packing-algorithm)called*A*1produces high-density solutions within short running times.\n## Introduction\nThe two-dimensional (2D) rectangular packing problem is an optimization problem of allocating a set of rectangular items to larger containers with the objective of minimizing the waste. The 2D rectangular packing problem has been widely studied in recent decades, as it has numerous applications in the cutting and packing industry, e.g. wood, glass and cloth industries, newspapers paging, VLSI floor planning and so on, with different applications incorporating different constraints and objectives (Chan and Markov, 2004, Hifi and Ouafi, 1998, Lee and Sewell, 1999, Lesh et al., 2004, Lodi et al., 2002). The 2D rectangular packing problem belongs to a subset of classical cutting and packing problems and has been shown to be an NP hard problem (Hochbaum &amp; Maass, 1985). Therefore, various approximation or heuristic algorithms have been proposed for approaching the problem.\nIn rectangle packing, one of the earliest approaches is the so-called bottom-left (BL) heuristic (Baker, Coffman, &amp; Rivest, 1980). In BL, the rectangles to be placed are, starting from the top-right corner of the container, first slide vertically downward as far as possible, followed by sliding horizontally as far as possible to the left, so as to reduce the number of possible packing patterns. One improved variant of BL is the bottom-left-fill (BLF) heuristic, in which the rectangles are placed directly into the lowest positions available and then left justified. Both BL and BLF are later used in meta-heuristic based algorithms. Hybrid algorithms combining genetic algorithm (GA) and deterministic methods were proposed by Jakobs, 1996, Liu and Teng, 1999, Dagli and Poshyanonda, 1997. An empirical investigation of the result of different combinations of simulated annealing (SA) and GA with various heuristics such as BL or BLF was given by Hopper and Turton (2001).\nInspired by enhancing some working experience of professional masons in their everyday work, a Less Flexibility First (LFF) packing principle was proposed in Tam et al., 1998, Wu et al., 2002 for solving the rectangular packing problem. Recently, by introducing a tightness measure to represent the degree of fitting between rectangles and placement locations, an enhanced version of LFF, called LFFT, was proposed in Wu, Chan, and SAGA (2005). More recently, a fast heuristic recursive (HR) algorithm based on divide-and-conquer and greedy strategies was proposed in Zhang, Kang, and Deng (2006), and an effective GA, called SPGAL, was proposed in Bortfeldt (2006) for the four subtypes of the 2D strip packing problem.\nBased on the previous studies (Huang et al., 2005, Tam et al., 1998, Wu et al., 2002), we will propose a quite different class of efficient heuristic for the 2D rectangular packing problem in this paper. Different from the stochastic search methods where the researches are mainly focused on finding the efficient data structures for presenting packing results so that the search space and the processing time of the underling search engine can be minimized, our algorithm is a deterministic algorithm and no data structure is needed. Similar to LFF, our algorithm packs the rectangles into the container one by one and each rectangle should be packed at a position occupying an empty corner in the container. The computational results of our proposed algorithm is very encouraging in terms of both packing density and running time.\nThe rest of this paper is organized as follows: Section 2 gives the problem definition. Section 3 describes the details of the algorithm. Section 4 presents our experimental results for two sets of test instances. We draw our conclusions in Section 5.\n## Section snippets\n## Problem definition\nWe consider the following rectangular packing problem: given a rectangular empty container with fixed width and infinite height and a set of rectangles with various sizes, the rectangle packing problem is to pack each rectangle into the container such that no two rectangles overlap and the used height of the container is minimized. From this optimization problem, an associated decision problem can be formally stated as follows:\nGiven a rectangular board with given width*W*and given height*H*, and\n## Corner-occupying action and degree\n**Definition**Configuration\nA configuration*C*is a pattern (layout) where*m*(0\u2a7d*m*&lt;*n*) rectangles have been already packed inside the container without overlap, and*n*\u2212*m*rectangles remain to be packed into the container.\nA configuration is said to be successful if*m*=*n*, i.e., all the rectangles have been placed inside the container without overlapping. A configuration is said to be failure if*m*&lt;*n*and none of the rectangles outside the container can be packed into the container without overlapping. A configuration is said to be\n## Computational results on rectangle packing problems\nThe first set of tests is done using the Hoppe...",
      "url": "https://www.sciencedirect.com/science/article/abs/pii/S0360835207000678"
    },
    {
      "title": "An Exact Algorithm for the Two-Dimensional Strip-Packing Problem",
      "text": "An Exact Algorithm for the Two-Dimensional Strip-Packing Problem | Semantic Scholar\n[Skip to search form](#search-form)[Skip to main content](#main-content)[Skip to account menu](#account-menu)\n[Semantic ScholarSemantic Scholar&#x27;s Logo](https://www.semanticscholar.org/)\nSearch 231,992,958 papers from all fields of science\nSearch\n* DOI:[10.1287/opre.1100.0833](https://doi.org/10.1287/opre.1100.0833)\n* Corpus ID: 26554551# An Exact Algorithm for the Two-Dimensional Strip-Packing Problem\n```\n@article{Boschetti2010AnEA,\ntitle={An Exact Algorithm for the Two-Dimensional Strip-Packing Problem},\nauthor={Marco A. Boschetti and Lorenza Montaletti},\njournal={Oper. Res.},\nyear={2010},\nvolume={58},\npages={1774-1791},\nurl={https://api.semanticscholar.org/CorpusID:26554551}\n}\n```\n* [Marco A. Boschetti](https://www.semanticscholar.org/author/Marco-A.-Boschetti/2032887),[L. Montaletti](https://www.semanticscholar.org/author/L.-Montaletti/2353793)\n* Publishedin[Operational Research](https://www.semanticscholar.org/venue?name=Operational%20Research)1 November 2010\n* Mathematics, Computer Science\nThis paper considers the two-dimensional strip-packing problem (2SP) in which a set of rectangular items have to be orthogonally packed, without overlapping, into a strip of a given width and\u2026Expand\n[View via Publisher](https://doi.org/10.1287/opre.1100.0833)\nSave to LibrarySave\nCreate AlertAlert\nCite\nShare\n62 Citations\n[\nHighly Influential Citations\n](#citing-papers)[](https://www.semanticscholar.org/faq#influential-citations)\n10\n[\nBackground Citations\n](#citing-papers)\n18\n[\nMethods Citations\n](#citing-papers)\n15\n[View All](#citing-papers)\n## Topics\nAI-Generated\n[NP-hard(opens in a new tab)](https://topics-beta.apps.semanticscholar.org/topic/42067575974?corpusId=26554551)[Rectangular Items(opens in a new tab)](https://topics-beta.apps.semanticscholar.org/topic/48618985407?corpusId=26554551)[Constructive Heuristics(opens in a new tab)](https://topics-beta.apps.semanticscholar.org/topic/32612717319?corpusId=26554551)[Orthogonally Packing(opens in a new tab)](https://topics-beta.apps.semanticscholar.org/topic/14349980845?corpusId=26554551)[Strip Packing Problem(opens in a new tab)](https://topics-beta.apps.semanticscholar.org/topic/21339777657?corpusId=26554551)\n## 62 Citations\nCitation Type\nHas PDF\nAuthor\nMore Filters\nMore Filters\nFilters\nSort by RelevanceSort by Most Influenced PapersSort by Citation CountSort by Recency\n[### An Effective Corner Increment-Based Algorithm for the Two-Dimensional Strip Packing Problem\n](https://www.semanticscholar.org/paper/An-Effective-Corner-Increment-Based-Algorithm-for-Chen-Chen/0e88c322d987b988f1d32f65f3e8ff322b68f428)[Zhen Chen](https://www.semanticscholar.org/author/Zhen-Chen/2117102384)[Jianli Chen](https://www.semanticscholar.org/author/Jianli-Chen/1946487)\nComputer Science\n[IEEE Access](https://www.semanticscholar.org/venue?name=IEEE%20Access)\n* 2018\nTLDR\nThis paper addresses the 2-D strip packing problem without guillotine constraint and presents an effective corner increment-based algorithm that uses the AVL tree and segment tree to implement a constructive heuristic.Expand\n* [\n11\n](https://www.semanticscholar.org/paper/0e88c322d987b988f1d32f65f3e8ff322b68f428#citing-papers)\n* [\nPDF\n](https://www.semanticscholar.org/paper/0e88c322d987b988f1d32f65f3e8ff322b68f428)\n* 2 Excerpts\nSave\n[### Exact solutions for the 2d-strip packing problem using the positions-and-covering methodology\n](https://www.semanticscholar.org/paper/Exact-solutions-for-the-2d-strip-packing-problem-Cid-Garc%C3%ADa-R%C3%ADos-Sol%C3%ADs/3059ec51b22b1d664e5487d93e1b4f64c18dde1e)[N\u00e9stor M. Cid-Garc\u00eda](https://www.semanticscholar.org/author/N%C3%A9stor-M.-Cid-Garc%C3%ADa/1403977231)[Y. A. R\u00edos-Sol\u00eds](https://www.semanticscholar.org/author/Y.-A.-R%C3%ADos-Sol%C3%ADs/1403027497)\nMathematics, Computer Science\n[PloS one](https://www.semanticscholar.org/venue?name=PloS%20one)\n* 2021\nTLDR\nThis work uses the Positions and Covering methodology to obtain exact solutions for the two-dimensional, non-guillotine restricted, strip packing problem, and is the first approach that generates optimal solutions for some literature instances for which the optimal solution was unknown before this study.Expand\n* [\n6\n](https://www.semanticscholar.org/paper/3059ec51b22b1d664e5487d93e1b4f64c18dde1e#citing-papers)[[PDF]](https://www.semanticscholar.org/reader/3059ec51b22b1d664e5487d93e1b4f64c18dde1e)\nSave\n[### A theoretical and experimental study of fast lower bounds for the two-dimensional bin packing problem\n](https://www.semanticscholar.org/paper/A-theoretical-and-experimental-study-of-fast-lower-Serairi-Haouari/a1faa5766970c71dc4e79a117a2b2660ec1b27cf)[Mehdi Serairi](https://www.semanticscholar.org/author/Mehdi-Serairi/2842118)[M. Haouari](https://www.semanticscholar.org/author/M.-Haouari/145829255)\nMathematics, Computer Science\nRAIRO Oper. Res.\n* 2018\nTLDR\nIt is found that the so-called Carlier-Clautiaux-Moukrim lower bounds exhibits an excellent relative performance and yields the tightest value for all of the benchmark instances.Expand\n* [\n10\n](https://www.semanticscholar.org/paper/a1faa5766970c71dc4e79a117a2b2660ec1b27cf#citing-papers)\n* [\nPDF\n](https://www.semanticscholar.org/paper/a1faa5766970c71dc4e79a117a2b2660ec1b27cf)\n* 1 Excerpt\nSave\n[### An open space based heuristic for the 2D strip packing problem with unloading constraints\n](https://www.semanticscholar.org/paper/An-open-space-based-heuristic-for-the-2D-strip-with-Wei-Wang/0f131e9da8e878dce97ae04ffc819c5843ce402a)[Lijun Wei](https://www.semanticscholar.org/author/Lijun-Wei/2165769275)[Yongsheng Wang](https://www.semanticscholar.org/author/Yongsheng-Wang/2107961506)[Huibing Cheng](https://www.semanticscholar.org/author/Huibing-Cheng/104263608)[Jianghai Huang](https://www.semanticscholar.org/author/Jianghai-Huang/1720746390)\nEngineering\n[Applied Mathematical Modelling](https://www.semanticscholar.org/venue?name=Applied%20Mathematical%20Modelling)\n* 2019\n* [\n23\n](https://www.semanticscholar.org/paper/0f131e9da8e878dce97ae04ffc819c5843ce402a#citing-papers)\n* [\nPDF\n](https://www.semanticscholar.org/paper/0f131e9da8e878dce97ae04ffc819c5843ce402a)\nSave\n[### New Lower Bounds for the Three-Dimensional Strip Packing Problem\n](https://www.semanticscholar.org/paper/New-Lower-Bounds-for-the-Three-Dimensional-Strip-Hoffmann/be8b30dab916bebc0aa10379e999a689cc679746)[Kirsten Hoffmann](https://www.semanticscholar.org/author/Kirsten-Hoffmann/2052382250)\nMathematics\n[OR](https://www.semanticscholar.org/venue?name=OR)\n* 2013\nTLDR\nNew lower bounds derived from different relaxations of the mathematical formulation of the three-dimensional strip packing problem (SPP3) are presented and dominance relations between different bounds are shown and the worst case performance ratio of some bounds is limited.Expand\nSave\n[### Upper bounds for heuristic approaches to the strip packing problem\n](https://www.semanticscholar.org/paper/Upper-bounds-for-heuristic-approaches-to-the-strip-Buchwald-Scheithauer/f1f986a40f5b7db96d2232ad1fbfb11d85f68189)[Torsten Buchwald](https://www.semanticscholar.org/author/Torsten-Buchwald/2542305)[G. Scheithauer](https://www.semanticscholar.org/author/G.-Scheithauer/1720364)\nComputer Science, Mathematics\n[Int. Trans. Oper. Res.](https://www.semanticscholar.org/venue?name=Int.%20Trans.%20Oper.%20Res.)\n* 2014\nTLDR\nAn algorithm for the two-dimensional strip packing problem (SPP) that improves the packing of the FFDH heuristic, and it is proved that the combination of both lower bounds also has an absolute worst-case performance ratio of at most 5 for the standard three-dimensional SPP.Expand\n* [\n7\n](https://www.semanticscholar.org/paper/f1f986a40f5b7db96d2232ad1fbfb11d85f68189#citing-papers)\n* [\nPDF\n](https://www.semanticscholar.org/paper/f1f986a40f5b7db96d2232ad1fbfb11d85f68189)\nSave\n[### Combinatorial Benders&#x27; Cuts for the Strip Packing Problem\n](https://www.semanticscholar.org/paper/Combinatorial-Benders&#x27;-Cuts-for-the...",
      "url": "https://www.semanticscholar.org/paper/An-Exact-Algorithm-for-the-Two-Dimensional-Problem-Boschetti-Montaletti/54b5e23153af64dd31f5f49db44cc9437536d86c"
    },
    {
      "title": "Extended local search algorithm based on nonlinear programming for two-dimensional irregular strip packing problem",
      "text": "Extended local search algorithm based on nonlinear programming for two-dimensional irregular strip packing problem - ScienceDirect\n[Skip to main content](#screen-reader-main-content)[Skip to article](#screen-reader-main-title)\n[![Elsevier logo](https://www.sciencedirect.com/shared-assets/24/images/elsevier-non-solus-new-grey.svg)ScienceDirect](https://www.sciencedirect.com/)\n[My account](https://www.sciencedirect.com/user/login?targetURL=/science/article/pii/S0305054811001596&amp;from=globalheader)\n[Sign in](https://www.sciencedirect.com/user/institution/login?targetURL=/science/article/pii/S0305054811001596)\n* [Access through**your organization**](https://www.sciencedirect.com/user/institution/login?targetUrl=/science/article/pii/S0305054811001596)\n* [Purchase PDF](https://www.sciencedirect.com/getaccess/pii/S0305054811001596/purchase)\nSearch ScienceDirect\n## Article preview\n* [Abstract](#preview-section-abstract)\n* [Introduction](#preview-section-introduction)\n* [Section snippets](#preview-section-snippets)\n* [References (20)](#preview-section-references)\n* [Cited by (70)](#preview-section-cited-by)\n[![Elsevier](https://www.sciencedirect.com/us-east-1/prod/bd96d51d266808527bf1018bd38b59c0b4bc6286/image/elsevier-non-solus.svg)](https://www.sciencedirect.com/journal/computers-and-operations-research)\n## [Computers &amp; Operations Research](https://www.sciencedirect.com/journal/computers-and-operations-research)\n[Volume 39, Issue 3](https://www.sciencedirect.com/journal/computers-and-operations-research/vol/39/issue/3),March 2012, Pages 678-686\n[![Computers &amp; Operations Research](https://ars.els-cdn.com/content/image/1-s2.0-S0305054811X00084-cov150h.gif)](https://www.sciencedirect.com/journal/computers-and-operations-research/vol/39/issue/3)\n# Extended local search algorithm based on nonlinear programming for two-dimensional irregular strip packing problem\nAuthor links open overlay panelStephen C.H.Leunga,YangbinLinb,DefuZhangb\nShow more\nAdd to Mendeley\nShare\nCite\n[https://doi.org/10.1016/j.cor.2011.05.025](https://doi.org/10.1016/j.cor.2011.05.025)[Get rights and content](https://s100.copyright.com/AppDispatchServlet?publisherName=ELS&amp;contentID=S0305054811001596&amp;orderBeanReset=true)\n## Abstract\nThis paper presents an extended local search algorithm (ELS) for the irregular strip[packing problem](https://www.sciencedirect.com/topics/social-sciences/packing-problem). It adopts two neighborhoods, swapping two given polygons in a placement and placing one polygon into a new position. The local search algorithm is used to minimize the overlap on the basis of the neighborhoods mentioned above and the unconstrained[nonlinear programming](https://www.sciencedirect.com/topics/earth-and-planetary-sciences/nonlinear-programming)model is adopted to further minimize the overlap during the search process. Moreover, the[tabu](https://www.sciencedirect.com/topics/social-sciences/tabu)search algorithm is used to avoid[local minima](https://www.sciencedirect.com/topics/engineering/local-minimum), and a compact algorithm is presented to improve the result. The results of standard test instances indicate that when compared with other existing algorithms, the presented algorithm does not only show some signs of competitive power but also updates several best known results.\n## Introduction\nThe irregular strip packing problem, also known as the nesting problem, has a wide area of applications. Given a set of irregular shapes and a rectangular strip with a fixed width and an arbitrary length, the target of the two-dimensional irregular strip packing problem is to place all shapes within the strip such that the length of the strip is minimized and the irregular shapes do not overlap. A classic example application is clothing industry. Several pieces of clothes will be cut from a roll of fabric and the objective is to minimize the waste of fabric. The fabric has a fixed width and its length can be generally assumed infinite; so the problem is to minimize the length required for producing the specified number of irregular shapes.\nThe irregular strip packing problem is a NP-hard combinatorial optimization problem [1]. Numerous papers on nesting problem have been published since the first paper by Art [2]. Meta-heuristics are often used to solve this problem. Hopper and Turton [3] reviewed these methods, and a summary of geometric methods was published by Bennell and Oliveira [4]. As research progressed, further breakthroughs in algorithms for this problem have achieved in recent years. When compared with the previous years, these solutions have markedly improved the effect and speed of nesting results. The typical methods include Burke et al. [5], Gomes and Oliveira [6], Egeblad et al. [7], Imamichi et al. [8], etc.\nAlbano and Sapuppo [9] proposed an algorithm that places each shape at the bottom-left position, and the sequence of places is obtained by tree search. Jakobs [10] proposed a two-stage solution which first generates the rectangular enclosure of each irregular shape, and then finds the placement for these enclosures through a genetic algorithm. Secondly, a shrinking algorithm moves the shapes to another one as close as possible using the idea of the bottom-left heuristic. Gomes and Oliveira [11] based on bottom-left heuristic and find a good placement by exchanging two shapes in the layout. Dowsland et al. [12] developed a compact algorithm to improve the bottom-left heuristic algorithm. The algorithm first gets the initial placement by the bottom-left heuristic, and then uses a shaking process to compact the placement. Burke et al. [5] presented a new bottom-left heuristic algorithm based on discretization, and combination with hill climbing or tabu search to get a high quality solution. This algorithm can also pack the shapes with circular arcs and holes. Egeblad et al. [7] proposed an efficient fast local search method whose neighborhood is any horizontal or vertical translation of a given shape. They also formulated a polynomial time algorithm to find a translation with minimum overlap area between the given polygon and the other polygons in the current placement. Gomes and Oliveira [6] presented a separation algorithm to locally optimize the placement based on linear programming models, and used simulated annealing to guide the search. A new separation algorithm based on unconstrained nonlinear programming is proposed by Imamichi et al. [8]. They also designed an algorithm that swaps two polygons in a placement, and then the algorithms are combined as a component into an iterated local search algorithm for the overlap minimization problem. This method yielded several best known results on the standard test instances. Our algorithm is based on a separation algorithm presented by Imamichi et al. [8], and local search is adopted to guide the search. Moreover, a tabu search algorithm is used to avoid local minima and a compacted algorithm is used to improve the packing results.\n## Section snippets\n## Formulation\nIn this section, some fundamental elements of geometry are first defined, before formulation of the irregular strip packing problem algorithm is given.\n**Definition 1 (point)**\nA point*p*in two-dimensional space is represented by a pair:p=(px,py)\u2208R2.\n**Definition 2 (line segment)**\nA line segment*s*is a point set defined by two endpoints*p**a*and*p**b*:s={p\u2208R2,t\u2208[0,1]|p=pa+t(pb\u2212pa)}.\n**Definition 3 (polygon)**\nA polygon is a plane figure bounded by a closed path composes of a finite sequence of line segments denoted by*S*. No cross occurs in any pair of line segments in*S*. Here we\n## Geometric approaches\nCompared with the regular polygon, e.g., triangle and rectangle, the irregular polygon is much more complex and more time is taken in dealing with some basic geometric problems, i.e., determining if two polygons are overlapping each other, and determining the minimum translation vector that can separate two overlap polygons. The increase in ge...",
      "url": "https://www.sciencedirect.com/science/article/abs/pii/S0305054811001596"
    }
  ]
}