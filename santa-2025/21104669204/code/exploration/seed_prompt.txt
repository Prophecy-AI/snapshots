# Santa 2025 - Christmas Tree Packing Challenge

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons into the smallest possible square bounding box for configurations of 1-200 trees.

**Scoring:** score = Σ(side_length² / n) for n=1 to 200 (lower is better)
**Target:** Beat 68.931058

## Tree Shape
Each tree is a 15-vertex polygon with:
- Tip at (0, 0.8)
- Three tiers of branches at y=0.5, 0.25, 0
- Trunk from y=0 to y=-0.2
- Width: 0.7 at base, 0.4 mid, 0.25 top
- Trunk width: 0.15

Trees can be rotated (0-360 degrees) and positioned at any (x, y) coordinates.

## CRITICAL: Download Pre-Computed Solutions

**ALL top kernels use pre-computed solutions from Kaggle datasets.** These contain HOURS of optimization results.

Key datasets to look for:
- `santa-submission` - Contains bbox3 binary and optimized CSV
- `santa-2025-csv` - Contains pre-optimized solutions  
- `bucket-of-chump` - Contains pre-optimized solutions
- SmartManoj's GitHub: `https://raw.githubusercontent.com/SmartManoj/Santa-Scoreboard/main/submission.csv`

**FIRST STEP:** Download and use these pre-computed solutions as baseline!

## Top Approaches from Public Kernels

### 1. bbox3 Binary Optimizer (Most Common)
All top kernels use a compiled `bbox3` binary with parameters:
- `-n [iterations]` - Number of optimization iterations (1000-5000)
- `-r [restarts]` - Number of random restarts (4-96)

Example: `./bbox3 -n 2000 -r 96`

**Source:** See `../research/kernels/saspav_santa-submission/` and `../research/kernels/jazivxt_why-not/`

### 2. Santa Claude C++ Optimizer (tree_packer_v21)
Custom C++ implementation with:
- Simulated annealing with swap moves
- Multi-start with different initial angles
- Squeeze and compaction operations
- Local search with 8-directional moves
- Backward propagation (bp.cpp) - improves smaller configs from larger ones

Compile: `g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer_v21.exe a.cpp`
Run: `./tree_packer_v21.exe -n 5000 -r 16`

**Source:** See `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

### 3. fix_direction Rotation Optimization
Post-processing step that:
1. Collects all polygon vertices
2. Computes convex hull
3. Uses scipy.minimize_scalar to find optimal rotation angle (0-90°)
4. Rotates entire configuration to minimize bounding box

**Source:** See `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

## Key Optimization Techniques

### Collision Detection
- Use Shapely library with STRtree for efficient spatial queries
- Check `polygon.intersects()` but allow `polygon.touches()` (touching is OK)
- Use high-precision Decimal arithmetic (25-30 digits) for coordinates

### Squeeze Operation
```python
# Iteratively scale configuration toward center
for scale in [0.9995, 0.999, ...]:
    trial_positions = center + (positions - center) * scale
    if no_overlap(trial_positions):
        positions = trial_positions
    else:
        break
```

### Compaction
Move each tree toward center in small steps until collision, then back up.

### Local Search
- Try 8-directional moves (N, S, E, W, NE, NW, SE, SW)
- Try rotation adjustments (±5°, ±2°, ±0.8°, ±0.3°, ±0.1°)
- Accept moves that reduce bounding box

### Backward Propagation
Key insight: A good n-tree configuration can be derived from (n+1)-tree by removing one tree.
1. Start from N=200 configuration
2. For each n from 200 down to 2:
   - Try removing each boundary-touching tree
   - If result improves n-1 configuration, save it

### Overlap Repair
If optimization creates overlaps, replace those groups from donor (baseline) file:
```python
for failed_n in overlapping_groups:
    replace_group(target_file, donor_file, group_id=f'{failed_n:03d}')
```

## Recommended Experiment Pipeline

### Experiment 1: Baseline from Pre-computed Solution
1. Try to download pre-computed solution from Kaggle dataset or GitHub
2. If not available, use sample_submission.csv as starting point
3. Validate no overlaps
4. Calculate score
5. Expected: Should be close to or beat target ~68.9

### Experiment 2: bbox3 Optimization (if binary available)
1. Start from baseline
2. Run `./bbox3 -n 2000 -r 96` (or similar parameters)
3. Apply fix_direction rotation optimization
4. Repair any overlaps from donor file
5. Validate and score

### Experiment 3: Custom C++ Optimizer
1. Compile tree_packer_v21.cpp with OpenMP
2. Run with `-n 5000 -r 16` or higher
3. Apply backward propagation (bp.exe)
4. Validate and score

### Experiment 4: Python-based Optimization
If C++ tools not available, implement in Python:
1. Greedy placement with weighted angles (sin(2*angle))
2. Local search with small position/rotation perturbations
3. Squeeze toward center
4. Rotation optimization for bounding box

### Experiment 5: Ensemble/Merge Best Configurations
1. For each n=1 to 200, take the best configuration from all experiments
2. Merge into single submission
3. Validate no overlaps

## Validation Code

```python
from shapely.geometry import Polygon
from shapely.strtree import STRtree
from shapely import affinity
from decimal import Decimal, getcontext
import numpy as np
import pandas as pd

getcontext().prec = 30
scale_factor = Decimal("1")

class ChristmasTree:
    def __init__(self, center_x="0", center_y="0", angle="0"):
        self.center_x = Decimal(str(center_x))
        self.center_y = Decimal(str(center_y))
        self.angle = Decimal(str(angle))
        
        # Tree dimensions
        trunk_w, trunk_h = Decimal("0.15"), Decimal("0.2")
        base_w, mid_w, top_w = Decimal("0.7"), Decimal("0.4"), Decimal("0.25")
        tip_y, tier_1_y, tier_2_y = Decimal("0.8"), Decimal("0.5"), Decimal("0.25")
        base_y, trunk_bottom_y = Decimal("0.0"), -trunk_h
        
        # 15 vertices
        initial_polygon = Polygon([
            (0, float(tip_y)),
            (float(top_w/2), float(tier_1_y)),
            (float(top_w/4), float(tier_1_y)),
            (float(mid_w/2), float(tier_2_y)),
            (float(mid_w/4), float(tier_2_y)),
            (float(base_w/2), float(base_y)),
            (float(trunk_w/2), float(base_y)),
            (float(trunk_w/2), float(trunk_bottom_y)),
            (float(-trunk_w/2), float(trunk_bottom_y)),
            (float(-trunk_w/2), float(base_y)),
            (float(-base_w/2), float(base_y)),
            (float(-mid_w/4), float(tier_2_y)),
            (float(-mid_w/2), float(tier_2_y)),
            (float(-top_w/4), float(tier_1_y)),
            (float(-top_w/2), float(tier_1_y)),
        ])
        
        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))
        self.polygon = affinity.translate(rotated, xoff=float(self.center_x), yoff=float(self.center_y))

def has_overlap(trees):
    if len(trees) <= 1:
        return False
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False

def get_score(trees, n):
    xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])
    side = max(xys.max(axis=0) - xys.min(axis=0))
    return side**2 / n

def calculate_total_score(submission_df, max_n=200):
    total_score = 0.0
    for n in range(1, max_n + 1):
        group = submission_df[submission_df["id"].str.startswith(f"{n:03d}_")]
        trees = []
        for _, row in group.iterrows():
            x = str(row["x"])[1:]  # Remove 's' prefix
            y = str(row["y"])[1:]
            deg = str(row["deg"])[1:]
            trees.append(ChristmasTree(x, y, deg))
        if trees:
            total_score += get_score(trees, n)
    return total_score
```

## Submission Format
- CSV with columns: id, x, y, deg
- id format: `{n:03d}_{tree_index}` (e.g., "001_0", "002_0", "002_1")
- Values prefixed with 's': `s0.123456`, `s-0.789`
- Coordinates constrained to -100 ≤ x, y ≤ 100

## Key Insights

1. **Pre-computed solutions are essential** - Don't try to optimize from scratch
2. **bbox3 binary is the workhorse** - Most improvements come from this tool
3. **fix_direction provides easy gains** - Rotation optimization is cheap and effective
4. **Backward propagation is powerful** - Smaller configs benefit from larger ones
5. **Always validate overlaps** - Invalid submissions will error
6. **Use high precision** - Decimal(25-30) to avoid floating point issues
7. **Trees can interlock** - Opposite-facing trees can nest together efficiently
8. **Boundary trees matter most** - Focus optimization on trees touching the bounding box

## Advanced Techniques from Research

### No-Fit Polygon (NFP)
- Pre-compute collision-free regions for each tree pair
- Enables faster collision checking during optimization

### Basin Hopping / Partitioned Action Space
- Approximate trees as squares to find large empty spaces
- Partition items by size for targeted optimization

### Formulation Space Search
- Alternate between Cartesian and polar coordinates
- Different formulations have different local optima

## Data Files
- `/home/data/sample_submission.csv` - Basic greedy solution (not optimized)
- Pre-computed solutions from Kaggle datasets (download required)

## References
- Getting Started: `../research/kernels/inversion_santa-2025-getting-started/`
- Santa-submission: `../research/kernels/saspav_santa-submission/`
- Why Not: `../research/kernels/jazivxt_why-not/`
- Santa Claude: `../research/kernels/smartmanoj_santa-claude/`
