# Santa 2025 - Christmas Tree Packing Challenge

## Problem Overview
Pack Christmas tree toys (irregular polygon shapes) into the smallest square bounding box for N=1 to 200 trees.
- Score = sum of (side_length^2 / N) for all N from 1 to 200
- Lower score is better
- **Target: 68.919154**
- Current best public solutions: ~70.66
- **Gap to close: 1.74 points (2.5% improvement needed)**

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Trunk: width 0.15, height 0.2
- Base tier: width 0.7
- Middle tier: width 0.4
- Top tier: width 0.25
- Tip at y=0.8
- Trees can be rotated (0-360 degrees)
- Position defined by (x, y) center of trunk top

## Pre-Optimized Resources (CRITICAL - USE THESE!)
1. **saspav/santa-2025-csv dataset**: Contains pre-optimized submission.csv and bbox3 binary
   - Download: `kaggle datasets download -d saspav/santa-2025-csv --unzip`
   - Score: ~70.66

2. **jazivxt/bucket-of-chump dataset**: Another pre-optimized solution
   - Download: `kaggle datasets download -d jazivxt/bucket-of-chump --unzip`
   - Score: ~70.66

## Key Optimization Approaches

### 1. bbox3 C++ Optimizer (Primary Tool)
The bbox3 binary is a simulated annealing optimizer with 14 move types:
- Single-tree moves: translate, rotate, move+rotate
- Pull to center / Push from center
- Swap positions between trees
- Bbox pull/push (move toward/away from bounding box center)
- Corner tree focus
- Fluid dynamics moves
- Hinge pivot
- Density gradient flow
- Global boundary tension

Usage: `./bbox3 -n <iterations> -r <restarts>`
- Higher n and r values = more optimization time
- Typical values: n=1000-2000, r=30-90

### 2. fix_direction (Rotation Optimization)
After bbox3 optimization, apply rotation optimization to minimize bounding box:
- Uses scipy.optimize.minimize_scalar to find optimal rotation angle
- Rotates entire configuration to minimize max(width, height)
- Can reduce score by tightening the bounding box

### 3. Compaction/Squeeze
- Move all trees toward center by scaling factor
- Start with scale=0.9995, decrease until overlap occurs
- Helps reduce bounding box after SA optimization

### 4. Overlap Detection and Repair
- Use Shapely library for polygon intersection tests
- STRtree for efficient spatial indexing
- Repair overlaps by pushing trees apart using separation vectors

## Simulated Annealing Best Practices (from research)

### Optimal SA Parameters for 2D Packing:
1. **Initial Temperature**: Set so 80-90% of random moves are accepted
2. **Cooling Schedule**: Geometric decay T_{k+1} = α * T_k with α = 0.90-0.99 (slow decay works best)
3. **Markov Chain Length**: c * n moves per temperature (where n = number of items)
4. **Termination**: When acceptance rate drops below 5% or max iterations reached
5. **Adaptive Schedules**: Adjust α based on observed acceptance ratio

### Move Operators to Consider:
- Translation (small and large steps)
- Rotation (fine and coarse)
- Swap positions between trees
- Cluster moves (move groups of nearby trees together)
- Boundary tree focus (prioritize trees on bounding box edge)

## Strategy for Beating Target (68.92)

### Gap Analysis
- Current best public: 70.66
- Target: 68.92
- Gap: 1.74 points (2.5% improvement needed)

### Per-N Score Distribution
Small N values (1-10) contribute most to total score due to side^2/N formula:
- N=1: 0.66 (highest per-N contribution)
- N=2: 0.45
- N=3-10: 0.37-0.42 each

**INSIGHT**: Improving small N configurations has outsized impact on total score!

### Recommended Experiments

#### Experiment 1: Baseline with Pre-optimized Solution
1. Download saspav/santa-2025-csv dataset
2. Run bbox3 with extended parameters: `./bbox3 -n 5000 -r 100`
3. Apply fix_direction
4. Validate and submit
Expected: Match or slightly improve on 70.66

#### Experiment 2: Focus on Small N Optimization (HIGH PRIORITY)
Small N values have highest per-N scores. Strategies:
1. For N=1-10, try exhaustive search over rotation angles (0-360 in 0.1 degree steps)
2. Use tighter compaction for small N
3. For N=1: Find optimal single-tree rotation (minimize bounding box)
4. For N=2-5: Try all permutations of tree arrangements

#### Experiment 3: Asymmetric Solutions
Discussion suggests asymmetric solutions may outperform symmetric ones:
- Don't force symmetry in tree arrangements
- Allow SA to find asymmetric local optima
- May require longer optimization time

#### Experiment 4: Multi-Start with Different Seeds
- Run bbox3 with multiple random seeds (10-20 runs)
- Keep best solution from each run
- **Combine best per-N solutions from different runs** (key technique!)

#### Experiment 5: Custom C++ Optimizer
Modify bbox3 source code:
- Add new move types (e.g., cluster moves, rotation-only moves)
- Tune temperature schedule for SA (try slower cooling)
- Add specialized moves for boundary trees
- Implement adaptive neighborhood size

#### Experiment 6: Per-N Specialization
- Different optimization strategy for different N ranges:
  - N<20: Exhaustive/near-exhaustive search with many restarts
  - N=20-100: Standard SA with many restarts, focus on boundary trees
  - N>100: Tessellation-based approaches, then local refinement

#### Experiment 7: Hybrid Algorithms
- Combine SA with local search (hill climbing)
- Use genetic algorithm for solution combination
- Implement beam search for small N

### Technical Implementation Notes

1. **Precision**: Use Decimal with prec=30 for calculations
2. **Submission format**: Prepend 's' to all numeric values
3. **Validation**: Check for overlaps before submission
4. **Coordinate bounds**: -100 <= x, y <= 100

### Code Structure
```python
# Score calculation
def get_total_score(dict_of_side_length):
    score = Decimal('0')
    for k, v in dict_of_side_length.items():
        score += v ** 2 / Decimal(str(k))
    return score

# Parse submission
def parse_csv(csv_path):
    result = pd.read_csv(csv_path)
    result['x'] = result['x'].str.strip('s')
    result['y'] = result['y'].str.strip('s')
    result['deg'] = result['deg'].str.strip('s')
    # ... build tree objects
```

### Key Kernels to Reference
1. `../research/kernels/jazivxt_why-not/` - bbox3 source code (C++)
2. `../research/kernels/saspav_santa-submission/` - Full pipeline
3. `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - 3-hour runner
4. `../research/kernels/smartmanoj_santa-claude/` - Alternative C++ optimizer

### Validation Checklist
- [ ] No overlapping trees (use Shapely intersection check)
- [ ] All coordinates within [-100, 100]
- [ ] Correct submission format (s-prefixed values)
- [ ] All 200 configurations present (N=1 to 200)
- [ ] Total 20100 tree entries

## Advanced Techniques from Research

### No-Fit Polygon (NFP)
- Precompute NFP for tree polygon with itself
- Enables O(1) overlap checking during optimization
- Could significantly speed up SA iterations
- Key technique in industrial nesting problems

### Bottom-Left (BL) Algorithm
- Alternative to SA for initial placement
- Pack trees from left to right, bottom to top
- May provide better starting point for SA
- Fast but sub-optimal alone

### Tessellation Approaches (for large N)
- For N>100, consider regular tessellation patterns
- Hexagonal or square grid arrangements
- Optimize rotation within tessellation
- Then apply local refinement

### Meta-CSP Approach
- Model pairwise relationships (above, below, left, right)
- Use constraint propagation for pruning
- May find better solutions for small N

## Expected Progression
1. Experiment 1: ~70.5-70.7 (baseline)
2. Experiment 2-3: ~70.0-70.5 (small improvements from small N focus)
3. Experiment 4-5: ~69.5-70.0 (moderate improvements from multi-start and custom optimizer)
4. Experiment 6-7: Target 68.92 (requires novel approach + per-N specialization)

## Critical Insights

1. **The gap of 1.74 points is significant** - simple parameter tuning won't close it
2. **Small N values are key** - focus optimization effort there
3. **Combine best per-N solutions** - don't use single monolithic solution
4. **Asymmetric solutions often beat symmetric** - don't constrain search space
5. **Multiple restarts essential** - SA can get stuck in local optima
6. **Boundary trees define score** - focus moves on trees touching bounding box

## Potential Breakthrough Approaches

1. **Per-N Solution Merging**: Run many optimizations, keep best solution for each N
2. **Specialized Small-N Solver**: Exhaustive search for N<10
3. **Tessellation + Refinement**: Start with regular pattern for large N, then optimize
4. **Parallel SA with Solution Sharing**: Multiple SA instances sharing best solutions
5. **Machine Learning for Move Selection**: Learn which moves work best for each N range
