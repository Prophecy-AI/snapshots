# Santa 2025 - Christmas Tree Packing Challenge

## Problem Overview
Pack Christmas tree toys (irregular polygon shapes) into the smallest square bounding box for N=1 to 200 trees.
- Score = sum of (side_length^2 / N) for all N from 1 to 200
- Lower score is better
- Target: 68.919154
- Current best public solutions: ~70.66

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Trunk: width 0.15, height 0.2
- Base tier: width 0.7
- Middle tier: width 0.4
- Top tier: width 0.25
- Tip at y=0.8
- Trees can be rotated (0-360 degrees)
- Position defined by (x, y) center of trunk top

## Pre-Optimized Resources
1. **saspav/santa-2025-csv dataset**: Contains pre-optimized submission.csv and bbox3 binary
   - Download: `kaggle datasets download -d saspav/santa-2025-csv --unzip`
   - Score: ~70.66

2. **jazivxt/bucket-of-chump dataset**: Another pre-optimized solution
   - Download: `kaggle datasets download -d jazivxt/bucket-of-chump --unzip`
   - Score: ~70.66

## Key Optimization Approaches

### 1. bbox3 C++ Optimizer (Primary Tool)
The bbox3 binary is a simulated annealing optimizer with 14 move types:
- Single-tree moves: translate, rotate, move+rotate
- Pull to center / Push from center
- Swap positions between trees
- Bbox pull/push (move toward/away from bounding box center)
- Corner tree focus
- Fluid dynamics moves
- Hinge pivot
- Density gradient flow
- Global boundary tension

Usage: `./bbox3 -n <iterations> -r <restarts>`
- Higher n and r values = more optimization time
- Typical values: n=1000-2000, r=30-90

### 2. fix_direction (Rotation Optimization)
After bbox3 optimization, apply rotation optimization to minimize bounding box:
- Uses scipy.optimize.minimize_scalar to find optimal rotation angle
- Rotates entire configuration to minimize max(width, height)
- Can reduce score by tightening the bounding box

### 3. Compaction/Squeeze
- Move all trees toward center by scaling factor
- Start with scale=0.9995, decrease until overlap occurs
- Helps reduce bounding box after SA optimization

### 4. Overlap Detection and Repair
- Use Shapely library for polygon intersection tests
- STRtree for efficient spatial indexing
- Repair overlaps by pushing trees apart using separation vectors

## Strategy for Beating Target (68.92)

### Gap Analysis
- Current best public: 70.66
- Target: 68.92
- Gap: 1.74 points (2.5% improvement needed)

### Per-N Score Distribution
Small N values (1-10) contribute most to total score due to side^2/N formula:
- N=1: 0.66 (highest per-N contribution)
- N=2: 0.45
- N=3-10: 0.37-0.42 each

### Recommended Experiments

#### Experiment 1: Baseline with Pre-optimized Solution
1. Download saspav/santa-2025-csv dataset
2. Run bbox3 with extended parameters: `./bbox3 -n 5000 -r 100`
3. Apply fix_direction
4. Validate and submit
Expected: Match or slightly improve on 70.66

#### Experiment 2: Focus on Small N Optimization
Small N values have highest per-N scores. Strategies:
1. For N=1-10, try exhaustive search over rotation angles
2. Use tighter compaction for small N
3. Consider symmetric arrangements for small N

#### Experiment 3: Asymmetric Solutions
Discussion suggests asymmetric solutions may outperform symmetric ones:
- Don't force symmetry in tree arrangements
- Allow SA to find asymmetric local optima
- May require longer optimization time

#### Experiment 4: Multi-Start with Different Seeds
- Run bbox3 with multiple random seeds
- Keep best solution from each run
- Combine best per-N solutions from different runs

#### Experiment 5: Custom C++ Optimizer
Modify bbox3 source code:
- Add new move types (e.g., cluster moves, rotation-only moves)
- Tune temperature schedule for SA
- Add specialized moves for boundary trees

#### Experiment 6: Per-N Specialization
- Different optimization strategy for different N ranges
- N<20: Exhaustive/near-exhaustive search
- N=20-100: Standard SA with many restarts
- N>100: Tessellation-based approaches

### Technical Implementation Notes

1. **Precision**: Use Decimal with prec=30 for calculations
2. **Submission format**: Prepend 's' to all numeric values
3. **Validation**: Check for overlaps before submission
4. **Coordinate bounds**: -100 <= x, y <= 100

### Code Structure
```python
# Score calculation
def get_total_score(dict_of_side_length):
    score = Decimal('0')
    for k, v in dict_of_side_length.items():
        score += v ** 2 / Decimal(str(k))
    return score

# Parse submission
def parse_csv(csv_path):
    result = pd.read_csv(csv_path)
    result['x'] = result['x'].str.strip('s')
    result['y'] = result['y'].str.strip('s')
    result['deg'] = result['deg'].str.strip('s')
    # ... build tree objects
```

### Key Kernels to Reference
1. `../research/kernels/jazivxt_why-not/` - bbox3 source code
2. `../research/kernels/saspav_santa-submission/` - Full pipeline
3. `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - 3-hour runner

### Validation Checklist
- [ ] No overlapping trees (use Shapely intersection check)
- [ ] All coordinates within [-100, 100]
- [ ] Correct submission format (s-prefixed values)
- [ ] All 200 configurations present (N=1 to 200)
- [ ] Total 20100 tree entries

## Advanced Techniques from Research

### No-Fit Polygon (NFP)
- Precompute NFP for tree polygon with itself
- Enables O(1) overlap checking during optimization
- Could significantly speed up SA iterations

### Bottom-Left (BL) Algorithm
- Alternative to SA for initial placement
- Pack trees from left to right, bottom to top
- May provide better starting point for SA

### Tessellation Approaches
- For large N, consider regular tessellation patterns
- Hexagonal or square grid arrangements
- Optimize rotation within tessellation

## Expected Progression
1. Experiment 1: ~70.5-70.7 (baseline)
2. Experiment 2-3: ~70.0-70.5 (small improvements)
3. Experiment 4-5: ~69.5-70.0 (moderate improvements)
4. Experiment 6+: Target 68.92 (requires novel approach)

The gap of 1.74 points suggests the winning solutions use techniques beyond simple SA optimization. Consider:
- Novel move operators
- Hybrid algorithms (SA + local search)
- Problem-specific heuristics
- Parallel optimization with solution sharing
