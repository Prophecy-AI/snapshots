# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt

## Problem Overview
This is a 2D geometric packing optimization problem. The goal is to pack Christmas tree toys (15-vertex polygons) into the smallest possible square bounding box for N=1 to 200 trees.

**Scoring:** score = Σ(side_length² / N) for N=1 to 200
**Target:** 68.919154 (lower is better)
**Best snapshot:** 70.659944 (gap: 1.74 points)

## Tree Geometry
Each tree is a 15-vertex polygon with vertices:
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```
- Tip at (0, 0.8), trunk bottom at (±0.075, -0.2)
- Width: 0.7 at base, 0.4 mid, 0.25 top
- Trees can be rotated (angle in degrees)

## CRITICAL INSIGHT: Pre-optimized Solutions are at Local Optimum

**WARNING:** Previous experiments (48 snapshots) show that local search methods CANNOT improve pre-optimized solutions. The best public CSVs are already at strong local optima.

Approaches that FAILED to improve:
- Simulated Annealing (SA) with various parameters
- bbox3 C++ optimizer (even with 50000 iterations, 256 restarts)
- Backward propagation
- Corner extraction (minimal improvement: 0.0006 points)
- Grid-based initialization (converges to worse optimum)
- tree_packer_v21 with swap moves, multi-start

## Recommended Approaches (Priority Order)

### 1. BOTTOM-LEFT PLACEMENT WITH BEAM SEARCH (HIGHEST PRIORITY)
Based on research, bottom-left placement combined with beam search is highly effective:
```python
def bottom_left_beam_search(N, beam_width=15):
    """Build N-tree configuration using bottom-left placement with beam search"""
    states = [EmptyConfig()]
    
    for tree_idx in range(N):
        candidates = []
        for state in states:
            # Try multiple angles
            for angle in [0, 45, 90, 135, 180, 225, 270, 315]:
                # Find bottom-left position for this angle
                pos = find_bottom_left_position(state, angle)
                if pos is not None:
                    new_state = state.add_tree(pos, angle)
                    if not new_state.has_overlap():
                        candidates.append(new_state)
        
        # Keep top beam_width by bounding box side
        candidates.sort(key=lambda s: s.bounding_box_side())
        states = candidates[:beam_width]
    
    return min(states, key=lambda s: s.score())
```

### 2. JOSTLE MOVES + LOCAL SEARCH
Jostle algorithm is effective for irregular packing:
```python
def jostle_optimization(config, max_iters=1000):
    """Apply jostle moves to improve packing"""
    for _ in range(max_iters):
        # Select random tree
        tree_idx = random.randint(0, config.n - 1)
        
        # Try small perturbations
        for dx, dy, da in generate_jostle_moves():
            new_config = config.perturb_tree(tree_idx, dx, dy, da)
            if not new_config.has_overlap() and new_config.score() < config.score():
                config = new_config
                break
    
    return config
```

### 3. LATTICE-BASED CONSTRUCTION
The best solutions show crystalline/lattice patterns:
- Trees alternate between "up" (0-90°, 270-360°) and "down" (90-270°) orientations
- Regular spacing patterns emerge for larger N
- Try hexagonal, square, and triangular lattice arrangements

```python
def lattice_construction(N, lattice_type='hexagonal'):
    """Build configuration using regular lattice pattern"""
    if lattice_type == 'hexagonal':
        points = generate_hexagonal_lattice(N)
    elif lattice_type == 'square':
        points = generate_square_lattice(N)
    
    # Assign alternating orientations
    trees = []
    for i, (x, y) in enumerate(points):
        angle = 0 if i % 2 == 0 else 180
        trees.append((x, y, angle))
    
    # Optimize lattice parameters (spacing, rotation)
    return optimize_lattice_params(trees)
```

### 4. MULTI-START RANDOM OPTIMIZATION
Instead of starting from pre-optimized CSV:
```python
def multi_start_optimization(N, num_starts=100):
    """Try multiple random starting points"""
    best = None
    best_score = float('inf')
    
    for _ in range(num_starts):
        # Random initial placement
        config = random_placement(N)
        
        # Apply squeeze + compaction + local search
        config = squeeze(config)
        config = compaction(config, iters=50)
        config = local_search(config, max_iter=100)
        
        if config.score() < best_score:
            best = config
            best_score = config.score()
    
    return best
```

### 5. CORNER EXTRACTION
Extract smaller configurations from corners of larger ones:
```python
def corner_extraction(target_N, source_configs):
    """Find N-tree config from corner of larger config"""
    best = None
    best_score = float('inf')
    
    for source_N in range(target_N + 1, 201):
        source = source_configs[source_N]
        for corner in ['top-left', 'top-right', 'bottom-left', 'bottom-right']:
            trees_in_corner = get_trees_in_corner(source, corner, target_N)
            if len(trees_in_corner) == target_N:
                score = calculate_score(trees_in_corner, target_N)
                if score < best_score:
                    best = trees_in_corner
                    best_score = score
    
    return best
```

### 6. ENSEMBLE FROM MULTIPLE SOURCES
Combine best N from different solution sources:
```python
def create_ensemble(sources):
    """Take best N from each source"""
    final = {}
    for N in range(1, 201):
        best_score = float('inf')
        for source in sources:
            score = get_score(source, N)
            if score < best_score:
                final[N] = source[N]
                best_score = score
    return final
```

## Key Kernels and Techniques

### From saspav/santa-submission:
- Uses bbox3 C++ optimizer with fix_direction rotation
- Pre-optimized santa-2025.csv as baseline
- Overlap repair by replacing invalid groups

### From jazivxt/why-not (bbox3.cpp):
- Complex number vector coordination
- Fluid dynamics simulation for tree movement
- Hinge pivot and density gradient flow
- Global boundary tension optimization

### From smartmanoj/santa-claude (tree_packer_v21.cpp):
- Swap moves between trees
- Multi-angle restarts
- Squeeze: scale all trees toward center
- Compaction: move each tree toward center
- Local search: 8-directional moves + rotation
- Backward propagation: remove trees from larger configs

### From inversion/getting-started:
- Greedy placement with weighted angle generation
- Weighted angles favor diagonal orientations: `abs(sin(2*angle))`

## Implementation Strategy

### Experiment 1: Baseline from Best Snapshot
```bash
cp /home/nonroot/snapshots/santa-2025/21145965159/submission/submission.csv submission.csv
python score_submission.py submission.csv
```
Expected score: ~70.66

### Experiment 2: Bottom-Left Beam Search Construction
Implement bottom-left placement with beam search for each N.
Focus on N values where current solution is weakest.

### Experiment 3: Lattice + Jostle Optimization
1. Generate lattice-based initial placement
2. Apply jostle moves for local refinement
3. Compare with baseline

### Experiment 4: Multi-Start Random Optimization
Generate 100+ random starting configurations per N.
Apply full optimization pipeline to each.

### Experiment 5: Hybrid Approach
1. Use bottom-left beam search for initial placement
2. Apply jostle moves
3. Finish with squeeze + compaction

## Validation and Scoring

```python
from shapely.geometry import Polygon
from shapely import affinity
from shapely.strtree import STRtree

def score_submission(csv_path):
    """Calculate total score and check for overlaps"""
    df = pd.read_csv(csv_path)
    total_score = 0
    
    for n in range(1, 201):
        trees = load_trees(df, n)
        side = get_bounding_box_side(trees)
        total_score += side**2 / n
        
        if has_overlap(trees):
            print(f"OVERLAP at N={n}")
    
    return total_score
```

## Key Parameters

- Tree polygon: 15 vertices, height 1.0 (from -0.2 to 0.8)
- Rotation: 0-360 degrees
- Position: (x, y) coordinates, constrained to -100 ≤ x, y ≤ 100
- Submission format: id,x,y,deg with 's' prefix on values

## Files and Resources

- Sample submission: /home/data/sample_submission.csv
- Best snapshot: /home/nonroot/snapshots/santa-2025/21145965159/submission/submission.csv
- Kernels: ../research/kernels/
- bbox3 optimizer: Available in kernel datasets

## DO NOT WASTE TIME ON:
- Running more SA/bbox3 on pre-optimized solutions (they're at local optimum)
- Small parameter tweaks to existing optimizers
- Longer optimization runs on same starting point
- Backward propagation on pre-optimized solutions

## FOCUS ON:
- Constructive approaches (bottom-left beam search, greedy backtracking)
- Different starting configurations (random, lattice)
- Per-N optimization with fresh starts
- Jostle moves for local refinement
- Ensemble from multiple construction methods

## Research Insights (from academic literature)
Best 2D irregular polygon packing algorithms:
1. Bottom-left placement + local search refinements
2. Meta-heuristics (GA, SA, tabu search) with good initial solutions
3. DJD-based heuristic (Djang and Finch selection rule)
4. Shelf packing algorithms
5. Jostle moves for local search
6. Hybrid approaches combining constructive heuristics with meta-heuristics

## Discussion Insights
Key discussions mention:
- Asymmetric solutions may outperform symmetric ones
- Lattice/crystalline patterns are common in good solutions
- Trees alternate between "up" and "down" orientations
- Efficient tessellations are key for larger N
