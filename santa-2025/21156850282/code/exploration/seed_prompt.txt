# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt

## Problem Overview
This is a 2D geometric packing optimization problem. The goal is to pack Christmas tree toys (15-vertex polygons) into the smallest possible square bounding box for N=1 to 200 trees.

**Scoring:** score = Σ(side_length² / N) for N=1 to 200
**Target:** 68.919154 (lower is better)
**Best snapshot:** 70.659944 (gap: 1.74 points)

## Tree Geometry
Each tree is a 15-vertex polygon with:
- Tip at (0, 0.8)
- Three tiers of branches at y=0.5, 0.25, 0
- Trunk from y=0 to y=-0.2
- Width: 0.7 at base, 0.4 mid, 0.25 top
- Trees can be rotated (angle in degrees)

## CRITICAL INSIGHT: Pre-optimized Solutions are at Local Optimum

**WARNING:** Previous experiments show that local search methods (SA, bbox3, backward propagation) CANNOT improve pre-optimized solutions. The best public CSVs are already at strong local optima.

Approaches that FAILED to improve:
- Simulated Annealing (SA) with various parameters
- bbox3 C++ optimizer (even with 50000 iterations)
- Backward propagation
- Corner extraction (minimal improvement)
- Grid-based initialization (converges to worse optimum)

## Recommended Approaches (Priority Order)

### 1. GREEDY BACKTRACKING WITH BEAM SEARCH (HIGHEST PRIORITY)
Build solutions from scratch using constructive methods:
```
BEAM_WIDTH = 10-20
MAX_DEPTH = 10
MAX_STATES = 4000

For each N from 1 to 200:
    1. Start with empty configuration
    2. For each tree to place:
        - Generate multiple candidate positions (beam search)
        - Score each partial configuration
        - Keep top BEAM_WIDTH configurations
    3. Select best final configuration
```

This is FUNDAMENTALLY DIFFERENT from optimizing existing solutions.

### 2. LATTICE-BASED CONSTRUCTION
The best solutions show crystalline/lattice patterns:
- Trees alternate between "up" (0-90°, 270-360°) and "down" (90-270°) orientations
- Regular spacing patterns emerge for larger N
- Try hexagonal, square, and triangular lattice arrangements
- Optimize lattice parameters (spacing, rotation) per N

### 3. RANDOM INITIALIZATION + OPTIMIZATION
Instead of starting from pre-optimized CSV:
```python
for trial in range(NUM_TRIALS):
    # Generate random starting configuration
    config = random_placement(N)
    # Apply optimization
    optimized = optimize(config)
    # Keep best
```

### 4. CORNER EXTRACTION
Extract smaller configurations from corners of larger ones:
- For N=k, check if any corner of N=m (m>k) contains exactly k trees
- This can find better local optima for specific N values

### 5. ENSEMBLE FROM MULTIPLE SOURCES
Combine best N from different solution sources:
```python
for N in range(1, 201):
    best_score = inf
    for source in sources:
        score = get_score(source, N)
        if score < best_score:
            best_N = source[N]
            best_score = score
    final[N] = best_N
```

## Key Kernels and Techniques

### From saspav/santa-submission:
- Uses bbox3 C++ optimizer with fix_direction rotation
- Pre-optimized santa-2025.csv as baseline
- Overlap repair by replacing invalid groups

### From jazivxt/why-not:
- bbox3.cpp with complex number vector coordination
- Fluid dynamics simulation for tree movement
- Hinge pivot and density gradient flow
- Global boundary tension optimization

### From inversion/getting-started:
- Greedy placement with weighted angle generation
- Trees placed at random angles, moved toward center until collision
- Weighted angles favor diagonal orientations (sin(2*angle))

### From yongsukprasertsuk/bbox3-runner:
- 3-phase optimization: short runs → medium runs → long runs
- fix_direction rotation optimization
- Overlap repair using donor CSV

## Implementation Strategy

### Experiment 1: Baseline from Best Snapshot
```bash
# Copy best pre-optimized solution
cp /home/nonroot/snapshots/santa-2025/21145965159/submission/submission.csv submission.csv
# Verify score
python score_submission.py submission.csv
```
Expected score: ~70.66

### Experiment 2: Greedy Backtracking Construction
```python
def greedy_backtracking(N, beam_width=10):
    """Build N-tree configuration from scratch using beam search"""
    states = [EmptyConfig()]
    
    for tree_idx in range(N):
        candidates = []
        for state in states:
            # Try multiple positions and angles
            for angle in np.linspace(0, 360, 36):
                for pos in generate_candidate_positions(state, angle):
                    new_state = state.add_tree(pos, angle)
                    if not new_state.has_overlap():
                        candidates.append(new_state)
        
        # Keep top beam_width by score
        candidates.sort(key=lambda s: s.bounding_box_side())
        states = candidates[:beam_width]
    
    return min(states, key=lambda s: s.score())
```

### Experiment 3: Lattice Construction
```python
def lattice_construction(N, lattice_type='hexagonal'):
    """Build configuration using regular lattice pattern"""
    # Generate lattice points
    points = generate_lattice(N, lattice_type)
    
    # Assign alternating orientations
    trees = []
    for i, (x, y) in enumerate(points):
        angle = 0 if i % 2 == 0 else 180  # Alternating up/down
        trees.append((x, y, angle))
    
    # Optimize lattice parameters
    best = optimize_lattice_params(trees)
    return best
```

### Experiment 4: Multi-Start Random Optimization
```python
def multi_start_optimization(N, num_starts=100):
    """Try multiple random starting points"""
    best = None
    best_score = float('inf')
    
    for _ in range(num_starts):
        # Random initial placement
        config = random_placement(N)
        
        # Local optimization
        optimized = local_search(config)
        
        score = optimized.score()
        if score < best_score:
            best = optimized
            best_score = score
    
    return best
```

## Validation and Scoring

```python
def score_submission(csv_path):
    """Calculate total score and check for overlaps"""
    df = pd.read_csv(csv_path)
    total_score = 0
    
    for n in range(1, 201):
        trees = load_trees(df, n)
        side = get_bounding_box_side(trees)
        total_score += side**2 / n
        
        if has_overlap(trees):
            print(f"OVERLAP at N={n}")
    
    return total_score
```

## Key Parameters

- Tree polygon: 15 vertices, height 1.0 (from -0.2 to 0.8)
- Rotation: 0-360 degrees
- Position: (x, y) coordinates, constrained to -100 ≤ x, y ≤ 100
- Submission format: id,x,y,deg with 's' prefix on values

## Files and Resources

- Sample submission: /home/data/sample_submission.csv
- Best snapshot: /home/nonroot/snapshots/santa-2025/21145965159/submission/submission.csv
- Kernels: ../research/kernels/
- bbox3 optimizer: Available in kernel datasets

## DO NOT WASTE TIME ON:
- Running more SA/bbox3 on pre-optimized solutions (they're at local optimum)
- Small parameter tweaks to existing optimizers
- Longer optimization runs on same starting point

## FOCUS ON:
- Constructive approaches (greedy backtracking, beam search)
- Different starting configurations (random, lattice)
- Per-N optimization with fresh starts
- Ensemble from multiple construction methods
