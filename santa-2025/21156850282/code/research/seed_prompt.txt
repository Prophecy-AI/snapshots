# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt

## Current Status
- Best CV score: 70.659958 from exp_002 (003_clean_ensemble)
- Best LB score: 70.6600 (CV matches LB perfectly - no gap!)
- Target: 68.919154 | Gap to target: 1.74 points (2.5%)

## Public Kernel Status
- Have we implemented the best kernel yet? PARTIALLY
- Top kernels identified:
  1. jonathanchan/santa25-ensemble-sa-fractional-translation (175 votes) - uses 19 external sources
  2. saspav/santa-submission (441 votes) - bbox3 C++ optimizer
  3. smartmanoj/santa-claude (373 votes) - tree_packer_v21
  4. crodoc/74-75-backpacking-christmas-trees (127 votes) - backward propagation
- Kernels we've implemented: C++ optimizers (sa_v1_parallel, tree_packer_v18), fractional translation
- **CRITICAL ISSUE**: The top kernels achieve ~68.5-69.5 by ensembling 15+ external sources. We only have access to 40 snapshots that all score ~70.66.

## CV-LB Relationship Analysis
- CV = LB (perfect match for exp_002)
- No gap to worry about - the scoring is deterministic

## Response to Evaluator
The evaluator correctly identified the key issue: **limited data sources = limited score**. Our 40 snapshots all converge to the same ~70.66 score. The overlapping snapshot (21145966992) has better individual N scores but 72 groups with overlaps that can't be fixed with small perturbations.

Key findings from analysis:
1. Fractional translation provides only 0.000009 improvement for N=2 - solutions are at tight local optima
2. C++ optimizers cannot improve pre-optimized solutions
3. Bottom-left beam search produces 30-40% worse results than baseline
4. Public datasets we can download (bucket-of-chump, telegram, etc.) don't have better solutions than 70.66

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY] Generate New Solutions from Scratch**
Since we can't access better external sources, we must generate our own. The key insight is that the overlapping snapshot has better scores for many N values - we need to find configurations that achieve similar packing density WITHOUT overlaps.

**Approach: Genetic Algorithm with Overlap Penalty**
```python
def genetic_optimization(n, population_size=100, generations=500):
    """Generate new configurations using genetic algorithm."""
    # Initialize population with random configurations
    population = [random_configuration(n) for _ in range(population_size)]
    
    for gen in range(generations):
        # Evaluate fitness (score + overlap penalty)
        fitness = []
        for config in population:
            score = calculate_score(config)
            overlap_penalty = calculate_overlap_area(config) * 1000
            fitness.append(score + overlap_penalty)
        
        # Selection, crossover, mutation
        # ...
    
    return best_valid_configuration
```

### 2. **[HIGH PRIORITY] Simulated Annealing from Random Starts**
Instead of starting from pre-optimized solutions, start from random configurations and run SA. This may find different local optima.

```python
def sa_from_random(n, num_starts=50, iterations=10000):
    """Run SA from multiple random starting points."""
    best = None
    best_score = float('inf')
    
    for _ in range(num_starts):
        # Random initial configuration
        config = random_configuration(n)
        
        # Run SA
        config = simulated_annealing(config, iterations)
        
        # Check if valid and better
        if not has_overlaps(config):
            score = calculate_score(config)
            if score < best_score:
                best = config
                best_score = score
    
    return best
```

### 3. **[MEDIUM PRIORITY] Lattice-Based Construction with Optimization**
The zaburo kernel shows lattice-based construction scores 88.33 - much worse than 70.66. But we can use lattice as a starting point and then optimize:

```python
def lattice_then_optimize(n):
    """Start from lattice, then optimize."""
    # Create lattice configuration
    config = create_lattice(n)
    
    # Apply aggressive optimization
    config = simulated_annealing(config, iterations=50000)
    config = local_search(config)
    config = fractional_translation(config)
    
    return config
```

### 4. **[MEDIUM PRIORITY] Fix Overlapping Configurations**
The overlapping snapshot has better scores. Try more aggressive overlap fixing:

```python
def fix_overlaps_aggressive(config):
    """Try to fix overlaps by larger perturbations."""
    while has_overlaps(config):
        # Find overlapping pair
        i, j = find_overlapping_pair(config)
        
        # Try moving one tree in many directions
        for angle in range(0, 360, 10):
            for distance in [0.01, 0.02, 0.05, 0.1]:
                dx = distance * cos(angle)
                dy = distance * sin(angle)
                new_config = move_tree(config, i, dx, dy)
                if not has_overlaps(new_config):
                    return new_config
        
        # If can't fix, try rotating
        for new_angle in range(0, 360, 5):
            new_config = rotate_tree(config, i, new_angle)
            if not has_overlaps(new_config):
                return new_config
    
    return config
```

## What NOT to Try
- ❌ More fractional translation on pre-optimized solutions (already at local optima)
- ❌ Running C++ optimizers on pre-optimized solutions (confirmed they can't improve)
- ❌ Bottom-left beam search with coarse grid (produces 30-40% worse results)
- ❌ Downloading more public datasets (they don't have better solutions)

## SUBMISSION STRATEGY
- Remaining submissions: 97
- Submit after this experiment? YES - we have abundant submissions
- Submit any experiment that produces a valid submission file with different score

## Validation Notes
- CV scheme: Local scoring matches LB exactly (deterministic)
- Overlap checking: Must verify no overlapping trees before submission
- Format: All x, y, deg values must have 's' prefix

## Key Insight
The gap of 1.74 points (2.5%) is significant. To reach the target:
- Need to reduce average score per N by 0.0087 points
- Small N values (1-10) have lowest efficiency (37-65%) - most room for improvement
- N=1 alone contributes 0.661 to total score - optimal is 0.245625 (tree area)

The winning approach is likely:
1. Generate many diverse solutions from scratch (not from pre-optimized)
2. Use aggressive optimization (SA, GA) with overlap penalty
3. Ensemble the best valid configurations per N
4. Apply fractional translation as final polish
