# Santa 2025 Christmas Tree Packing - Seed Prompt

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree toys (15-vertex polygons) into the smallest possible square bounding box for configurations of N=1 to N=200 trees.

**Scoring:** score = Σ(side_length² / N) for all N from 1 to 200. Lower is better.
**Target:** Beat 68.922808

## Data Format
- Submission CSV with columns: id, x, y, deg
- id format: "NNN_T" where NNN is the tree count (001-200) and T is tree index
- x, y, deg values are prefixed with 's' (e.g., "s0.123456")
- Total rows: 20,100 (sum of 1+2+...+200)

## Tree Geometry (15 vertices)
```
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```
Tree has tip at (0, 0.8), trunk bottom at y=-0.2, max width 0.7 at base.

## Top Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (Primary Approach)
**Source:** `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- Uses simulated annealing with complex number geometry
- Key techniques: fluid dynamics, hinge pivot, density gradient flow, global boundary tension
- Phased approach: short runs to find promising (n,r) parameters, then longer runs on top candidates
- Parameters: n (iterations), r (restarts)
- Typical values: n=1000-2000, r=30-90 for phase A; n=5000-10000, r=128-256 for longer runs

### 2. fix_direction Rotation Optimization
**Source:** `../research/kernels/saspav_santa-submission/`
- After placing trees, optimize the rotation of the ENTIRE configuration
- Uses scipy.optimize.minimize_scalar on convex hull points
- Finds optimal rotation angle (0-90 degrees) to minimize bounding box
- Can reduce score by tightening the bounding box alignment

### 3. Backward Propagation
**Source:** `../research/kernels/smartmanoj_santa-claude/`
- Start from N=200 configuration
- Remove boundary-touching trees one at a time
- Check if resulting (N-1) config is better than stored best
- Propagates improvements downward through all N values
- Key insight: Trees touching the bounding box boundary are candidates for removal

### 4. Greedy Tree Placement (Baseline)
**Source:** `../research/kernels/inversion_santa-2025-getting-started/`
- Start with existing N-tree config, add new tree
- Place tree far away at random angle, move toward center until collision
- Back up until no overlap
- Try 10 random angles, keep best placement
- Uses weighted angle distribution: abs(sin(2*angle)) to favor diagonal placements

### 5. C++ Local Search Techniques
**Source:** `../research/kernels/smartmanoj_santa-claude/`
- **Squeeze:** Scale all trees toward center (scale=0.9995 down to 0.98)
- **Compaction:** Move individual trees toward center in small steps
- **Local search:** 8-direction moves + rotations with decreasing step sizes
- **Swap moves:** Exchange positions of two trees
- **Multi-angle restarts:** Try different initial rotation configurations

## CRITICAL: Constructive Approaches (Beyond Local Search)

**WARNING:** If starting from a pre-optimized CSV, local search methods (SA, compaction, squeeze) may already be at a local optimum. To find better solutions, use CONSTRUCTIVE approaches:

### Beam Search for Packing (HIGH PRIORITY)
Beam search is highly effective for irregular packing problems. It builds solutions tree-by-tree while exploring multiple paths:

```python
def beam_search_packing(n_trees, beam_width=10, max_depth=10):
    """
    Build N-tree configuration using beam search.
    
    At each step:
    1. For each partial solution in beam, try adding next tree at multiple positions/angles
    2. Score each resulting configuration (bounding box size)
    3. Keep only top beam_width configurations
    4. Continue until all trees placed
    """
    # Initialize beam with empty configuration
    beam = [{'trees': [], 'score': 0}]
    
    for tree_idx in range(n_trees):
        candidates = []
        for partial in beam:
            # Try multiple placements for next tree
            for angle in [0, 45, 90, 135, 180, 225, 270, 315]:
                for attempt in range(10):  # Random positions
                    new_config = try_add_tree(partial, angle)
                    if new_config and not has_overlap(new_config):
                        candidates.append(new_config)
        
        # Keep top beam_width candidates
        candidates.sort(key=lambda x: x['score'])
        beam = candidates[:beam_width]
    
    return beam[0]  # Best configuration
```

**Parameters:**
- BEAM_WIDTH = 10-20 (number of parallel partial solutions)
- Try multiple angles: [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330]
- Try multiple random starting positions per angle

### Greedy Backtracking with Restarts
Build solutions from scratch with backtracking:

```python
def greedy_backtracking(n_trees, max_backtracks=100):
    """
    Build configuration greedily, backtrack on failure.
    """
    trees = []
    history = []
    
    while len(trees) < n_trees:
        best_placement = None
        best_score = float('inf')
        
        # Try many placements
        for angle in range(0, 360, 15):
            for _ in range(20):
                placement = find_valid_placement(trees, angle)
                if placement:
                    score = evaluate_with_new_tree(trees, placement)
                    if score < best_score:
                        best_score = score
                        best_placement = placement
        
        if best_placement:
            history.append(trees.copy())
            trees.append(best_placement)
        else:
            # Backtrack
            if history and max_backtracks > 0:
                trees = history.pop()
                max_backtracks -= 1
            else:
                break
    
    return trees
```

### Random Initialization (Not from Pre-optimized CSV)
Generate completely new starting configurations:

```python
def random_initialization(n_trees, num_attempts=100):
    """
    Generate random valid configurations, keep best.
    """
    best_config = None
    best_score = float('inf')
    
    for _ in range(num_attempts):
        config = []
        for i in range(n_trees):
            # Random position and angle
            x = random.uniform(-5, 5)
            y = random.uniform(-5, 5)
            angle = random.uniform(0, 360)
            
            tree = ChristmasTree(x, y, angle)
            # Adjust position to avoid overlaps
            tree = adjust_to_valid_position(tree, config)
            config.append(tree)
        
        score = calculate_score(config)
        if score < best_score:
            best_score = score
            best_config = config
    
    return best_config
```

## Key Implementation Details

### Collision Detection
- Use Shapely library for polygon operations
- STRtree for efficient spatial indexing
- Check: `poly.intersects(other) and not poly.touches(other)`
- Bounding box pre-filter for speed

### Overlap Repair
- When optimizer creates overlaps, replace with known-good configuration
- Keep donor CSV with valid configurations for fallback

### Scoring Function
```python
def get_score(trees, n):
    xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])
    min_x, min_y = xys.min(axis=0)
    max_x, max_y = xys.max(axis=0)
    side_length = max(max_x - min_x, max_y - min_y)
    return side_length**2 / n
```

## Recommended Experiment Strategy

### Experiment 1: Baseline with Best Public Submission
1. Download best public submission CSV (look for datasets like "bucket-of-chump" or "santa-2025-csv")
2. Run fix_direction optimization
3. Validate no overlaps
4. Submit to establish baseline score

### Experiment 2: C++ Optimizer with Fresh Start
1. Compile bbox3.cpp with: `g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp`
2. Run with parameters: `./bbox3 -n 10000 -r 128`
3. Apply fix_direction post-processing
4. Repair any overlaps with donor CSV

### Experiment 3: Beam Search Construction (PRIORITY)
1. Implement beam search packing algorithm
2. For each N from 1 to 200, build configuration using beam search
3. Parameters: beam_width=15, try 12 angles, 10 positions per angle
4. Apply fix_direction post-processing

### Experiment 4: Backward Propagation
1. Start from best submission
2. Implement backward propagation from N=200 to N=2
3. For each N, try removing each boundary-touching tree
4. Keep improvements that reduce score

### Experiment 5: Hybrid Ensemble
1. For each N, run multiple construction methods
2. Keep best configuration from: beam search, greedy, backward propagation
3. Apply final fix_direction pass
4. Combine best-per-N into final submission

## Critical Optimization Insights

1. **Focus on high-N configurations:** N=150-200 contribute most to score
2. **Rotation matters:** fix_direction can significantly reduce bounding box
3. **Boundary trees are key:** Trees touching the bounding box define the score
4. **Incremental improvement:** Small improvements compound across 200 configurations
5. **Validation is essential:** Always check for overlaps before submission
6. **Constructive > Local Search:** When starting from optimized CSV, build fresh solutions

## External Resources
- Best public submissions are often shared as Kaggle datasets
- Look for datasets with names like "santa-2025-csv", "bucket-of-chump"
- These contain pre-optimized configurations that can be used as starting points OR as fallback for overlap repair

## Validation Checklist
1. All 200 configurations present (N=1 to N=200)
2. Correct number of trees per configuration
3. No overlapping trees in any configuration
4. Values within bounds: -100 ≤ x, y ≤ 100
5. Proper 's' prefix on all numeric values

## C++ Compilation Commands
```bash
# bbox3 optimizer
g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp

# Backward propagation
g++ -O3 -std=c++17 -o bp bp.cpp

# Run optimizer
export OMP_NUM_THREADS=4
./bbox3 -n 5000 -r 64
```
