# Santa 2025 Christmas Tree Packing - Seed Prompt

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree toys (15-vertex polygons) into the smallest possible square bounding box for configurations of N=1 to N=200 trees.

**Scoring:** score = Σ(side_length² / N) for all N from 1 to 200. Lower is better.
**Target:** Beat 68.922808

## Data Format
- Submission CSV with columns: id, x, y, deg
- id format: "NNN_T" where NNN is the tree count (001-200) and T is tree index
- x, y, deg values are prefixed with 's' (e.g., "s0.123456")
- Total rows: 20,100 (sum of 1+2+...+200)

## Tree Geometry (15 vertices)
```
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```
Tree has tip at (0, 0.8), trunk bottom at y=-0.2, max width 0.7 at base.

## Top Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (Primary Approach)
**Source:** `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- Uses simulated annealing with complex number geometry
- Key techniques: fluid dynamics, hinge pivot, density gradient flow, global boundary tension
- Phased approach: short runs to find promising (n,r) parameters, then longer runs on top candidates
- Parameters: n (iterations), r (restarts)
- Typical values: n=1000-2000, r=30-90 for phase A; n=5000-10000, r=128-256 for longer runs

### 2. fix_direction Rotation Optimization
**Source:** `../research/kernels/saspav_santa-submission/`
- After placing trees, optimize the rotation of the ENTIRE configuration
- Uses scipy.optimize.minimize_scalar on convex hull points
- Finds optimal rotation angle (0-90 degrees) to minimize bounding box
- Can reduce score by tightening the bounding box alignment

### 3. Backward Propagation
**Source:** `../research/kernels/smartmanoj_santa-claude/`
- Start from N=200 configuration
- Remove boundary-touching trees one at a time
- Check if resulting (N-1) config is better than stored best
- Propagates improvements downward through all N values
- Key insight: Trees touching the bounding box boundary are candidates for removal

### 4. Greedy Tree Placement (Baseline)
**Source:** `../research/kernels/inversion_santa-2025-getting-started/`
- Start with existing N-tree config, add new tree
- Place tree far away at random angle, move toward center until collision
- Back up until no overlap
- Try 10 random angles, keep best placement
- Uses weighted angle distribution: abs(sin(2*angle)) to favor diagonal placements

### 5. C++ Local Search Techniques
**Source:** `../research/kernels/smartmanoj_santa-claude/`
- **Squeeze:** Scale all trees toward center (scale=0.9995 down to 0.98)
- **Compaction:** Move individual trees toward center in small steps
- **Local search:** 8-direction moves + rotations with decreasing step sizes
- **Swap moves:** Exchange positions of two trees
- **Multi-angle restarts:** Try different initial rotation configurations

## Key Implementation Details

### Collision Detection
- Use Shapely library for polygon operations
- STRtree for efficient spatial indexing
- Check: `poly.intersects(other) and not poly.touches(other)`
- Bounding box pre-filter for speed

### Overlap Repair
- When optimizer creates overlaps, replace with known-good configuration
- Keep donor CSV with valid configurations for fallback

### Scoring Function
```python
def get_score(trees, n):
    xys = np.concatenate([np.asarray(t.polygon.exterior.xy).T for t in trees])
    min_x, min_y = xys.min(axis=0)
    max_x, max_y = xys.max(axis=0)
    side_length = max(max_x - min_x, max_y - min_y)
    return side_length**2 / n
```

## Recommended Experiment Strategy

### Experiment 1: Baseline with Best Public Submission
1. Download best public submission CSV (look for datasets like "bucket-of-chump" or "santa-2025-csv")
2. Run fix_direction optimization
3. Validate no overlaps
4. Submit to establish baseline score

### Experiment 2: C++ Optimizer
1. Compile bbox3.cpp with: `g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp`
2. Run with parameters: `./bbox3 -n 5000 -r 64`
3. Apply fix_direction post-processing
4. Repair any overlaps with donor CSV

### Experiment 3: Backward Propagation
1. Start from best submission
2. Implement backward propagation from N=200 to N=2
3. For each N, try removing each boundary-touching tree
4. Keep improvements that reduce score

### Experiment 4: Greedy Reconstruction
1. For problematic N values (high score contribution), rebuild from scratch
2. Use weighted angle distribution for tree placement
3. Try multiple random seeds, keep best

### Experiment 5: Ensemble/Hybrid
1. Combine best configurations from different approaches
2. For each N, use whichever method produced best result
3. Apply final fix_direction pass

## Critical Optimization Insights

1. **Focus on high-N configurations:** N=150-200 contribute most to score
2. **Rotation matters:** fix_direction can significantly reduce bounding box
3. **Boundary trees are key:** Trees touching the bounding box define the score
4. **Incremental improvement:** Small improvements compound across 200 configurations
5. **Validation is essential:** Always check for overlaps before submission

## External Resources
- Best public submissions are often shared as Kaggle datasets
- Look for datasets with names like "santa-2025-csv", "bucket-of-chump"
- These contain pre-optimized configurations that can be used as starting points

## Validation Checklist
1. All 200 configurations present (N=1 to N=200)
2. Correct number of trees per configuration
3. No overlapping trees in any configuration
4. Values within bounds: -100 ≤ x, y ≤ 100
5. Proper 's' prefix on all numeric values
