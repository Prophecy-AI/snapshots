{
  "phase": "executor",
  "loop_count": 1,
  "last_submission": null,
  "competition_id": "santa-2025",
  "seed_prompt": "# Santa 2025 Christmas Tree Packing - Seed Prompt\n\n## Problem Overview\nThis is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree toys (15-vertex polygons) into the smallest possible square bounding box for configurations of N=1 to N=200 trees.\n\n**Scoring:** score = \u03a3(side_length\u00b2 / N) for all N from 1 to 200. Lower is better.\n**Target:** Beat 68.922808\n\n## Score Distribution Analysis\nBased on EDA (see `exploration/eda.ipynb`):\n- N=1-50 contributes ~20% of total score\n- N=51-100 contributes ~25% of total score  \n- N=101-150 contributes ~27% of total score\n- N=151-200 contributes ~28% of total score\n**Implication:** Focus optimization efforts on higher N values for maximum impact.\n\n## Data Format\n- Submission CSV with columns: id, x, y, deg\n- id format: \"NNN_T\" where NNN is the tree count (001-200) and T is tree index\n- x, y, deg values are prefixed with 's' (e.g., \"s0.123456\")\n- Total rows: 20,100 (sum of 1+2+...+200)\n\n## Tree Geometry (15 vertices)\n```python\nTX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]\nTY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]\n```\nTree has tip at (0, 0.8), trunk bottom at y=-0.2, max width 0.7 at base.\n\n## Top Approaches from Public Kernels\n\n### 1. bbox3 C++ Optimizer (Primary Approach)\n**Source:** `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`\n- Uses simulated annealing with complex number geometry\n- Key techniques: fluid dynamics, hinge pivot, density gradient flow, global boundary tension\n- Phased approach: short runs to find promising (n,r) parameters, then longer runs on top candidates\n- Parameters: n (iterations), r (restarts)\n- Typical values: n=1000-2000, r=30-90 for phase A; n=5000-10000, r=128-256 for longer runs\n\n### 2. fix_direction Rotation Optimization\n**Source:** `../research/kernels/saspav_santa-submission/`\n- After placing trees, optimize the rotation of the ENTIRE configuration\n- Uses scipy.optimize.minimize_scalar on convex hull points\n- Finds optimal rotation angle (0-90 degrees) to minimize bounding box\n- Can reduce score by tightening the bounding box alignment\n\n### 3. Backward Propagation\n**Source:** `../research/kernels/smartmanoj_santa-claude/`\n- Start from N=200 configuration\n- Remove boundary-touching trees one at a time\n- Check if resulting (N-1) config is better than stored best\n- Propagates improvements downward through all N values\n- Key insight: Trees touching the bounding box boundary are candidates for removal\n\n### 4. Greedy Tree Placement (Baseline)\n**Source:** `../research/kernels/inversion_santa-2025-getting-started/`\n- Start with existing N-tree config, add new tree\n- Place tree far away at random angle, move toward center until collision\n- Back up until no overlap\n- Try 10 random angles, keep best placement\n- Uses weighted angle distribution: abs(sin(2*angle)) to favor diagonal placements\n\n### 5. C++ Local Search Techniques\n**Source:** `../research/kernels/smartmanoj_santa-claude/`\n- **Squeeze:** Scale all trees toward center (scale=0.9995 down to 0.98)\n- **Compaction:** Move individual trees toward center in small steps\n- **Local search:** 8-direction moves + rotations with decreasing step sizes\n- **Swap moves:** Exchange positions of two trees\n- **Multi-angle restarts:** Try different initial rotation configurations\n\n## CRITICAL: Constructive Approaches (Beyond Local Search)\n\n**WARNING:** If starting from a pre-optimized CSV, local search methods (SA, compaction, squeeze) may already be at a local optimum. To find better solutions, use CONSTRUCTIVE approaches:\n\n### Beam Search for Packing (HIGH PRIORITY)\nBeam search is highly effective for irregular packing problems. It builds solutions tree-by-tree while exploring multiple paths:\n\n```python\ndef beam_search_packing(n_trees, beam_width=10, max_depth=10):\n    \"\"\"\n    Build N-tree configuration using beam search.\n    \n    At each step:\n    1. For each partial solution in beam, try adding next tree at multiple positions/angles\n    2. Score each resulting configuration (bounding box size)\n    3. Keep only top beam_width configurations\n    4. Continue until all trees placed\n    \"\"\"\n    # Initialize beam with empty configuration\n    beam = [{'trees': [], 'score': 0}]\n    \n    for tree_idx in range(n_trees):\n        candidates = []\n        for partial in beam:\n            # Try multiple placements for next tree\n            for angle in [0, 45, 90, 135, 180, 225, 270, 315]:\n                for attempt in range(10):  # Random positions\n                    new_config = try_add_tree(partial, angle)\n                    if new_config and not has_overlap(new_config):\n                        candidates.append(new_config)\n        \n        # Keep top beam_width candidates\n        candidates.sort(key=lambda x: x['score'])\n        beam = candidates[:beam_width]\n    \n    return beam[0]  # Best configuration\n```\n\n**Parameters:**\n- BEAM_WIDTH = 10-20 (number of parallel partial solutions)\n- Try multiple angles: [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330]\n- Try multiple random starting positions per angle\n\n### Greedy Backtracking with Restarts\nBuild solutions from scratch with backtracking:\n\n```python\ndef greedy_backtracking(n_trees, max_backtracks=100):\n    \"\"\"\n    Build configuration greedily, backtrack on failure.\n    \"\"\"\n    trees = []\n    history = []\n    \n    while len(trees) < n_trees:\n        best_placement = None\n        best_score = float('inf')\n        \n        # Try many placements\n        for angle in range(0, 360, 15):\n            for _ in range(20):\n                placement = find_valid_placement(trees, angle)\n                if placement:\n                    score = evaluate_with_new_tree(trees, placement)\n                    if score < best_score:\n                        best_score = score\n                        best_placement = placement\n        \n        if best_placement:\n            history.append(trees.copy())\n            trees.append(best_placement)\n        else:\n            # Backtrack\n            if history and max_backtracks > 0:\n                trees = history.pop()\n                max_backtracks -= 1\n            else:\n                break\n    \n    return trees\n```\n\n### Random Initialization (Not from Pre-optimized CSV)\nGenerate completely new starting configurations:\n\n```python\ndef random_initialization(n_trees, num_attempts=100):\n    \"\"\"\n    Generate random valid configurations, keep best.\n    \"\"\"\n    best_config = None\n    best_score = float('inf')\n    \n    for _ in range(num_attempts):\n        config = []\n        for i in range(n_trees):\n            # Random position and angle\n            x = random.uniform(-5, 5)\n            y = random.uniform(-5, 5)\n            angle = random.uniform(0, 360)\n            \n            tree = ChristmasTree(x, y, angle)\n            # Adjust position to avoid overlaps\n            tree = adjust_to_valid_position(tree, config)\n            config.append(tree)\n        \n        score = calculate_score(config)\n        if score < best_score:\n            best_score = score\n            best_config = config\n    \n    return best_config\n```\n\n## Key Implementation Details\n\n### ChristmasTree Class (from kernels)\n```python\nfrom decimal import Decimal, getcontext\nfrom shapely import affinity\nfrom shapely.geometry import Polygon\n\ngetcontext().prec = 30\n\nclass ChristmasTree:\n    def __init__(self, center_x='0', center_y='0', angle='0'):\n        self.center_x = Decimal(str(center_x))\n        self.center_y = Decimal(str(center_y))\n        self.angle = Decimal(str(angle))\n        \n        # Tree dimensions\n        trunk_w, trunk_h = Decimal('0.15'), Decimal('0.2')\n        base_w, mid_w, top_w = Decimal('0.7'), Decimal('0.4'), Decimal('0.25')\n        tip_y, tier_1_y, tier_2_y = Decimal('0.8'), Decimal('0.5'), Decimal('0.25')\n        base_y, trunk_bottom_y = Decimal('0.0'), -trunk_h\n        \n        initial_polygon = Polygon([\n            (0, float(tip_y)),\n            (float(top_w/2), float(tier_1_y)), (float(top_w/4), float(tier_1_y)),\n            (float(mid_w/2), float(tier_2_y)), (float(mid_w/4), float(tier_2_y)),\n            (float(base_w/2), float(base_y)),\n            (float(trunk_w/2), float(base_y)), (float(trunk_w/2), float(trunk_bottom_y)),\n            (float(-trunk_w/2), float(trunk_bottom_y)), (float(-trunk_w/2), float(base_y)),\n            (float(-base_w/2), float(base_y)),\n            (float(-mid_w/4), float(tier_2_y)), (float(-mid_w/2), float(tier_2_y)),\n            (float(-top_w/4), float(tier_1_y)), (float(-top_w/2), float(tier_1_y)),\n        ])\n        \n        rotated = affinity.rotate(initial_polygon, float(self.angle), origin=(0, 0))\n        self.polygon = affinity.translate(rotated, xoff=float(self.center_x), yoff=float(self.center_y))\n```\n\n### Collision Detection\n```python\nfrom shapely.strtree import STRtree\n\ndef has_overlap(trees):\n    if len(trees) <= 1:\n        return False\n    polygons = [t.polygon for t in trees]\n    tree_index = STRtree(polygons)\n    \n    for i, poly in enumerate(polygons):\n        indices = tree_index.query(poly)\n        for idx in indices:\n            if idx != i:\n                if poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):\n                    return True\n    return False\n```\n\n### Scoring Function\n```python\nfrom shapely.ops import unary_union\n\ndef get_score(trees, n):\n    all_polygons = [t.polygon for t in trees]\n    bounds = unary_union(all_polygons).bounds\n    side_length = max(bounds[2] - bounds[0], bounds[3] - bounds[1])\n    return side_length**2 / n\n\ndef get_total_score(configs):\n    \"\"\"configs is dict: {n: [trees]}\"\"\"\n    return sum(get_score(trees, n) for n, trees in configs.items())\n```\n\n## Recommended Experiment Strategy\n\n### Experiment 1: Baseline with Best Public Submission\n1. Download best public submission CSV (look for datasets like \"bucket-of-chump\" or \"santa-2025-csv\")\n2. Run fix_direction optimization\n3. Validate no overlaps\n4. Submit to establish baseline score\n\n### Experiment 2: C++ Optimizer with Fresh Start\n1. Compile bbox3.cpp with: `g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp`\n2. Run with parameters: `./bbox3 -n 10000 -r 128`\n3. Apply fix_direction post-processing\n4. Repair any overlaps with donor CSV\n\n### Experiment 3: Beam Search Construction (PRIORITY)\n1. Implement beam search packing algorithm\n2. For each N from 1 to 200, build configuration using beam search\n3. Parameters: beam_width=15, try 12 angles, 10 positions per angle\n4. Apply fix_direction post-processing\n\n### Experiment 4: Backward Propagation\n1. Start from best submission\n2. Implement backward propagation from N=200 to N=2\n3. For each N, try removing each boundary-touching tree\n4. Keep improvements that reduce score\n\n### Experiment 5: Hybrid Ensemble\n1. For each N, run multiple construction methods\n2. Keep best configuration from: beam search, greedy, backward propagation\n3. Apply final fix_direction pass\n4. Combine best-per-N into final submission\n\n## Critical Optimization Insights\n\n1. **Focus on high-N configurations:** N=150-200 contribute ~28% of total score\n2. **Rotation matters:** fix_direction can significantly reduce bounding box\n3. **Boundary trees are key:** Trees touching the bounding box define the score\n4. **Incremental improvement:** Small improvements compound across 200 configurations\n5. **Validation is essential:** Always check for overlaps before submission\n6. **Constructive > Local Search:** When starting from optimized CSV, build fresh solutions\n\n## External Resources\n- Best public submissions are often shared as Kaggle datasets\n- Look for datasets with names like \"santa-2025-csv\", \"bucket-of-chump\"\n- These contain pre-optimized configurations that can be used as starting points OR as fallback for overlap repair\n\n## Validation Checklist\n1. All 200 configurations present (N=1 to N=200)\n2. Correct number of trees per configuration\n3. No overlapping trees in any configuration\n4. Values within bounds: -100 \u2264 x, y \u2264 100\n5. Proper 's' prefix on all numeric values\n\n## C++ Compilation Commands\n```bash\n# bbox3 optimizer\ng++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp\n\n# Backward propagation\ng++ -O3 -std=c++17 -o bp bp.cpp\n\n# Run optimizer\nexport OMP_NUM_THREADS=4\n./bbox3 -n 5000 -r 64\n```\n\n## Submission Format\n```python\ndef create_submission(configs, output_path):\n    \"\"\"\n    configs: dict {n: list of ChristmasTree objects}\n    \"\"\"\n    rows = []\n    for n in range(1, 201):\n        trees = configs[n]\n        for idx, tree in enumerate(trees):\n            rows.append({\n                'id': f'{n:03d}_{idx}',\n                'x': f's{tree.center_x}',\n                'y': f's{tree.center_y}',\n                'deg': f's{tree.angle}'\n            })\n    \n    df = pd.DataFrame(rows)\n    df.to_csv(output_path, index=False)\n```\n",
  "evaluator_feedback": "",
  "latest_experiment": {},
  "competitive_intel": "## Available Competitive Intelligence\n\n- Competition description: `../research/description.md`\n- 5 top kernel notebooks in `../research/kernels/`",
  "target_score": 68.922808051418,
  "manual_instructions": "",
  "messages": [],
  "experiments": [],
  "submissions": [],
  "candidates": [],
  "findings": [],
  "metric_lower_is_better": true,
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D packing optimization problem: fit Christmas tree toys (15-vertex polygons) into smallest square bounding box for N=1 to 200 trees. Score = sum of (side_length^2 / N) for all N. Lower is better. Target: 68.922808",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "Key approach: bbox3 C++ optimizer using simulated annealing with complex number geometry, fluid dynamics, hinge pivot, density gradient flow, and global boundary tension. Uses phases: short runs to find promising (n,r) parameters, then medium/long runs on top candidates.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "fix_direction technique: Optimize rotation of entire configuration to minimize bounding box. Uses scipy.optimize.minimize_scalar on convex hull points to find optimal rotation angle (0-90 degrees).",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Greedy tree placement: Start with existing N-tree config, add new tree at random angle far away, move toward center until collision, back up until no overlap. Try 10 random angles, keep best.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Backward propagation: Start from N=200, remove boundary-touching trees one at a time, check if resulting (N-1) config is better than stored best. Propagates improvements downward.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "C++ optimizer techniques: squeeze (scale toward center), compaction (move trees toward center), local search (8-direction moves + rotations), swap moves, multi-angle restarts, higher temperature SA.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Beam search for irregular packing: Build solutions tree-by-tree, keep top beam_width partial solutions at each step. Highly competitive for packing problems - generates solutions in significantly less time than other methods. Key: use no-fit polygon for placement evaluation.",
      "source": "WebSearch: beam search for packing problems",
      "agent": "explorer"
    },
    {
      "finding": "CRITICAL: Pre-optimized CSVs are at local optimum for local search. Must use CONSTRUCTIVE approaches (beam search, greedy backtracking, random initialization) to find better solutions. Local search on pre-optimized data = wasted experiments.",
      "source": "seed_prompt.txt",
      "agent": "explorer"
    },
    {
      "finding": "Score distribution by N: N=1-50 contributes 19.8%, N=51-100 contributes 25.4%, N=101-150 contributes 27.0%, N=151-200 contributes 27.8%. Focus optimization on higher N values for maximum impact.",
      "source": "exploration/eda.ipynb",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best optimization techniques for 2D irregular polygon packing problems?",
      "finding": "Two\u2011dimensional irregular polygon packing is an NP\u2011hard combinatorial problem, so most state\u2011of\u2011the\u2011art solvers rely on a mixture of exact, heuristic and learning\u2011based strategies.  **Exact branch\u2011and\u2011bound** methods can guarantee optimality for modest instance sizes by systematically exploring placement trees and pruning infeasible branches; a dedicated branch\u2011and\u2011bound algorithm for irregular pieces demonstrates strong performance on benchmark cutting\u2011and\u2011packing tests ([ScienceDirect](https://www.sciencedirect.com/science/article/abs/pii/S0925527313001692)).  **Geometric heuristics** remain the work\u2011horse for larger problems.  The classic *bottom\u2011left* placement rule, often combined with a preprocessing step that generates No\u2011Fit Polygons (NFPs), provides a fast constructive solution; recent refinements such as an *improved sliding algorithm* for NFP generation further reduce collisions and improve packing density ([MDPI](https://www.mdpi.com/2227-7390/10/16/2941)).  Heuristic selec",
      "agent": "explorer"
    },
    {
      "query": "What is beam search for combinatorial optimization and how does it work for packing problems?",
      "finding": "Beam search is a heuristic breadth\u2011first search that keeps only a fixed number\u202f\\(w\\)\u202fof the most promising partial solutions (the *beam*) at each depth of the search tree, discarding the rest.  It can be seen as a memory\u2011limited variant of best\u2011first search: nodes are expanded level\u2011by\u2011level, an evaluation (or scoring) function estimates the quality of each partial solution, and only the top\u202f\\(w\\)\u202fnodes are retained for the next expansion step\u202f([en.wikipedia.org](https://en.wikipedia.org/wiki/Beam_search)).  In combinatorial optimization the algorithm is used as an *incomplete* method that quickly produces high\u2011quality solutions when exhaustive search is infeasible; the key is designing a problem\u2011specific evaluation that guides which partial solutions survive.\n\nFor packing problems the search space is naturally expressed as a sequence of placement decisions.  Each node in the beam corresponds to a partially filled container together with an ordering of the items already placed.  When a",
      "agent": "explorer"
    }
  ],
  "remaining_submissions": 100,
  "max_submissions": 100,
  "last_reset_date_utc": "2026-01-19",
  "start_time": "2026-01-19T01:06:00.886828",
  "time_limit_minutes": 2100,
  "_saved_at": "2026-01-19T01:20:55.490103"
}