# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack n Christmas trees (n=1 to 200) into the smallest possible square bounding box for each configuration. 

**Metric:** Score = Σ(side²/n) for n=1 to 200 (lower is better)
**Target:** Beat 68.901319

## Tree Geometry
Each tree is a 15-vertex polygon with specific dimensions:
- Trunk: width=0.15, height=0.2
- Base tier: width=0.7
- Middle tier: width=0.4
- Top tier: width=0.25
- Tip at y=0.8

Tree vertices (TX, TY):
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

Trees can be rotated to any angle (continuous rotation).

## Submission Format
- CSV with columns: id, x, y, deg
- Values prefixed with 's' (e.g., "s0.123456")
- id format: "NNN_T" where NNN is the n-tree count (001-200) and T is tree index
- Coordinates constrained to -100 ≤ x, y ≤ 100

## Key Optimization Approaches from Public Kernels

### 1. bbox3 Binary Optimizer (Primary Tool)
From `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`:
- C++ compiled binary for global optimization
- Parameters: -n (iterations), -r (radius/range)
- Run in phases: short runs to find promising settings, then longer runs on best candidates
- Phase A: timeout=120s, n=[1000,1200,1500,1800,2000], r=[30,60,90]
- Phase B: timeout=600s on top candidates
- Phase C: timeout=1200s on best few

### 2. shake_public Binary Optimizer
From `../research/kernels/saspav_santa-submission/`:
- Local refinement tool
- Usage: `./shake_public --input="submission.csv" --output="submission.csv"`
- Run after bbox3 for additional optimization

### 3. fix_direction Rotation Tightening (Rotating Calipers)
Critical post-processing step based on the theorem: "The smallest-area enclosing rectangle has a side collinear with one edge of its convex hull."
```python
def optimize_rotation(trees):
    # Get all polygon points from all trees
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points_np = np.array(all_points)
    
    # Compute convex hull
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    # Use scipy.optimize.minimize_scalar to find optimal rotation angle
    res = minimize_scalar(
        lambda a: calculate_bbox_side_at_angle(a, hull_points),
        bounds=(0.001, 89.999), method='bounded'
    )
    return res.fun, res.x
```

### 4. Overlap Detection and Repair
- Use Shapely library for polygon operations
- STRtree for efficient spatial indexing
- Check intersects() but not touches() for true overlaps
- Replace invalid groups with donor solution (fallback to known-good configurations)

### 5. Backward Propagation (from smartmanoj kernel)
From `../research/kernels/smartmanoj_santa-claude/`:
- Remove trees from n-tree configuration to potentially improve (n-1)-tree configuration
- For each n from 200 down to 2:
  - Try removing each boundary-touching tree
  - If resulting (n-1) config is better than stored, save it
- Can find better configurations by "inheriting" from larger solutions

### 6. Additional Local Search Techniques
From `../research/kernels/smartmanoj_santa-claude/`:
- **Squeeze:** Scale all trees toward center (scale=0.9995 down to 0.98)
- **Compaction:** Move each tree toward center in small steps
- **8-directional moves:** Try moving each tree in 8 directions
- **Rotation adjustments:** Try small angle changes (±5°, ±2°, ±0.8°, etc.)
- **Swap moves:** Exchange positions of two trees
- **Multi-start:** Try different initial angle configurations

## Implementation Strategy

### Phase 1: Start with Best Baseline
- Use existing optimized submission from snapshots if available
- Or start from sample_submission.csv

### Phase 2: Global Optimization
```python
# Run bbox3 with different parameters
for r in [30, 60, 90]:
    for n in [1000, 1500, 2000]:
        subprocess.run(['./bbox3', '-n', str(n), '-r', str(r)])
```

### Phase 3: Local Refinement
```python
# Run shake_public
subprocess.run(['./shake_public', '--input=submission.csv', '--output=submission.csv'])
```

### Phase 4: Backward Propagation
```python
# For n from 200 down to 2
for n in range(200, 1, -1):
    cfg = load_config(n)
    for tree_idx in get_boundary_trees(cfg):
        test_cfg = remove_tree(cfg, tree_idx)
        if test_cfg.side() < best_sides[n-1]:
            save_config(n-1, test_cfg)
```

### Phase 5: Rotation Tightening
```python
# For each n-tree configuration
for n in range(1, 201):
    trees = load_trees_for_n(n)
    best_side, best_angle = optimize_rotation(trees)
    if best_angle > 0:
        rotated_trees = apply_rotation(trees, best_angle)
        save_trees(rotated_trees)
```

### Phase 6: Validation and Repair
```python
# Check for overlaps
invalid_groups = find_invalid_groups(submission_path)
# Replace with donor solution
for n in invalid_groups:
    replace_group(submission_path, donor_path, n)
```

## Key Techniques from Research

### Geometric Operations
1. **Polygon Representation:** Use Shapely Polygon with Decimal precision for accuracy
2. **Collision Detection:** Point-in-polygon test + segment intersection
3. **Bounding Box:** Track min/max x,y across all tree polygons
4. **Convex Hull:** For rotation optimization (scipy.spatial.ConvexHull)
5. **Rotating Calipers:** For finding optimal bounding box orientation

### Optimization Algorithms
1. **Greedy Placement:** Place trees one by one, moving from far to center until collision
2. **Weighted Angle Generation:** Bias angles toward corners (abs(sin(2*angle)))
3. **Separation Vector:** Push overlapping trees apart using centroid difference
4. **Iterative Refinement:** Multiple passes of local optimization
5. **Simulated Annealing:** Accept worse solutions with decreasing probability
6. **No-Fit Polygon (NFP):** Generate candidate placements using Minkowski sum

### Precision Handling
- Use Decimal with precision=25-30
- Scale factor for integer operations (1e15 or 1e18)
- Round to 6 decimal places for submission

## Code Structure Recommendation

```
/code/
├── main.py              # Main optimization loop
├── geometry.py          # ChristmasTree class, polygon operations
├── optimizer.py         # bbox3/shake integration
├── rotation.py          # fix_direction rotation tightening
├── backward_prop.py     # Backward propagation optimizer
├── local_search.py      # Squeeze, compaction, directional moves
├── validation.py        # Overlap detection and repair
├── utils.py             # CSV parsing, scoring
└── binaries/
    ├── bbox3            # Compiled C++ optimizer
    └── shake_public     # Local refinement tool
```

## Recommended Experiments (Priority Order)

1. **Baseline + Rotation Tightening:** Start with best available submission, apply fix_direction
2. **bbox3 Parameter Sweep:** Try different n/r combinations systematically
3. **Combined Pipeline:** bbox3 → shake_public → backward_prop → fix_direction → validate
4. **Per-N Optimization:** Focus on configurations with highest score contribution
5. **Asymmetric Solutions:** Consider non-symmetric tree arrangements (per discussion insights)
6. **Squeeze + Compaction:** Apply squeeze and compaction after other optimizations
7. **Multi-start Local Search:** Run local search from multiple random starting configurations

## Validation

### Local Scoring
```python
def calculate_score(submission_path):
    score = 0
    for n in range(1, 201):
        trees = load_trees_for_n(n)
        side = get_bounding_box_side(trees)
        score += (side ** 2) / n
    return score
```

### Overlap Check
```python
def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

## Key Dependencies
- shapely (polygon operations)
- numpy (numerical operations)
- scipy (optimization, convex hull)
- pandas (CSV handling)
- decimal (high precision arithmetic)
- OpenMP (for C++ parallelization)

## C++ Optimization Notes
The bbox3 and tree_packer C++ code uses:
- Complex number vector coordination
- Fluid dynamics concepts for tree movement
- OpenMP parallelization for overlap checks
- Long double precision for accuracy
- Fast RNG (xoshiro256++) for random operations

## Competition Insights
- Asymmetric solutions may outperform symmetric ones (per discussion insights)
- Focus optimization time on larger n values (higher score contribution)
- Always validate for overlaps before submission
- The problem is NP-hard; metaheuristics are the primary approach
- Combining multiple optimization techniques yields best results
- The smallest-area enclosing rectangle has a side collinear with one edge of the convex hull (key theorem for rotation optimization)

## Reference Kernels
- `../research/kernels/inversion_santa-2025-getting-started/` - Basic greedy algorithm
- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/` - bbox3 optimizer
- `../research/kernels/saspav_santa-submission/` - shake_public + fix_direction
- `../research/kernels/jazivxt_why-not/` - bbox3 C++ source code
- `../research/kernels/smartmanoj_santa-claude/` - Backward propagation + local search

## Snapshot Submissions
Pre-optimized submissions are available in `/home/nonroot/snapshots/santa-2025/`. These can be used as starting points for further optimization.
