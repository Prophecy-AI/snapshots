# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D irregular polygon packing optimization problem. The goal is to pack n Christmas trees (n=1 to 200) into the smallest possible square bounding box for each configuration. 

**Metric:** Score = Σ(side²/n) for n=1 to 200 (lower is better)
**Target:** Beat 68.901319

## Tree Geometry
Each tree is a 15-vertex polygon with specific dimensions:
- Trunk: width=0.15, height=0.2
- Base tier: width=0.7
- Middle tier: width=0.4
- Top tier: width=0.25
- Tip at y=0.8

The tree shape has 3 tiers (branches) and a trunk. Trees can be rotated to any angle.

## Submission Format
- CSV with columns: id, x, y, deg
- Values prefixed with 's' (e.g., "s0.123456")
- id format: "NNN_T" where NNN is the n-tree count (001-200) and T is tree index
- Coordinates constrained to -100 ≤ x, y ≤ 100

## Key Optimization Approaches from Public Kernels

### 1. bbox3 Binary Optimizer (Primary Tool)
From `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`:
- C++ compiled binary for global optimization
- Parameters: -n (iterations), -r (radius/range)
- Run in phases: short runs to find promising settings, then longer runs on best candidates
- Phase A: timeout=120s, n=[1000,1200,1500,1800,2000], r=[30,60,90]
- Phase B: timeout=600s on top candidates
- Phase C: timeout=1200s on best few

### 2. shake_public Binary Optimizer
From `../research/kernels/saspav_santa-submission/`:
- Local refinement tool
- Usage: `./shake_public --input="submission.csv" --output="submission.csv"`
- Run after bbox3 for additional optimization

### 3. fix_direction Rotation Tightening
Critical post-processing step:
```python
def optimize_rotation(trees):
    # Get all polygon points
    # Compute convex hull
    # Use scipy.optimize.minimize_scalar to find optimal rotation angle
    # Rotate entire configuration to minimize bounding box
```
- Uses convex hull of all tree polygons
- Finds optimal rotation angle (0-90 degrees) using bounded minimization
- Can significantly reduce bounding box size

### 4. Overlap Detection and Repair
- Use Shapely library for polygon operations
- STRtree for efficient spatial indexing
- Check intersects() but not touches() for true overlaps
- Replace invalid groups with donor solution (fallback to known-good configurations)

## Implementation Strategy

### Phase 1: Start with Best Baseline
- Use existing optimized submission from snapshots if available
- Or start from sample_submission.csv

### Phase 2: Global Optimization
```python
# Run bbox3 with different parameters
for r in [30, 60, 90]:
    for n in [1000, 1500, 2000]:
        subprocess.run(['./bbox3', '-n', str(n), '-r', str(r)])
```

### Phase 3: Local Refinement
```python
# Run shake_public
subprocess.run(['./shake_public', '--input=submission.csv', '--output=submission.csv'])
```

### Phase 4: Rotation Tightening
```python
# For each n-tree configuration
for n in range(1, 201):
    trees = load_trees_for_n(n)
    best_side, best_angle = optimize_rotation(trees)
    if best_angle > 0:
        rotated_trees = apply_rotation(trees, best_angle)
        save_trees(rotated_trees)
```

### Phase 5: Validation and Repair
```python
# Check for overlaps
invalid_groups = find_invalid_groups(submission_path)
# Replace with donor solution
for n in invalid_groups:
    replace_group(submission_path, donor_path, n)
```

## Key Techniques from Research

### Geometric Operations
1. **Polygon Representation:** Use Shapely Polygon with Decimal precision for accuracy
2. **Collision Detection:** Point-in-polygon test + segment intersection
3. **Bounding Box:** Track min/max x,y across all tree polygons
4. **Convex Hull:** For rotation optimization (scipy.spatial.ConvexHull)

### Optimization Algorithms
1. **Greedy Placement:** Place trees one by one, moving from far to center until collision
2. **Weighted Angle Generation:** Bias angles toward corners (abs(sin(2*angle)))
3. **Separation Vector:** Push overlapping trees apart using centroid difference
4. **Iterative Refinement:** Multiple passes of local optimization

### Precision Handling
- Use Decimal with precision=25-30
- Scale factor for integer operations (1e15 or 1e18)
- Round to 6 decimal places for submission

## Code Structure Recommendation

```
/code/
├── main.py              # Main optimization loop
├── geometry.py          # ChristmasTree class, polygon operations
├── optimizer.py         # bbox3/shake integration
├── rotation.py          # fix_direction rotation tightening
├── validation.py        # Overlap detection and repair
├── utils.py             # CSV parsing, scoring
└── binaries/
    ├── bbox3            # Compiled C++ optimizer
    └── shake_public     # Local refinement tool
```

## Recommended Experiments (Priority Order)

1. **Baseline + Rotation Tightening:** Start with best available submission, apply fix_direction
2. **bbox3 Parameter Sweep:** Try different n/r combinations systematically
3. **Combined Pipeline:** bbox3 → shake_public → fix_direction → validate
4. **Per-N Optimization:** Focus on configurations with highest score contribution
5. **Asymmetric Solutions:** Consider non-symmetric tree arrangements (per discussion insights)

## Validation

### Local Scoring
```python
def calculate_score(submission_path):
    score = 0
    for n in range(1, 201):
        trees = load_trees_for_n(n)
        side = get_bounding_box_side(trees)
        score += (side ** 2) / n
    return score
```

### Overlap Check
```python
def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

## Key Dependencies
- shapely (polygon operations)
- numpy (numerical operations)
- scipy (optimization, convex hull)
- pandas (CSV handling)
- decimal (high precision arithmetic)

## Notes
- The bbox3 C++ code uses complex number vector coordination and fluid dynamics concepts
- Asymmetric solutions may outperform symmetric ones (per competition discussions)
- Focus optimization time on larger n values (higher score contribution)
- Always validate for overlaps before submission
