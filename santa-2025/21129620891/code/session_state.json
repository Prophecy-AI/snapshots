{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T08:02:59.932337",
  "time_limit_minutes": 2100,
  "experiments": [
    {
      "id": "exp_000",
      "name": "001_baseline_fix_direction_bbox3",
      "model_type": "optimization",
      "score": 150.761401,
      "cv_score": 150.761401,
      "lb_score": null,
      "notes": "Baseline experiment: Started with sample submission (score 173.65), applied fix_direction optimization (3 passes) to get 151.37, then ran bbox3 optimizer for 500 iterations to get 150.76. The sample submission uses only 4 rotation angles (0, 90, 180, 270) which is suboptimal. The bbox3 optimizer is slow (~2341s per 100 iterations) and provides minimal improvement because the initial positions are poor. Need a better starting solution or different optimization approach. Target is 68.92.",
      "experiment_folder": "/home/code/experiments/001_baseline",
      "timestamp": "2026-01-19T11:30:16.993005"
    }
  ],
  "candidates": [
    {
      "file_path": "/home/code/submission_candidates/candidate_000.csv",
      "score": 150.761401,
      "cv_score": 150.761401,
      "model_name": "001_baseline_fix_direction_bbox3",
      "experiment_id": "exp_000",
      "timestamp": "2026-01-19T11:30:16.994356"
    }
  ],
  "submissions": [],
  "strategy_history": [
    {
      "strategy": "# Christmas Tree Packing Optimization - Seed Prompt\n\n## Problem Overview\nThis is a 2D irregular polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (15-vertex non-convex shapes) into the smallest possible square bounding box for each n-tree configuration (n=1 to 200). \n\n**Metric:** Score = \u03a3(s\u00b2/n) for n=1 to 200, where s is the side length of the bounding square. Lower is better.\n**Target Score:** Beat 68.922808\n**Total submission rows:** 20,100 (sum of 1 to 200)\n\n## Tree Geometry\n- 15-vertex polygon with trunk (non-convex shape)\n- Key dimensions: trunk_w=0.15, trunk_h=0.2, base_w=0.7, mid_w=0.4, top_w=0.25, tip_y=0.8\n- TX coordinates: [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]\n- TY coordinates: [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]\n- Trees can be rotated (0-360 degrees continuous) and positioned (x, y)\n- Collision detection uses Shapely polygons with high precision (Decimal type)\n\n## Key Insight: Asymmetric Solutions Win\n**Source:** Competition discussions\n\nWinning solutions tend to be **asymmetric**, not symmetric. While symmetric arrangements may seem optimal, asymmetric configurations often achieve better packing density. This means:\n- Don't force symmetry constraints\n- Allow the optimizer to explore irregular arrangements\n- Focus on exploration over exploitation\n\n## Top Approaches from Public Kernels\n\n### 1. bbox3 C++ Optimizer (Primary Approach)\n**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`\n\nThe bbox3 optimizer is the most successful approach, using:\n- Complex number vector coordination for efficient geometry\n- Fluid dynamics-inspired movement\n- Hinge pivot optimization\n- Density gradient flow\n- Global boundary tension\n- OpenMP parallelization for speed\n- Aggressive overlap repair cycles\n\n**Key parameters:**\n- `-n`: Number of iterations (try 1000-10000)\n- `-r`: Restart/radius parameter (try 30-256)\n\n**Usage pattern:**\n```bash\ng++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp\n./bbox3 -n 5000 -r 60\n```\n\n### 2. tree_packer C++ Optimizer\n**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n\nAlternative optimizer with different techniques:\n- Swap moves between trees\n- Multi-angle restarts (try different starting rotations)\n- Higher temperature simulated annealing\n- Squeeze operation (scale all trees towards center)\n- Compaction (move individual trees toward center)\n- Local search with 8-directional moves + rotation adjustments\n- Uses long double precision for accuracy\n\n### 3. fix_direction Post-Processing (CRITICAL)\n**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`\n\nCritical post-processing step that optimizes the rotation of the entire configuration:\n- Uses scipy.optimize.minimize_scalar with bounded method\n- Computes convex hull of all tree polygon points\n- Finds optimal rotation angle (0-90 degrees) to minimize bounding box\n- Can improve score significantly - always apply after optimization\n- Multiple passes (1-3) can help\n\n```python\nfrom scipy.optimize import minimize_scalar\nfrom scipy.spatial import ConvexHull\n\ndef optimize_rotation(trees):\n    # Get all polygon points\n    all_points = []\n    for tree in trees:\n        all_points.extend(list(tree.polygon.exterior.coords))\n    points_np = np.array(all_points)\n    hull_points = points_np[ConvexHull(points_np).vertices]\n    \n    # Find optimal rotation\n    res = minimize_scalar(\n        lambda a: calculate_bbox_side_at_angle(a, hull_points),\n        bounds=(0.001, 89.999), method='bounded'\n    )\n    return res.x, res.fun\n```\n\n### 4. Backward Propagation\n**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n\nImproves smaller configurations by extracting from larger ones:\n- Start from n=200, work down to n=2\n- For each n, try removing boundary-touching trees\n- If resulting (n-1) config is better than current best, save it\n- Exploits the fact that good large configs often contain good smaller configs\n\n## Multi-Phase Optimization Strategy\n**Source:** `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`\n\nRecommended workflow:\n1. **Phase A (Short runs):** 2-min runs with many n/r combinations to find promising settings\n   - n_values: [1000, 1200, 1500, 1800, 2000]\n   - r_values: [30, 60, 90]\n2. **Phase B (Medium runs):** 10-min runs on top 3 candidates\n3. **Phase C (Long runs):** 20-min runs on best 2 settings\n4. **Validation:** Check for overlaps, repair by replacing with donor solution\n5. **Post-processing:** Apply fix_direction with multiple passes\n\n## Key Optimization Techniques from Research\n\n### Constructive Heuristics\n- Bottom-left (BL) placement rule\n- Weighted angle generation (prefer diagonal orientations for square packing)\n- Greedy placement with collision detection\n\n### Local Search Moves\n- **Jostle:** Small random perturbations\n- **Swap:** Exchange positions of two trees\n- **Rotate:** Adjust individual tree angles (try \u00b15\u00b0, \u00b12\u00b0, \u00b10.8\u00b0, \u00b10.3\u00b0, \u00b10.1\u00b0)\n- **Translate:** Move trees toward center or away from boundaries\n- **Boundary focus:** Prioritize moving trees that touch the bounding box\n\n### Meta-heuristics\n- Simulated Annealing with adaptive temperature\n- Genetic Algorithms for sequence optimization\n- Particle Swarm Optimization for placement order\n\n### Geometric Techniques\n- No-fit polygon (NFP) for collision-free regions - reduces collision check from O(nm) to O(k)\n- Convex hull for bounding box optimization\n- STRtree for efficient spatial queries (Shapely)\n- Minkowski sums for NFP computation\n\n## Validation & Overlap Repair\n\n**CRITICAL:** Submissions with overlapping trees are rejected!\n\n**Overlap detection:**\n```python\nfrom shapely.strtree import STRtree\n\ndef has_overlap(trees):\n    polygons = [t.polygon for t in trees]\n    tree_index = STRtree(polygons)\n    for i, poly in enumerate(polygons):\n        indices = tree_index.query(poly)\n        for idx in indices:\n            if idx != i:\n                if poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):\n                    return True\n    return False\n```\n\n**Repair strategy:**\n- If overlaps detected for configuration n, replace with known-good solution\n- Keep a \"donor\" submission with valid configurations\n- Use replace_group() function to swap individual n-configurations\n\n## Recommended Experiments (Priority Order)\n\n1. **Implement bbox3 optimizer** - Compile and run with various n/r parameters\n   - Start with n=5000, r=60\n   - Try grid search: n in [1000, 2000, 5000, 10000], r in [30, 60, 90, 120]\n\n2. **Apply fix_direction post-processing** - Always run after optimization\n   - Multiple passes can help (passes=1 to 3)\n\n3. **Backward propagation** - Extract better small configs from large ones\n\n4. **Ensemble approach** - Keep best configuration for each n across multiple runs\n   - Run optimizer multiple times with different seeds\n   - For each n, keep the configuration with smallest bounding box\n\n5. **Local search refinement** - Fine-tune positions with small step sizes\n   - Focus on boundary-touching trees\n   - Try small translations and rotations\n\n6. **Hybrid approach** - Combine bbox3 and tree_packer\n   - Use bbox3 for initial optimization\n   - Apply tree_packer's local search for refinement\n\n## Submission Format\n```\nid,x,y,deg\n001_0,s0.0,s0.0,s90.0\n002_0,s0.0,s0.0,s90.0\n002_1,s0.202736,s-0.511271,s90.0\n...\n```\n- Values prefixed with 's' to preserve precision\n- Coordinates constrained to -100 \u2264 x, y \u2264 100\n- Use high precision (at least 6 decimal places)\n\n## Important Implementation Notes\n\n1. **Precision matters:** Use Decimal type or long double for coordinates\n2. **Continuous rotation:** Don't limit to 90\u00b0 increments - use continuous angles\n3. **Parallel processing:** Use OpenMP for C++ or multiprocessing for Python\n4. **Incremental improvement:** Save best solution after each improvement\n5. **Time management:** Budget time across phases, don't spend all time on one approach\n6. **Asymmetric is better:** Don't force symmetry - let optimizer find irregular arrangements\n\n## Code References\n- Getting started: `../research/kernels/inversion_santa-2025-getting-started/`\n- bbox3 source: `../research/kernels/jazivxt_why-not/why-not.ipynb`\n- tree_packer: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n- Multi-phase runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`\n- Fix direction: `../research/kernels/saspav_santa-submission/santa-submission.ipynb`\n\n## Quick Start Implementation\n\nFor a Python-only approach without C++ compilation:\n\n```python\n# 1. Load best available submission (from kernels or sample)\n# 2. Apply fix_direction optimization for each n\n# 3. Validate for overlaps\n# 4. Apply local search refinement (small translations/rotations)\n# 5. Backward propagation for small configs\n# 6. Final validation and save\n```\n\nFor best results, use the C++ optimizers (bbox3 or tree_packer) with Python post-processing.\n\n## Expected Score Progression\nBased on competition discussions:\n- Sample submission: ~157 (very basic)\n- With fix_direction: ~75-80\n- With bbox3 optimization: ~68-70\n- With full pipeline: <68 (target)\n\nThe target of 68.922808 is achievable with proper implementation of the C++ optimizers and post-processing steps.\n",
      "agent": "explorer",
      "timestamp": "2026-01-19T08:10:07.639992"
    }
  ],
  "feedback_history": [
    {
      "feedback": "## What I Understood\n\nThe junior researcher is working on the Santa 2025 competition - a 2D polygon packing optimization problem where the goal is to pack Christmas tree-shaped polygons into the smallest possible square bounding boxes for n=1 to 200 trees. The target score is 68.92 (lower is better). They started with the sample submission (score ~157), applied fix_direction optimization (3 passes) to get 151.37, then ran the bbox3 C++ optimizer for 500 iterations to achieve 150.76. The approach follows the kernel recommendations but the results are far from the target.\n\n## Technical Execution Assessment\n\n**Validation**: The scoring methodology is correct - computing s\u00b2/n for each configuration and summing. The bbox3 optimizer correctly tracks and reports scores.\n\n**Leakage Risk**: None - this is an optimization problem, not a prediction task. No train/test split concerns.\n\n**Score Integrity**: Verified in the execution logs. The bbox3 optimizer reported:\n- Initial score: 151.37 (after fix_direction)\n- Final score: 150.76 (after 500 iterations)\n- This is a legitimate but minimal improvement (~0.6 points)\n\n**Code Quality**: The bbox3.cpp implementation is sound. It uses OpenMP parallelization, proper overlap detection, and the global_squeeze optimization approach. However, the optimizer is designed for refinement, not for creating good initial solutions from scratch.\n\nVerdict: **TRUSTWORTHY** - The results are technically correct, but the approach has fundamental limitations.\n\n## Strategic Assessment\n\n**Approach Fit**: \u26a0\ufe0f **CRITICAL ISSUE** - The approach is fundamentally misaligned with the problem.\n\nThe bbox3 optimizer and fix_direction are **refinement tools** designed to improve already-good solutions. Looking at the kernels:\n- `saspav_santa-submission` uses `/kaggle/input/santa-2025-csv/santa-2025.csv` as input - a pre-optimized submission with score ~68-70\n- `yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner` also uses pre-optimized inputs\n\nThe sample submission has trees placed in a very sparse, inefficient pattern using only 4 rotation angles (0\u00b0, 90\u00b0, 180\u00b0, 270\u00b0). The bbox3 optimizer's \"global_squeeze\" approach (scaling towards center + overlap repair) cannot fundamentally restructure this poor layout - it can only make marginal improvements.\n\n**The gap**: 150.76 \u2192 68.92 is a **54% reduction** needed. This is not achievable through local refinement of a bad starting point.\n\n**Effort Allocation**: Misallocated. Running bbox3 for 500 iterations on a poor starting point is wasted compute. The bottleneck is the **initial solution quality**, not the refinement.\n\n**Assumptions**: The implicit assumption is that bbox3 can optimize any starting point to a competitive solution. This is FALSE. The optimizer is designed for local search, not global restructuring.\n\n**Blind Spots - CRITICAL**:\n\n1. **No constructive heuristic**: The kernels assume you have a good starting solution. Without one, you need to BUILD one. The seed prompt mentions:\n   - Bottom-left (BL) placement rule\n   - Greedy placement with collision detection\n   - Weighted angle generation (prefer diagonal orientations)\n   \n   None of these were implemented.\n\n2. **tree_packer optimizer not tried**: The `smartmanoj_santa-claude` kernel has a different optimizer with:\n   - Swap moves between trees\n   - Multi-angle restarts\n   - Higher temperature simulated annealing\n   - Compaction moves\n   \n   This might be better at restructuring poor solutions.\n\n3. **Backward propagation not implemented**: The technique of extracting smaller configurations from larger ones could help, but requires a good n=200 solution first.\n\n**Trajectory**: The current trajectory is **not promising**. Continuing to run bbox3 on the sample submission will yield diminishing returns. A fundamental change in approach is needed.\n\n## What's Working\n\n1. **Infrastructure is solid**: The bbox3 optimizer compiles and runs correctly. The fix_direction post-processing works.\n2. **Understanding of the problem**: The researcher correctly identified the key techniques from kernels.\n3. **Validation**: The overlap checking and scoring are implemented correctly.\n\n## Key Concerns\n\n### 1. **CRITICAL: No Good Starting Solution**\n- **Observation**: Starting from sample submission (score ~157) instead of a pre-optimized solution (~68-70)\n- **Why it matters**: The gap is too large for local search to bridge. bbox3 is designed for refinement, not restructuring.\n- **Suggestion**: Implement a constructive heuristic to generate a better initial solution:\n  ```\n  For each n from 1 to 200:\n    1. Start with empty configuration\n    2. For each tree to place:\n       a. Try multiple rotation angles (0\u00b0, 15\u00b0, 30\u00b0, 45\u00b0, 60\u00b0, 75\u00b0, 90\u00b0, etc.)\n       b. For each angle, find the bottom-left valid position\n       c. Choose the (angle, position) that minimizes bounding box\n    3. Apply fix_direction to optimize global rotation\n  ```\n\n### 2. **Optimizer Parameters Not Tuned**\n- **Observation**: Used -n 500 -r 60 without exploring other settings\n- **Why it matters**: The multi-phase strategy from kernels suggests trying many (n, r) combinations\n- **Suggestion**: Once you have a better starting solution, try:\n  - n_values: [1000, 2000, 5000, 10000]\n  - r_values: [30, 60, 90, 120, 256]\n\n### 3. **Alternative Optimizers Not Explored**\n- **Observation**: Only bbox3 was tried\n- **Why it matters**: tree_packer has different moves (swap, compaction) that might help restructure poor solutions\n- **Suggestion**: Compile and try tree_packer from `smartmanoj_santa-claude` kernel\n\n## Top Priority for Next Experiment\n\n**IMPLEMENT A CONSTRUCTIVE PLACEMENT ALGORITHM**\n\nThe current approach cannot succeed because the starting point is fundamentally flawed. Before running any optimizer, you need to generate a reasonable initial solution.\n\nRecommended approach:\n1. **Implement greedy bottom-left placement**:\n   - For each n, place trees one by one\n   - For each tree, try multiple angles (at least 8-12 angles from 0\u00b0 to 360\u00b0)\n   - For each angle, find the position that minimizes the bounding box while avoiding overlaps\n   - Use the best (angle, position) combination\n\n2. **Apply fix_direction** after each n-configuration is complete\n\n3. **Then run bbox3** for refinement\n\nThis should get you from ~150 to ~75-80, which is within striking distance of the target. The bbox3 optimizer can then refine to ~68-70.\n\nAlternative quick win: Check if the `smartmanoj_santa-claude` kernel's tree_packer can generate better initial solutions from scratch, or if it has a constructive placement mode.\n\n**Time is valuable** - don't spend more compute on refining the sample submission. The fundamental issue is the starting point, not the refinement algorithm.\n",
      "experiment_id": "exp_000",
      "agent": "evaluator",
      "timestamp": "2026-01-19T11:32:13.884940"
    }
  ],
  "data_findings": [
    {
      "finding": "Problem is 2D bin packing: pack Christmas tree-shaped polygons into smallest square bounding box for n=1 to 200 trees. Score = sum(s\u00b2/n) where s is side length. Lower is better. Target: 68.922808",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "bbox3.cpp is the key optimizer: C++ code using complex number vector coordination, fluid dynamics, hinge pivot, density gradient flow, global boundary tension. Uses OpenMP parallelization. Key params: -n (iterations) -r (radius). Compiled binary runs optimization.",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "fix_direction technique: Optimizes rotation of entire tree configuration to minimize bounding box. Uses scipy.optimize.minimize_scalar with convex hull points. Can improve score by finding optimal rotation angle (0-90 degrees).",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Multi-phase optimization strategy: Phase A (short 2min runs, many n/r combos), Phase B (10min on top candidates), Phase C (20min on best few). Always validate for overlaps and repair by replacing with donor solution.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "tree_packer C++ optimizer: Uses swap moves, multi-angle restarts, higher temperature SA, squeeze, compaction, local search. Key params: -n (iterations) -r (restarts). Also has backward_propagation.cpp that improves smaller configs by removing trees from larger ones.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Tree geometry: 15 vertices polygon with trunk. TX/TY coordinates define shape. Key dimensions: trunk_w=0.15, trunk_h=0.2, base_w=0.7, mid_w=0.4, top_w=0.25, tip_y=0.8. Rotation around origin (0,0).",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "No-fit polygon (NFP) is key geometric technique: Represents all relative positions where two polygons touch/overlap. Reduces collision detection from O(nm) to O(k) point-in-polygon test. Can be computed via Minkowski sums or orbital/sliding methods.",
      "source": "Web search - 2D polygon packing",
      "agent": "explorer"
    },
    {
      "finding": "Sample submission uses only 4 rotation angles (0, 90, 180, 270) - this is suboptimal. Continuous rotation optimization can significantly improve packing density. Total rows: 20100 (sum of 1 to 200).",
      "source": "exploration/eda.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Discussion insight: Winning solutions tend to be asymmetric (not symmetric). Symmetric solutions may be locally optimal but asymmetric arrangements can achieve better packing density. Focus on exploration over exploitation.",
      "source": "../research/discussions.json - \"Why the winning solutions will be Asymmetric\"",
      "agent": "explorer"
    },
    {
      "finding": "Well-Aligned Initial Solution kernel (zaburo): Creates grid-based initial solution with score ~88.33 by placing trees in rows with alternating orientations (0\u00b0 and 180\u00b0). Tries different row configurations (n_even, n_odd) to find best packing. This is MUCH better than sample submission (173.65).",
      "source": "research/kernels/zaburo_88-32999-a-well-aligned-initial-solution/",
      "agent": "evolver"
    },
    {
      "finding": "Backward propagation technique: Start from n=200, work down to n=1. For each n, try removing each boundary-touching tree and keep the configuration that minimizes bounding box. Propagates good packing patterns from larger to smaller configurations.",
      "source": "research/kernels/crodoc_74-75-backpacking-christmas-trees/",
      "agent": "evolver"
    },
    {
      "finding": "Simulated Annealing with translations: Uses two-tree translation patterns in x and y directions. Perturbs tree positions and angles with decreasing temperature. Can improve specific n-configurations significantly.",
      "source": "research/kernels/egortrushin_santa25-simulated-annealing-with-translations/",
      "agent": "evolver"
    }
  ],
  "web_research": [
    {
      "query": "What are the best optimization algorithms for 2D irregular polygon packing problems?",
      "finding": "Two\u2011dimensional irregular polygon packing \u2013 often called irregular strip or bin packing \u2013 seeks a layout of arbitrarily shaped polygons inside a rectangular sheet (or a set of sheets) while minimizing waste or the number of bins used. Because the geometry of each piece influences both feasibility and quality of a solution, the problem is NP\u2011hard and is typically tackled with a blend of constructive heuristics, local\u2011search/meta\u2011heuristic refinements, and, for small instances, exact methods\u202f([Frontiers review](https://www.frontiersin.org/articles/10.3389/fmech.2022.966691/full)).\n\nAmong the most successful approaches are:\n\n* **Constructive placement heuristics** \u2013 the classic bottom\u2011left (BL) rule and its variants provide a fast initial sequence; the Djang\u2011Finch selection heuristic (DJD) adapted for irregular shapes, when coupled with a placement routine, yields significantly better packings than conventional selectors\u202f([Springer article](https://link.springer.com/article/10.1007/s10479",
      "agent": "explorer"
    },
    {
      "query": "What is the no-fit polygon technique for 2D polygon packing and how does it work?",
      "finding": "The no\u2011fit polygon (NFP) is a geometric construct that represents **all relative positions at which two planar polygons can be placed without intersecting**.  In a 2\u2011D packing or nesting problem the NFP of a \u201cmoving\u201d piece\u202fA with respect to a fixed piece\u202fB defines the feasible region for the reference point of\u202fA; any point inside the NFP corresponds to a placement where the two shapes do not overlap, while points outside would cause a collision.  Because the NFP reduces a continuous overlap test to a simple point\u2011in\u2011polygon query, it is a cornerstone of irregular cutting\u2011stock and nesting algorithms\u202f([Computers & Operations Research](https://www.sciencedirect.com/science/article/abs/pii/S0305054806000669); [Elsevier](https://www.sciencedirect.com/science/article/abs/pii/S0377221706012379)).\n\nMost modern NFP generators are based on **Minkowski sums** or on **sliding/orbital methods** that trace the interaction of the two polygon boundaries.  The Minkowski\u2011sum approach treats the NFP as ",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 95
}