# Christmas Tree Packing Optimization - Evolved Seed Prompt (Loop 1)

## Current Status
- Best CV score: 150.76 from exp_000 (001_baseline_fix_direction_bbox3)
- Best LB score: N/A (no submissions yet)
- Target: 68.922808 | Gap to target: 81.84 points (54% reduction needed)

## Response to Evaluator
**Technical verdict was TRUSTWORTHY** - The execution is sound, but the approach has fundamental limitations.

**Evaluator's top priority: IMPLEMENT A CONSTRUCTIVE PLACEMENT ALGORITHM**
- **FULLY AGREE.** The evaluator correctly identified that the fundamental problem is the poor starting solution (sample submission score ~157). The bbox3 optimizer is designed for refinement, not restructuring. Running it on a poor starting point yields minimal improvements.

**Key concerns raised:**
1. No constructive heuristic - **ADDRESSING NOW** with the Well-Aligned Initial Solution approach
2. Optimizer parameters not tuned - Will address after getting a better starting solution
3. Alternative optimizers not explored - Will try tree_packer after constructive heuristic

## Critical Insight: The Starting Point Problem

The sample submission has score ~173.65 (after fix_direction: ~151.37). The target is 68.92. This is a **54% reduction** that cannot be achieved through local search refinement alone.

**Solution discovered in kernels:**
- `zaburo/88-32999-a-well-aligned-initial-solution` provides a constructive heuristic that achieves score ~88.33
- This is a grid-based placement with alternating tree orientations
- From 88.33, the bbox3 optimizer can refine to ~68-70

## Data Understanding
- Reference notebooks: See `exploration/eda.ipynb` for tree geometry
- Key findings from research:
  - Tree geometry: 15-vertex polygon, 0.7 width at base, 1.0 height total
  - Trees can be placed in rows with alternating 0° and 180° orientations
  - Asymmetric solutions tend to win (don't force symmetry)

## Recommended Approaches (Priority Order)

### 1. **CRITICAL: Implement Well-Aligned Initial Solution** (HIGHEST PRIORITY)
**Source:** `research/kernels/zaburo_88-32999-a-well-aligned-initial-solution/`

Implement the constructive heuristic that creates a grid-based initial solution:
```python
def find_best_trees(n: int) -> tuple[float, list[ChristmasTree]]:
    best_score, best_trees = float("inf"), None
    for n_even in range(1, n + 1):
        for n_odd in [n_even, n_even - 1]:
            all_trees = []
            rest = n
            r = 0
            while rest > 0:
                m = min(rest, n_even if r % 2 == 0 else n_odd)
                rest -= m
                angle = 0 if r % 2 == 0 else 180
                x_offset = 0 if r % 2 == 0 else Decimal("0.7") / 2
                y = r // 2 * Decimal("1.0") if r % 2 == 0 else (Decimal("0.8") + (r - 1) // 2 * Decimal("1.0"))
                row_trees = [ChristmasTree(center_x=Decimal("0.7") * i + x_offset, center_y=y, angle=angle) for i in range(m)]
                all_trees.extend(row_trees)
                r += 1
            # Calculate score and keep best
```

This should get us from ~150 to ~88, a massive improvement.

### 2. Apply fix_direction Post-Processing
After constructive placement, apply fix_direction to optimize global rotation:
- Use scipy.optimize.minimize_scalar with bounded method
- Multiple passes (1-3) can help
- Expected improvement: 1-3 points

### 3. Run bbox3 Optimizer on Better Starting Point
With score ~88 starting point, bbox3 can refine to ~68-70:
- Try parameters: n=5000, r=60
- Then try: n=10000, r=120
- The optimizer is designed for refinement and will work much better on a good starting point

### 4. Apply Backward Propagation
**Source:** `research/kernels/crodoc_74-75-backpacking-christmas-trees/`

After optimization, apply backward propagation:
- Start from n=200, work down to n=1
- For each n, try removing each boundary-touching tree
- Keep configuration that minimizes bounding box
- Propagates good patterns from larger to smaller configurations

### 5. Try tree_packer Optimizer
**Source:** `research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Alternative optimizer with different moves:
- Swap moves between trees
- Multi-angle restarts
- Higher temperature simulated annealing
- Compaction moves

## What NOT to Try
- ❌ Running bbox3 on sample submission - already proven ineffective
- ❌ Hyperparameter tuning before getting a good starting solution
- ❌ Forcing symmetric arrangements - asymmetric solutions win

## Validation Notes
- Always validate for overlaps before saving
- Use Shapely STRtree for efficient collision detection
- Score = Σ(s²/n) for n=1 to 200, lower is better
- Coordinates must be in range [-100, 100]

## Expected Trajectory
1. Constructive heuristic: 150 → 88 (immediate)
2. fix_direction: 88 → 85 (quick)
3. bbox3 optimization: 85 → 72 (hours)
4. Backward propagation: 72 → 70 (quick)
5. Fine-tuning: 70 → 68.9 (target)

## Code References
- Constructive heuristic: `research/kernels/zaburo_88-32999-a-well-aligned-initial-solution/`
- bbox3 optimizer: `research/kernels/jazivxt_why-not/why-not.ipynb`
- fix_direction: `research/kernels/saspav_santa-submission/santa-submission.ipynb`
- Backward propagation: `research/kernels/crodoc_74-75-backpacking-christmas-trees/`
- tree_packer: `research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

## Immediate Next Steps
1. Create new experiment folder: `experiments/002_constructive_heuristic`
2. Implement the Well-Aligned Initial Solution from zaburo's kernel
3. Apply fix_direction post-processing
4. Validate and score the result
5. If score ~85-88, proceed to bbox3 optimization
