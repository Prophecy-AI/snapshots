# Santa 2025 Christmas Tree Packing - Seed Prompt

## Problem Overview
This is a 2D packing optimization problem. The goal is to pack N Christmas trees (N=1 to 200) into the smallest possible square bounding box for each N. 

**Scoring:** score = Σ(side_length² / N) for N=1 to 200. Lower is better.
**Target:** 68.919154
**Best public solution:** ~70.65 (bucket-of-chump dataset)
**Gap to close:** ~1.73 points

## Key Data Characteristics
- Each tree is a 15-vertex polygon (Christmas tree shape with trunk)
- Trees can be positioned (x, y) and rotated (deg)
- No overlapping trees allowed
- Coordinates must be in range [-100, 100]
- Score is evenly distributed: N=1-50 contributes ~19, N=51-100 ~17.6, N=101-150 ~17.1, N=151-200 ~16.8

## Pre-optimized Solutions Available
1. **bucket-of-chump dataset** (jazivxt): Score ~70.65, includes bbox3 binary
2. **santa-2025-csv dataset** (saspav): Score ~70.66, includes bbox3 binary

Download with:
```bash
kaggle datasets download jazivxt/bucket-of-chump -p preoptimized/ --unzip
kaggle datasets download saspav/santa-2025-csv -p saspav/ --unzip
```

## Key Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (Simulated Annealing)
- The main optimization tool used by top kernels
- Uses complex number vector coordination, fluid dynamics, hinge pivot
- Parameters: -n (iterations), -r (random seed)
- Typical usage: `./bbox3 -n 1000 -r 30`
- WARNING: Pre-optimized solutions are already at local optima - running more SA iterations yields diminishing returns

### 2. fix_direction (Rotation Optimization)
- After SA optimization, rotate the entire configuration to minimize bounding box
- Uses scipy.optimize.minimize_scalar to find optimal rotation angle
- Can squeeze out small improvements (1e-8 to 1e-6 range)

### 3. Backward Propagation
- If removing one tree from N-tree config gives better (N-1)-tree config, propagate backward
- Can find better solutions for smaller N values

### 4. Overlap Repair
- After optimization, check for overlaps and repair by replacing with donor solution
- Essential for valid submissions

## Discussion Insights (from discussions.json)
1. **Asymmetric vs Symmetric solutions** (high-vote discussions):
   - "Why the winning solutions will be Asymmetric" (34 votes)
   - "Symmetric solutions that are apparently optimal" (42 votes)
   - Suggests different approaches may work for different N ranges

2. **Tessellations** for efficient packing (mentioned in discussions)
   - May work better for large N values

3. **SA micro-optimization has diminishing returns**
   - "My Journey with Claude Code: 7,850 Rounds of Optimization, 0 Improvements" (13 votes)
   - Pre-optimized solutions are at local optima

## Recommended Strategy

### Phase 1: Establish Baseline
1. Download bucket-of-chump dataset as starting point
2. Verify score matches ~70.65
3. Run fix_direction to tighten rotations

### Phase 2: Focus on Specific N Ranges
Since score is evenly distributed, improvements in any range help:
- Small N (1-50): Try exhaustive search, symmetric patterns
- Medium N (51-100): Try different initialization patterns
- Large N (101-200): Try tessellation-based approaches

### Phase 3: Alternative Approaches (NOT just more SA)
1. **Constructive approaches**: Build solutions tree-by-tree with beam search
2. **Tessellation patterns**: Use regular patterns as starting points for large N
3. **Hybrid symmetric/asymmetric**: Use symmetric for some N, asymmetric for others
4. **Per-N specialization**: Different strategies for different N values

### Phase 4: Ensemble Best Solutions
- Combine best configurations from different approaches
- For each N, keep the configuration with lowest score

## Code Resources
- Getting started: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
- Full optimization: `../research/kernels/saspav_santa-submission/`
- Alternative approaches: `../research/kernels/smartmanoj_santa-claude/`

## Critical Notes
1. **DO NOT** just run more SA iterations on pre-optimized solutions - they're at local optima
2. **DO** try fundamentally different approaches (tessellations, constructive methods)
3. **DO** focus on per-N improvements rather than global optimization
4. **DO** validate for overlaps before submission
5. The gap of 1.73 points requires ~2.5% improvement - this needs new approaches, not micro-optimization

## Validation Code
```python
from shapely.strtree import STRtree
from shapely.geometry import Polygon

def has_overlap(trees):
    polygons = [t.polygon for t in trees]
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx != i and poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

## Submission Format
```
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s-0.541068,s0.259317,s51.66348
...
```
Note: Values must be prefixed with 's' to preserve precision.
