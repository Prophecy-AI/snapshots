# Santa 2025 Christmas Tree Packing - Evolved Seed Prompt (Loop 3)

## Current Status
- **Best CV score:** 70.647306 from exp_002 (003_full_ensemble_bbox3)
- **Best LB score:** 70.647306 (CV = LB exactly, as expected for optimization)
- **Target:** 68.919154
- **Gap to target:** 1.728152 (2.45% improvement needed)

## LB Feedback Analysis
- CV = LB exactly for all 3 submissions (no gap)
- This is expected for optimization problems - no distribution shift
- All 3 experiments converged to the SAME score (70.647306)
- **CRITICAL: We are STUCK at a local optimum!**

## Response to Evaluator

**Agreed with evaluator's assessment:**
1. ✅ SmartManoj solution didn't improve on boc/saspav for any N - confirmed
2. ✅ Python fractional translation found 0 improvements - confirmed
3. ✅ bbox3 C++ binary incompatible with system GLIBC - confirmed
4. ✅ Need to compile C++ optimizer from source - this is the key next step

**Key insight from evaluator:** The C++ source code is available in multiple kernels (jonathanchan, seshurajup, jazivxt). We have g++ 9.4.0 available. We should compile from source rather than relying on pre-built binaries.

**Additional insight from research:**
- The chistyakov "new-simple-fix" kernel shows a NOVEL approach: extract smaller layouts from larger ones by looking at corners
- This is fundamentally different from SA optimization and hasn't been tried yet!

## CRITICAL: STUCK AT LOCAL OPTIMUM

All 3 experiments have identical scores (70.647306). This confirms:
1. boc, saspav, and smartmanoj solutions are all at the same local optimum
2. Python fractional translation cannot improve them
3. Simple ensembling of similar solutions doesn't help

**THE FIX: We need either:**
1. More powerful optimization (C++ SA with longer iterations)
2. Fundamentally different approaches (corner extraction, constructive heuristics)
3. Access to more diverse public solutions

## Recommended Approaches (Priority Order)

### 1. **[HIGHEST PRIORITY] COMPILE C++ SA OPTIMIZER FROM SOURCE**

The seshurajup kernel has complete C++ source code that can be compiled:

```bash
# Extract C++ code from seshurajup kernel
# Save to sa_optimizer.cpp
# Compile with:
g++ -O3 -march=native -std=c++17 -fopenmp -o sa_optimizer sa_optimizer.cpp
# Run:
./sa_optimizer -i submission.csv -n 15000 -r 5
```

**Why this is critical:**
- C++ is 100x faster than Python for this problem
- Can run many more iterations in the same time
- The proven approach that top kernels use

### 2. **[HIGH PRIORITY] TRY CORNER EXTRACTION APPROACH**

The chistyakov "new-simple-fix" kernel shows a novel approach:
- For each large N layout (e.g., N=111), look at each corner
- Extract trees closest to that corner
- Check if this subset forms a better solution for smaller N

**Why this is promising:**
- Fundamentally different from SA optimization
- Can find improvements that SA misses
- Exploits the structure of good large-N solutions

### 3. **[MEDIUM PRIORITY] ACCESS MORE PUBLIC SOLUTIONS**

The jonathanchan kernel lists 15+ sources we haven't tried:
- santa-2025-try3 (Kaggle dataset)
- santa25-public (Kaggle dataset)
- telegram-public-shared-solution-for-santa-2025 (Kaggle dataset)
- Various kernel outputs (chistyakov, egortrushin, etc.)

**Why this matters:**
- Different solutions may have better configs for specific N values
- Ensemble of diverse solutions can improve overall score

### 4. **[MEDIUM PRIORITY] FOCUS ON SMALL N (1-20)**

Small N values have highest per-N contribution:
- N=1: 0.661 (0.94% of total)
- N=2: 0.451 (0.64% of total)
- N=3: 0.435 (0.62% of total)

For small N, exhaustive or near-exhaustive search is tractable.

## What NOT to Try
- ❌ More Python fractional translation (already found 0 improvements)
- ❌ Simple ensembling of boc/saspav/smartmanoj (all at same optimum)
- ❌ Running pre-built bbox3 binary (GLIBC incompatible)
- ❌ Random perturbations without structure

## Concrete Next Experiment: 004_cpp_sa_optimizer

**Goal:** Compile and run C++ SA optimizer from source

**Steps:**
1. Extract C++ code from seshurajup or jonathanchan kernel
2. Save to `/home/code/code/sa_optimizer.cpp`
3. Compile with: `g++ -O3 -march=native -std=c++17 -fopenmp -o sa_optimizer sa_optimizer.cpp`
4. Run on current best submission with high iterations: `./sa_optimizer -i submission.csv -n 50000 -r 10`
5. Calculate score and submit

**Expected outcome:** 
- If C++ optimizer works: potential improvement of 0.01-0.1 points
- If no improvement: confirms solutions are at global optimum, need different approach

## Alternative Experiment: 004_corner_extraction

If C++ compilation fails, try the corner extraction approach:

**Steps:**
1. Load current best solution
2. For each large N (100-200), examine each corner
3. Extract trees closest to corner, check if better than existing small N
4. If improvement found, update solution

**Expected outcome:**
- Novel improvements that SA cannot find
- Exploits structure of good large-N solutions

## SUBMISSION STRATEGY
- **Remaining submissions:** 88
- **Submit after this experiment?** YES - we have abundant submissions
- Submit even if score is similar - confirms whether C++ optimizer helps

## Validation Notes
- Use Shapely for polygon operations
- Check for overlaps before submission
- Verify score calculation matches Kaggle's
- C++ optimizer should handle overlap checking internally
