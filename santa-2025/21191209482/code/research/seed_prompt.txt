## Current Status
- Best CV score: 70.630455 from exp_019_cpp_sa
- Best LB score: 70.6305 (verified)
- Target: 68.919154 | Gap to target: 1.711 points (2.48%)
- Experiments run: 20 (ALL converge to ~70.630)

## CRITICAL INSIGHT: WE ARE BETTER THAN PUBLIC LEADERBOARD!
- Our score: 70.630
- Public LB #1 (terry_u16): 71.19
- **We are 0.56 points BETTER than the public leader!**
- The target 68.919 is 1.71 points below our best

## Response to Evaluator
The evaluator correctly identified that:
1. Asymmetric placement from scratch is fundamentally WORSE (2-3x worse scores)
2. The baseline is at an extremely strong local optimum
3. SA-based optimization yields only microscopic improvements (~0.00002 per run)
4. The egortrushin two-tree translation + tree removal approach is unexplored

**I AGREE with the evaluator's recommendation.** The two-tree translation approach is fundamentally different from what we've tried. It doesn't start from scratch - it uses a structured 2-tree unit cell and optimizes the translation vectors.

## What Has Been Tried (ALL FAILED TO IMPROVE SIGNIFICANTLY)
1. ❌ SA optimization (bbox3, sa_v1_parallel, fractional_translation) - ~0.00002 improvement
2. ❌ Grid-based approaches (zaburo grid) - 25% worse than baseline
3. ❌ Ensemble from multiple sources - 0.017 improvement (now exhausted)
4. ❌ Asymmetric placements from scratch - 2-3x WORSE
5. ❌ Angle perturbation - NO improvement
6. ❌ Random restart SA - NO improvement
7. ❌ Basin hopping - NO improvement
8. ❌ Constraint programming - NO improvement
9. ❌ Cross-N extraction - NO improvement
10. ❌ Rebuild corners - NO improvement

## What Has NOT Been Tried (PRIORITY ORDER)

### 1. **[HIGHEST PRIORITY] JIWEILIU SUPER-FAST SA WITH TRANSLATIONS**
The jiweiliu kernel claims ~0.15 improvement in under 2 minutes using:
- Two-tree unit cell with ~75°/255° angles (180° apart)
- Numba JIT compilation for 10x speed
- Grid configurations with append_x/append_y for non-multiple N
- Tree deletion cascade to propagate improvements to smaller N
- Center distance check optimization (skip if centers > 1.8 apart)

**Implementation:**
```python
# Initial seed configuration (from jiweiliu kernel)
initial_seeds = [(0.0, 0.0, 75.0), (0.5, 0.3, 255.0)]  # Two trees at ~180° apart

# Generate grid configurations for all N from 1-200
# For each N, find the best (ncols, nrows, append_x, append_y) combination
# Run SA to optimize: seed positions, angles, translation vectors (tx, ty)
# Apply tree deletion cascade to propagate improvements
```

### 2. **[HIGH PRIORITY] TREE DELETION CASCADE**
From egortrushin kernel - propagate good large configs to smaller N:
```python
# Start from N=200 (or larger like 210)
# For each N from 200 down to 2:
#   For each tree in current config:
#     Calculate bounding box if this tree is removed
#   Remove the tree that minimizes bounding box
#   If new config is better than baseline for N-1, use it
```

### 3. **[MEDIUM PRIORITY] SPECIFIC N VALUES FOR TESSELLATION**
The egortrushin kernel shows specific grid dimensions work well:
- N=72: 6x6 grid (36 pairs)
- N=100: 5x10 grid (50 pairs)
- N=110: 5x11 grid (55 pairs)
- N=144: 6x12 grid (72 pairs)
- N=156: 6x13 grid (78 pairs)
- N=196: 7x14 grid (98 pairs)
- N=200: 7x15 grid (105 pairs = 210 trees, remove 10)

## What NOT to Try
- ❌ More SA iterations on existing baseline (diminishing returns)
- ❌ Different SA parameters (same result)
- ❌ Asymmetric placements from scratch (proven 2-3x worse)
- ❌ Grid-based approaches without the two-tree unit cell structure
- ❌ Any approach that doesn't use the structured 2-tree seed

## SUBMISSION STRATEGY
- Remaining submissions: 85
- **SUBMIT AFTER EVERY EXPERIMENT** - we have abundant submissions
- LB feedback is free information - USE IT!

## Validation Notes
- This is a deterministic optimization problem: CV = LB exactly
- Use Shapely for overlap detection (matches Kaggle validation)
- Check for overlaps before submitting - invalid solutions fail

## IMPLEMENTATION PLAN FOR NEXT EXPERIMENT

**Experiment 021: jiweiliu_two_tree_translation**

1. **Implement the jiweiliu kernel's approach:**
   - Use Numba JIT for speed
   - Two-tree unit cell with ~75°/255° angles
   - Generate all viable grid configurations
   - SA optimization with translation vectors
   - Tree deletion cascade

2. **Key parameters from jiweiliu kernel:**
   ```python
   sa_params = {
       "Tmax": 0.001,
       "Tmin": 0.000001,
       "nsteps": 10,
       "nsteps_per_T": 10000,
       "position_delta": 0.002,
       "angle_delta": 1.0,
       "delta_t": 0.002,
   }
   initial_seeds = [(0.0, 0.0, 75.0), (0.5, 0.3, 255.0)]
   ```

3. **Expected outcome:**
   - If it works: ~0.15 improvement (70.63 -> 70.48)
   - If it doesn't work: We learn that the baseline is truly optimal

4. **SUBMIT the result regardless of outcome** - LB feedback is valuable!

## THE TARGET IS ACHIEVABLE
- We are already BETTER than the public leaderboard leader
- The gap to target (1.71 points) requires finding a fundamentally better structure
- The two-tree translation approach is the most promising unexplored direction
- Even if this doesn't reach the target, it will teach us about the problem structure