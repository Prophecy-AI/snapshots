# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D irregular polygon packing problem. The goal is to pack Christmas tree-shaped polygons (15 vertices each) into the smallest square bounding box for N=1 to 200 trees.

**Scoring Formula:** score = Σ(side_n² / n) for n=1 to 200
- Lower is better
- Target score: 68.889699

**Tree Shape (15 vertices):**
- Tip at (0, 0.8)
- Three tiers of branches at y=0.5, 0.25, 0.0
- Trunk from y=0 to y=-0.2, width 0.15
- Base width: 0.7, mid width: 0.4, top width: 0.25

**Submission Format:**
- id: NNN_T (e.g., 001_0, 002_0, 002_1)
- x, y: coordinates with 's' prefix (e.g., s0.123456)
- deg: rotation angle with 's' prefix

## Pre-Optimized Solutions Available
Check `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/` for:
- `santa-2025.csv` - Best known pre-optimized submission (~70.68 score)
- `best_ensemble.csv` - Ensemble of multiple sources
- Multiple other CSV files from various sources

## Key Optimization Techniques from Kernels

### 1. Simulated Annealing (SA) - Primary Approach
From `tree_packer_v21.cpp`:
- **Local Search:** 8-directional moves + rotation adjustments
- **Squeeze:** Scale all trees towards center (0.9995 to 0.98 scale factor)
- **Compaction:** Move individual trees towards center
- **Swap Moves:** Exchange positions of two trees
- **Multi-start:** Try different initial angles/configurations

### 2. fix_direction Optimization
From `saspav_santa-submission`:
- Rotates entire configuration to minimize bounding box
- Uses `scipy.optimize.minimize_scalar` with bounds (0.001, 89.999)
- Can tighten bounds without changing relative positions

### 3. Backward Propagation
- Start from N=200, work down to N=2
- For each N, try removing each boundary-touching tree
- If resulting (N-1) config is better than stored, save it
- Helps find better configurations for smaller N values

### 4. bbox3 Binary Optimizer
- Pre-compiled C++ optimizer
- Parameters: `-n <iterations>` `-r <rounds>`
- Typical usage: `-n 1000-2000 -r 30-90`
- Runs simulated annealing with perturbation

### 5. shake_public Binary
- Another pre-compiled optimizer
- Usage: `--input="submission.csv" --output="submission.csv"`

## Collision Detection
Using Shapely library with high-precision Decimal arithmetic:
```python
from shapely import affinity
from shapely.geometry import Polygon
from shapely.strtree import STRtree

# Check overlap: intersects but not just touches
if poly1.intersects(poly2) and not poly1.touches(poly2):
    # Overlap detected
```

## Academic Algorithms for 2D Irregular Packing

### Recommended Approaches:
1. **Simulated Annealing (SA)** - Most commonly used, proven effective
2. **Genetic Algorithms (GA)** - Good for exploring solution space
3. **Tabu Search** - Avoids local minima
4. **Bottom-Left Heuristic** - Fast constructive placement
5. **Jostle Heuristic** - Iteratively moves pieces to improve packing
6. **No-Fit Polygon (NFP)** - Precompute collision-free regions for O(1) overlap checks

### Key Insights from Research:
- Extended local search with nonlinear programming can minimize overlap
- Hybrid approaches (GA + LP) often outperform single methods
- Rotation freedom significantly affects solution quality
- Boundary-touching trees are key to improving bounding box

## ⛔ BLOCKED AFTER BASELINE (exp_000)
After getting baseline score, the following are PERMANENTLY FORBIDDEN:
- Running bbox3, shake_public, or ANY pre-compiled binary without understanding
- "More iterations" or "different parameters" on existing optimizers
- Simple ensembling without algorithmic improvements

## ✅ REQUIRED: IMPLEMENT FROM SCRATCH
All experiments after baseline MUST implement a novel algorithm:
1. **Custom SA Implementation** - Implement simulated annealing in Python/C++ with:
   - Temperature schedule optimization
   - Novel move operators (swap, rotate, translate)
   - Adaptive step sizes
   
2. **Lattice/Grid-Based Approach** - For large N (N >= 58):
   - Start with 2 base trees in optimal configuration
   - Translate in x and y directions to create grid pattern
   - Optimize base configuration and translation vectors

3. **Per-N Specialization:**
   - N=1: Exhaustive search for optimal rotation angle (minimize bounding box)
   - N=2-10: Small enough for more exhaustive search
   - N>100: Lattice-based approaches may be more efficient

4. **Backward Propagation Enhancement:**
   - Implement in Python with proper overlap detection
   - Try removing ALL trees, not just boundary-touching ones
   - Apply local optimization after each removal

5. **Ensemble Strategy:**
   - Collect best configurations for each N from multiple sources
   - For each N, keep the configuration with smallest side length

## Validation Requirements
1. **No Overlaps:** Kaggle rejects submissions with overlapping trees
2. **Coordinate Bounds:** -100 ≤ x, y ≤ 100
3. **Precision:** Use Decimal arithmetic with 25+ digits precision
4. **Format:** Values must have 's' prefix (e.g., s0.123456)

## Recommended Experiment Order

### exp_000: Baseline
- Copy best pre-optimized submission from snapshots
- Calculate score to establish baseline
- Expected: ~70.68

### exp_001: Ensemble Best-Per-N
- Load all available CSV files
- For each N, select configuration with smallest side
- Create ensemble submission

### exp_002: Custom SA Implementation
- Implement simulated annealing from scratch in Python
- Focus on small N values (1-20) first
- Use moves: translate, rotate, swap

### exp_003: Lattice Approach for Large N
- Implement grid-based placement for N >= 58
- Optimize base 2-tree configuration
- Calculate optimal grid dimensions

### exp_004: Backward Propagation
- Start from N=200, propagate improvements downward
- Apply local optimization after each step

### exp_005: Focus on Small N
- N=1 contributes ~0.66 to score (highest single contribution)
- Exhaustive angle search for N=1
- More intensive optimization for N=2-10

## Technical Notes
- Use OpenMP for parallelization (multi-core available)
- C++ implementations are faster than Python
- Decimal precision is critical for avoiding overlap detection errors
- STRtree provides efficient spatial indexing for collision detection

## Key Files
- Tree geometry: 15 vertices, defined in ChristmasTree class
- Sample submission: `/home/data/sample_submission.csv`
- Pre-optimized: `/home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/`

## Insights from Discussions (MANDATORY)
Note: Discussion content was not accessible during exploration, but based on kernel analysis:
- Asymmetric solutions may outperform symmetric ones
- Lattice-based approaches work well for large N
- Small N values (1-10) have lowest efficiency and highest score contribution
- Long optimization runs (hours, not minutes) are needed for top scores
- The gap between ~70.68 and target 68.89 requires ~2.5% improvement

## What NOT to Try
- Simple parameter tuning of existing binaries (diminishing returns)
- Short optimization runs (local optima are too tight)
- Ignoring small N values (they contribute disproportionately to score)
