# Santa 2025 - Christmas Tree Packing Optimization

## Problem Overview
This is a 2D packing optimization problem where we need to pack Christmas tree-shaped polygons into the smallest square bounding box for configurations of 1-200 trees.

**Scoring:** score = Σ(side_length² / n) for n=1 to 200 (lower is better)
**Target:** Beat 68.901319

## Tree Geometry
Each tree is a 15-vertex polygon with:
- trunk_w=0.15, trunk_h=0.2
- base_w=0.7, mid_w=0.4, top_w=0.25
- tip_y=0.8, tier_1_y=0.5, tier_2_y=0.25
- Trees can be rotated (0-360°) and positioned (x, y)
- No overlapping allowed (collision detection via Shapely/STRtree)

## Top Approaches from Public Kernels

### 1. bbox3 Optimizer (C++ Binary)
From `../research/kernels/jazivxt_why-not/why-not.ipynb`:
- Complex number-based geometry for efficient rotation
- Simulated annealing with multiple phases (short, medium, long runs)
- Global boundary tension optimization
- Aggressive overlap repair using separation vectors
- Parameters: -n (iterations), -r (restarts)

### 2. shake_public Optimizer
Another binary optimizer used in combination with bbox3 for further refinement.

### 3. fix_direction (Rotation Optimization)
From `../research/kernels/saspav_santa-submission/santa-submission.ipynb`:
- Uses convex hull of all tree vertices
- scipy.optimize.minimize_scalar to find optimal rotation angle (0-90°)
- Rotates entire configuration to minimize bounding box side length
- Multiple passes can yield incremental improvements

### 4. Tree Packer v21 (C++ with OpenMP)
From `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`:
- Parallel processing of all n values (1-200)
- Swap move operator for tree position exchanges
- Multi-angle restarts with higher temperature SA
- Long double precision for accuracy

### 5. Backward Propagation
From `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`:
- Start from N=200, work down to N=2
- Remove trees that touch the bounding box boundary
- If removing a tree improves the (N-1) configuration, save it
- Propagates improvements from larger to smaller configurations

## Key Optimization Techniques

### Local Optimization
1. **Squeeze**: Scale all trees toward center (scale=0.9995 down to 0.98)
2. **Compaction**: Move trees toward center in small steps (0.02, 0.008, 0.003, 0.001, 0.0004)
3. **Local Search**: 8-directional moves + rotation adjustments
4. **Boundary Focus**: Prioritize moving trees that define the bounding box

### Global Optimization
1. **Simulated Annealing**: High temperature exploration, gradual cooling
2. **Multi-start**: Try different initial configurations/angles
3. **Swap Moves**: Exchange positions of two trees
4. **Global Tension**: Pull all trees toward center while avoiding overlaps

### Post-processing
1. **Rotation Tightening**: Find optimal rotation angle for entire configuration
2. **Overlap Validation**: Check all pairs for collisions
3. **Repair**: Replace invalid configurations with known-good ones

## Recommended Experiments (Priority Order)

### Experiment 1: Implement Core Optimizer
- Build Python-based optimizer with:
  - Greedy initial placement (weighted random angles favor corners)
  - Local search with compaction
  - Squeeze operation
  - Rotation optimization (fix_direction)

### Experiment 2: Simulated Annealing
- Implement SA with:
  - Move types: translate, rotate, swap
  - Temperature schedule: start high (0.1), cool to 0.0001
  - Accept worse solutions probabilistically
  - Focus on boundary trees

### Experiment 3: Backward Propagation
- After optimizing N=200, propagate improvements backward
- Remove boundary-touching trees to improve smaller configs
- Can find better solutions for N<200 from optimized N=200

### Experiment 4: Ensemble/Blending
- Run multiple optimizers with different seeds
- Keep best configuration for each N
- Blend results from different approaches

### Experiment 5: C++ Implementation
- Port critical loops to C++ for 10-100x speedup
- Use OpenMP for parallel processing
- Long double precision for numerical stability

## Validation Strategy
- Check for overlaps using Shapely intersection (not just touches)
- Verify bounding box calculation
- Score each N configuration independently
- Replace invalid configs with known-good baseline

## Implementation Notes

### Collision Detection
```python
from shapely.strtree import STRtree
tree_index = STRtree(polygons)
possible_indices = tree_index.query(candidate_poly)
overlap = any(candidate_poly.intersects(p) and not candidate_poly.touches(p) 
              for p in possible_indices)
```

### Bounding Box Calculation
```python
bounds = unary_union(all_polygons).bounds
side_length = max(bounds[2] - bounds[0], bounds[3] - bounds[1])
```

### Submission Format
- Values prefixed with 's' (e.g., "s0.123456")
- High precision (12+ decimal places)
- Coordinates constrained to -100 ≤ x, y ≤ 100

## Reference Notebooks
- Getting Started: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 + shake: `../research/kernels/jazivxt_why-not/`
- Full pipeline: `../research/kernels/saspav_santa-submission/`
- C++ optimizer: `../research/kernels/smartmanoj_santa-claude/`
- Runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
