{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T08:02:19.566082",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [
    {
      "strategy": "# Santa 2025 Seed Prompt\n\n## Problem Definition\nPack $N$ identical \"Christmas Tree\" polygons ($N \\in [1, 200]$) into the smallest possible square bounding box.\n**Metric:** Minimize $\\sum_{n=1}^{200} \\frac{s_n^2}{n}$, where $s_n$ is the side length of the square bounding box for $n$ trees.\n**Constraints:** No overlaps.\n\n## Tree Geometry\nThe tree is a 15-point polygon defined by these coordinates (relative to center):\n```python\nTX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]\nTY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]\n```\n\n## Winning Strategy: Advanced C++ Optimization + Backward Propagation\n\nThe best approach combines a high-performance C++ solver, backward propagation to improve smaller $N$ solutions from larger ones, and Python post-processing.\n\n### 1. The C++ Solver (`tree_packer_v21` / `bbox3`)\nA physical simulation/simulated annealing approach.\n- **Source Code:** See `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb` for `tree_packer_v21.cpp`.\n- **Compilation:** `g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer_v21 tree_packer_v21.cpp`\n- **Key Features:** Swap moves, multi-angle restarts, global tension.\n\n### 2. Backward Propagation (`bp.cpp`)\nSince a valid packing for $N$ trees contains a valid packing for $N-1$ trees (by removing one), we can \"propagate\" good solutions downwards.\n- **Logic:** Take the best solution for $N$. Try removing each tree to see if the resulting $N-1$ configuration has a smaller bounding box than the current best for $N-1$.\n- **Source Code:** See `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb` for `bp.cpp`.\n- **Compilation:** `g++ -O3 -std=c++17 -o bp bp.cpp`\n\n### 3. Rotation Optimization (Post-Processing)\nOnce a valid packing is found, rotate the *entire configuration* to find the minimal axis-aligned bounding box.\n- **Technique:** Rotate points by $\\theta \\in [0, 90]$ and minimize bounding box side.\n- **Implementation:** See `fix_direction` in `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb`.\n\n## Recommended Workflow\n\n1.  **Setup:** Extract and compile `tree_packer_v21.cpp` and `bp.cpp`.\n2.  **Generate Solutions:** Run `tree_packer_v21` for all $N \\in [1, 200]$.\n    - Use high run counts (`-r`) and parallel threads.\n3.  **Propagate Improvements:** Run `bp` (Backward Propagation) on the generated `submission.csv`. This is CRITICAL for maximizing the score.\n4.  **Refine:** Apply `fix_direction` (rotation optimization) to the result.\n5.  **Iterate:** Feed the improved `submission.csv` back into the solver or `bp` if supported (the kernel suggests an iterative loop).\n\n## Key Files\n- `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`: **BEST SOURCE**. Contains `tree_packer_v21.cpp` and `bp.cpp`.\n- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb`: Contains `fix_direction` Python code.\n- `../research/kernels/jazivxt_why-not/why-not.ipynb`: Contains lattice analysis code.\n\n## Experiments to Try\n1.  **Iterative Loop:** Run Packer -> Backward Prop -> Rotation Opt -> Repeat.\n2.  **Parameter Tuning:** Adjust the \"temperature\" or \"tension\" in the C++ code if you can edit it.\n3.  **Lattice Seeding:** If the solver gets stuck on large $N$, try initializing with a lattice pattern (see `why-not.ipynb`).\n\n",
      "agent": "explorer",
      "timestamp": "2026-01-19T08:05:59.588963"
    }
  ],
  "feedback_history": [],
  "data_findings": [],
  "web_research": [
    {
      "query": "optimal packing of irregular polygons lattice patterns",
      "finding": "Optimal lattice packing of irregular polygons is the problem of arranging congruent copies of a non\u2011rectangular shape on a plane (or on a rectangular sheet) so that the repeating unit\u2011cell of a lattice contains the maximum possible area fraction of the polygons.  Because the polygons are not convex or regular, the geometry of the lattice vectors and the relative orientation of the pieces become decision variables, and the objective is to minimise waste or maximise density.  This formulation underlies many industrial nesting tasks where material cost is critical\u202f([sciencedirect](https://www.sciencedirect.com/science/article/abs/pii/S0377221799001150);\u202f[dl.acm.org](https://dl.acm.org/doi/10.1145/336154.336214)).\n\nA variety of exact and heuristic techniques have been proposed.  Dyckhoff (2000) presented a constructive method that computes the optimal lattice parameters for a given oriented polygon by solving a nonlinear optimisation over the lattice basis vectors\u202f([sciencedirect](https://",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 95
}