# Santa 2025 Seed Prompt

## Problem Definition
Pack $N$ identical "Christmas Tree" polygons ($N \in [1, 200]$) into the smallest possible square bounding box.
**Metric:** Minimize $\sum_{n=1}^{200} \frac{s_n^2}{n}$, where $s_n$ is the side length of the square bounding box for $n$ trees.
**Constraints:** No overlaps.

## Tree Geometry
The tree is a 15-point polygon defined by these coordinates (relative to center):
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## Winning Strategy: Advanced C++ Optimization + Backward Propagation

The best approach combines a high-performance C++ solver, backward propagation to improve smaller $N$ solutions from larger ones, and Python post-processing.

### 1. The C++ Solver (`tree_packer_v21` / `bbox3`)
A physical simulation/simulated annealing approach.
- **Source Code:** See `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb` for `tree_packer_v21.cpp`.
- **Compilation:** `g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer_v21 tree_packer_v21.cpp`
- **Key Features:** Swap moves, multi-angle restarts, global tension.

### 2. Backward Propagation (`bp.cpp`)
Since a valid packing for $N$ trees contains a valid packing for $N-1$ trees (by removing one), we can "propagate" good solutions downwards.
- **Logic:** Take the best solution for $N$. Try removing each tree to see if the resulting $N-1$ configuration has a smaller bounding box than the current best for $N-1$.
- **Source Code:** See `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb` for `bp.cpp`.
- **Compilation:** `g++ -O3 -std=c++17 -o bp bp.cpp`

### 3. Rotation Optimization (Post-Processing)
Once a valid packing is found, rotate the *entire configuration* to find the minimal axis-aligned bounding box.
- **Technique:** Rotate points by $\theta \in [0, 90]$ and minimize bounding box side.
- **Implementation:** See `fix_direction` in `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb`.

## Recommended Workflow

1.  **Setup:** Extract and compile `tree_packer_v21.cpp` and `bp.cpp`.
2.  **Generate Solutions:** Run `tree_packer_v21` for all $N \in [1, 200]$.
    - Use high run counts (`-r`) and parallel threads.
3.  **Propagate Improvements:** Run `bp` (Backward Propagation) on the generated `submission.csv`. This is CRITICAL for maximizing the score.
4.  **Refine:** Apply `fix_direction` (rotation optimization) to the result.
5.  **Iterate:** Feed the improved `submission.csv` back into the solver or `bp` if supported (the kernel suggests an iterative loop).

## Key Files
- `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`: **BEST SOURCE**. Contains `tree_packer_v21.cpp` and `bp.cpp`.
- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb`: Contains `fix_direction` Python code.
- `../research/kernels/jazivxt_why-not/why-not.ipynb`: Contains lattice analysis code.

## Experiments to Try
1.  **Iterative Loop:** Run Packer -> Backward Prop -> Rotation Opt -> Repeat.
2.  **Parameter Tuning:** Adjust the "temperature" or "tension" in the C++ code if you can edit it.
3.  **Lattice Seeding:** If the solver gets stuck on large $N$, try initializing with a lattice pattern (see `why-not.ipynb`).

