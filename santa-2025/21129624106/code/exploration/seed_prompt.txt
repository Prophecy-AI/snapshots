# Santa 2025 Seed Prompt

## Problem Definition
Pack $N$ identical "Christmas Tree" polygons ($N \in [1, 200]$) into the smallest possible square bounding box.
**Metric:** Minimize $\sum_{n=1}^{200} \frac{s_n^2}{n}$, where $s_n$ is the side length of the square bounding box for $n$ trees.
**Constraints:** No overlaps.

## Tree Geometry
The tree is a 15-point polygon defined by these coordinates (relative to center):
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```
(See `../research/kernels/jazivxt_why-not/why-not.ipynb` for the C++ definition).

## Winning Strategy: Hybrid C++ Physics + Python Optimization

The best approach combines a high-performance C++ solver for the packing with Python post-processing for global rotation.

### 1. The C++ Solver (`bbox3`)
The core solver is a C++ program that uses a physical simulation approach (Global Dynamics) where trees push each other apart while being squeezed by a global tension.
- **Source Code:** Located in `../research/kernels/jazivxt_why-not/why-not.ipynb`. You must extract the C++ code from the cell starting with `%%writefile bbox3.cpp`.
- **Compilation:** `g++ -O3 bbox3.cpp -o bbox3 -fopenmp`
- **Usage:** `./bbox3 -n <num_trees> -r <runs>` (The kernel uses a wrapper to run this).
- **Key Features:**
  - Uses Complex Number Vector Coordination.
  - Implements "Aggressive Repair" to resolve overlaps.
  - Uses OpenMP for parallelization.

### 2. Rotation Optimization (Post-Processing)
Once a valid packing is found, the bounding box can often be reduced by rotating the *entire configuration* and finding the minimal axis-aligned bounding box.
- **Technique:** Rotate the set of points by $\theta \in [0, 90]$ and calculate the bounding box side. Minimize this function.
- **Implementation:** See `fix_direction` function in `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb`.
- **Impact:** This is a "free" improvement on any valid packing.

### 3. Lattice Packing Analysis
Optimal packings for large $N$ tend to form a lattice (crystal) structure.
- **Insight:** Trees align in a pattern (e.g., alternating up/down or specific angles).
- **Action:** Analyze the output of the solver for $N=200$ to find the optimal lattice vectors. You might be able to seed the solver with a lattice configuration for faster convergence.
- **Reference:** `why-not.ipynb` contains code to analyze "crystallization".

## Recommended Workflow

1.  **Extract and Compile:** Extract `bbox3.cpp` from `why-not.ipynb` and compile it.
2.  **Run Optimization:** Run the solver for all $N \in [1, 200]$. Focus computational resources on larger $N$ as they contribute less to the score per unit area but are harder to pack? Actually, check the metric: $s_n^2/n$. The contribution is proportional to the area per tree. All $N$ are important.
3.  **Post-Process:** Apply `fix_direction` (rotation optimization) to every solution found.
4.  **Validate:** Use `shapely` to ensure no overlaps (floating point precision issues can occur between C++ and Python).
    - Use `Decimal` with high precision in Python for validation.
    - Scale coordinates by $10^{15}$ or similar to avoid precision loss.

## Key Files
- `../research/kernels/jazivxt_why-not/why-not.ipynb`: Source for `bbox3.cpp` and lattice analysis.
- `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb`: Python runner with `fix_direction` and parameter tuning.
- `../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb`: Basic geometry and visualization.

## Experiments to Try
1.  **Baseline:** Run `bbox3` with default settings for all $N$.
2.  **Tuning:** Increase the number of runs (`-r`) for `bbox3`.
3.  **Lattice Seeding:** Hardcode a lattice pattern generator in Python, generate a packing, and feed it to `bbox3` (if it accepts input) or use it as a starting point for a Python-based physics engine if you build one.
4.  **Python Physics:** If `bbox3` is hard to use, port the "Aggressive Repair" logic to Python using `jax` or `numba` for speed.

