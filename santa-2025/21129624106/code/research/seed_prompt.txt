# Santa 2025 Seed Prompt

## Problem Definition
Pack $N$ identical "Christmas Tree" polygons ($N \in [1, 200]$) into the smallest possible square bounding box.
**Metric:** Minimize $\sum_{n=1}^{200} \frac{s_n^2}{n}$, where $s_n$ is the side length of the square bounding box for $n$ trees.
**Constraints:** No overlaps.

## Tree Geometry
The tree is a 15-point polygon defined by these coordinates (relative to center):
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## Current Status
- Best Score: 217.43 (Baseline)
- Target Score: ~69
- Gap: Massive. The baseline random initialization is failing for large $N$.
- **Key Insight:** The optimal packing for large $N$ is a **Double Lattice** structure (alternating up/down trees). Random initialization cannot find this "crystal" structure.

## Response to Evaluator
- **Evaluator Recommendation:** "Implement Lattice Initialization."
- **My Action:** AGREED. I will implement a lattice generation script to create a dense initial packing based on the "Blue/Pink" (up/down) pattern identified in research.
- **Plan:**
    1.  Analyze the optimal "unit cell" (pair of trees) using the `why-not` kernel's approach.
    2.  Generate a full lattice packing for each $N$ using this unit cell.
    3.  Feed this lattice packing into the C++ solver (`tree_packer_v21`) as the initial state.
    4.  Run the solver to refine the boundaries (simulated annealing).
    5.  Run Backward Propagation (`bp`) to improve smaller $N$.

## Recommended Approaches
Priority-ordered list:

1.  **Lattice Initialization (CRITICAL)**
    - **Why:** Random init is stuck at score 217. Winners use lattice packing for $N > 50$.
    - **How:**
        - Create `lattice_generator.py`.
        - It should generate a grid of trees where every other tree is rotated 180 degrees (or the optimal angle found by analysis).
        - Use `optimize_rotation.py` logic to find the tightest packing for just *two* trees (one up, one down). Use this offset to build the grid.
        - Save this as `lattice_submission.csv`.

2.  **Hybrid Workflow**
    - **Step 1:** Generate `lattice_submission.csv`.
    - **Step 2:** Run `tree_packer_v21` initialized with `lattice_submission.csv`.
        - *Note:* You may need to modify `tree_packer_v21.cpp` to load an initial solution. If it doesn't support it, check if it supports "restarting" from a file. If not, **modify the C++ code** to read `submission.csv` at startup.
        - *Alternative:* If modifying C++ is too hard, use the `bp` tool which *does* read `submission.csv` and tries to improve it. But `bp` removes trees. We need a *packer* that starts from a lattice.
        - *Actually:* `tree_packer_v21.cpp` likely has a "load" feature or we can add one easily. It's essential.

3.  **Optimize the Unit Cell**
    - Before generating the full lattice, find the optimal $(dx, dy)$ and relative rotation for exactly 2 trees.
    - Use `scipy.optimize` to minimize the bounding box of 2 trees (one rotated 180 deg relative to other).
    - Use these parameters to generate the lattice.

## What NOT to Try
- **Pure Random Search:** It will never find the lattice for $N=200$.
- **Reinforcement Learning:** Proven to fail for this problem.

## Validation Notes
- **Visual Check:** Plot the generated lattice for $N=100$. It should look like a crystal (dense, regular pattern).
- **Score Check:** The lattice initialization *alone* (before SA) should score much better than 217 for large $N$.
