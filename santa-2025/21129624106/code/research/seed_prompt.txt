## Current Status
- Best CV score: 107.76 (Lattice Init)
- Target: ~69
- Gap: ~38 points
- **Critical Insight**: The current lattice density is ~0.37 (avg). The target requires density > 0.71. We are essentially packing "loose" grids. The bottleneck is the *Unit Cell*.
- **Validation**: The 107.76 submission is valid (overlaps are negligible, ~1e-13).

## CV-LB Relationship Analysis
- Not enough submissions to establish a line yet.
- However, the physics are clear: Score = Area / N. Area = N * TreeArea / Density.
- Score = TreeArea / Density.
- Current Score ~107 => Density ~0.37.
- Target Score ~69 => Density ~0.58 (Wait, 107 is sum(s^2/n). Let's look at per-tree score).
- Actually, the metric is sum(s_n^2 / n).
- If density is constant $\rho$, then $s_n^2 \approx n \cdot A_{tree} / \rho$.
- So term is $A_{tree} / \rho$.
- Sum is $200 \cdot A_{tree} / \rho$.
- $A_{tree} \approx 0.20$ (roughly, need to verify).
- If Score 107: $107 = 200 \cdot 0.2 / \rho \implies \rho \approx 0.37$.
- If Target 69: $69 = 200 \cdot 0.2 / \rho \implies \rho \approx 0.58$.
- Wait, my analysis notebook showed max density 0.45.
- **Conclusion**: We need to DOUBLE the density.

## Response to Evaluator
- **Technical Verdict**: TRUSTWORTHY. The pipeline works.
- **Evaluator's Top Priority**: "Maximize Lattice Density". I AGREE completely.
- **Action**: We will implement the `find_dense_lattice.py` using Differential Evolution as suggested.

## Data Understanding
- See `exploration/evolver_loop2_analysis.ipynb` for density plots.
- The "Why Not" kernel (jazivxt) confirms that "Blue" (0 deg) and "Pink" (180 deg) trees form the optimal crystal.
- We need to find the *tightest* Blue/Pink unit cell.

## Recommended Approaches
**Priority 1: Global Optimization of the Unit Cell (The "Crystal" Finder)**
Create `find_dense_lattice.py` to find the optimal lattice parameters.
- **Variables**: `v1_x, v1_y` (Vector 1), `v2_x, v2_y` (Vector 2), `off_x, off_y` (Offset of 2nd tree).
- **Objective**: Minimize `abs(v1_x*v2_y - v1_y*v2_x)` (Parallelogram Area).
- **Constraints**:
    - Tree1(0,0) vs Tree2(off_x, off_y): No Overlap.
    - Tree1(0,0) vs Tree1(v1): No Overlap.
    - Tree1(0,0) vs Tree1(v2): No Overlap.
    - Tree1(0,0) vs Tree2(off+v1): No Overlap.
    - ... Check all neighbors in 3x3 grid.
- **Method**: `scipy.optimize.differential_evolution`. This is non-convex and jagged. Gradient descent will fail.
- **Target**: Find parameters that give density > 0.75.

**Priority 2: Generate "Crystalline" Submission**
Update `lattice_generator.py` to use the optimized `v1, v2, offset`.
- Generate the grid using these vectors.
- This will produce a skewed lattice (parallelogram grid), not a rectangular one.
- This is FINE. The packer handles coordinates.

**Priority 3: Run Packer on Crystal**
- Run `tree_packer_v21` on this new dense initialization.
- The starting score should be much lower (maybe < 80).

## What NOT to Try
- Do not tweak the rectangular grid parameters manually.
- Do not run the packer on random initialization.
- Do not assume `Lx, Ly` are independent. The lattice is likely oblique.

## Validation Notes
- Check the density of the generated lattice *before* running the packer.
- If density < 0.6, the optimization failed. Retry with different bounds.
