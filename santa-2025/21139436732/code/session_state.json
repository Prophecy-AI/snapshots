{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T13:39:22.814113",
  "time_limit_minutes": 2100,
  "experiments": [],
  "candidates": [],
  "submissions": [],
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "Baseline greedy approach: Place trees one-by-one, starting far away and moving toward center until collision, then back up. Uses weighted random angles (sin(2*angle)) to favor diagonal placements for better corner packing. Uses Shapely for collision detection with STRtree spatial indexing.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Advanced approach uses bbox3 binary optimizer with phased runs: Phase A (short 2min runs), Phase B (medium 10min), Phase C (long 20min). Key technique: rotation tightening via convex hull optimization - finds optimal rotation angle to minimize bounding box. Uses scipy.optimize.minimize_scalar on hull points. Also includes overlap repair mechanism.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Combined approach: Uses bbox3 binary optimizer + fix_direction rotation optimization. Key technique: replace_group function to repair overlapping configurations by replacing them with donor (baseline) solutions. Runs for 9 hours with iterative improvement.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "bbox3.cpp is the core C++ optimizer with: Complex number vector coordination, Fluid dynamics simulation, Hinge pivot mechanics, Density gradient flow, Global boundary tension. Uses OpenMP for parallelization. Key techniques: aggressive_repair for overlap resolution using separation vectors, corner tree identification for boundary optimization. Compiled with g++ -O3 -fopenmp.",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "tree_packer_v21.cpp optimizer with: Simulated annealing (SA), Swap move operator, Multi-angle restarts, Squeeze (scale toward center), Compaction (move toward center), Local search (8-directional moves + rotations), Boundary tree identification. Also includes backward_propagation optimizer that removes trees from larger configs to improve smaller ones. Uses long double precision.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "2D irregular polygon packing best practices: 1) Bottom-left (BL) placement strategy as constructive backbone, 2) Meta-heuristics (GA, SA, tabu search) for exploration, 3) Hybrid approaches combining local search with GA, 4) Extended local search with nonlinear programming refinements, 5) Jostle algorithm for local optimization, 6) No-fit polygons for efficient collision detection.",
      "source": "WebSearch: 2D irregular polygon packing optimization",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization problems?",
      "finding": "Two\u2011dimensional irregular\u2011polygon packing is a highly combinatorial problem, so the most successful approaches combine a fast constructive rule with a powerful meta\u2011heuristic that can explore the huge search space.  A common constructive backbone is the **bottom\u2011left (BL) placement strategy**, which inserts polygons in a given order as far to the bottom and then to the left as possible; many modern solvers start from a BL solution and then improve it\u202f([Taylor\u202f&\u202fFrancis](https://www.taylorfrancis.com/chapters/edit/10.1201/9781351236423-33/practical-algorithms-two-dimensional-packing-general-shapes-yannan-hu-hideki-hashimoto-shinji-imahori-mutsunori-yagiura))\u200b.  For the selection order, the **Djang\u2011Finch (DJD) heuristic**\u2014originally devised for 1\u2011D bin packing\u2014has been adapted to irregular 2\u2011D items and shown to outperform classic selection rules when paired with a placement heuristic\u202f([Springer\u202f2013](https://link.springer.com/article/10.1007/s10479-013-1341-4))\u200b.\n\nBeyond deterministic r",
      "agent": "explorer"
    },
    {
      "query": "What are the best techniques for minimizing bounding box area when packing irregular polygons?",
      "finding": "Minimizing the area of the bounding box that contains a set of irregular polygons is usually tackled by a combination of exact geometric preprocessing and powerful optimisation engines.  A common first step is to compute the **no\u2011fit polygon (NFP)** for each pair of pieces, which captures all relative positions that avoid overlap; the NFP can be obtained robustly with Minkowski\u2011sum techniques and careful handling of internal edges, holes and lock\u2011key configurations\u202f([Computers\u202f&\u202fOperations\u202fResearch](https://www.sciencedirect.com/science/article/abs/pii/S0305054806000669),\u202f[PDF\u202f2005](https://eprints.soton.ac.uk/36850/1/CORMSIS-05-05.pdf)).  Once the NFPs are known, the nesting problem can be expressed as a **mixed\u2011integer linear program (MILP)** that enforces non\u2011overlap through linearised NFP constraints and often uses vertical\u2011slice or polygonal\u2011enclosure formulations to tighten the bounding\u2011box dimensions\u202f([Springer\u202f2022](https://link.springer.com/article/10.1007/s10479-015-1971-9)).",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 95
}