{
  "workspace_dir": "/home/code",
  "competition_id": "santa-2025",
  "metric_direction": true,
  "start_time": "2026-01-19T13:39:22.814113",
  "time_limit_minutes": 2100,
  "experiments": [
    {
      "id": "exp_000",
      "name": "001_baseline",
      "model_type": "optimization",
      "score": 164.924007,
      "cv_score": 164.924007,
      "lb_score": null,
      "notes": "Baseline experiment using sample_submission.csv as starting point. Compiled and ran bbox3.cpp optimizer with 50 iterations and 5 restarts. Score improved from 173.65 (sample) to 164.92. Still far from target of 68.92. The sample submission is a very basic greedy solution. Top solutions in kernels start with much better baselines (~69-70) and run for 3-9 hours. Next steps: 1) Run optimizer for much longer, 2) Implement backward propagation, 3) Try rotation optimization properly, 4) Consider using lattice patterns for initialization.",
      "experiment_folder": "/home/code/experiments/001_baseline",
      "timestamp": "2026-01-19T14:27:20.910948"
    }
  ],
  "candidates": [
    {
      "file_path": "/home/code/submission_candidates/candidate_000.csv",
      "score": 164.924007,
      "cv_score": 164.924007,
      "model_name": "001_baseline",
      "experiment_id": "exp_000",
      "timestamp": "2026-01-19T14:27:20.912468"
    }
  ],
  "submissions": [],
  "strategy_history": [
    {
      "strategy": "# Santa 2025 Christmas Tree Packing - Optimization Seed Prompt\n\n## Problem Overview\nThis is a 2D geometric packing optimization problem. The goal is to pack Christmas tree-shaped polygons into the smallest possible square bounding box for each configuration of n trees (n=1 to 200).\n\n**Metric:** Sum of (side_length^2 / n) for all n from 1 to 200. Lower is better.\n**Target Score:** Beat 68.922808\n\n## Data Structure\n- 200 separate packing problems (n=1 to n=200)\n- Each tree is a 15-vertex polygon with fixed shape (trunk + 3-tier branches)\n- Tree dimensions: ~0.7 width at base, ~1.0 height (from trunk bottom to tip)\n- Submission format: id (nnn_idx), x, y, deg (all prefixed with 's' for precision)\n- Coordinates must be in range [-100, 100]\n- No overlapping trees allowed (touching is OK)\n- Total rows: 20100 (sum of 1 to 200)\n\n## Key Techniques from Top Kernels\n\n### 1. Core Optimization Algorithms (C++ Required)\nReference: `../research/kernels/jazivxt_why-not/why-not.ipynb` (bbox3.cpp)\nReference: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb` (tree_packer_v21.cpp)\n\n**C++ Optimizers are essential** - Python is too slow for this problem:\n- Compile with: `g++ -O3 -march=native -std=c++17 -fopenmp -o optimizer optimizer.cpp`\n- Use OpenMP for parallelization across n-values\n\n**Key optimization moves:**\n1. **Squeeze/Compaction**: Scale all trees toward center (scale=0.9995 to 0.98), check for overlaps\n2. **Local Search**: 8-directional moves (steps: 0.01, 0.004, 0.0015, 0.0006, 0.00025, 0.0001) + rotation adjustments (5\u00b0, 2\u00b0, 0.8\u00b0, 0.3\u00b0, 0.1\u00b0)\n3. **Simulated Annealing**: Accept worse moves with decreasing probability, higher temperature for exploration\n4. **Swap Moves**: Exchange positions of two trees\n5. **Boundary Tree Focus**: Prioritize moving trees that define the bounding box edges\n\n**Advanced techniques from bbox3.cpp:**\n- Complex number vector coordination for geometry\n- Fluid dynamics simulation for tree movement\n- Hinge pivot mechanics\n- Density gradient flow\n- Global boundary tension\n- Aggressive overlap repair using separation vectors (MTV approximation)\n\n### 2. Rotation Tightening (fix_direction) - CRITICAL\nReference: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`\n\nAfter packing, rotate the entire configuration to minimize bounding box:\n```python\nfrom scipy.spatial import ConvexHull\nfrom scipy.optimize import minimize_scalar\n\ndef optimize_rotation(trees):\n    # Get all polygon vertices\n    all_points = []\n    for tree in trees:\n        all_points.extend(list(tree.polygon.exterior.coords))\n    points_np = np.array(all_points)\n    \n    # Get convex hull for efficiency\n    hull_points = points_np[ConvexHull(points_np).vertices]\n    \n    # Find optimal rotation angle (0-90 degrees)\n    res = minimize_scalar(\n        lambda a: calculate_bbox_side_at_angle(a, hull_points),\n        bounds=(0.001, 89.999), method='bounded'\n    )\n    return res.x, res.fun\n```\n\n### 3. Backward Propagation - IMPORTANT\nReference: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n\nUse larger configurations to improve smaller ones:\n- Start from n=200, work down to n=2\n- Remove boundary-touching trees one at a time\n- If resulting (n-1) config is better than stored, save it\n- Key insight: Good n=200 solution can provide good n=199, n=198, etc.\n\n### 4. Overlap Detection & Repair\nReference: `../research/kernels/saspav_santa-submission/santa-submission.ipynb`\n\n- Use Shapely with STRtree for efficient collision detection\n- Point-in-polygon + segment intersection checks\n- If overlaps found, replace with known-good configuration from baseline\n- Bounding box pre-check for fast rejection\n\n### 5. Greedy Initialization\nReference: `../research/kernels/inversion_santa-2025-getting-started/`\n\n- Place trees one at a time, starting far from center (radius=20)\n- Move toward center in steps of 0.5 until collision\n- Back up in steps of 0.05 until no collision\n- Use weighted random angles: `abs(sin(2*angle))` to favor diagonal placements (better corner packing)\n- Try 10 random starting attempts, keep best\n\n## Academic Best Practices (from literature)\n\n1. **Bottom-Left (BL) Placement Strategy**: Place items as far bottom-left as possible\n2. **Djang-Finch (DJD) Heuristic**: Adapted from 1D bin packing for selection order\n3. **Meta-heuristics**: GA, SA, tabu search dominate state-of-the-art\n4. **Hybrid approaches**: Combine local search with GA for best results\n5. **Extended local search with nonlinear programming**: Refine solutions with continuous optimization\n6. **Jostle algorithm**: Shake/compact placements to improve density\n7. **No-fit polygons (NFP)**: Precompute valid placement regions for efficiency (reduces overlap check from O(nm) to O(k))\n\n## Recommended Approach\n\n### Phase 1: Baseline Setup\n1. Start with sample_submission.csv or fetch a known good baseline\n2. Implement Python validation (overlap checking, score calculation)\n3. Set up C++ compilation pipeline\n\n### Phase 2: C++ Optimizer (Main Work)\n1. Adapt bbox3.cpp or tree_packer_v21.cpp from kernels\n2. Key parameters to tune:\n   - n (iterations): 1000-10000\n   - r (restarts): 30-256\n   - Temperature schedule for SA\n3. Run for extended time (3-9 hours on Kaggle)\n4. Use phased approach:\n   - Phase A: Short 2-min runs to find promising (n, r) combinations\n   - Phase B: Medium 10-min runs on top candidates\n   - Phase C: Long 20-min runs on best few\n\n### Phase 3: Post-Processing\n1. Apply fix_direction rotation optimization (multiple passes)\n2. Run backward propagation\n3. Validate no overlaps, repair if needed by replacing with baseline\n\n### Phase 4: Iterative Refinement\n1. Keep best submission, revert on regressions\n2. Track improvements with MIN_IMPROVEMENT_TO_PROCESS threshold (1e-10)\n3. Save snapshots at each improvement\n\n## Implementation Notes\n\n### Precision\n- Use Decimal (Python) or long double (C++) for coordinates\n- Scale factor of 1e15 used in some implementations for integer arithmetic\n- Round to 6-12 decimal places for submission\n- Prepend 's' to all numeric values in submission\n\n### Tree Geometry (15 vertices, origin at top of trunk)\n```cpp\nconst double TX[15] = {0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125};\nconst double TY[15] = {0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5};\n// Tree tip at (0, 0.8), trunk bottom at y=-0.2\n// Width: 0.7 at base (y=0), 0.4 at middle tier, 0.25 at top tier\n```\n\n### Collision Detection (fast to slow)\n1. Bounding box pre-check (AABB rejection)\n2. Point-in-polygon test (ray casting)\n3. Segment intersection test (for edge cases)\n4. Note: Touching (not overlapping) is allowed\n\n### Score Calculation\n```python\ndef calculate_score(submission_df):\n    total_score = 0\n    for n in range(1, 201):\n        group = submission_df[submission_df['id'].str.startswith(f'{n:03d}_')]\n        # Parse coordinates (strip 's' prefix)\n        x = group['x'].str[1:].astype(float)\n        y = group['y'].str[1:].astype(float)\n        deg = group['deg'].str[1:].astype(float)\n        \n        # Build polygons and get bounding box\n        # ... (use ChristmasTree class)\n        side_length = max(max_x - min_x, max_y - min_y)\n        total_score += side_length**2 / n\n    return total_score\n```\n\n## C++ Code Structure Template\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <omp.h>\n\nconstexpr int MAX_N = 200;\nconstexpr int NV = 15;\nconstexpr double PI = 3.14159265358979323846;\n\n// Tree geometry\nconst double TX[NV] = {0,0.125,0.0625,0.2,0.1,0.35,0.075,0.075,-0.075,-0.075,-0.35,-0.1,-0.2,-0.0625,-0.125};\nconst double TY[NV] = {0.8,0.5,0.5,0.25,0.25,0,0,-0.2,-0.2,0,0,0.25,0.25,0.5,0.5};\n\nstruct Poly {\n    double px[NV], py[NV];\n    double x0, y0, x1, y1;  // bounding box\n};\n\nstruct Cfg {\n    int n;\n    double x[MAX_N], y[MAX_N], a[MAX_N];  // positions and angles\n    Poly pl[MAX_N];\n    \n    void upd(int i);      // update polygon i\n    void updAll();        // update all polygons\n    bool hasOvl(int i);   // check if tree i overlaps any other\n    bool anyOvl();        // check for any overlap\n    double side();        // get bounding box side length\n    double score();       // side^2 / n\n};\n\n// Key functions to implement:\n// - getPoly(cx, cy, deg) -> Poly\n// - overlap(Poly& a, Poly& b) -> bool\n// - squeeze(Cfg c) -> Cfg\n// - localSearch(Cfg c, int iters) -> Cfg\n// - compaction(Cfg c, int iters) -> Cfg\n```\n\n## Experiments to Try (Priority Order)\n\n1. **Adapt bbox3.cpp**: Most sophisticated optimizer in kernels\n2. **Adapt tree_packer_v21.cpp**: Alternative with swap moves and multi-start\n3. **Parameter sweep**: Try n=1000-5000, r=30-256\n4. **Backward propagation**: Run after main optimization\n5. **Rotation optimization**: Apply fix_direction with multiple passes\n6. **Focus on high-n**: n=150-200 contribute most to score (larger side^2)\n7. **Lattice patterns**: Some solutions show crystalline arrangements with alternating orientations\n\n## Validation Checklist\n- [ ] No overlapping trees (touching OK)\n- [ ] All coordinates in [-100, 100]\n- [ ] Correct number of trees per configuration (n trees for config n)\n- [ ] Values prefixed with 's' in submission\n- [ ] Score calculated correctly: sum(side^2 / n) for n=1 to 200\n- [ ] Total rows = 20100\n\n## Reference Notebooks\n- EDA: `exploration/eda.ipynb`\n- Getting Started: `../research/kernels/inversion_santa-2025-getting-started/`\n- bbox3 optimizer: `../research/kernels/jazivxt_why-not/why-not.ipynb`\n- tree_packer: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n- Rotation optimization: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`\n- Combined approach: `../research/kernels/saspav_santa-submission/santa-submission.ipynb`\n\n## Key Insights from Kernels\n\n1. **Runtime matters**: Top solutions run for 3-9+ hours\n2. **C++ is mandatory**: Python too slow for competitive solutions\n3. **Iterative improvement**: Keep best, revert on regressions\n4. **Post-processing critical**: Rotation optimization can significantly improve scores\n5. **Overlap repair**: Replace broken configs with known-good baseline\n6. **Parallelization**: Use OpenMP to optimize multiple n-values simultaneously\n\n## Quick Start Recommendation\n\nThe fastest path to a competitive solution:\n1. Copy bbox3.cpp from `../research/kernels/jazivxt_why-not/why-not.ipynb`\n2. Compile: `g++ -O3 -march=native -std=c++17 -fopenmp -o bbox3 bbox3.cpp`\n3. Run with good baseline: `./bbox3 -n 2000 -r 60`\n4. Apply fix_direction post-processing\n5. Validate and submit\n",
      "agent": "explorer",
      "timestamp": "2026-01-19T13:46:43.679361"
    }
  ],
  "feedback_history": [
    {
      "feedback": "## What I Understood\n\nThe junior researcher set up a baseline experiment for the Santa 2025 Christmas tree packing problem. They correctly identified that C++ optimization is essential, compiled the bbox3.cpp optimizer, and ran it on the sample_submission.csv. The goal was to establish a working pipeline and get an initial score. They improved from 173.65 (sample) to 164.92, but the target is 68.92 - still a 2.4x gap.\n\n## Technical Execution Assessment\n\n**Validation**: The score calculation appears correct - using bounding box side^2 / n summed over all configurations. The submission format is valid (20100 rows, 's' prefix on values).\n\n**Leakage Risk**: None - this is a pure optimization problem, not a prediction task.\n\n**Score Integrity**: Verified in logs - the optimizer output shows \"Final score: 164.924\" which matches the recorded score.\n\n**Code Quality**: The C++ compilation and execution worked correctly. The notebook structure is clean. No silent failures detected.\n\nVerdict: **TRUSTWORTHY** - The technical execution is sound.\n\n## Strategic Assessment\n\n**Approach Fit**: The approach (C++ optimizer) is correct for this problem. However, the execution is severely under-resourced.\n\n**Effort Allocation**: This is where the critical issue lies. The experiment spent effort on the wrong starting point and used inadequate optimization parameters.\n\n**Assumptions**: The implicit assumption that sample_submission.csv is a reasonable starting point is **WRONG**. The sample submission is a basic greedy solution with score ~173, while competitive baselines start at ~69-70.\n\n**Blind Spots**: \n1. **CRITICAL - Starting Point**: Top kernels (saspav, jazivxt) use pre-computed good baselines from datasets, NOT sample_submission.csv. The sample is 2.5x worse than competitive starting points.\n2. **Optimization Duration**: The experiment ran for ~10 minutes with n=50, r=5. Top kernels run for 3-9 HOURS with n=1000-2000, r=30-90.\n3. **Missing Post-Processing**: The fix_direction rotation optimization is critical and wasn't applied.\n4. **Missing Backward Propagation**: This technique uses larger configs to improve smaller ones.\n\n**Trajectory**: The current trajectory cannot reach the target. Even with perfect optimization, starting from 173 and improving by ~5% per run would take many iterations. The fundamental issue is the starting point.\n\n## What's Working\n\n1. \u2705 C++ compilation and execution pipeline is functional\n2. \u2705 Score calculation and validation are correct\n3. \u2705 The bbox3.cpp optimizer is a good choice (used by top kernels)\n4. \u2705 Understanding that C++ is required for competitive performance\n5. \u2705 The experiment structure and logging are clean\n\n## Key Concerns\n\n### 1. **CRITICAL: Wrong Starting Point**\n- **Observation**: Starting from sample_submission.csv (score 173.65) instead of a good baseline (~69-70)\n- **Why it matters**: The gap between 173 and 69 is enormous. No amount of local optimization can bridge this gap efficiently. Top kernels start from pre-computed good solutions.\n- **Suggestion**: Either (a) generate a much better initial solution using the greedy algorithm from the getting-started kernel with many more attempts, or (b) run the optimizer for much longer to build up a good solution iteratively.\n\n### 2. **Severely Under-Resourced Optimization**\n- **Observation**: n=50 iterations, r=5 restarts, ~10 minutes runtime\n- **Why it matters**: Top kernels use n=1000-2000, r=30-90, and run for 3-9 hours. The current parameters are ~20-40x too low.\n- **Suggestion**: Increase to at least n=1000, r=30 and run for 1+ hours as a next step.\n\n### 3. **Missing Critical Post-Processing**\n- **Observation**: No rotation optimization (fix_direction) applied\n- **Why it matters**: This technique finds the optimal rotation angle for the entire configuration to minimize bounding box. It's used by all top kernels.\n- **Suggestion**: Implement the fix_direction function from the saspav or yongsukprasertsuk kernels.\n\n### 4. **Missing Backward Propagation**\n- **Observation**: Each n-configuration is optimized independently\n- **Why it matters**: Good solutions for n=200 can provide good solutions for n=199, 198, etc. by removing boundary trees.\n- **Suggestion**: After main optimization, run backward propagation to improve smaller configs.\n\n## Top Priority for Next Experiment\n\n**IMMEDIATE ACTION REQUIRED**: The current approach cannot reach the target from this starting point.\n\n**Option A (Recommended)**: Generate a much better initial solution:\n1. Use the greedy initialization from the getting-started kernel\n2. Run with many more attempts (100+ per configuration instead of 10)\n3. Apply rotation optimization after each configuration\n4. This should get you to ~100-120 range as a starting point\n\n**Option B**: Run the optimizer for MUCH longer:\n1. Increase parameters to n=2000, r=60\n2. Run for 2-3 hours minimum\n3. Apply fix_direction rotation optimization\n4. Iterate: save best, restart from best\n\nThe key insight from top kernels: They start from baselines around 69-70 (from shared datasets) and then run optimization for hours. The sample_submission.csv is NOT a competitive starting point - it's just a format example.\n\n**Concrete Next Steps**:\n1. Implement fix_direction rotation optimization (copy from saspav kernel)\n2. Run optimizer with n=2000, r=60 for at least 1 hour\n3. Apply fix_direction after optimization\n4. Track score progression and iterate\n\nThe target of 68.92 IS achievable - top public kernels reach this range. But it requires starting from a better baseline and running optimization for much longer.\n",
      "experiment_id": "exp_000",
      "agent": "evaluator",
      "timestamp": "2026-01-19T14:29:18.258646"
    }
  ],
  "data_findings": [
    {
      "finding": "Baseline greedy approach: Place trees one-by-one, starting far away and moving toward center until collision, then back up. Uses weighted random angles (sin(2*angle)) to favor diagonal placements for better corner packing. Uses Shapely for collision detection with STRtree spatial indexing.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Advanced approach uses bbox3 binary optimizer with phased runs: Phase A (short 2min runs), Phase B (medium 10min), Phase C (long 20min). Key technique: rotation tightening via convex hull optimization - finds optimal rotation angle to minimize bounding box. Uses scipy.optimize.minimize_scalar on hull points. Also includes overlap repair mechanism.",
      "source": "../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/santa-2025-best-keeping-bbox3-runner.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Combined approach: Uses bbox3 binary optimizer + fix_direction rotation optimization. Key technique: replace_group function to repair overlapping configurations by replacing them with donor (baseline) solutions. Runs for 9 hours with iterative improvement.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "bbox3.cpp is the core C++ optimizer with: Complex number vector coordination, Fluid dynamics simulation, Hinge pivot mechanics, Density gradient flow, Global boundary tension. Uses OpenMP for parallelization. Key techniques: aggressive_repair for overlap resolution using separation vectors, corner tree identification for boundary optimization. Compiled with g++ -O3 -fopenmp.",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "tree_packer_v21.cpp optimizer with: Simulated annealing (SA), Swap move operator, Multi-angle restarts, Squeeze (scale toward center), Compaction (move toward center), Local search (8-directional moves + rotations), Boundary tree identification. Also includes backward_propagation optimizer that removes trees from larger configs to improve smaller ones. Uses long double precision.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "2D irregular polygon packing best practices: 1) Bottom-left (BL) placement strategy as constructive backbone, 2) Meta-heuristics (GA, SA, tabu search) for exploration, 3) Hybrid approaches combining local search with GA, 4) Extended local search with nonlinear programming refinements, 5) Jostle algorithm for local optimization, 6) No-fit polygons for efficient collision detection.",
      "source": "WebSearch: 2D irregular polygon packing optimization",
      "agent": "explorer"
    },
    {
      "finding": "No-Fit Polygon (NFP) is a powerful tool for irregular packing: precompute NFP for each pair of pieces to efficiently check valid placements. NFP reduces overlap detection from O(nm+n+m) to O(k) point inclusion test. Can be computed via Minkowski sums or orbiting method.",
      "source": "WebSearch: minimizing bounding box irregular polygons",
      "agent": "explorer"
    },
    {
      "finding": "Grid-based initialization (Well-Aligned): Arrange trees in alternating rows with 0\u00b0 and 180\u00b0 rotations. Search for optimal (n_even, n_odd) combinations for each n. Achieves score ~88.33 as a starting point. Much better than sample_submission (173.65).",
      "source": "research/kernels/zaburo_88-32999-a-well-aligned-initial-solution/88-32999-a-well-aligned-initial-solution.ipynb",
      "agent": "evolver"
    },
    {
      "finding": "Backward propagation (BackPacking): Start from n=200 and iterate backward to n=1. For each n, try removing each tree and keep the best result. This propagates good configurations from larger to smaller counts. Achieves score ~74.75.",
      "source": "research/kernels/crodoc_74-75-backpacking-christmas-trees/74-75-backpacking-christmas-trees.ipynb",
      "agent": "evolver"
    },
    {
      "finding": "Simulated annealing with translations: Use two trees translated in x and y directions. Perturb tree positions and angles with decreasing temperature. Combine with backward propagation for final refinement.",
      "source": "research/kernels/egortrushin_santa25-simulated-annealing-with-translations/santa25-simulated-annealing-with-translations.ipynb",
      "agent": "evolver"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization problems?",
      "finding": "Two\u2011dimensional irregular\u2011polygon packing is a highly combinatorial problem, so the most successful approaches combine a fast constructive rule with a powerful meta\u2011heuristic that can explore the huge search space.  A common constructive backbone is the **bottom\u2011left (BL) placement strategy**, which inserts polygons in a given order as far to the bottom and then to the left as possible; many modern solvers start from a BL solution and then improve it\u202f([Taylor\u202f&\u202fFrancis](https://www.taylorfrancis.com/chapters/edit/10.1201/9781351236423-33/practical-algorithms-two-dimensional-packing-general-shapes-yannan-hu-hideki-hashimoto-shinji-imahori-mutsunori-yagiura))\u200b.  For the selection order, the **Djang\u2011Finch (DJD) heuristic**\u2014originally devised for 1\u2011D bin packing\u2014has been adapted to irregular 2\u2011D items and shown to outperform classic selection rules when paired with a placement heuristic\u202f([Springer\u202f2013](https://link.springer.com/article/10.1007/s10479-013-1341-4))\u200b.\n\nBeyond deterministic r",
      "agent": "explorer"
    },
    {
      "query": "What are the best techniques for minimizing bounding box area when packing irregular polygons?",
      "finding": "Minimizing the area of the bounding box that contains a set of irregular polygons is usually tackled by a combination of exact geometric preprocessing and powerful optimisation engines.  A common first step is to compute the **no\u2011fit polygon (NFP)** for each pair of pieces, which captures all relative positions that avoid overlap; the NFP can be obtained robustly with Minkowski\u2011sum techniques and careful handling of internal edges, holes and lock\u2011key configurations\u202f([Computers\u202f&\u202fOperations\u202fResearch](https://www.sciencedirect.com/science/article/abs/pii/S0305054806000669),\u202f[PDF\u202f2005](https://eprints.soton.ac.uk/36850/1/CORMSIS-05-05.pdf)).  Once the NFPs are known, the nesting problem can be expressed as a **mixed\u2011integer linear program (MILP)** that enforces non\u2011overlap through linearised NFP constraints and often uses vertical\u2011slice or polygonal\u2011enclosure formulations to tighten the bounding\u2011box dimensions\u202f([Springer\u202f2022](https://link.springer.com/article/10.1007/s10479-015-1971-9)).",
      "agent": "explorer"
    }
  ],
  "max_submissions": 100,
  "remaining_submissions": 95
}