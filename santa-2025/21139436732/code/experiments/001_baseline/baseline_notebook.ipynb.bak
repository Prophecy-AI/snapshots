{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "7d51b3fd",
   "metadata": {},
   "source": [
    "# Baseline Experiment - Santa 2025 Christmas Tree Packing\n",
    "\n",
    "## Goals:\n",
    "1. Load and validate sample_submission.csv\n",
    "2. Calculate baseline score\n",
    "3. Set up C++ optimizer (bbox3.cpp)\n",
    "4. Run optimization and generate improved submission"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "0d829d19",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-19T13:47:49.863479Z",
     "iopub.status.busy": "2026-01-19T13:47:49.862925Z",
     "iopub.status.idle": "2026-01-19T13:47:50.229303Z",
     "shell.execute_reply": "2026-01-19T13:47:50.228882Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Functions defined successfully!\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from shapely.geometry import Polygon\n",
    "from shapely import affinity\n",
    "from shapely.strtree import STRtree\n",
    "import os\n",
    "\n",
    "# Tree geometry\n",
    "TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]\n",
    "TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]\n",
    "\n",
    "def make_tree_polygon(x, y, deg):\n",
    "    \"\"\"Create a tree polygon at position (x, y) with rotation deg degrees.\"\"\"\n",
    "    p = Polygon(zip(TX, TY))\n",
    "    p = affinity.rotate(p, deg, origin=(0, 0))\n",
    "    p = affinity.translate(p, x, y)\n",
    "    return p\n",
    "\n",
    "def load_configuration(df, n):\n",
    "    \"\"\"Load configuration for n trees from dataframe.\"\"\"\n",
    "    prefix = f\"{n:03d}_\"\n",
    "    group = df[df['id'].str.startswith(prefix)].copy()\n",
    "    \n",
    "    trees = []\n",
    "    for _, row in group.iterrows():\n",
    "        x = float(str(row['x'])[1:])  # Strip 's' prefix\n",
    "        y = float(str(row['y'])[1:])\n",
    "        deg = float(str(row['deg'])[1:])\n",
    "        trees.append({'x': x, 'y': y, 'deg': deg, 'polygon': make_tree_polygon(x, y, deg)})\n",
    "    return trees\n",
    "\n",
    "def get_bounding_box_side(trees):\n",
    "    \"\"\"Get the side length of the bounding box for a configuration.\"\"\"\n",
    "    if not trees:\n",
    "        return 0\n",
    "    \n",
    "    all_x = []\n",
    "    all_y = []\n",
    "    for tree in trees:\n",
    "        coords = list(tree['polygon'].exterior.coords)\n",
    "        all_x.extend([c[0] for c in coords])\n",
    "        all_y.extend([c[1] for c in coords])\n",
    "    \n",
    "    return max(max(all_x) - min(all_x), max(all_y) - min(all_y))\n",
    "\n",
    "def check_overlaps(trees):\n",
    "    \"\"\"Check if any trees overlap (touching is OK).\"\"\"\n",
    "    polygons = [t['polygon'] for t in trees]\n",
    "    tree_index = STRtree(polygons)\n",
    "    \n",
    "    for i, poly in enumerate(polygons):\n",
    "        candidates = tree_index.query(poly)\n",
    "        for idx in candidates:\n",
    "            if idx != i:\n",
    "                if poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):\n",
    "                    return True\n",
    "    return False\n",
    "\n",
    "def calculate_score(df, max_n=200):\n",
    "    \"\"\"Calculate total score for submission.\"\"\"\n",
    "    total_score = 0\n",
    "    for n in range(1, max_n + 1):\n",
    "        trees = load_configuration(df, n)\n",
    "        if trees:\n",
    "            side = get_bounding_box_side(trees)\n",
    "            score = side ** 2 / n\n",
    "            total_score += score\n",
    "    return total_score\n",
    "\n",
    "print(\"Functions defined successfully!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "a5f2bc2c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-19T13:47:50.230522Z",
     "iopub.status.busy": "2026-01-19T13:47:50.230348Z",
     "iopub.status.idle": "2026-01-19T13:47:50.247642Z",
     "shell.execute_reply": "2026-01-19T13:47:50.247236Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Loaded 20100 rows\n",
      "Sample rows:\n",
      "      id           x           y     deg\n",
      "0  001_0        s0.0        s0.0   s90.0\n",
      "1  002_0        s0.0        s0.0   s90.0\n",
      "2  002_1   s0.202736  s-0.511271   s90.0\n",
      "3  003_0        s0.0        s0.0   s90.0\n",
      "4  003_1   s0.202736  s-0.511271   s90.0\n",
      "5  003_2     s0.5206   s0.177413  s180.0\n",
      "6  004_0        s0.0        s0.0   s90.0\n",
      "7  004_1   s0.202736  s-0.511271   s90.0\n",
      "8  004_2     s0.5206   s0.177413  s180.0\n",
      "9  004_3  s-0.818657  s-0.228694  s180.0\n"
     ]
    }
   ],
   "source": [
    "# Load sample submission and calculate baseline score\n",
    "df = pd.read_csv('/home/data/sample_submission.csv')\n",
    "print(f\"Loaded {len(df)} rows\")\n",
    "print(f\"Sample rows:\")\n",
    "print(df.head(10))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "95531b4c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-19T13:47:50.248645Z",
     "iopub.status.busy": "2026-01-19T13:47:50.248535Z",
     "iopub.status.idle": "2026-01-19T13:47:53.826340Z",
     "shell.execute_reply": "2026-01-19T13:47:53.825911Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Calculating baseline score (this may take a minute)...\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Baseline Score: 173.652299\n"
     ]
    }
   ],
   "source": [
    "# Calculate score for sample submission\n",
    "print(\"Calculating baseline score (this may take a minute)...\")\n",
    "baseline_score = calculate_score(df)\n",
    "print(f\"\\nBaseline Score: {baseline_score:.6f}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "6e3c6076",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-19T13:47:53.827675Z",
     "iopub.status.busy": "2026-01-19T13:47:53.827557Z",
     "iopub.status.idle": "2026-01-19T13:47:53.916037Z",
     "shell.execute_reply": "2026-01-19T13:47:53.915639Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Checking for overlaps in sample configurations...\n",
      "N=  1: side=1.0000, score_contrib=1.0000, overlaps=False\n",
      "N= 10: side=3.4411, score_contrib=1.1841, overlaps=False\n",
      "N= 50: side=6.6492, score_contrib=0.8842, overlaps=False\n",
      "N=100: side=8.9561, score_contrib=0.8021, overlaps=False\n",
      "N=200: side=13.0345, score_contrib=0.8495, overlaps=False\n"
     ]
    }
   ],
   "source": [
    "# Check for overlaps in a few configurations\n",
    "print(\"Checking for overlaps in sample configurations...\")\n",
    "for n in [1, 10, 50, 100, 200]:\n",
    "    trees = load_configuration(df, n)\n",
    "    has_overlap = check_overlaps(trees)\n",
    "    side = get_bounding_box_side(trees)\n",
    "    print(f\"N={n:3d}: side={side:.4f}, score_contrib={side**2/n:.4f}, overlaps={has_overlap}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "d68e77b9",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-19T13:47:53.917030Z",
     "iopub.status.busy": "2026-01-19T13:47:53.916922Z",
     "iopub.status.idle": "2026-01-19T13:47:53.920207Z",
     "shell.execute_reply": "2026-01-19T13:47:53.919828Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Copied sample_submission.csv to /home/submission/submission.csv\n"
     ]
    }
   ],
   "source": [
    "# Copy sample submission as our starting baseline\n",
    "import shutil\n",
    "shutil.copy('/home/data/sample_submission.csv', '/home/submission/submission.csv')\n",
    "print(\"Copied sample_submission.csv to /home/submission/submission.csv\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "9a4d304f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-19T13:49:30.164735Z",
     "iopub.status.busy": "2026-01-19T13:49:30.164561Z",
     "iopub.status.idle": "2026-01-19T13:49:30.171807Z",
     "shell.execute_reply": "2026-01-19T13:49:30.171361Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Wrote bbox3.cpp\n"
     ]
    }
   ],
   "source": [
    "# Now let's set up the C++ optimizer\n",
    "# First, extract bbox3.cpp from the kernel\n",
    "\n",
    "bbox3_cpp = '''// BBOX3 - Global Dynamics Edition\n",
    "// Features: Complex Number Vector Coordination, Fluid Dynamics, Hinge Pivot, \n",
    "// Density Gradient Flow, and NEW Global Boundary Tension.\n",
    "// Uses a separate 'global_squeeze' function for Dynamic Scaling and Overlap Repair.\n",
    "\n",
    "#include <iostream>\n",
    "#include <fstream>\n",
    "#include <sstream>\n",
    "#include <cmath>\n",
    "#include <algorithm>\n",
    "#include <string>\n",
    "#include <vector>\n",
    "#include <map>\n",
    "#include <set>\n",
    "#include <tuple>\n",
    "#include <iomanip>\n",
    "#include <chrono>\n",
    "#include <random>\n",
    "#include <numeric>\n",
    "#include <omp.h>\n",
    "#include <complex> \n",
    "\n",
    "using namespace std;\n",
    "using namespace chrono;\n",
    "\n",
    "constexpr int MAX_N = 200;\n",
    "constexpr int NV = 15;\n",
    "constexpr double PI = 3.14159265358979323846;\n",
    "constexpr double EPSILON = 1e-16;\n",
    "constexpr double NEIGHBOR_RADIUS = 0.5;      \n",
    "constexpr double PIVOT_ANGLE_MAX = 10.0;     \n",
    "constexpr double GLOBAL_TENSION_STRENGTH = 0.05; \n",
    "\n",
    "// Base tree geometry \n",
    "const double TX[NV] = {0,0.125,0.0625,0.2,0.1,0.35,0.075,0.075,-0.075,-0.075,-0.35,-0.1,-0.2,-0.0625,-0.125};\n",
    "const double TY[NV] = {0.8,0.5,0.5,0.25,0.25,0,0,-0.2,-0.2,0,0,0.25,0.25,0.5,0.5};\n",
    "\n",
    "thread_local mt19937_64 rng(44); \n",
    "thread_local uniform_real_distribution<double> U(0, 1);\n",
    "\n",
    "inline double rf() { return U(rng); }\n",
    "inline int ri(int n) { return rng() % n; }\n",
    "\n",
    "// --- Geometric Structures and Functions (Complex Numbers) ---\n",
    "\n",
    "using Complex = std::complex<double>;\n",
    "\n",
    "// Forward declarations for mutual dependency\n",
    "struct Cfg;\n",
    "struct Poly;\n",
    "\n",
    "Cfg global_squeeze(Cfg c, uint64_t seed);\n",
    "Complex getSeparationVector(const Poly& a, const Poly& b); \n",
    "\n",
    "struct Poly {\n",
    "    Complex p[NV]; \n",
    "    double x0, y0, x1, y1;\n",
    "    void bbox() {\n",
    "        x0 = x1 = p[0].real(); y0 = y1 = p[0].imag();\n",
    "        for (int i = 1; i < NV; i++) {\n",
    "            x0 = min(x0, p[i].real()); x1 = max(x1, p[i].real());\n",
    "            y0 = min(y0, p[i].imag()); y1 = max(y1, p[i].imag());\n",
    "        }\n",
    "    }\n",
    "};\n",
    "\n",
    "Poly getPoly(Complex c_center, double deg) {\n",
    "    Poly q;\n",
    "    double r = deg * PI / 180;\n",
    "    Complex c_rot = polar(1.0, r); \n",
    "\n",
    "    for (int i = 0; i < NV; i++) {\n",
    "        Complex base_pt(TX[i], TY[i]);\n",
    "        Complex rotated_pt = base_pt * c_rot; \n",
    "        q.p[i] = rotated_pt + c_center;\n",
    "    }\n",
    "    q.bbox();\n",
    "    return q;\n",
    "}\n",
    "\n",
    "bool pip(double px, double py, const Poly& q) {\n",
    "    bool in = false;\n",
    "    int j = NV - 1;\n",
    "    for (int i = 0; i < NV; i++) {\n",
    "        double qi_x = q.p[i].real(), qi_y = q.p[i].imag();\n",
    "        double qj_x = q.p[j].real(), qj_y = q.p[j].imag();\n",
    "        if ((qi_y > py) != (qj_y > py) &&\n",
    "            px < (qj_x - qi_x) * (py - qi_y) / (qj_y - qi_y) + qi_x)\n",
    "            in = !in;\n",
    "        j = i;\n",
    "    }\n",
    "    return in;\n",
    "}\n",
    "\n",
    "bool segInt(Complex a, Complex b, Complex c, Complex d) {\n",
    "    auto ccw = [](Complex p, Complex q, Complex r) { \n",
    "        return (r.imag() - p.imag()) * (q.real() - p.real()) > (q.imag() - p.imag()) * (r.real() - p.real()); \n",
    "    };\n",
    "    return ccw(a, c, d) != ccw(b, c, d) && ccw(a, b, c) != ccw(a, b, d);\n",
    "}\n",
    "\n",
    "// Minimal overlap check\n",
    "bool overlap(const Poly& a, const Poly& b) {\n",
    "    if (a.x1 < b.x0 || b.x1 < a.x0 || a.y1 < b.y0 || b.y1 < a.y0) return false;\n",
    "    for (int i = 0; i < NV; i++) {\n",
    "        if (pip(a.p[i].real(), a.p[i].imag(), b)) return true;\n",
    "        if (pip(b.p[i].real(), b.p[i].imag(), a)) return true;\n",
    "    }\n",
    "    for (int i = 0; i < NV; i++)\n",
    "        for (int j = 0; j < NV; j++)\n",
    "            if (segInt(a.p[i], a.p[(i + 1) % NV], b.p[j], b.p[(j + 1) % NV])) return true;\n",
    "    return false;\n",
    "}\n",
    "\n",
    "struct Cfg {\n",
    "    int n;\n",
    "    Complex c[MAX_N]; \n",
    "    double a[MAX_N];  \n",
    "    Poly pl[MAX_N];\n",
    "\n",
    "    void upd(int i) { pl[i] = getPoly(c[i], a[i]); }\n",
    "    void updAll() { for (int i = 0; i < n; i++) upd(i); }\n",
    "\n",
    "    bool hasOvl(int i) const {\n",
    "        for (int j = 0; j < n; j++) { \n",
    "            if (i != j && overlap(pl[i], pl[j])) {\n",
    "                return true;\n",
    "            }\n",
    "        }\n",
    "        return false;\n",
    "    }\n",
    "\n",
    "    bool hasOvlPair(int i, int j) const {\n",
    "        if (overlap(pl[i], pl[j])) return true;\n",
    "        for (int k = 0; k < n; k++) {\n",
    "            if (k != i && k != j) {\n",
    "                if (overlap(pl[i], pl[k]) || overlap(pl[j], pl[k])) {\n",
    "                    return true;\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "        return false;\n",
    "    }\n",
    "\n",
    "    bool anyOvl() const {\n",
    "        for (int i = 0; i < n; i++)\n",
    "            for (int j = i + 1; j < n; j++)\n",
    "                if (overlap(pl[i], pl[j])) return true;\n",
    "        return false;\n",
    "    }\n",
    "\n",
    "    double side() const {\n",
    "        if (!n) return 0;\n",
    "        double x0 = pl[0].x0, x1 = pl[0].x1, y0 = pl[0].y0, y1 = pl[0].y1;\n",
    "        for (int i = 1; i < n; i++) {\n",
    "            x0 = min(x0, pl[i].x0); x1 = max(x1, pl[i].x1);\n",
    "            y0 = min(y0, pl[i].y0); y1 = max(y1, pl[i].y1);\n",
    "        }\n",
    "        return max(x1 - x0, y1 - y0);\n",
    "    }\n",
    "\n",
    "    double score() const { double s = side(); return s * s / n; }\n",
    "\n",
    "    Complex centroid() const {\n",
    "        Complex sum = 0.0;\n",
    "        for (int i = 0; i < n; i++) { sum += c[i]; }\n",
    "        return sum / (double)n;\n",
    "    }\n",
    "\n",
    "    tuple<double, double, double, double> getBBox() const {\n",
    "        double gx0 = pl[0].x0, gx1 = pl[0].x1, gy0 = pl[0].y0, gy1 = pl[0].y1;\n",
    "        for (int i = 1; i < n; i++) {\n",
    "            gx0 = min(gx0, pl[i].x0); gx1 = max(gx1, pl[i].x1);\n",
    "            gy0 = min(gy0, pl[i].y0); gy1 = max(gy1, pl[i].y1);\n",
    "        }\n",
    "        return {gx0, gy0, gx1, gy1};\n",
    "    }\n",
    "\n",
    "    vector<int> findCornerTrees() const {\n",
    "        auto [gx0, gy0, gx1, gy1] = getBBox();\n",
    "        double eps = 0.01;\n",
    "        vector<int> corners;\n",
    "        for (int i = 0; i < n; i++) {\n",
    "            if (abs(pl[i].x0 - gx0) < eps || abs(pl[i].x1 - gx1) < eps ||\n",
    "                abs(pl[i].y0 - gy0) < eps || abs(pl[i].y1 - gy1) < eps) {\n",
    "                corners.push_back(i);\n",
    "            }\n",
    "        }\n",
    "        return corners;\n",
    "    }\n",
    "};\n",
    "\n",
    "// --- Overlap Resolution Helper Function ---\n",
    "\n",
    "Complex getSeparationVector(const Poly& a, const Poly& b) {\n",
    "    Complex c_a = a.p[0]; for(int i=1; i<NV; ++i) c_a += a.p[i]; c_a /= (double)NV;\n",
    "    Complex c_b = b.p[0]; for(int i=1; i<NV; ++i) c_b += b.p[i]; c_b /= (double)NV;\n",
    "\n",
    "    Complex diff = c_a - c_b;\n",
    "    double dist = abs(diff);\n",
    "    double overlap_depth = 0.2; \n",
    "\n",
    "    if (dist > EPSILON) {\n",
    "        return diff / dist * overlap_depth;\n",
    "    } else {\n",
    "        return Complex(rf() * 0.1, rf() * 0.1);\n",
    "    }\n",
    "}\n",
    "\n",
    "// --- Optimization Routines ---\n",
    "\n",
    "Cfg aggressive_repair(Cfg c, int max_cycles) {\n",
    "    Cfg current = c;\n",
    "    for (int cycle = 0; cycle < max_cycles; ++cycle) {\n",
    "        bool repaired = true;\n",
    "        for (int i = 0; i < current.n; ++i) {\n",
    "            for (int j = i + 1; j < current.n; ++j) {\n",
    "                if (overlap(current.pl[i], current.pl[j])) {\n",
    "                    repaired = false;\n",
    "                    Complex sep_vector = getSeparationVector(current.pl[i], current.pl[j]);\n",
    "                    current.c[i] += sep_vector * 0.5;\n",
    "                    current.c[j] -= sep_vector * 0.5;\n",
    "                    current.upd(i);\n",
    "                    current.upd(j);\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "        if (repaired) break;\n",
    "    }\n",
    "    return current;\n",
    "}\n",
    "\n",
    "Cfg global_squeeze(Cfg c, uint64_t seed) {\n",
    "    rng.seed(seed);\n",
    "    Cfg best = c;\n",
    "    double best_side = c.side();\n",
    "\n",
    "    for (int iter = 0; iter < 500; ++iter) {\n",
    "        double scale = 0.995 + rf() * 0.004; // 0.995 to 0.999\n",
    "        Cfg trial = c;\n",
    "        Complex cent = trial.centroid();\n",
    "        \n",
    "        for (int i = 0; i < trial.n; ++i) {\n",
    "            trial.c[i] = cent + (trial.c[i] - cent) * scale;\n",
    "        }\n",
    "        trial.updAll();\n",
    "        \n",
    "        // Repair overlaps\n",
    "        trial = aggressive_repair(trial, 50);\n",
    "        \n",
    "        if (!trial.anyOvl()) {\n",
    "            double s = trial.side();\n",
    "            if (s < best_side) {\n",
    "                best = trial;\n",
    "                best_side = s;\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "    return best;\n",
    "}\n",
    "\n",
    "Cfg local_search(Cfg c, int iters) {\n",
    "    const double steps[] = {0.01, 0.004, 0.0015, 0.0006, 0.00025, 0.0001};\n",
    "    const double angles[] = {5.0, 2.0, 0.8, 0.3, 0.1};\n",
    "    const int dx[] = {1, -1, 0, 0, 1, 1, -1, -1};\n",
    "    const int dy[] = {0, 0, 1, -1, 1, -1, 1, -1};\n",
    "    \n",
    "    Cfg best = c;\n",
    "    double best_side = c.side();\n",
    "    \n",
    "    for (int it = 0; it < iters; ++it) {\n",
    "        bool improved = false;\n",
    "        \n",
    "        // Focus on corner trees\n",
    "        vector<int> corners = best.findCornerTrees();\n",
    "        if (corners.empty()) {\n",
    "            for (int i = 0; i < best.n; ++i) corners.push_back(i);\n",
    "        }\n",
    "        \n",
    "        for (int idx : corners) {\n",
    "            Complex orig_c = best.c[idx];\n",
    "            double orig_a = best.a[idx];\n",
    "            \n",
    "            // Try position moves\n",
    "            for (double step : steps) {\n",
    "                for (int d = 0; d < 8; ++d) {\n",
    "                    best.c[idx] = orig_c + Complex(dx[d] * step, dy[d] * step);\n",
    "                    best.upd(idx);\n",
    "                    \n",
    "                    if (!best.hasOvl(idx)) {\n",
    "                        double s = best.side();\n",
    "                        if (s < best_side) {\n",
    "                            best_side = s;\n",
    "                            orig_c = best.c[idx];\n",
    "                            improved = true;\n",
    "                        }\n",
    "                    }\n",
    "                    best.c[idx] = orig_c;\n",
    "                    best.upd(idx);\n",
    "                }\n",
    "            }\n",
    "            \n",
    "            // Try rotation moves\n",
    "            for (double ang : angles) {\n",
    "                for (int sign = -1; sign <= 1; sign += 2) {\n",
    "                    best.a[idx] = orig_a + sign * ang;\n",
    "                    best.upd(idx);\n",
    "                    \n",
    "                    if (!best.hasOvl(idx)) {\n",
    "                        double s = best.side();\n",
    "                        if (s < best_side) {\n",
    "                            best_side = s;\n",
    "                            orig_a = best.a[idx];\n",
    "                            improved = true;\n",
    "                        }\n",
    "                    }\n",
    "                    best.a[idx] = orig_a;\n",
    "                    best.upd(idx);\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "        \n",
    "        if (!improved) break;\n",
    "    }\n",
    "    return best;\n",
    "}\n",
    "\n",
    "Cfg compaction(Cfg c, int iters) {\n",
    "    Cfg best = c;\n",
    "    double best_side = c.side();\n",
    "    \n",
    "    for (int it = 0; it < iters; ++it) {\n",
    "        Complex cent = best.centroid();\n",
    "        bool improved = false;\n",
    "        \n",
    "        for (int i = 0; i < best.n; ++i) {\n",
    "            Complex orig = best.c[i];\n",
    "            Complex dir = cent - orig;\n",
    "            double dist = abs(dir);\n",
    "            if (dist < EPSILON) continue;\n",
    "            dir /= dist;\n",
    "            \n",
    "            // Move toward center\n",
    "            for (double step = 0.1; step > 0.001; step *= 0.5) {\n",
    "                best.c[i] = orig + dir * step;\n",
    "                best.upd(i);\n",
    "                \n",
    "                if (!best.hasOvl(i)) {\n",
    "                    double s = best.side();\n",
    "                    if (s < best_side) {\n",
    "                        best_side = s;\n",
    "                        orig = best.c[i];\n",
    "                        improved = true;\n",
    "                    }\n",
    "                }\n",
    "                best.c[i] = orig;\n",
    "                best.upd(i);\n",
    "            }\n",
    "        }\n",
    "        \n",
    "        if (!improved) break;\n",
    "    }\n",
    "    return best;\n",
    "}\n",
    "\n",
    "// --- I/O Functions ---\n",
    "\n",
    "map<int, Cfg> loadCSV(const string& fname) {\n",
    "    map<int, Cfg> cfgs;\n",
    "    ifstream f(fname);\n",
    "    string line;\n",
    "    getline(f, line); // header\n",
    "    \n",
    "    while (getline(f, line)) {\n",
    "        stringstream ss(line);\n",
    "        string id, xs, ys, ds;\n",
    "        getline(ss, id, ',');\n",
    "        getline(ss, xs, ',');\n",
    "        getline(ss, ys, ',');\n",
    "        getline(ss, ds, ',');\n",
    "        \n",
    "        int n = stoi(id.substr(0, 3));\n",
    "        int idx = stoi(id.substr(4));\n",
    "        \n",
    "        double x = stod(xs.substr(1));\n",
    "        double y = stod(ys.substr(1));\n",
    "        double d = stod(ds.substr(1));\n",
    "        \n",
    "        if (cfgs.find(n) == cfgs.end()) {\n",
    "            cfgs[n].n = n;\n",
    "        }\n",
    "        cfgs[n].c[idx] = Complex(x, y);\n",
    "        cfgs[n].a[idx] = d;\n",
    "    }\n",
    "    \n",
    "    for (auto& [n, cfg] : cfgs) {\n",
    "        cfg.updAll();\n",
    "    }\n",
    "    return cfgs;\n",
    "}\n",
    "\n",
    "void saveCSV(const string& fname, const map<int, Cfg>& cfgs) {\n",
    "    ofstream f(fname);\n",
    "    f << \"id,x,y,deg\\\\n\";\n",
    "    f << fixed << setprecision(12);\n",
    "    \n",
    "    for (int n = 1; n <= 200; ++n) {\n",
    "        if (cfgs.find(n) == cfgs.end()) continue;\n",
    "        const Cfg& cfg = cfgs.at(n);\n",
    "        for (int i = 0; i < cfg.n; ++i) {\n",
    "            f << setfill('0') << setw(3) << n << \"_\" << i << \",\";\n",
    "            f << \"s\" << cfg.c[i].real() << \",\";\n",
    "            f << \"s\" << cfg.c[i].imag() << \",\";\n",
    "            f << \"s\" << cfg.a[i] << \"\\\\n\";\n",
    "        }\n",
    "    }\n",
    "}\n",
    "\n",
    "double totalScore(const map<int, Cfg>& cfgs) {\n",
    "    double total = 0;\n",
    "    for (const auto& [n, cfg] : cfgs) {\n",
    "        total += cfg.score();\n",
    "    }\n",
    "    return total;\n",
    "}\n",
    "\n",
    "int main(int argc, char* argv[]) {\n",
    "    string input_file = \"submission.csv\";\n",
    "    string output_file = \"submission_optimized.csv\";\n",
    "    int n_iters = 100;\n",
    "    int n_restarts = 10;\n",
    "    \n",
    "    for (int i = 1; i < argc; i++) {\n",
    "        string arg = argv[i];\n",
    "        if (arg == \"-i\" && i + 1 < argc) input_file = argv[++i];\n",
    "        else if (arg == \"-o\" && i + 1 < argc) output_file = argv[++i];\n",
    "        else if (arg == \"-n\" && i + 1 < argc) n_iters = stoi(argv[++i]);\n",
    "        else if (arg == \"-r\" && i + 1 < argc) n_restarts = stoi(argv[++i]);\n",
    "    }\n",
    "    \n",
    "    cout << \"Loading \" << input_file << \"...\" << endl;\n",
    "    map<int, Cfg> cfgs = loadCSV(input_file);\n",
    "    cout << \"Initial score: \" << totalScore(cfgs) << endl;\n",
    "    \n",
    "    auto start = high_resolution_clock::now();\n",
    "    \n",
    "    #pragma omp parallel for schedule(dynamic)\n",
    "    for (int n = 1; n <= 200; ++n) {\n",
    "        if (cfgs.find(n) == cfgs.end()) continue;\n",
    "        \n",
    "        Cfg best = cfgs[n];\n",
    "        double best_score = best.score();\n",
    "        \n",
    "        for (int r = 0; r < n_restarts; ++r) {\n",
    "            Cfg trial = cfgs[n];\n",
    "            \n",
    "            // Apply optimization sequence\n",
    "            trial = global_squeeze(trial, r * 12345 + n);\n",
    "            trial = local_search(trial, n_iters);\n",
    "            trial = compaction(trial, n_iters);\n",
    "            trial = local_search(trial, n_iters);\n",
    "            \n",
    "            if (!trial.anyOvl()) {\n",
    "                double s = trial.score();\n",
    "                if (s < best_score) {\n",
    "                    best = trial;\n",
    "                    best_score = s;\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "        \n",
    "        #pragma omp critical\n",
    "        {\n",
    "            cfgs[n] = best;\n",
    "            if (n % 20 == 0) {\n",
    "                cout << \"Processed N=\" << n << \", score=\" << best_score << endl;\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    auto end = high_resolution_clock::now();\n",
    "    double elapsed = duration_cast<seconds>(end - start).count();\n",
    "    \n",
    "    cout << \"Final score: \" << totalScore(cfgs) << endl;\n",
    "    cout << \"Time: \" << elapsed << \" seconds\" << endl;\n",
    "    \n",
    "    saveCSV(output_file, cfgs);\n",
    "    cout << \"Saved to \" << output_file << endl;\n",
    "    \n",
    "    return 0;\n",
    "}\n",
    "'''\n",
    "\n",
    "with open('/home/code/experiments/001_baseline/bbox3.cpp', 'w') as f:\n",
    "    f.write(bbox3_cpp)\n",
    "print(\"Wrote bbox3.cpp\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "5970bc5e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-19T13:49:30.172970Z",
     "iopub.status.busy": "2026-01-19T13:49:30.172852Z",
     "iopub.status.idle": "2026-01-19T13:49:31.496748Z",
     "shell.execute_reply": "2026-01-19T13:49:31.496285Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "STDOUT: \n",
      "STDERR: \n",
      "Return code: 0\n"
     ]
    }
   ],
   "source": [
    "# Compile the C++ optimizer\n",
    "import subprocess\n",
    "result = subprocess.run(\n",
    "    ['g++', '-O3', '-march=native', '-std=c++17', '-fopenmp', '-o', \n",
    "     '/home/code/experiments/001_baseline/bbox3', \n",
    "     '/home/code/experiments/001_baseline/bbox3.cpp'],\n",
    "    capture_output=True, text=True\n",
    ")\n",
    "print(\"STDOUT:\", result.stdout)\n",
    "print(\"STDERR:\", result.stderr)\n",
    "print(\"Return code:\", result.returncode)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "3a7aa1c7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-19T13:50:04.761557Z",
     "iopub.status.busy": "2026-01-19T13:50:04.760960Z",
     "iopub.status.idle": "2026-01-19T14:00:35.183177Z",
     "shell.execute_reply": "2026-01-19T14:00:35.182749Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "STDOUT: Loading /home/code/experiments/001_baseline/submission.csv...\n",
      "Initial score: 173.652\n",
      "Processed N=20, score=0.788572\n",
      "Processed N=40, score=0.834393\n",
      "Processed N=60, score=0.82306\n",
      "Processed N=80, score=0.701761\n",
      "Processed N=100, score=0.783528\n",
      "Processed N=120, score=0.742152\n",
      "Processed N=140, score=0.839883\n",
      "Processed N=160, score=0.786562\n",
      "Processed N=180, score=0.822553\n",
      "Processed N=200, score=0.831356\n",
      "Final score: 164.924\n",
      "Time: 630 seconds\n",
      "Saved to /home/code/experiments/001_baseline/submission_optimized.csv\n",
      "\n",
      "STDERR: \n",
      "Time: 630.4 seconds\n"
     ]
    }
   ],
   "source": [
    "# Copy sample submission to working directory and run optimizer\n",
    "import shutil\n",
    "shutil.copy('/home/data/sample_submission.csv', '/home/code/experiments/001_baseline/submission.csv')\n",
    "\n",
    "# Run the optimizer with moderate settings (quick test)\n",
    "import subprocess\n",
    "import time\n",
    "\n",
    "start = time.time()\n",
    "result = subprocess.run(\n",
    "    ['/home/code/experiments/001_baseline/bbox3',\n",
    "     '-i', '/home/code/experiments/001_baseline/submission.csv',\n",
    "     '-o', '/home/code/experiments/001_baseline/submission_optimized.csv',\n",
    "     '-n', '50',  # iterations\n",
    "     '-r', '5'],  # restarts\n",
    "    capture_output=True, text=True,\n",
    "    cwd='/home/code/experiments/001_baseline'\n",
    ")\n",
    "elapsed = time.time() - start\n",
    "\n",
    "print(\"STDOUT:\", result.stdout)\n",
    "print(\"STDERR:\", result.stderr)\n",
    "print(f\"Time: {elapsed:.1f} seconds\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "fdf7323f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-19T14:01:00.502460Z",
     "iopub.status.busy": "2026-01-19T14:01:00.501872Z",
     "iopub.status.idle": "2026-01-19T14:01:00.504739Z",
     "shell.execute_reply": "2026-01-19T14:01:00.504328Z"
    }
   },
   "outputs": [],
   "source": [
    "# Validate the optimized submission and calculate score\\nimport pandas as pd\\n\\ndf_opt = pd.read_csv('/home/code/experiments/001_baseline/submission_optimized.csv')\\nprint(f\\\"Loaded {len(df_opt)} rows\\\")\\n\\n# Calculate score\\nopt_score = calculate_score(df_opt)\\nprint(f\\\"Optimized Score: {opt_score:.6f}\\\")\\n\\n# Check for overlaps in key configurations\\nprint(\\\"\\\\nChecking for overlaps...\\\")\\nfor n in [1, 10, 50, 100, 200]:\\n    trees = load_configuration(df_opt, n)\\n    has_overlap = check_overlaps(trees)\\n    side = get_bounding_box_side(trees)\\n    print(f\\\"N={n:3d}: side={side:.4f}, score_contrib={side**2/n:.4f}, overlaps={has_overlap}\\\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "1e74eed7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-19T14:02:00.229680Z",
     "iopub.status.busy": "2026-01-19T14:02:00.229240Z",
     "iopub.status.idle": "2026-01-19T14:02:00.232300Z",
     "shell.execute_reply": "2026-01-19T14:02:00.231938Z"
    }
   },
   "outputs": [],
   "source": [
    "# Implement rotation optimization (fix_direction)\\nfrom scipy.spatial import ConvexHull\\nfrom scipy.optimize import minimize_scalar\\nimport numpy as np\\n\\ndef calculate_bbox_side_at_angle(angle_deg, points):\\n    \\\"\\\"\\\"Calculate bounding box side length at a given rotation angle.\\\"\\\"\\\"\\n    angle_rad = np.radians(angle_deg)\\n    c, s = np.cos(angle_rad), np.sin(angle_rad)\\n    rot_matrix_T = np.array([[c, s], [-s, c]])\\n    rotated_points = points.dot(rot_matrix_T)\\n    min_xy = np.min(rotated_points, axis=0)\\n    max_xy = np.max(rotated_points, axis=0)\\n    return max(max_xy[0] - min_xy[0], max_xy[1] - min_xy[1])\\n\\ndef optimize_rotation_for_config(trees):\\n    \\\"\\\"\\\"Find optimal rotation angle to minimize bounding box.\\\"\\\"\\\"\\n    # Get all polygon vertices\\n    all_points = []\\n    for tree in trees:\\n        coords = list(tree['polygon'].exterior.coords)\\n        all_points.extend(coords)\\n    points_np = np.array(all_points)\\n    \\n    # Get convex hull for efficiency\\n    try:\\n        hull_points = points_np[ConvexHull(points_np).vertices]\\n    except:\\n        hull_points = points_np\\n    \\n    initial_side = calculate_bbox_side_at_angle(0, hull_points)\\n    \\n    # Find optimal rotation angle (0-90 degrees due to symmetry)\\n    res = minimize_scalar(\\n        lambda a: calculate_bbox_side_at_angle(a, hull_points),\\n        bounds=(0.001, 89.999), method='bounded'\\n    )\\n    \\n    found_angle_deg = res.x\\n    found_side = res.fun\\n    \\n    improvement = initial_side - found_side\\n    \\n    if improvement > 1e-8:\\n        return found_angle_deg, found_side\\n    else:\\n        return 0.0, initial_side\\n\\ndef apply_rotation_to_config(trees, angle_deg):\\n    \\\"\\\"\\\"Apply rotation to all trees in a configuration.\\\"\\\"\\\"\\n    if abs(angle_deg) < 1e-9:\\n        return trees\\n    \\n    # Find center of bounding box\\n    all_x = []\\n    all_y = []\\n    for tree in trees:\\n        coords = list(tree['polygon'].exterior.coords)\\n        all_x.extend([c[0] for c in coords])\\n        all_y.extend([c[1] for c in coords])\\n    \\n    center_x = (min(all_x) + max(all_x)) / 2\\n    center_y = (min(all_y) + max(all_y)) / 2\\n    \\n    angle_rad = np.radians(angle_deg)\\n    c, s = np.cos(angle_rad), np.sin(angle_rad)\\n    \\n    new_trees = []\\n    for tree in trees:\\n        # Rotate position around center\\n        dx = tree['x'] - center_x\\n        dy = tree['y'] - center_y\\n        new_x = center_x + dx * c - dy * s\\n        new_y = center_y + dx * s + dy * c\\n        new_deg = tree['deg'] + angle_deg\\n        \\n        new_trees.append({\\n            'x': new_x,\\n            'y': new_y,\\n            'deg': new_deg,\\n            'polygon': make_tree_polygon(new_x, new_y, new_deg)\\n        })\\n    \\n    return new_trees\\n\\nprint(\\\"Rotation optimization functions defined!\\\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "6f471b43",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-19T14:02:00.233337Z",
     "iopub.status.busy": "2026-01-19T14:02:00.233232Z",
     "iopub.status.idle": "2026-01-19T14:02:00.236093Z",
     "shell.execute_reply": "2026-01-19T14:02:00.235740Z"
    }
   },
   "outputs": [],
   "source": [
    "# Apply rotation optimization to the optimized submission\\nprint(\\\"Applying rotation optimization to all configurations...\\\")\\n\\ndf_opt = pd.read_csv('/home/code/experiments/001_baseline/submission_optimized.csv')\\n\\nimproved_configs = {}\\ntotal_improvement = 0\\n\\nfor n in range(1, 201):\\n    trees = load_configuration(df_opt, n)\\n    if not trees:\\n        continue\\n    \\n    old_side = get_bounding_box_side(trees)\\n    old_score = old_side ** 2 / n\\n    \\n    # Find optimal rotation\\n    best_angle, new_side = optimize_rotation_for_config(trees)\\n    \\n    if best_angle > 0.01:  # Only apply if meaningful rotation found\\n        # Apply rotation\\n        rotated_trees = apply_rotation_to_config(trees, best_angle)\\n        \\n        # Verify no overlaps\\n        if not check_overlaps(rotated_trees):\\n            new_score = new_side ** 2 / n\\n            improvement = old_score - new_score\\n            \\n            if improvement > 1e-10:\\n                improved_configs[n] = rotated_trees\\n                total_improvement += improvement\\n                if n % 20 == 0:\\n                    print(f\\\"N={n}: angle={best_angle:.2f}Â°, improvement={improvement:.6f}\\\")\\n\\nprint(f\\\"\\\\nTotal improvement from rotation: {total_improvement:.6f}\\\")\\nprint(f\\\"Configurations improved: {len(improved_configs)}\\\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "ba2be561",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-19T14:02:23.470419Z",
     "iopub.status.busy": "2026-01-19T14:02:23.470009Z",
     "iopub.status.idle": "2026-01-19T14:02:23.472910Z",
     "shell.execute_reply": "2026-01-19T14:02:23.472492Z"
    }
   },
   "outputs": [],
   "source": [
    "# Save the improved submission with rotation optimization\\nprint(f\\\"Improved configs: {len(improved_configs)}\\\")\\nprint(f\\\"Total improvement: {total_improvement:.6f}\\\")\\n\\n# Create final submission by updating the optimized file with rotated configs\\ndf_final = df_opt.copy()\\n\\nfor n, trees in improved_configs.items():\\n    prefix = f\\\"{n:03d}_\\\"\\n    mask = df_final['id'].str.startswith(prefix)\\n    \\n    for i, tree in enumerate(trees):\\n        row_id = f\\\"{n:03d}_{i}\\\"\\n        idx = df_final[df_final['id'] == row_id].index[0]\\n        df_final.loc[idx, 'x'] = f\\\"s{tree['x']:.12f}\\\"\\n        df_final.loc[idx, 'y'] = f\\\"s{tree['y']:.12f}\\\"\\n        df_final.loc[idx, 'deg'] = f\\\"s{tree['deg']:.12f}\\\"\\n\\n# Calculate final score\\nfinal_score = calculate_score(df_final)\\nprint(f\\\"\\\\nFinal Score after rotation optimization: {final_score:.6f}\\\")\\n\\n# Save to submission folder\\ndf_final.to_csv('/home/submission/submission.csv', index=False)\\nprint(\\\"Saved to /home/submission/submission.csv\\\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "10fc7276",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-19T14:03:11.170255Z",
     "iopub.status.busy": "2026-01-19T14:03:11.169758Z",
     "iopub.status.idle": "2026-01-19T14:03:11.172711Z",
     "shell.execute_reply": "2026-01-19T14:03:11.172212Z"
    }
   },
   "outputs": [],
   "source": [
    "# Run a longer optimization with more restarts\\nimport subprocess\\nimport time\\nimport shutil\\n\\n# Use the optimized submission as input for further optimization\\nshutil.copy('/home/code/experiments/001_baseline/submission_optimized.csv', \\n            '/home/code/experiments/001_baseline/submission_v2.csv')\\n\\nprint(\\\"Running extended optimization (this will take several minutes)...\\\")\\nstart = time.time()\\n\\nresult = subprocess.run(\\n    ['/home/code/experiments/001_baseline/bbox3',\\n     '-i', '/home/code/experiments/001_baseline/submission_v2.csv',\\n     '-o', '/home/code/experiments/001_baseline/submission_v3.csv',\\n     '-n', '200',  # more iterations\\n     '-r', '20'],  # more restarts\\n    capture_output=True, text=True,\\n    cwd='/home/code/experiments/001_baseline',\\n    timeout=1800  # 30 minute timeout\\n)\\n\\nelapsed = time.time() - start\\nprint(f\\\"Time: {elapsed:.1f} seconds\\\")\\nprint(\\\"STDOUT:\\\", result.stdout[-2000:] if len(result.stdout) > 2000 else result.stdout)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "d1af8f87",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-19T14:25:20.007584Z",
     "iopub.status.busy": "2026-01-19T14:25:20.007297Z",
     "iopub.status.idle": "2026-01-19T14:25:20.010556Z",
     "shell.execute_reply": "2026-01-19T14:25:20.010185Z"
    }
   },
   "outputs": [],
   "source": [
    "# Implement a better greedy initialization based on the getting-started kernel\\n# Key insight: Use weighted random angles favoring diagonals, and try multiple restarts\\n\\nimport numpy as np\\nfrom shapely.geometry import Polygon\\nfrom shapely import affinity\\nfrom shapely.strtree import STRtree\\nimport random\\n\\nTX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]\\nTY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]\\n\\ndef make_tree(x, y, deg):\\n    p = Polygon(zip(TX, TY))\\n    p = affinity.rotate(p, deg, origin=(0, 0))\\n    p = affinity.translate(p, x, y)\\n    return {'x': x, 'y': y, 'deg': deg, 'polygon': p}\\n\\ndef check_collision(tree, existing_trees):\\n    \\\"\\\"\\\"Check if tree collides with any existing trees.\\\"\\\"\\\"\\n    for t in existing_trees:\\n        if tree['polygon'].intersects(t['polygon']) and not tree['polygon'].touches(t['polygon']):\\n            return True\\n    return False\\n\\ndef get_bbox_side(trees):\\n    if not trees:\\n        return 0\\n    all_x, all_y = [], []\\n    for t in trees:\\n        coords = list(t['polygon'].exterior.coords)\\n        all_x.extend([c[0] for c in coords])\\n        all_y.extend([c[1] for c in coords])\\n    return max(max(all_x) - min(all_x), max(all_y) - min(all_y))\\n\\ndef greedy_pack(n, num_attempts=10):\\n    \\\"\\\"\\\"Pack n trees using greedy approach with multiple attempts.\\\"\\\"\\\"\\n    best_trees = None\\n    best_side = float('inf')\\n    \\n    for attempt in range(num_attempts):\\n        trees = []\\n        \\n        for i in range(n):\\n            placed = False\\n            \\n            # Try multiple starting angles\\n            for _ in range(50):\\n                # Weighted random angle favoring diagonals\\n                angle = random.uniform(0, 360)\\n                weight = abs(np.sin(2 * np.radians(angle)))\\n                if random.random() > weight:\\n                    continue\\n                \\n                # Start far from center and move in\\n                for deg in [0, 90, 180, 270]:\\n                    radius = 20.0\\n                    x = radius * np.cos(np.radians(angle))\\n                    y = radius * np.sin(np.radians(angle))\\n                    \\n                    # Move toward center\\n                    step = 0.5\\n                    while radius > 0:\\n                        tree = make_tree(x, y, deg)\\n                        if not check_collision(tree, trees):\\n                            # Found valid position, now move closer\\n                            last_valid = tree\\n                            while True:\\n                                radius -= step\\n                                if radius < 0:\\n                                    break\\n                                x = radius * np.cos(np.radians(angle))\\n                                y = radius * np.sin(np.radians(angle))\\n                                tree = make_tree(x, y, deg)\\n                                if check_collision(tree, trees):\\n                                    break\\n                                last_valid = tree\\n                            trees.append(last_valid)\\n                            placed = True\\n                            break\\n                        radius -= step\\n                        x = radius * np.cos(np.radians(angle))\\n                        y = radius * np.sin(np.radians(angle))\\n                    \\n                    if placed:\\n                        break\\n                if placed:\\n                    break\\n            \\n            if not placed:\\n                # Fallback: place at a random position\\n                for _ in range(100):\\n                    x = random.uniform(-10, 10)\\n                    y = random.uniform(-10, 10)\\n                    deg = random.choice([0, 90, 180, 270])\\n                    tree = make_tree(x, y, deg)\\n                    if not check_collision(tree, trees):\\n                        trees.append(tree)\\n                        placed = True\\n                        break\\n        \\n        if len(trees) == n:\\n            side = get_bbox_side(trees)\\n            if side < best_side:\\n                best_side = side\\n                best_trees = trees\\n    \\n    return best_trees, best_side\\n\\nprint(\\\"Greedy packing functions defined!\\\")\\n\\n# Test on small n\\ntrees, side = greedy_pack(10, num_attempts=5)\\nprint(f\\\"N=10: side={side:.4f}, score={side**2/10:.4f}\\\")"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}
