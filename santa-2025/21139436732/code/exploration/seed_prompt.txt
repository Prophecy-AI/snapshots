# Santa 2025 Christmas Tree Packing - Optimization Seed Prompt

## Problem Overview
This is a 2D geometric packing optimization problem. The goal is to pack Christmas tree-shaped polygons into the smallest possible square bounding box for each configuration of n trees (n=1 to 200).

**Metric:** Sum of (side_length^2 / n) for all n from 1 to 200. Lower is better.
**Target Score:** Beat 68.922808

## Data Structure
- 200 separate packing problems (n=1 to n=200)
- Each tree is a 15-vertex polygon with fixed shape (trunk + 3-tier branches)
- Tree dimensions: ~0.7 width at base, ~1.0 height (from trunk bottom to tip)
- Submission format: id (nnn_idx), x, y, deg (all prefixed with 's' for precision)
- Coordinates must be in range [-100, 100]
- No overlapping trees allowed (touching is OK)

## Key Techniques from Top Kernels

### 1. Core Optimization Algorithms (from bbox3.cpp / tree_packer_v21.cpp)
Reference: `../research/kernels/jazivxt_why-not/why-not.ipynb`
Reference: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

**C++ Optimizers are essential** - Python is too slow for this problem:
- Compile with: `g++ -O3 -march=native -std=c++17 -fopenmp -o optimizer optimizer.cpp`
- Use OpenMP for parallelization across n-values

**Key optimization moves:**
1. **Squeeze/Compaction**: Scale all trees toward center, check for overlaps
2. **Local Search**: 8-directional moves + rotation adjustments
3. **Simulated Annealing**: Accept worse moves with decreasing probability
4. **Swap Moves**: Exchange positions of two trees
5. **Boundary Tree Focus**: Prioritize moving trees that define the bounding box

### 2. Rotation Tightening (fix_direction)
Reference: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`

After packing, rotate the entire configuration to minimize bounding box:
```python
from scipy.spatial import ConvexHull
from scipy.optimize import minimize_scalar

def optimize_rotation(trees):
    # Get convex hull of all tree vertices
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    # Find optimal rotation angle (0-90 degrees)
    res = minimize_scalar(
        lambda a: calculate_bbox_side_at_angle(a, hull_points),
        bounds=(0.001, 89.999), method='bounded'
    )
    return res.x, res.fun
```

### 3. Backward Propagation
Reference: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Use larger configurations to improve smaller ones:
- Start from n=200, work down to n=2
- Remove boundary-touching trees one at a time
- If resulting (n-1) config is better than stored, save it

### 4. Overlap Detection & Repair
Reference: `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

- Use Shapely with STRtree for efficient collision detection
- Point-in-polygon + segment intersection checks
- If overlaps found, replace with known-good configuration from baseline

### 5. Greedy Initialization
Reference: `../research/kernels/inversion_santa-2025-getting-started/`

- Place trees one at a time, starting far from center
- Move toward center until collision, then back up
- Use weighted random angles (sin(2*angle)) to favor diagonal placements

## Recommended Approach

### Phase 1: Baseline Implementation
1. Start with sample_submission.csv or a known good baseline
2. Implement basic Python validation (overlap checking, score calculation)
3. Set up C++ compilation pipeline

### Phase 2: C++ Optimizer
1. Implement or adapt bbox3.cpp optimizer
2. Key parameters to tune:
   - n (iterations): 1000-5000
   - r (restarts): 30-256
   - Temperature schedule for SA
3. Run for extended time (3-9 hours on Kaggle)

### Phase 3: Post-Processing
1. Apply fix_direction rotation optimization
2. Run backward propagation
3. Validate no overlaps, repair if needed

### Phase 4: Iterative Refinement
1. Use phased approach: short runs to find promising parameters
2. Longer runs on best candidates
3. Keep best submission, revert on regressions

## Implementation Notes

### Precision
- Use Decimal or long double for coordinates
- Scale factor of 1e15 used in some implementations
- Round to 6-12 decimal places for submission

### Tree Geometry (15 vertices)
```cpp
const double TX[15] = {0,0.125,0.0625,0.2,0.1,0.35,0.075,0.075,-0.075,-0.075,-0.35,-0.1,-0.2,-0.0625,-0.125};
const double TY[15] = {0.8,0.5,0.5,0.25,0.25,0,0,-0.2,-0.2,0,0,0.25,0.25,0.5,0.5};
```

### Collision Detection
- Bounding box pre-check (fast rejection)
- Point-in-polygon test
- Segment intersection test
- Touching (not overlapping) is allowed

## Experiments to Try

1. **Baseline C++ optimizer**: Adapt bbox3.cpp or tree_packer_v21.cpp
2. **Parameter sweep**: Try different n, r values
3. **Hybrid approach**: Combine multiple optimizers
4. **Focus on high-n configurations**: n=150-200 contribute most to score
5. **Lattice patterns**: Some solutions show crystalline arrangements

## Validation Checklist
- [ ] No overlapping trees (touching OK)
- [ ] All coordinates in [-100, 100]
- [ ] Correct number of trees per configuration
- [ ] Values prefixed with 's' in submission
- [ ] Score calculated correctly: sum(side^2 / n)

## Reference Notebooks
- EDA: `exploration/eda.ipynb`
- Getting Started: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 optimizer: `../research/kernels/jazivxt_why-not/why-not.ipynb`
- tree_packer: `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`
- Rotation optimization: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`
