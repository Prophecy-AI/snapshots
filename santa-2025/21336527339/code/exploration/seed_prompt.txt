# Christmas Tree Packing Optimization - Loop 2 Strategy

## Current Status
- **Best CV score**: 70.676102 from exp_000 (baseline_preoptimized)
- **Best LB score**: N/A (NO SUBMISSIONS YET!)
- **Target**: 68.888293 | **Gap**: 1.788 points (2.53% improvement needed)
- **Submissions remaining**: 93/100

## ⚠️ CRITICAL FIRST ACTION: SUBMIT BASELINE TO LEADERBOARD ⚠️

**Before doing ANYTHING else, submit the baseline (exp_000) to get LB feedback!**
- This establishes ground truth
- Verifies local scoring matches Kaggle scoring
- We have 93 submissions - use them!

## Response to Evaluator

The evaluator made several excellent points that I'm incorporating:

1. **AGREE: Submit baseline immediately** - This is critical. We need LB feedback.

2. **AGREE: Apply fix_direction (rotation tightening)** - This is a quick win from the saspav kernel. The function optimizes the rotation of entire configurations using ConvexHull + scipy.optimize.minimize_scalar.

3. **PARTIALLY AGREE: Compile bbox3 from source** - The evaluator correctly notes that compiling from source is different from using pre-compiled binaries. However, I want to first try the fix_direction approach since it's simpler and can be applied immediately.

4. **AGREE: Don't neglect medium/large N** - Score breakdown shows n=51-200 contributes ~51.6 points (73% of total). While small N has higher per-tree contribution, the bulk of improvement potential is in larger N.

## Recommended Approaches (Priority Order)

### EXPERIMENT 1: Apply fix_direction to baseline
**Priority: HIGHEST - Quick Win**

The saspav kernel shows the `fix_direction` function that:
1. Computes ConvexHull of all tree vertices
2. Uses scipy.optimize.minimize_scalar to find optimal rotation angle (0-90°)
3. Applies rotation to minimize max(width, height) of bounding box

**Implementation:**
```python
from scipy.spatial import ConvexHull
from scipy.optimize import minimize_scalar

def calculate_bbox_side_at_angle(angle_deg, points):
    angle_rad = np.radians(angle_deg)
    c, s = np.cos(angle_rad), np.sin(angle_rad)
    rot_matrix_T = np.array([[c, s], [-s, c]])
    rotated_points = points.dot(rot_matrix_T)
    min_xy = np.min(rotated_points, axis=0)
    max_xy = np.max(rotated_points, axis=0)
    return max(max_xy[0] - min_xy[0], max_xy[1] - min_xy[1])

def optimize_rotation(trees):
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points_np = np.array(all_points)
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    res = minimize_scalar(
        lambda a: calculate_bbox_side_at_angle(a, hull_points),
        bounds=(0.001, 89.999), method='bounded'
    )
    return res.x, res.fun
```

**Expected improvement**: 0.1-0.5 points (based on saspav kernel results)

### EXPERIMENT 2: Compile and run bbox3 optimizer
**Priority: HIGH - Main optimization engine**

The bbox3.cpp source code is available in `research/kernels/jazivxt_why-not/why-not.ipynb`.

**Steps:**
1. Extract bbox3.cpp from the notebook
2. Compile with: `g++ -O3 -fopenmp -o bbox3 bbox3.cpp`
3. Run optimization passes with different parameters
4. Apply fix_direction after each pass
5. Validate and keep best results

**Parameters to try:**
- `-n` (iterations): 1000, 5000, 10000
- `-r` (radius): 0.1, 0.2, 0.5

### EXPERIMENT 3: Targeted optimization for high-contribution N values
**Priority: MEDIUM**

Analyze which N values have the most room for improvement:
- Compare current side lengths to theoretical minimums
- Focus optimization on N values where efficiency is lowest
- Small N (1-20) have highest per-tree contribution but may already be near-optimal
- Medium N (21-100) may have more room for improvement

## Score Breakdown Analysis

From baseline:
- n=1-10: 4.33 (6.1% of total)
- n=11-20: 3.73 (5.3% of total)
- n=21-50: 10.98 (15.5% of total)
- n=51-100: 17.64 (25.0% of total)
- n=101-150: 17.14 (24.3% of total)
- n=151-200: 16.85 (23.8% of total)

**Key insight**: n=51-200 contributes 73% of the score. Even small percentage improvements here have large absolute impact.

## What NOT to Try
- Starting from scratch with greedy algorithms (baseline is already optimized)
- Complex NFP implementation before trying simpler approaches
- Genetic algorithms (too slow for the time available)

## Validation Requirements

**CRITICAL: Use high-precision validation before submission**
```python
from decimal import Decimal, getcontext
getcontext().prec = 25
scale_factor = Decimal('1e18')

# Scale coordinates to integers for precise overlap detection
# Use Shapely with scaled integer coordinates
```

## Submission Strategy

**With 93 submissions remaining, submit AGGRESSIVELY:**
1. Submit baseline FIRST (exp_000)
2. Submit after fix_direction experiment
3. Submit after bbox3 optimization
4. LB feedback is FREE information - use it!

## Files and Resources

- Baseline submission: `/home/code/experiments/000_baseline/submission.csv`
- bbox3 source: `research/kernels/jazivxt_why-not/why-not.ipynb` (extract bbox3.cpp)
- fix_direction code: `research/kernels/saspav_santa-submission/santa-submission.ipynb`
- Tree geometry: 15 vertices, trunk at y=-0.2 to y=0, tip at y=0.8

## Expected Path to Target

1. **Baseline**: 70.676 (current)
2. **After fix_direction**: ~70.2-70.5 (estimated 0.2-0.5 improvement)
3. **After bbox3 optimization**: ~69.5-70.0 (estimated 0.5-1.0 improvement)
4. **After targeted N optimization**: ~69.0-69.5 (estimated 0.5 improvement)
5. **Target**: 68.888

This is achievable with the tools available!
