# Christmas Tree Packing Optimization - Loop 2 Strategy

## Current Status
- **Best CV score**: 70.647327 from exp_000 (baseline)
- **Best LB score**: 70.647327 (confirmed from snapshot 21328309254)
- **Target**: 68.888293 | **Gap to target**: 1.759 points (2.49% improvement needed)

## CRITICAL FIX APPLIED
The original baseline from snapshot 21116303805 had overlapping trees in group 126 and was rejected by Kaggle.
We have replaced it with the VALID submission from snapshot 21328309254 which scored 70.647327 on LB.

**Valid baseline location**: `/home/code/experiments/000_baseline/submission_valid.csv`
**This is now in**: `/home/submission/submission.csv`

## Response to Evaluator
The evaluator correctly identified that:
1. ✅ We needed to submit to LB to verify - DONE (but failed due to overlaps)
2. ✅ The baseline is now fixed with a valid submission
3. The evaluator suggested compiling bbox3 from source - this is a valid approach
4. The evaluator suggested rotation tightening (fix_direction) - worth trying

## Score Breakdown (from valid baseline)
- n=1-10: 4.329 (6.1% of total) - HIGH per-tree impact
- n=11-20: 3.726 (5.3% of total)
- n=21-50: 10.984 (15.5% of total)
- n=51-100: 17.628 (25.0% of total)
- n=101-150: 17.137 (24.3% of total)
- n=151-200: 16.843 (23.8% of total)

**Key insight**: Large N (51-200) contributes 73% of the score. Small N has higher per-tree impact but lower total contribution.

## Available Optimization Tools
Pre-compiled binaries available in snapshots:
- `/home/nonroot/snapshots/santa-2025/21328309254/code/bbox3` - Main optimizer
- `/home/nonroot/snapshots/santa-2025/21328309254/code/sa_fast_v2` - Simulated annealing
- `/home/nonroot/snapshots/santa-2025/21123768399/code/bbox3_advanced` - Advanced version

Source code available for compilation:
- `/home/nonroot/snapshots/santa-2025/21328309254/code/bbox3.cpp`
- `/home/nonroot/snapshots/santa-2025/21328309254/code/sa_fast_v2.cpp`

## Recommended Approach for exp_001: Run bbox3 Optimization

### Step 1: Setup
```bash
mkdir -p /home/code/experiments/001_bbox3_optimization
cp /home/nonroot/snapshots/santa-2025/21328309254/code/bbox3 /home/code/experiments/001_bbox3_optimization/
cp /home/code/experiments/000_baseline/submission_valid.csv /home/code/experiments/001_bbox3_optimization/input.csv
chmod +x /home/code/experiments/001_bbox3_optimization/bbox3
```

### Step 2: Run Optimization
```bash
cd /home/code/experiments/001_bbox3_optimization
./bbox3 -i input.csv -o optimized.csv -n 5000 -r 0.1
```

### Step 3: Validate Output
Create a validation notebook that:
1. Loads the optimized output
2. Checks for overlaps using high-precision arithmetic
3. Computes the score
4. If valid, copy to /home/submission/submission.csv

### Step 4: Submit
If validation passes, submit to get LB feedback.

## IMPORTANT: Overlap Validation Code
```python
from shapely.geometry import Polygon
from shapely.affinity import rotate, translate
from shapely.strtree import STRtree

def check_overlaps_strict(polygons, tolerance=1e-12):
    """Strict overlap check with small tolerance."""
    if len(polygons) <= 1:
        return []
    overlaps = []
    tree_index = STRtree(polygons)
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx > i:
                if polygons[i].intersects(polygons[idx]):
                    if not polygons[i].touches(polygons[idx]):
                        intersection = polygons[i].intersection(polygons[idx])
                        if intersection.area > tolerance:
                            overlaps.append((i, idx, intersection.area))
    return overlaps
```

## What NOT to Try
- Using snapshot 21116303805 submission (has overlaps)
- Submitting without validation
- Running optimization without checking output for overlaps

## Submission Strategy
- Remaining submissions: 93
- **SUBMIT after this experiment** - we have abundant submissions
- LB feedback is valuable even if score doesn't improve

## Alternative Approaches (if bbox3 doesn't help)
1. **Rotation tightening (fix_direction)**: Apply scipy.optimize.minimize_scalar to find optimal rotation angle for each configuration
2. **Ensemble from multiple snapshots**: Pick best configuration for each n from different sources
3. **Implement novel algorithms**: NFP, genetic algorithm, branch-and-bound for small N