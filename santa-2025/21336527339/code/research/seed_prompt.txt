# Christmas Tree Packing Optimization - Loop 5 Strategy

## Current Status
- Best CV score: 70.615744 from exp_005 (ensemble_fixed)
- Best LB score: 70.647327 (exp_002, exp_003)
- Target: 68.887744 | Gap to target: 1.728 points (2.5%)
- Submissions used: 5/100 (91 remaining)

## CRITICAL: exp_004 Failed with Overlaps - FIXED in exp_005
The ensemble submission failed because 4 N values (N=2, N=29, N=103, N=138) had tiny overlaps (1e-13 area). These were fixed by replacing with valid baseline solutions. exp_005 is ready for submission.

## Response to Evaluator
The evaluator correctly identified:
1. ✅ Ensemble approach is correct - confirmed with 0.032 improvement
2. ✅ Only 3 snapshots contributed to valid ensemble - CONFIRMED
3. ✅ Need more diverse solution sources - CONFIRMED

**Key Discovery from Loop 5 Analysis:**
- Scanned 118 CSV files (88 snapshots + 30 preoptimized solutions)
- Found 57 N values where better solutions exist but have tiny overlaps
- Total potential improvement if overlaps fixed: 0.092 points
- Top opportunities: N=5 (0.023), N=2 (0.013), N=56 (0.011)

## Recommended Approaches (Priority Order)

### 1. **IMMEDIATE: Submit exp_005** (fixed ensemble)
- Score: 70.615744 (improvement of 0.032 from baseline)
- No overlaps - should pass Kaggle validation
- Submit to verify CV-LB alignment

### 2. **HIGH PRIORITY: Fix Overlapping Solutions**
The 57 N values with overlapping solutions could give us 0.092 points improvement.
Strategy: For each overlapping solution, apply tiny translations to separate trees:
```python
# For each N with overlap:
# 1. Identify which trees overlap
# 2. Calculate separation vector
# 3. Move trees apart by minimum distance (1e-10 to 1e-8)
# 4. Verify no new overlaps created
# 5. Recalculate score
```

### 3. **MEDIUM PRIORITY: Implement Overlap Repair Algorithm**
Create a function that takes an overlapping solution and repairs it:
```python
def repair_overlaps(trees, max_iterations=1000):
    """Move trees apart to eliminate overlaps while minimizing score impact."""
    for iteration in range(max_iterations):
        overlaps = find_overlaps(trees)
        if not overlaps:
            return trees, True  # Success
        
        # For each overlap, calculate separation vector
        for i, j in overlaps:
            separation = calculate_separation_vector(trees[i], trees[j])
            # Move both trees by half the separation
            trees[i] = move_tree(trees[i], separation / 2)
            trees[j] = move_tree(trees[j], -separation / 2)
    
    return trees, False  # Failed to repair
```

### 4. **LOWER PRIORITY: Generate New Diverse Solutions**
Run optimization with different random seeds to generate new solutions that might be better for different N values.

## What NOT to Try
- ❌ Running bbox3/sa_fast with more iterations (already at local optimum)
- ❌ Fractional translation on valid solutions (tested, no improvement)
- ❌ Simple parameter tuning (won't bridge 1.7 point gap)

## Validation Notes
- CV = LB perfectly (confirmed from exp_002, exp_003)
- Use Shapely polygon intersection with area > 1e-15 threshold for overlap detection
- Kaggle uses stricter validation than default Shapely floating-point

## Score Breakdown (from baseline)
- n=1-10: 4.33 (6.1%)
- n=11-20: 3.73 (5.3%)
- n=21-50: 10.98 (15.5%)
- n=51-100: 17.63 (25.0%)
- n=101-150: 17.14 (24.3%)
- n=151-200: 16.84 (23.8%)

## Key Files
- Valid ensemble: /home/code/experiments/005_ensemble_fixed/submission.csv
- Preoptimized solutions: /home/nonroot/snapshots/santa-2025/21116303805/code/preoptimized/
- Analysis notebook: /home/code/exploration/evolver_loop5_analysis.ipynb
