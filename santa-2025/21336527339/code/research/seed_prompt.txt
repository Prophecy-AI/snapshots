# Christmas Tree Packing Optimization - Loop 4 Strategy

## Current Status
- Best CV score: 70.647327 from exp_002 (valid baseline)
- Best LB score: 70.647327 (exp_002 and exp_003 both confirmed)
- Target: 68.887744 | Gap to target: 1.76 points (2.5%)

## CV-LB Relationship
- **PERFECT MATCH**: CV = LB exactly (confirmed by exp_002 and exp_003)
- We can trust local validation completely
- No distribution shift concerns

## Response to Evaluator
The evaluator correctly identified that single-solution optimization has hit a wall:
- exp_001: bbox3/sa_fast → 0.000006 improvement
- exp_003: fix_direction → 0.00000001 improvement

The baseline is at a VERY strong local optimum. Three different optimization techniques all failed.

**I AGREE with the evaluator's recommendation to pivot to ENSEMBLE approach.**

However, my analysis shows the ensemble approach is LIMITED:
- 88 snapshots scanned
- Best single snapshot (21145966992) scores 70.572798 but has 57 N values with OVERLAPS
- Valid ensemble (excluding overlapping solutions) only scores 70.615744
- This is only 0.032 improvement from baseline - NOT ENOUGH

**The key insight**: Most snapshots have overlapping solutions that Kaggle rejects.
We need to either:
1. Find/generate MORE diverse VALID solutions
2. Implement novel algorithms to generate new solutions from scratch

## What We Know Works
1. **Ensemble approach** - combining best per-N from multiple sources (jonathanchan kernel)
2. **C++ optimizers** - bbox3, sa_fast_v2 for local refinement
3. **Fractional translation** - very small steps (0.001, 0.0005, etc.) in 8 directions
4. **Rotation tightening** - fix_direction (but baseline already has this applied)

## What We Know DOESN'T Work
1. Running bbox3/sa_fast on the current baseline - it's already at local optimum
2. fix_direction - baseline is already optimally rotated
3. Simple ensemble from snapshots - most have overlaps, valid ones only give 0.032 improvement

## ⛔ BLOCKED APPROACHES (DO NOT USE)
- Running bbox3, sa_fast_v2, eazy_optimizer on the current baseline
- "More iterations" on existing optimizers
- fix_direction (already applied)

## ✅ RECOMMENDED APPROACHES (Priority Order)

### 1. **[HIGHEST PRIORITY] Generate New Solutions with Different Seeds/Algorithms**
The jonathanchan kernel shows that the best scores come from COMBINING solutions from MANY different sources:
- Different random seeds
- Different optimization algorithms
- Different initial configurations

**Implementation:**
```python
# Generate 10+ new solutions with different seeds
for seed in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
    # Run bbox3 or sa_fast with different seed
    # Save each solution
    # Then ensemble the best per-N
```

### 2. **[HIGH PRIORITY] Fractional Translation Refinement**
The jonathanchan kernel uses very small step movements:
- Steps: 0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001
- Directions: 8 cardinal + diagonal directions
- This can squeeze out small improvements without creating overlaps

**Implementation:**
```python
steps = [0.001, 0.0005, 0.0002, 0.0001]
directions = [(1,0), (-1,0), (0,1), (0,-1), (1,1), (1,-1), (-1,1), (-1,-1)]
for step in steps:
    for dx, dy in directions:
        # Try moving each tree by (dx*step, dy*step)
        # Keep if score improves and no overlaps
```

### 3. **[MEDIUM PRIORITY] Per-N Specialized Optimization**
Different N values may benefit from different approaches:
- N=1-10: Exhaustive rotation search (test every 0.1° rotation)
- N=11-50: More aggressive SA with different parameters
- N=51-100: Cluster-based moves
- N=100+: Tessellation patterns

### 4. **[LOWER PRIORITY] Novel Algorithm Implementation**
If the above don't work, implement from scratch:
- No-Fit Polygon (NFP) for efficient collision detection
- Genetic algorithm with custom crossover operators
- Branch-and-bound for small N (guarantee optimal)

## Validation Notes
- CV = LB perfectly, so we can trust local validation
- MUST check for overlaps before submission (Kaggle is strict)
- Use integer scaling (1e18) for precise overlap detection:
```python
from decimal import Decimal, getcontext
getcontext().prec = 30
SCALE = 10**18

def validate_no_overlap(trees):
    # Use integer coordinates for precise intersection tests
    coords = [(int(Decimal(str(x)) * SCALE), int(Decimal(str(y)) * SCALE)) for x, y in vertices]
```

## Submission Strategy
- Remaining submissions: 91
- **SUBMIT after EVERY experiment** - we have abundant submissions
- LB feedback is free information - USE IT

## Expected Outcome
If we can generate 10+ diverse valid solutions and ensemble the best per-N:
- Expected improvement: 0.1-0.3 points (based on jonathanchan approach)
- This would get us to ~70.35-70.55
- Still 1.5+ points from target - may need novel algorithms

## Key Files
- Valid baseline: `/home/nonroot/snapshots/santa-2025/21328309254/submission/submission.csv`
- Best ensemble snapshot: `/home/nonroot/snapshots/santa-2025/21336527339/submission/submission.csv`
- jonathanchan kernel: `/home/code/research/kernels/jonathanchan_santa25-ensemble-sa-fractional-translation/`
