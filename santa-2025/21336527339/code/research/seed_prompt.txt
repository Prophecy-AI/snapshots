# Christmas Tree Packing Optimization - Loop 3 Strategy

## Current Status
- Best CV score: **70.647327** from exp_002 (valid baseline)
- Best LB score: **70.647327** (CONFIRMED on Kaggle!)
- Target: **68.888293**
- Gap to target: **1.759 points (2.5% improvement needed)**
- CV-LB gap: **0.0000** - Perfect calibration! CV = LB for this problem.

## ðŸŽ‰ CRITICAL SUCCESS: Baseline Works on Kaggle!
exp_002 scored 70.647327 on LB - exactly matching CV. This means:
1. Our local validation is perfectly calibrated
2. We can trust CV scores completely
3. The overlap validation is working correctly

## Response to Evaluator
The evaluator correctly identified that:
1. âœ… The original valid baseline works on Kaggle (confirmed!)
2. âœ… fix_direction (rotation tightening) is the TOP PRIORITY
3. âœ… This is pure Python - no binaries needed
4. âœ… bbox3/sa_fast_v2 cannot escape the local optimum

I AGREE with the evaluator's assessment. The next experiment MUST implement fix_direction.

## â›” BLOCKED APPROACHES (DO NOT USE)
- bbox3, sa_fast_v2, eazy_optimizer - FORBIDDEN (already proven ineffective)
- Any pre-compiled C++ binary - FORBIDDEN
- "More iterations" on existing optimizer - FORBIDDEN
- Submitting the same baseline again - FORBIDDEN

## âœ… REQUIRED: Implement fix_direction (Rotation Tightening)

### What is fix_direction?
For each N configuration, find the optimal rotation angle that minimizes the bounding box:
1. Get all polygon vertices from all trees in the configuration
2. Compute ConvexHull of all vertices
3. Use scipy.optimize.minimize_scalar to find optimal rotation angle (0-90Â°)
4. Objective: minimize max(width, height) of axis-aligned bounding box
5. Apply rotation to all tree positions and angles

### Implementation (from saspav kernel):
```python
from scipy.spatial import ConvexHull
from scipy.optimize import minimize_scalar
import numpy as np

def calculate_bbox_side_at_angle(angle_deg, points):
    """Calculate bounding box side at a given rotation angle."""
    angle_rad = np.radians(angle_deg)
    c, s = np.cos(angle_rad), np.sin(angle_rad)
    rot_matrix_T = np.array([[c, s], [-s, c]])
    rotated_points = points.dot(rot_matrix_T)
    min_xy = np.min(rotated_points, axis=0)
    max_xy = np.max(rotated_points, axis=0)
    return max(max_xy[0] - min_xy[0], max_xy[1] - min_xy[1])

def optimize_rotation(trees):
    """Find optimal rotation angle for a configuration."""
    # Get all polygon vertices
    all_points = []
    for tree in trees:
        all_points.extend(list(tree.polygon.exterior.coords))
    points_np = np.array(all_points)
    
    # Get convex hull points (faster to optimize)
    hull_points = points_np[ConvexHull(points_np).vertices]
    
    # Find optimal angle
    res = minimize_scalar(
        lambda a: calculate_bbox_side_at_angle(a, hull_points),
        bounds=(0.001, 89.999), 
        method='bounded'
    )
    
    return res.x, res.fun  # angle, new_side

def apply_rotation(trees, angle_deg):
    """Apply rotation to all trees in configuration."""
    if abs(angle_deg) < 1e-9:
        return trees
    
    # Find rotation center (center of bounding box)
    bounds = [t.polygon.bounds for t in trees]
    min_x = min(b[0] for b in bounds)
    min_y = min(b[1] for b in bounds)
    max_x = max(b[2] for b in bounds)
    max_y = max(b[3] for b in bounds)
    center = np.array([(min_x + max_x) / 2.0, (min_y + max_y) / 2.0])
    
    # Rotate all tree positions and angles
    angle_rad = np.radians(angle_deg)
    c, s = np.cos(angle_rad), np.sin(angle_rad)
    rot_matrix = np.array([[c, -s], [s, c]])
    
    new_trees = []
    for tree in trees:
        # Rotate position around center
        pos = np.array([float(tree.center_x), float(tree.center_y)])
        new_pos = (pos - center).dot(rot_matrix.T) + center
        # Add rotation to angle
        new_angle = tree.angle + angle_deg
        new_trees.append(ChristmasTree(new_pos[0], new_pos[1], new_angle))
    
    return new_trees
```

### Experiment Structure:
```
experiments/003_fix_direction/
â”œâ”€â”€ fix_direction.py      # Implementation
â”œâ”€â”€ metrics.json          # Results
â””â”€â”€ submission.csv        # Output
```

### Steps:
1. Load the valid baseline (snapshot 21328309254)
2. For each N from 1 to 200:
   a. Load trees for this N
   b. Call optimize_rotation() to find best angle
   c. If improvement > epsilon, apply rotation
   d. Validate no overlaps introduced
3. Compute new total score
4. Save submission.csv

### Expected Improvement:
- Rotation tightening typically yields 0.1-0.5 points improvement
- This alone won't beat the target, but it's a necessary step
- After this, we can try ensemble approaches

## SMALL N TEST FIRST (MANDATORY)

Before running on all 200 N values, test on small N:
```python
# Test on N = 10, 20, 30
for n in [10, 20, 30]:
    trees = load_trees_for_n(n)
    old_side = get_bbox_side(trees)
    angle, new_side = optimize_rotation(trees)
    improvement = old_side - new_side
    print(f"N={n}: old={old_side:.6f}, new={new_side:.6f}, improvement={improvement:.6f}, angle={angle:.2f}Â°")
```

If small N test shows NO improvement, the approach won't work for larger N either.

## Validation Requirements

### High-Precision Overlap Detection (CRITICAL):
```python
from decimal import Decimal, getcontext
getcontext().prec = 25
scale_factor = Decimal("1e18")

def has_overlap(trees):
    """Check for overlaps using high-precision coordinates."""
    from shapely.geometry import Polygon
    from shapely.strtree import STRtree
    
    polygons = [t.polygon for t in trees]  # Already scaled
    tree_index = STRtree(polygons)
    
    for i, poly in enumerate(polygons):
        indices = tree_index.query(poly)
        for idx in indices:
            if idx == i:
                continue
            if poly.intersects(polygons[idx]) and not poly.touches(polygons[idx]):
                return True
    return False
```

### Before Submission:
1. Validate ALL 200 N configurations have no overlaps
2. Verify total score matches expected
3. Check submission format (id, x, y, deg with 's' prefix)

## Score Breakdown (for reference)
- n=1-10: 4.33 (6.1%)
- n=11-20: 3.73 (5.3%)
- n=21-50: 10.98 (15.5%)
- n=51-100: 17.63 (25.0%)
- n=101-150: 17.14 (24.3%)
- n=151-200: 16.84 (23.8%)

## After fix_direction: Next Steps
1. **Ensemble approach**: Combine best solutions from multiple sources per N
2. **Fractional translation**: Very small step movements (0.001, 0.0005, etc.)
3. **Per-N targeted optimization**: Focus on N values with most room for improvement

## SUBMISSION STRATEGY
- Remaining submissions: **92** (ABUNDANT!)
- Submit after EVERY experiment to get LB feedback
- CV = LB for this problem, so we can trust local scores

## Success Criteria
- If fix_direction improves score by > 0.01: SUCCESS, proceed to full implementation
- If fix_direction shows NO improvement on small N: Try different approach (ensemble)