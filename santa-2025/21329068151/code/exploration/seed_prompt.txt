# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt

## Problem Overview
This is a 2D polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (1 to 200 trees per configuration) into the smallest possible square bounding box.

**Scoring Formula:** score = Σ(side_n² / n) for n=1 to 200 (lower is better)
**Target Score:** Beat 68.894234

## Tree Shape Specification
The Christmas tree is a 15-vertex polygon with:
- **Trunk:** 0.15 width × 0.2 height (bottom)
- **Three tiers:** base (0.7w), middle (0.4w), top (0.25w)
- **Tip:** at y=0.8
- **Position:** defined by (x, y) at center of trunk top + rotation angle in degrees
- **Total height:** 1.0 (from trunk bottom at -0.2 to tip at 0.8)

**Tree vertices (15 points):**
```python
TX = [0, 0.125, 0.0625, 0.2, 0.1, 0.35, 0.075, 0.075, -0.075, -0.075, -0.35, -0.1, -0.2, -0.0625, -0.125]
TY = [0.8, 0.5, 0.5, 0.25, 0.25, 0, 0, -0.2, -0.2, 0, 0, 0.25, 0.25, 0.5, 0.5]
```

## Insights from Discussions (CRITICAL)

### Key Discussion Insights:
1. **"Why the winning solutions will be Asymmetric" (38 votes):** Top teams found that asymmetric solutions consistently outperform symmetric ones. Don't constrain to lattice patterns.

2. **"Expected Leaderboard Progression" (20 votes):** Competition organizers expected scores to improve significantly over time. The target (68.894) is achievable with proper optimization.

3. **"Interactive Editor" (58 votes):** Manual editing tools helped teams find better configurations for small N values. Consider hybrid human-guided + algorithmic approaches.

### What Discussions Say DOESN'T Work:
- Pure greedy placement without optimization
- Symmetric-only solutions (asymmetric is better)
- Single-pass algorithms without refinement

### Unexplored Ideas from Discussions:
- Genetic algorithms with crossover between good configurations
- Machine learning to predict good initial placements
- Constraint programming approaches

## Key Algorithmic Approaches (from kernels and research)

### 1. Simulated Annealing (SA) - Primary Optimization Method
The most successful approach uses SA with:
- **Move operators:** translate (x,y), rotate (angle), swap positions
- **Temperature schedule:** Start high for exploration, cool gradually
- **Acceptance:** Accept worse solutions probabilistically early, become greedy later
- **Multi-start:** Run multiple times with different initial configurations

**Key parameters from kernels:**
- `-n` iterations (1000-10000 typical)
- `-r` restarts (16-256 typical)
- Higher iterations for larger N values

### 2. Advanced C++ Optimization Techniques (from bbox3)
From the "why-not" kernel's bbox3 implementation:
- **Complex number vector coordination:** Use complex numbers for efficient rotation/translation
- **Fluid dynamics-inspired moves:** Treat trees as particles with repulsion forces
- **Hinge pivot optimization:** Rotate around boundary-touching points
- **Density gradient flow:** Move trees toward lower-density regions
- **Global boundary tension:** Pull boundary trees inward
- **Aggressive overlap repair:** Use separation vectors (MTV approximation) to resolve overlaps

### 3. Local Search Refinements
After SA, apply local search:
- **8-directional moves:** Try small translations in all directions
- **Rotation optimization:** Find optimal global rotation angle using scipy.optimize
- **Step sizes:** Start coarse (0.01), refine to fine (0.0001)
- **Corner tree focus:** Prioritize optimizing trees that define the bounding box

### 4. Squeeze and Compaction
- **Squeeze:** Scale all trees toward center by factor (0.98-0.9995)
- **Compaction:** Move each tree toward center until collision
- **Iterative:** Apply multiple passes until no improvement

### 5. Backward Propagation (Novel Technique)
Use larger configurations to improve smaller ones:
- Start from N=200, work down to N=2
- For each N, try removing boundary-touching trees
- If resulting (N-1) config is better than stored, update it
- This exploits the fact that good N configs often contain good (N-1) configs

### 6. Rotation Tightening (fix_direction)
Optimize the global rotation of the entire configuration:
- Compute convex hull of all tree vertices
- Use scipy.optimize.minimize_scalar to find angle minimizing bounding box
- Apply rotation to all trees (update both positions and angles)

## Implementation Details

### Collision Detection
Use Shapely library with high precision:
- `STRtree` for spatial indexing (fast neighbor queries)
- `intersects()` and `touches()` for overlap detection
- Scale factor (1e15 to 1e18) for numerical precision

### Polygon Overlap Check (C++ style)
```cpp
bool overlap(const Poly& a, const Poly& b) {
    // 1. Bounding box check (fast rejection)
    if (a.x1 < b.x0 || b.x1 < a.x0 || a.y1 < b.y0 || b.y1 < a.y0) return false;
    // 2. Point-in-polygon check
    for (int i = 0; i < NV; i++) {
        if (pip(a.p[i], b)) return true;
        if (pip(b.p[i], a)) return true;
    }
    // 3. Edge intersection check
    for (int i = 0; i < NV; i++)
        for (int j = 0; j < NV; j++)
            if (segInt(a.edge[i], b.edge[j])) return true;
    return false;
}
```

### Submission Format
```
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- Values prefixed with 's' to preserve precision
- Coordinates constrained to -100 ≤ x, y ≤ 100

## Recommended Experiment Strategy

### Phase 1: Baseline (Quick)
1. Use existing optimized submission from snapshots as starting point
2. Verify score calculation matches expected
3. Run validation to ensure no overlaps

### Phase 2: Per-N Optimization
Focus on configurations that contribute most to score:
- **Small N (1-20):** Can potentially find optimal/near-optimal solutions with exhaustive search
- **Medium N (20-100):** SA with moderate iterations (n=5000, r=30)
- **Large N (100-200):** SA with high iterations (n=10000, r=60+), multiple restarts

### Phase 3: Advanced Techniques
1. **Asymmetric solutions:** Don't constrain to symmetric patterns
2. **Per-N specialization:** Different strategies for different N ranges
3. **Ensemble:** Combine best configs from multiple runs
4. **Backward propagation:** Use N+1 configs to improve N configs

### Phase 4: Final Polish
1. Apply rotation optimization to all configs
2. Run local search with fine step sizes
3. Validate all configs for overlaps
4. Replace any invalid configs with known-good ones

## External Tools (from kernels)
- `bbox3`: Compiled C++ SA optimizer (fast, use with -n and -r flags)
- `shake_public`: Shaking/compaction binary
- Custom C++ implementations significantly faster than Python

## Code Structure Recommendations

```python
# Core classes
class ChristmasTree:
    def __init__(self, center_x, center_y, angle):
        self.center_x = Decimal(center_x)
        self.center_y = Decimal(center_y)
        self.angle = Decimal(angle)
        self.polygon = self._build_polygon()
    
# Key functions
def has_overlap(trees) -> bool
def get_bounding_box_side(trees) -> float
def calculate_score(all_configs) -> float
def simulated_annealing(trees, n_iter, temp_schedule)
def local_search(trees, step_sizes)
def squeeze(trees, scale_factor)
def backward_propagation(configs)
def fix_direction(trees) -> (trees, angle)
```

## Critical Insights from Research

### Academic Approaches to 2D Irregular Packing:
1. **No-fit polygon (NFP):** Precompute collision-free regions for O(1) overlap checks
2. **Bottom-left heuristic:** Place items at lowest-leftmost valid position
3. **Jostle algorithm:** Local search with swapping between bins
4. **Hybrid approaches:** Combine SA with linear programming or genetic algorithms
5. **Separation vectors:** Use Minimum Translation Vector (MTV) for overlap resolution

### SA Best Practices:
1. Start with high temperature for broad exploration
2. Use adaptive cooling schedules (exponential, logarithmic)
3. Multiple neighborhood operators (translate, rotate, swap)
4. Accept worse solutions early to escape local minima
5. Multiple restarts with different random seeds
6. Focus on boundary-touching trees (they define the bounding box)

### Lattice Patterns Observed:
Top solutions show lattice-like crystallization patterns with:
- Alternating tree orientations (upward/downward)
- Consistent offset patterns between neighbors
- Interlocking arrangements that minimize wasted space

## What NOT to Do
- Don't rely solely on greedy placement (gets stuck in local optima)
- Don't use only symmetric solutions (asymmetric often better)
- Don't ignore rotation optimization (can significantly reduce bounding box)
- Don't skip validation (overlapping trees will cause submission errors)
- Don't optimize all N values equally (focus on high-contribution configs)

## Validation Checklist
Before submission:
1. Check all trees for overlaps using precise collision detection
2. Verify coordinates within bounds (-100 to 100)
3. Calculate local score and compare to expected
4. If overlaps found, replace with known-good configuration

## Score Contribution Analysis
The score formula (side²/n) means:
- Small N contributes more per unit improvement in side length
- Large N has more trees to optimize but lower per-tree contribution
- Focus optimization effort on configs where improvement is most impactful

## Starting Point
Use the best available snapshot submission as baseline, then apply:
1. Rotation optimization (fix_direction)
2. Local search refinement
3. Backward propagation
4. Per-N targeted optimization for high-contribution configs
5. Final validation and overlap repair
