# Santa 2025 - Christmas Tree Packing Challenge Seed Prompt

## Problem Overview
This is a 2D polygon packing optimization problem. The goal is to pack Christmas tree-shaped polygons (1 to 200 trees per configuration) into the smallest possible square bounding box.

**Scoring Formula:** score = Σ(side_n² / n) for n=1 to 200 (lower is better)
**Target Score:** Beat 68.894234

## Tree Shape Specification
The Christmas tree is a 15-vertex polygon with:
- **Trunk:** 0.15 width × 0.2 height (bottom)
- **Three tiers:** base (0.7w), middle (0.4w), top (0.25w)
- **Tip:** at y=0.8
- **Position:** defined by (x, y) at center of trunk top + rotation angle in degrees
- **Total height:** 1.0 (from trunk bottom at -0.2 to tip at 0.8)

## Key Algorithmic Approaches (from kernels and research)

### 1. Simulated Annealing (SA) - Primary Optimization Method
The most successful approach uses SA with:
- **Move operators:** translate (x,y), rotate (angle), swap positions
- **Temperature schedule:** Start high for exploration, cool gradually
- **Acceptance:** Accept worse solutions probabilistically early, become greedy later
- **Multi-start:** Run multiple times with different initial configurations

**Key parameters from kernels:**
- `-n` iterations (1000-10000 typical)
- `-r` restarts (16-256 typical)
- Higher iterations for larger N values

### 2. Local Search Refinements
After SA, apply local search:
- **8-directional moves:** Try small translations in all directions
- **Rotation optimization:** Find optimal global rotation angle using scipy.optimize
- **Step sizes:** Start coarse (0.01), refine to fine (0.0001)

### 3. Squeeze and Compaction
- **Squeeze:** Scale all trees toward center by factor (0.98-0.9995)
- **Compaction:** Move each tree toward center until collision
- **Iterative:** Apply multiple passes until no improvement

### 4. Backward Propagation (Novel Technique)
Use larger configurations to improve smaller ones:
- Start from N=200, work down to N=2
- For each N, try removing boundary-touching trees
- If resulting (N-1) config is better than stored, update it
- This exploits the fact that good N configs often contain good (N-1) configs

### 5. Rotation Tightening (fix_direction)
Optimize the global rotation of the entire configuration:
- Compute convex hull of all tree vertices
- Use scipy.optimize.minimize_scalar to find angle minimizing bounding box
- Apply rotation to all trees (update both positions and angles)

## Implementation Details

### Collision Detection
Use Shapely library with high precision:
- `STRtree` for spatial indexing (fast neighbor queries)
- `intersects()` and `touches()` for overlap detection
- Scale factor (1e15 to 1e18) for numerical precision

### Submission Format
```
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- Values prefixed with 's' to preserve precision
- Coordinates constrained to -100 ≤ x, y ≤ 100

## Recommended Experiment Strategy

### Phase 1: Baseline (Quick)
1. Use existing optimized submission from snapshots as starting point
2. Verify score calculation matches expected

### Phase 2: Per-N Optimization
Focus on configurations that contribute most to score:
- Small N (1-20): Can potentially find optimal/near-optimal solutions
- Medium N (20-100): SA with moderate iterations
- Large N (100-200): SA with high iterations, multiple restarts

### Phase 3: Advanced Techniques
1. **Asymmetric solutions:** Don't constrain to symmetric patterns
2. **Per-N specialization:** Different strategies for different N ranges
3. **Ensemble:** Combine best configs from multiple runs

## External Tools (from kernels)
- `bbox3`: Compiled C++ SA optimizer (fast, use with -n and -r flags)
- `shake_public`: Shaking/compaction binary
- Custom C++ implementations significantly faster than Python

## Code Structure Recommendations

```python
# Core classes
class ChristmasTree:
    # Store position (x, y) and angle
    # Generate polygon on demand
    
# Key functions
def has_overlap(trees) -> bool
def get_bounding_box_side(trees) -> float
def calculate_score(all_configs) -> float
def simulated_annealing(trees, n_iter, temp_schedule)
def local_search(trees, step_sizes)
def squeeze(trees, scale_factor)
def backward_propagation(configs)
```

## Critical Insights from Research

### Academic Approaches to 2D Irregular Packing:
1. **No-fit polygon (NFP):** Precompute collision-free regions for O(1) overlap checks
2. **Bottom-left heuristic:** Place items at lowest-leftmost valid position
3. **Jostle algorithm:** Local search with swapping between bins
4. **Hybrid approaches:** Combine SA with linear programming or genetic algorithms

### SA Best Practices:
1. Start with high temperature for broad exploration
2. Use adaptive cooling schedules (exponential, logarithmic)
3. Multiple neighborhood operators (translate, rotate, swap)
4. Accept worse solutions early to escape local minima
5. Multiple restarts with different random seeds

## What NOT to Do
- Don't rely solely on greedy placement (gets stuck in local optima)
- Don't use only symmetric solutions (asymmetric often better)
- Don't ignore rotation optimization (can significantly reduce bounding box)
- Don't skip validation (overlapping trees will cause submission errors)

## Validation Checklist
Before submission:
1. Check all trees for overlaps using precise collision detection
2. Verify coordinates within bounds (-100 to 100)
3. Calculate local score and compare to expected
4. If overlaps found, replace with known-good configuration

## Starting Point
Use the best available snapshot submission as baseline, then apply:
1. Rotation optimization (fix_direction)
2. Local search refinement
3. Backward propagation
4. Per-N targeted optimization for high-contribution configs
