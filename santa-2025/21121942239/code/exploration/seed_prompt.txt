# Santa 2025 Christmas Tree Packing - Seed Prompt

## Problem Understanding
This is a 2D packing optimization problem where we need to fit Christmas tree toys into the smallest square bounding box for configurations of n=1 to 200 trees.

**Score Formula:** score = Σ(s²/n) for n=1 to 200, where s is the side length of the square bounding box.
**Goal:** MINIMIZE the total score (lower is better).
**Target to beat:** 68.922808

## Tree Geometry
Each tree is a 15-vertex polygon:
- Trunk: 0.15 width × 0.2 height
- Base tier: 0.7 width at y=0
- Middle tier: 0.4 width at y=0.25
- Top tier: 0.25 width at y=0.5
- Tip: at y=0.8
- Total height: ~1.0 units

## CRITICAL: External Datasets for Pre-optimized Solutions

The top kernels use pre-optimized CSV files and compiled bbox3 binaries from Kaggle datasets:

1. **santa-2025-csv** - Contains `santa-2025.csv` (pre-optimized submission) and `bbox3` binary
2. **bucket-of-chump** - Contains optimized `submission.csv`
3. **SmartManoj/Santa-Scoreboard** - GitHub repo with latest optimized submissions

**To download:**
```bash
kaggle datasets download -d <username>/santa-2025-csv
kaggle datasets download -d jazivxt/bucket-of-chump
wget https://raw.githubusercontent.com/SmartManoj/Santa-Scoreboard/main/submission.csv
```

## Key Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (HIGHEST PRIORITY)
**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`, `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

The bbox3 binary is a C++ simulated annealing optimizer with:
- Complex number vector coordination
- Fluid dynamics-based movement
- Hinge pivot rotations
- Density gradient flow
- Global boundary tension
- Overlap repair cycles

**Usage:**
```bash
chmod +x ./bbox3
./bbox3 -n <iterations> -r <restarts>
```
Typical parameters: n=1000-2000, r=30-90 for quick runs; n=5000-10000, r=128-256 for longer optimization.

### 2. Tree Packer C++ (Multi-threaded SA)
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Features:
- Simulated annealing with swap moves
- Multi-angle restarts
- Squeeze operation (scale towards center)
- Compaction (move trees towards center)
- Local search (8-directional moves + rotations)
- Boundary tree focus

**Compile:**
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer.cpp
```

**Run:**
```bash
export OMP_NUM_THREADS=96
./tree_packer -n 5000 -r 16
```

### 3. Backward Propagation
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Key insight: Smaller configurations (N-1) can be derived from larger ones (N) by removing boundary-touching trees.

Algorithm:
1. Start from N=200, work backwards to N=2
2. For each N, identify trees touching the bounding box boundary
3. Try removing each boundary tree and check if resulting (N-1) config is better than current best
4. Continue recursively

**Compile and run:**
```bash
g++ -O3 -std=c++17 -o bp bp.cpp
./bp submission.csv submission.csv
```

### 4. Rotation Optimization (fix_direction)
**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

After placing trees, optimize global rotation angle:
1. Get convex hull of all tree polygon points
2. Use scipy.optimize.minimize_scalar to find optimal rotation angle (0-90°)
3. Apply rotation to minimize bounding box side length

```python
from scipy.optimize import minimize_scalar
res = minimize_scalar(
    lambda a: calculate_bbox_side_at_angle(a, hull_points),
    bounds=(0.001, 89.999), method='bounded'
)
```

### 5. Greedy Tree Placement (Baseline)
**Source:** `../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb`

For building initial configurations:
1. Place first tree at origin
2. For each new tree:
   - Generate random angle weighted by abs(sin(2*angle)) to favor corners
   - Start far from center, move inward until collision
   - Back up until no overlap
3. Use Shapely STRtree for efficient collision detection

## Additional Techniques from Research

### Bottom-Left (BL) Placement Strategy
Classic deterministic approach for 2D packing:
1. Sort pieces by some criteria (height, area)
2. Place each piece at the lowest, leftmost valid position
3. Can be enhanced with No-Fit Polygon (NFP) for arbitrary shapes

### No-Fit Polygon (NFP)
Efficient collision detection for irregular shapes:
- Pre-compute NFP between pairs of shapes
- NFP defines all positions where one shape would overlap another
- Enables O(1) collision checking after precomputation

### Meta-heuristic Frameworks
- **Genetic Algorithms (GA):** Evolve population of solutions with crossover/mutation
- **Simulated Annealing (SA):** Accept worse solutions probabilistically to escape local minima
- **Tabu Search:** Maintain list of forbidden moves to avoid cycling
- **Hybrid GA-SA:** Combine global search (GA) with local refinement (SA)

### Jostle Algorithm
Local search heuristic for irregular packing:
1. Randomly select a piece
2. Move it slightly in a random direction
3. If overlap, push overlapping pieces apart
4. Accept if overall packing improves

## Competition Insights from Discussions

### Symmetric vs Asymmetric Solutions
- **Small N (1-10):** Symmetric solutions may be optimal
- **Large N (50+):** Winning solutions are asymmetric
- Focus optimization on asymmetric arrangements for better packing density

### Key Discussion Points
- "Why the winning solutions will be Asymmetric" - 33 votes
- "Symmetric solutions that are apparently optimal" - 42 votes (for small N)
- "Efficient basin search" - exploring local optima neighborhoods

## Recommended Experiment Strategy

### Experiment 1: Baseline with Pre-optimized CSV (FIRST PRIORITY)
1. Download best available pre-optimized submission from Kaggle datasets or GitHub
2. Apply fix_direction rotation optimization
3. Validate no overlaps
4. Submit to establish baseline score
5. **Expected score: Should match or beat target of 68.922808**

### Experiment 2: Run bbox3 Optimizer
1. Copy bbox3 binary and best submission
2. Run bbox3 with moderate parameters: `-n 2000 -r 60`
3. Apply fix_direction
4. Validate and submit

### Experiment 3: Extended Optimization
1. Run bbox3 with longer parameters: `-n 5000 -r 128`
2. Run backward propagation
3. Apply fix_direction
4. Submit

### Experiment 4: Multi-phase Optimization
1. Phase A: Short runs with multiple (n,r) combinations to find promising settings
2. Phase B: Medium runs on top candidates
3. Phase C: Long runs on best few
4. Apply fix_direction after each phase
5. Keep best submission, revert on regressions

### Experiment 5: Fresh Construction + Optimization
1. Build configurations from scratch using greedy placement
2. Apply C++ optimizer
3. Apply backward propagation
4. Apply fix_direction
5. Compare with pre-optimized baseline

### Experiment 6: Hybrid Approach
1. Use greedy construction for initial placement
2. Apply squeeze + compaction
3. Run SA with swap moves
4. Apply backward propagation
5. Final rotation optimization

## Critical Implementation Details

### Collision Detection
Use Shapely library with STRtree for efficient spatial indexing:
```python
from shapely.strtree import STRtree
tree_index = STRtree(placed_polygons)
possible_indices = tree_index.query(candidate_poly)
```

### Overlap Check
Two polygons overlap if:
1. Bounding boxes overlap AND
2. Any vertex of A is inside B OR any vertex of B is inside A OR any edges intersect

### Submission Format
```
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- Values prefixed with 's' to preserve precision
- Coordinates constrained to -100 ≤ x,y ≤ 100

### Validation
Always validate submissions before submitting:
1. Check for overlaps in all N configurations
2. If overlaps found, replace with donor configuration from baseline
3. Recalculate total score

```python
def score_and_validate_submission(file_path, max_n=200):
    # Load CSV, check overlaps for each N, calculate total score
    # Return {"status": "SUCCESS/FAILED", "total_score": X, "failed_overlap_n": []}
```

## Key Insights
1. **Pre-optimized baselines are near local optima** - Local search may not improve them much
2. **Backward propagation can find improvements** - Smaller configs derived from larger ones
3. **Rotation optimization is cheap and effective** - Always apply fix_direction
4. **C++ is essential for speed** - Python too slow for serious optimization
5. **Multi-restart strategies help escape local optima** - Try different (n,r) combinations
6. **Boundary trees are key** - Focus optimization on trees touching the bounding box
7. **Asymmetric solutions win for large N** - Don't constrain to symmetric arrangements
8. **Squeeze + compaction before SA** - Tighten configuration before fine-tuning
9. **Use external datasets** - Don't start from scratch, use pre-optimized solutions

## Code References
- Getting started notebook: `../research/kernels/inversion_santa-2025-getting-started/`
- bbox3 optimizer: `../research/kernels/jazivxt_why-not/` and `../research/kernels/saspav_santa-submission/`
- Tree packer + backward propagation: `../research/kernels/smartmanoj_santa-claude/`
- Best-keeping runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`

## Warning: Local Search Limitations
If starting from a pre-optimized CSV that's already at a local optimum:
- Simple SA/local search may not improve it
- Need constructive approaches (greedy backtracking, beam search)
- Or try different random initializations
- Backward propagation is one way to escape local optima
