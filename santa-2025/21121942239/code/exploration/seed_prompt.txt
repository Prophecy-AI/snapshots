# Santa 2025 Christmas Tree Packing - Seed Prompt

## Problem Understanding
This is a 2D packing optimization problem where we need to fit Christmas tree toys into the smallest square bounding box for configurations of n=1 to 200 trees.

**Score Formula:** score = Σ(s²/n) for n=1 to 200, where s is the side length of the square bounding box.
**Goal:** MINIMIZE the total score (lower is better).
**Target to beat:** 68.922808

## Tree Geometry
Each tree is a 15-vertex polygon:
- Trunk: 0.15 width × 0.2 height
- Base tier: 0.7 width at y=0
- Middle tier: 0.4 width at y=0.25
- Top tier: 0.25 width at y=0.5
- Tip: at y=0.8
- Total height: ~1.0 units

## Key Approaches from Public Kernels

### 1. bbox3 C++ Optimizer (HIGHEST PRIORITY)
**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`, `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

The bbox3 binary is a C++ simulated annealing optimizer with:
- Complex number vector coordination
- Fluid dynamics-based movement
- Hinge pivot rotations
- Density gradient flow
- Global boundary tension
- Overlap repair cycles

**Usage:**
```bash
./bbox3 -n <iterations> -r <restarts>
```
Typical parameters: n=1000-2000, r=30-90 for quick runs; n=5000-10000, r=128-256 for longer optimization.

### 2. Tree Packer C++ (Multi-threaded SA)
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Features:
- Simulated annealing with swap moves
- Multi-angle restarts
- Squeeze operation (scale towards center)
- Compaction (move trees towards center)
- Local search (8-directional moves + rotations)
- Boundary tree focus

**Compile:**
```bash
g++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer.cpp
```

### 3. Backward Propagation
**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`

Key insight: Smaller configurations (N-1) can be derived from larger ones (N) by removing boundary-touching trees.

Algorithm:
1. Start from N=200, work backwards to N=2
2. For each N, identify trees touching the bounding box boundary
3. Try removing each boundary tree and check if resulting (N-1) config is better than current best
4. Continue recursively

### 4. Rotation Optimization (fix_direction)
**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`

After placing trees, optimize global rotation angle:
1. Get convex hull of all tree polygon points
2. Use scipy.optimize.minimize_scalar to find optimal rotation angle (0-90°)
3. Apply rotation to minimize bounding box side length

```python
from scipy.optimize import minimize_scalar
res = minimize_scalar(
    lambda a: calculate_bbox_side_at_angle(a, hull_points),
    bounds=(0.001, 89.999), method='bounded'
)
```

### 5. Greedy Tree Placement (Baseline)
**Source:** `../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb`

For building initial configurations:
1. Place first tree at origin
2. For each new tree:
   - Generate random angle weighted by abs(sin(2*angle)) to favor corners
   - Start far from center, move inward until collision
   - Back up until no overlap
3. Use Shapely STRtree for efficient collision detection

## Recommended Experiment Strategy

### Experiment 1: Baseline with Pre-optimized CSV
1. Download best available pre-optimized submission from Kaggle datasets
2. Apply fix_direction rotation optimization
3. Validate no overlaps
4. Submit to establish baseline score

### Experiment 2: Run bbox3 Optimizer
1. Copy bbox3 binary and best submission
2. Run bbox3 with moderate parameters: `-n 2000 -r 60`
3. Apply fix_direction
4. Validate and submit

### Experiment 3: Extended Optimization
1. Run bbox3 with longer parameters: `-n 5000 -r 128`
2. Run backward propagation
3. Apply fix_direction
4. Submit

### Experiment 4: Multi-phase Optimization
1. Phase A: Short runs with multiple (n,r) combinations to find promising settings
2. Phase B: Medium runs on top candidates
3. Phase C: Long runs on best few
4. Apply fix_direction after each phase
5. Keep best submission, revert on regressions

### Experiment 5: Fresh Construction + Optimization
1. Build configurations from scratch using greedy placement
2. Apply C++ optimizer
3. Apply backward propagation
4. Apply fix_direction
5. Compare with pre-optimized baseline

## Critical Implementation Details

### Collision Detection
Use Shapely library with STRtree for efficient spatial indexing:
```python
from shapely.strtree import STRtree
tree_index = STRtree(placed_polygons)
possible_indices = tree_index.query(candidate_poly)
```

### Overlap Check
Two polygons overlap if:
1. Bounding boxes overlap AND
2. Any vertex of A is inside B OR any vertex of B is inside A OR any edges intersect

### Submission Format
```
id,x,y,deg
001_0,s0.0,s0.0,s90.0
002_0,s0.0,s0.0,s90.0
002_1,s0.202736,s-0.511271,s90.0
...
```
- Values prefixed with 's' to preserve precision
- Coordinates constrained to -100 ≤ x,y ≤ 100

### Validation
Always validate submissions before submitting:
1. Check for overlaps in all N configurations
2. If overlaps found, replace with donor configuration from baseline
3. Recalculate total score

## External Resources
Many kernels use pre-optimized CSVs from Kaggle datasets:
- `kaggle datasets download` to get best available submissions
- Look for datasets like "santa-2025-csv", "bucket-of-chump"

## Key Insights
1. **Pre-optimized baselines are near local optima** - Local search may not improve them much
2. **Backward propagation can find improvements** - Smaller configs derived from larger ones
3. **Rotation optimization is cheap and effective** - Always apply fix_direction
4. **C++ is essential for speed** - Python too slow for serious optimization
5. **Multi-restart strategies help escape local optima** - Try different (n,r) combinations
6. **Boundary trees are key** - Focus optimization on trees touching the bounding box
