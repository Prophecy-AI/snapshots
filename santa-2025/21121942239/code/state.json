{
  "phase": "executor",
  "loop_count": 1,
  "last_submission": null,
  "competition_id": "santa-2025",
  "seed_prompt": "# Santa 2025 Christmas Tree Packing - Seed Prompt\n\n## Problem Understanding\nThis is a 2D packing optimization problem where we need to fit Christmas tree toys into the smallest square bounding box for configurations of n=1 to 200 trees.\n\n**Score Formula:** score = \u03a3(s\u00b2/n) for n=1 to 200, where s is the side length of the square bounding box.\n**Goal:** MINIMIZE the total score (lower is better).\n**Target to beat:** 68.922808\n\n## Tree Geometry\nEach tree is a 15-vertex polygon:\n- Trunk: 0.15 width \u00d7 0.2 height\n- Base tier: 0.7 width at y=0\n- Middle tier: 0.4 width at y=0.25\n- Top tier: 0.25 width at y=0.5\n- Tip: at y=0.8\n- Total height: ~1.0 units\n\n## CRITICAL: External Datasets for Pre-optimized Solutions\n\nThe top kernels use pre-optimized CSV files and compiled bbox3 binaries from Kaggle datasets:\n\n1. **santa-2025-csv** - Contains `santa-2025.csv` (pre-optimized submission) and `bbox3` binary\n2. **bucket-of-chump** - Contains optimized `submission.csv`\n3. **SmartManoj/Santa-Scoreboard** - GitHub repo with latest optimized submissions\n\n**To download:**\n```bash\nkaggle datasets download -d <username>/santa-2025-csv\nkaggle datasets download -d jazivxt/bucket-of-chump\nwget https://raw.githubusercontent.com/SmartManoj/Santa-Scoreboard/main/submission.csv\n```\n\n## Key Approaches from Public Kernels\n\n### 1. bbox3 C++ Optimizer (HIGHEST PRIORITY)\n**Source:** `../research/kernels/jazivxt_why-not/why-not.ipynb`, `../research/kernels/saspav_santa-submission/santa-submission.ipynb`\n\nThe bbox3 binary is a C++ simulated annealing optimizer with:\n- Complex number vector coordination\n- Fluid dynamics-based movement\n- Hinge pivot rotations\n- Density gradient flow\n- Global boundary tension\n- Overlap repair cycles\n\n**Usage:**\n```bash\nchmod +x ./bbox3\n./bbox3 -n <iterations> -r <restarts>\n```\nTypical parameters: n=1000-2000, r=30-90 for quick runs; n=5000-10000, r=128-256 for longer optimization.\n\n### 2. Tree Packer C++ (Multi-threaded SA)\n**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n\nFeatures:\n- Simulated annealing with swap moves\n- Multi-angle restarts\n- Squeeze operation (scale towards center)\n- Compaction (move trees towards center)\n- Local search (8-directional moves + rotations)\n- Boundary tree focus\n\n**Compile:**\n```bash\ng++ -O3 -march=native -std=c++17 -fopenmp -o tree_packer tree_packer.cpp\n```\n\n**Run:**\n```bash\nexport OMP_NUM_THREADS=96\n./tree_packer -n 5000 -r 16\n```\n\n### 3. Backward Propagation\n**Source:** `../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb`\n\nKey insight: Smaller configurations (N-1) can be derived from larger ones (N) by removing boundary-touching trees.\n\nAlgorithm:\n1. Start from N=200, work backwards to N=2\n2. For each N, identify trees touching the bounding box boundary\n3. Try removing each boundary tree and check if resulting (N-1) config is better than current best\n4. Continue recursively\n\n**Compile and run:**\n```bash\ng++ -O3 -std=c++17 -o bp bp.cpp\n./bp submission.csv submission.csv\n```\n\n### 4. Rotation Optimization (fix_direction)\n**Source:** `../research/kernels/saspav_santa-submission/santa-submission.ipynb`\n\nAfter placing trees, optimize global rotation angle:\n1. Get convex hull of all tree polygon points\n2. Use scipy.optimize.minimize_scalar to find optimal rotation angle (0-90\u00b0)\n3. Apply rotation to minimize bounding box side length\n\n```python\nfrom scipy.optimize import minimize_scalar\nres = minimize_scalar(\n    lambda a: calculate_bbox_side_at_angle(a, hull_points),\n    bounds=(0.001, 89.999), method='bounded'\n)\n```\n\n### 5. Greedy Tree Placement (Baseline)\n**Source:** `../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb`\n\nFor building initial configurations:\n1. Place first tree at origin\n2. For each new tree:\n   - Generate random angle weighted by abs(sin(2*angle)) to favor corners\n   - Start far from center, move inward until collision\n   - Back up until no overlap\n3. Use Shapely STRtree for efficient collision detection\n\n## Additional Techniques from Research\n\n### Bottom-Left (BL) Placement Strategy\nClassic deterministic approach for 2D packing:\n1. Sort pieces by some criteria (height, area)\n2. Place each piece at the lowest, leftmost valid position\n3. Can be enhanced with No-Fit Polygon (NFP) for arbitrary shapes\n\n### No-Fit Polygon (NFP)\nEfficient collision detection for irregular shapes:\n- Pre-compute NFP between pairs of shapes\n- NFP defines all positions where one shape would overlap another\n- Enables O(1) collision checking after precomputation\n\n### Meta-heuristic Frameworks\n- **Genetic Algorithms (GA):** Evolve population of solutions with crossover/mutation\n- **Simulated Annealing (SA):** Accept worse solutions probabilistically to escape local minima\n- **Tabu Search:** Maintain list of forbidden moves to avoid cycling\n- **Hybrid GA-SA:** Combine global search (GA) with local refinement (SA)\n\n### Jostle Algorithm\nLocal search heuristic for irregular packing:\n1. Randomly select a piece\n2. Move it slightly in a random direction\n3. If overlap, push overlapping pieces apart\n4. Accept if overall packing improves\n\n## Competition Insights from Discussions\n\n### Symmetric vs Asymmetric Solutions\n- **Small N (1-10):** Symmetric solutions may be optimal\n- **Large N (50+):** Winning solutions are asymmetric\n- Focus optimization on asymmetric arrangements for better packing density\n\n### Key Discussion Points\n- \"Why the winning solutions will be Asymmetric\" - 33 votes\n- \"Symmetric solutions that are apparently optimal\" - 42 votes (for small N)\n- \"Efficient basin search\" - exploring local optima neighborhoods\n\n## Recommended Experiment Strategy\n\n### Experiment 1: Baseline with Pre-optimized CSV (FIRST PRIORITY)\n1. Download best available pre-optimized submission from Kaggle datasets or GitHub\n2. Apply fix_direction rotation optimization\n3. Validate no overlaps\n4. Submit to establish baseline score\n5. **Expected score: Should match or beat target of 68.922808**\n\n### Experiment 2: Run bbox3 Optimizer\n1. Copy bbox3 binary and best submission\n2. Run bbox3 with moderate parameters: `-n 2000 -r 60`\n3. Apply fix_direction\n4. Validate and submit\n\n### Experiment 3: Extended Optimization\n1. Run bbox3 with longer parameters: `-n 5000 -r 128`\n2. Run backward propagation\n3. Apply fix_direction\n4. Submit\n\n### Experiment 4: Multi-phase Optimization\n1. Phase A: Short runs with multiple (n,r) combinations to find promising settings\n2. Phase B: Medium runs on top candidates\n3. Phase C: Long runs on best few\n4. Apply fix_direction after each phase\n5. Keep best submission, revert on regressions\n\n### Experiment 5: Fresh Construction + Optimization\n1. Build configurations from scratch using greedy placement\n2. Apply C++ optimizer\n3. Apply backward propagation\n4. Apply fix_direction\n5. Compare with pre-optimized baseline\n\n### Experiment 6: Hybrid Approach\n1. Use greedy construction for initial placement\n2. Apply squeeze + compaction\n3. Run SA with swap moves\n4. Apply backward propagation\n5. Final rotation optimization\n\n## Critical Implementation Details\n\n### Collision Detection\nUse Shapely library with STRtree for efficient spatial indexing:\n```python\nfrom shapely.strtree import STRtree\ntree_index = STRtree(placed_polygons)\npossible_indices = tree_index.query(candidate_poly)\n```\n\n### Overlap Check\nTwo polygons overlap if:\n1. Bounding boxes overlap AND\n2. Any vertex of A is inside B OR any vertex of B is inside A OR any edges intersect\n\n### Submission Format\n```\nid,x,y,deg\n001_0,s0.0,s0.0,s90.0\n002_0,s0.0,s0.0,s90.0\n002_1,s0.202736,s-0.511271,s90.0\n...\n```\n- Values prefixed with 's' to preserve precision\n- Coordinates constrained to -100 \u2264 x,y \u2264 100\n\n### Validation\nAlways validate submissions before submitting:\n1. Check for overlaps in all N configurations\n2. If overlaps found, replace with donor configuration from baseline\n3. Recalculate total score\n\n```python\ndef score_and_validate_submission(file_path, max_n=200):\n    # Load CSV, check overlaps for each N, calculate total score\n    # Return {\"status\": \"SUCCESS/FAILED\", \"total_score\": X, \"failed_overlap_n\": []}\n```\n\n## Key Insights\n1. **Pre-optimized baselines are near local optima** - Local search may not improve them much\n2. **Backward propagation can find improvements** - Smaller configs derived from larger ones\n3. **Rotation optimization is cheap and effective** - Always apply fix_direction\n4. **C++ is essential for speed** - Python too slow for serious optimization\n5. **Multi-restart strategies help escape local optima** - Try different (n,r) combinations\n6. **Boundary trees are key** - Focus optimization on trees touching the bounding box\n7. **Asymmetric solutions win for large N** - Don't constrain to symmetric arrangements\n8. **Squeeze + compaction before SA** - Tighten configuration before fine-tuning\n9. **Use external datasets** - Don't start from scratch, use pre-optimized solutions\n\n## Code References\n- Getting started notebook: `../research/kernels/inversion_santa-2025-getting-started/`\n- bbox3 optimizer: `../research/kernels/jazivxt_why-not/` and `../research/kernels/saspav_santa-submission/`\n- Tree packer + backward propagation: `../research/kernels/smartmanoj_santa-claude/`\n- Best-keeping runner: `../research/kernels/yongsukprasertsuk_santa-2025-best-keeping-bbox3-runner/`\n\n## Warning: Local Search Limitations\nIf starting from a pre-optimized CSV that's already at a local optimum:\n- Simple SA/local search may not improve it\n- Need constructive approaches (greedy backtracking, beam search)\n- Or try different random initializations\n- Backward propagation is one way to escape local optima\n",
  "evaluator_feedback": "",
  "latest_experiment": {},
  "competitive_intel": "## Available Competitive Intelligence\n\n- Competition description: `../research/description.md`\n- 5 top kernel notebooks in `../research/kernels/`",
  "target_score": 68.922808051418,
  "manual_instructions": "",
  "messages": [],
  "experiments": [],
  "submissions": [],
  "candidates": [],
  "findings": [],
  "metric_lower_is_better": false,
  "strategy_history": [],
  "feedback_history": [],
  "data_findings": [
    {
      "finding": "This is a 2D packing optimization problem: fit Christmas tree toys into smallest square bounding box for n=1 to 200 trees. Score = sum(s\u00b2/n) where s is side length. Lower score is better.",
      "source": "../research/description.md",
      "agent": "explorer"
    },
    {
      "finding": "Key approach: bbox3 C++ optimizer using simulated annealing with complex number vector coordination, fluid dynamics, hinge pivot, density gradient flow, and global boundary tension. Runs for hours to optimize.",
      "source": "../research/kernels/jazivxt_why-not/why-not.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Rotation optimization: After placing trees, optimize the global rotation angle to minimize bounding box using scipy.optimize.minimize_scalar on convex hull points.",
      "source": "../research/kernels/saspav_santa-submission/santa-submission.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Greedy tree placement: Start from center, place trees at random weighted angles (weighted by abs(sin(2*angle)) to fill corners), move inward until collision, back up until no overlap.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Backward propagation technique: Start from N=200 and work backwards. For each N, try removing boundary-touching trees to see if smaller configurations can be improved. This exploits the fact that N-1 trees can be derived from N trees.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "C++ optimizer features: Simulated annealing with swap moves, multi-angle restarts, squeeze (scale towards center), compaction (move towards center), local search (8-directional moves + rotations), boundary tree focus.",
      "source": "../research/kernels/smartmanoj_santa-claude/santa-claude.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Tree geometry: 15-vertex polygon with trunk (0.15w x 0.2h), base tier (0.7w), middle tier (0.4w), top tier (0.25w), tip at y=0.8. Total height ~1.0 units.",
      "source": "../research/kernels/inversion_santa-2025-getting-started/santa-2025-getting-started.ipynb",
      "agent": "explorer"
    },
    {
      "finding": "Key 2D packing algorithms: Bottom-left (BL) placement strategy, No-fit polygon (NFP) generation for collision detection, meta-heuristics (GA, SA, tabu search), shelf packing algorithms. Learning-based approaches emerging for faster placement.",
      "source": "WebSearch: 2D irregular polygon packing",
      "agent": "explorer"
    },
    {
      "finding": "Discussion insight: Symmetric solutions may be optimal for small N, but winning solutions for larger N are asymmetric. Focus on asymmetric arrangements for better packing.",
      "source": "Competition discussions",
      "agent": "explorer"
    }
  ],
  "web_research": [
    {
      "query": "What are the best algorithms for 2D irregular polygon packing optimization?",
      "finding": "Two\u2011dimensional irregular polygon packing is a classic combinatorial optimisation problem that appears in sheet\u2011metal cutting, textile layout, 3D\u2011texture atlas generation and many other manufacturing settings.  Because the feasible region is highly non\u2011convex and the pieces may be rotated arbitrarily, exact methods quickly become impractical for realistic instance sizes, so the state\u2011of\u2011the\u2011art relies on a mix of sophisticated heuristics, meta\u2011heuristics and provable approximation schemes.  A common deterministic backbone is the **bottom\u2011left (BL) placement strategy** combined with shelf\u2011 or strip\u2011packing ideas; this simple rule can be enhanced with **no\u2011fit polygon (NFP) generation** to handle arbitrary shapes and orientations efficiently\u202f([Frontiers](https://www.frontiersin.org/articles/10.3389/fmech.2022.966691/full);\u202f[Handbook chapter](https://www.taylorfrancis.com/chapters/edit/10.1201/9781351236423-33/practical-algorithms-two-dimensional-packing-general-shapes-yannan-hu-hideki-ha",
      "agent": "explorer"
    }
  ],
  "remaining_submissions": 100,
  "max_submissions": 100,
  "last_reset_date_utc": "2026-01-19",
  "start_time": "2026-01-19T01:21:48.092170",
  "time_limit_minutes": 2100,
  "_saved_at": "2026-01-19T01:36:08.958796"
}