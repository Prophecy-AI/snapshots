{
  "spans": [
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "02a6402458aeedd6",
      "parent_span_id": "4df94b9b0f13c589",
      "name": "ListFilesTool",
      "kind": "INTERNAL",
      "start_time": 1767939673992943499,
      "end_time": 1767939673993311687,
      "duration": 0.000368188,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "ListFilesTool",
        "cascade.agent_name": "ExplorerAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.file_tools.ListFilesTool object at 0x738bd1a8a590>\", \"input\": {\"directory_path\": \"/home/data\"}}",
        "tool.output": "{\"content\": \"/home/data:\\n[FILE] description.md (7.0KB)\\n[FILE] sampleSubmission.csv (13.0KB)\\n[FILE] test.json (2.0MB)\\n[FILE] test.zip (433.1KB)\\n[FILE] train.json (8.4MB)\\n[FILE] train.zip (1.3MB)\", \"is_error\": false}",
        "tool.duration_ms": 0.4742145538330078
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "6654cbd5d12edd1d",
      "parent_span_id": "4df94b9b0f13c589",
      "name": "ReadTool",
      "kind": "INTERNAL",
      "start_time": 1767939682474727115,
      "end_time": 1767939682475095498,
      "duration": 0.000368383,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "ReadTool",
        "cascade.agent_name": "ExplorerAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.file_tools.ReadTool object at 0x738bd1a8a490>\", \"input\": {\"file_path\": \"/home/data/description.md\"}}",
        "tool.output": "{\"content\": \"# Overview\\n\\n## Description\\n\\n[Get started on this competition through Kaggle Scripts](https://www.kaggle.com/c/random-acts-of-pizza/forums/t/14286/kaggle-scripts-enabled-on-random-acts-of-pizza)\\n\\nIn machine learning, it is often said there are [no free lunches](http://en.wikipedia.org/wiki/No_free_lunch_theorem). *How wrong we were.*\\n\\nThis competition contains a dataset with 5671 textual requests for pizza from the Reddit community [Random Acts of Pizza](http://www.reddit.com/r/Random_Acts_Of_Pizza/) together with their outcome (successful/unsuccessful) and meta-data. Participants must create an algorithm capable of predicting which requests will garner a cheesy (but sincere!) act of kindness.\\n\\n\\\"I'll write a poem, sing a song, do a dance, play an instrument, whatever! I just want a pizza,\\\" says one hopeful poster. What about making an algorithm?\\n\\n![Pizzas](https://storage.googleapis.com/kaggle-media/competitions/kaggle/3949/media/pizzas.png)\\n\\nKaggle is hosting this competition for the machine learning community to use for fun and practice. This [data](http://cs.stanford.edu/~althoff/raop-dataset/) was collected and graciously shared by [Althoff](http://www.timalthoff.com/) et al. (Buy them a pizza -- data collection is a thankless and tedious job!) We encourage participants to explore their [accompanying paper](http://cs.stanford.edu/~althoff/raop-dataset/altruistic_requests_icwsm.pdf) and ask that you cite the following reference in any publications that result from your work:\\n\\nTim Althoff, Cristian Danescu-Niculescu-Mizil, Dan Jurafsky. *How to Ask for a Favor: A Case Study on the Success of Altruistic Requests*, Proceedings of ICWSM, 2014.\\n\\n~*Pizza icons designed by Matthew Dera from the [Noun Project](http://thenounproject.com/term/pizza/30194/)*~\\n\\n### Evaluation\\n\\nSubmissions are evaluated on [area under the ROC curve](http://en.wikipedia.org/wiki/Receiver_operating_characteristic) between the predicted probability that a request will get pizza and the observed outcomes.\\n\\n### Submission File\\n\\nFor each request in the test set, you should predict a real-valued probability that it resulted in a pizza. The file should contain a header and have the following format:\\n\\n```\\nrequest_id,requester_received_pizza\\nt3_i8iy4,0\\nt3_1mfqi0,0\\nt3_lclka,0\\n...\\n...\\n```\\n\\n### Citation\\n\\nWill Cukierski. (2014). Random Acts of Pizza. Kaggle. https://kaggle.com/competitions/random-acts-of-pizza\\n\\n\\n# Data\\n\\n## Dataset Description\\n\\n[See, fork, and run a random forest benchmark model through Kaggle Scripts](https://www.kaggle.com/users/993/ben-hamner/random-acts-of-pizza/simple-julia-benchmark)\\n\\nThis dataset includes 5671 requests collected from the Reddit community [Random Acts of Pizza](http://www.reddit.com/r/Random_Acts_Of_Pizza/) between December 8, 2010 and September 29, 2013 (retrieved on September 30, 2013). All requests ask for the same thing: a free pizza. The outcome of each request -- whether its author received a pizza or not -- is known. Meta-data includes information such as: time of the request, activity of the requester, community-age of the requester, etc.\\n\\nEach JSON entry corresponds to one request (the first and only request by the requester on Random Acts of Pizza). We have removed fields from the test set which would not be available at the time of posting.\\n\\n## Data fields\\n\\n\\\"giver_username_if_known\\\": Reddit username of giver if known, i.e. the person satisfying the request (\\\"N/A\\\" otherwise).\\n\\n\\\"number_of_downvotes_of_request_at_retrieval\\\": Number of downvotes at the time the request was collected.\\n\\n\\\"number_of_upvotes_of_request_at_retrieval\\\": Number of upvotes at the time the request was collected.\\n\\n\\\"post_was_edited\\\": Boolean indicating whether this post was edited (from Reddit).\\n\\n\\\"request_id\\\": Identifier of the post on Reddit, e.g. \\\"t3_w5491\\\".\\n\\n\\\"request_number_of_comments_at_retrieval\\\": Number of comments for the request at time of retrieval.\\n\\n\\\"request_text\\\": Full text of the request.\\n\\n\\\"request_text_edit_aware\\\": Edit aware version of \\\"request_text\\\". We use a set of rules to strip edited comments indicating the success of the request such as \\\"EDIT: Thanks /u/foo, the pizza was delicous\\\".\\n\\n\\\"request_title\\\": Title of the request.\\n\\n\\\"requester_account_age_in_days_at_request\\\": Account age of requester in days at time of request.\\n\\n\\\"requester_account_age_in_days_at_retrieval\\\": Account age of requester in days at time of retrieval.\\n\\n\\\"requester_days_since_first_post_on_raop_at_request\\\": Number of days between requesters first post on RAOP and this request (zero if requester has never posted before on RAOP).\\n\\n\\\"requester_days_since_first_post_on_raop_at_retrieval\\\": Number of days between requesters first post on RAOP and time of retrieval.\\n\\n\\\"requester_number_of_comments_at_request\\\": Total number of comments on Reddit by requester at time of request.\\n\\n\\\"requester_number_of_comments_at_retrieval\\\": Total number of comments on Reddit by requester at time of retrieval.\\n\\n\\\"requester_number_of_comments_in_raop_at_request\\\": Total number of comments in RAOP by requester at time of request.\\n\\n\\\"requester_number_of_comments_in_raop_at_retrieval\\\": Total number of comments in RAOP by requester at time of retrieval.\\n\\n\\\"requester_number_of_posts_at_request\\\": Total number of posts on Reddit by requester at time of request.\\n\\n\\\"requester_number_of_posts_at_retrieval\\\": Total number of posts on Reddit by requester at time of retrieval.\\n\\n\\\"requester_number_of_posts_on_raop_at_request\\\": Total number of posts in RAOP by requester at time of request.\\n\\n\\\"requester_number_of_posts_on_raop_at_retrieval\\\": Total number of posts in RAOP by requester at time of retrieval.\\n\\n\\\"requester_number_of_subreddits_at_request\\\": The number of subreddits in which the author had already posted in at the time of request.\\n\\n\\\"requester_received_pizza\\\": Boolean indicating the success of the request, i.e., whether the requester received pizza.\\n\\n\\\"requester_subreddits_at_request\\\": The list of subreddits in which the author had already posted in at the time of request.\\n\\n\\\"requester_upvotes_minus_downvotes_at_request\\\": Difference of total upvotes and total downvotes of requester at time of request.\\n\\n\\\"requester_upvotes_minus_downvotes_at_retrieval\\\": Difference of total upvotes and total downvotes of requester at time of retrieval.\\n\\n\\\"requester_upvotes_plus_downvotes_at_request\\\": Sum of total upvotes and total downvotes of requester at time of request.\\n\\n\\\"requester_upvotes_plus_downvotes_at_retrieval\\\": Sum of total upvotes and total downvotes of requester at time of retrieval.\\n\\n\\\"requester_user_flair\\\": Users on RAOP receive badges (Reddit calls them flairs) which is a small picture next to their username. In our data set the user flair is either None (neither given nor received pizza, N=4282), \\\"shroom\\\" (received pizza, but not given, N=1306), or \\\"PIF\\\" (pizza given after having received, N=83).\\n\\n\\\"requester_username\\\": Reddit username of requester.\\n\\n\\\"unix_timestamp_of_request\\\": Unix timestamp of request (supposedly in timezone of user, but in most cases it is equal to the UTC timestamp -- which is incorrect since most RAOP users are from the USA).\\n\\n\\\"unix_timestamp_of_request_utc\\\": Unit timestamp of request in UTC.\", \"is_error\": false}",
        "tool.duration_ms": 0.3952980041503906
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "095c5b20ae91d9ba",
      "parent_span_id": "4df94b9b0f13c589",
      "name": "CreateNotebookTool",
      "kind": "INTERNAL",
      "start_time": 1767939693931716164,
      "end_time": 1767939695074433533,
      "duration": 1.142717369,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "CreateNotebookTool",
        "cascade.agent_name": "ExplorerAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.notebook.CreateNotebookTool object at 0x738bd1a8a7d0>\", \"input\": {\"notebook_path\": \"eda.ipynb\", \"cells\": [{\"cell_type\": \"code\", \"content\": \"import pandas as pd\\nimport numpy as np\\nimport json\\n\\n# Load the training data\\ntrain_path = \\\"/home/data/train.json\\\"\\n\\n# Read the JSON file\\nwith open(train_path, 'r') as f:\\n    train_data = json.load(f)\\n\\nprint(f\\\"Number of training samples: {len(train_data)}\\\")\\nprint(f\\\"Type of data: {type(train_data)}\\\")\\nprint(f\\\"First sample keys: {list(train_data[0].keys())}\\\")\"}]}}",
        "tool.output": "{\"content\": \"Created: /home/code/exploration/eda.ipynb\\n\\nStrong Note: OOM is unrecoverable. Use strong models - just estimate memory first.\", \"is_error\": false}",
        "tool.duration_ms": 1142.7264213562012
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "bfdf6866913d20a8",
      "parent_span_id": "4df94b9b0f13c589",
      "name": "ExecuteCellRangeTool",
      "kind": "INTERNAL",
      "start_time": 1767939705111198114,
      "end_time": 1767939705670197351,
      "duration": 0.558999237,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "ExecuteCellRangeTool",
        "cascade.agent_name": "ExplorerAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.notebook.ExecuteCellRangeTool object at 0x738bf6c14150>\", \"input\": {\"start_cell\": 0, \"duration\": 30}}",
        "tool.output": "{\"content\": \"Executed cells 0-0\\n==================================================\\n\\nCell 0:\\n```\\nimport pandas as pd\\nimport numpy as np\\nimport json\\n\\n# Load the training data\\ntrain_path = \\\"/home/data/train.json\\\"\\n\\n# Read the JSON file\\nwith open(train_path, 'r') as f:\\n    train_data = json.load(f)\\n\\nprint(f\\\"Number of training samples: {len(train_data)}\\\")\\nprint(f\\\"Type of data: {type(train_data)}\\\")\\nprint(f\\\"First sample keys: {list(train_data[0].keys())}\\\")\\n```\\nOutput:\\nNumber of training samples: 2878\\nType of data: <class 'list'>\\nFirst sample keys: ['giver_username_if_known', 'number_of_downvotes_of_request_at_retrieval', 'number_of_upvotes_of_request_at_retrieval', 'post_was_edited', 'request_id', 'request_number_of_comments_at_retrieval', 'request_text', 'request_text_edit_aware', 'request_title', 'requester_account_age_in_days_at_request', 'requester_account_age_in_days_at_retrieval', 'requester_days_since_first_post_on_raop_at_request', 'requester_days_since_first_post_on_raop_at_retrieval', 'requester_number_of_comments_at_request', 'requester_number_of_comments_at_retrieval', 'requester_number_of_comments_in_raop_at_request', 'requester_number_of_comments_in_raop_at_retrieval', 'requester_number_of_posts_at_request', 'requester_number_of_posts_at_retrieval', 'requester_number_of_posts_on_raop_at_request', 'requester_number_of_posts_on_raop_at_retrieval', 'requester_number_of_subreddits_at_request', 'requester_received_pizza', 'requester_subreddits_at_request', 'requester_upvotes_minus_downvotes_at_request', 'requester_upvotes_minus_downvotes_at_retrieval', 'requester_upvotes_plus_downvotes_at_request', 'requester_upvotes_plus_downvotes_at_retrieval', 'requester_user_flair', 'requester_username', 'unix_timestamp_of_request', 'unix_timestamp_of_request_utc']\\n\", \"is_error\": false}",
        "tool.duration_ms": 559.065580368042
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "39fea410e09cf672",
      "parent_span_id": "4df94b9b0f13c589",
      "name": "AddNotebookCellTool",
      "kind": "INTERNAL",
      "start_time": 1767939724870230613,
      "end_time": 1767939724872244971,
      "duration": 0.002014358,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "AddNotebookCellTool",
        "cascade.agent_name": "ExplorerAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.notebook.AddNotebookCellTool object at 0x738bd1df65d0>\", \"input\": {\"cell_type\": \"code\", \"content\": \"# Convert to DataFrame for easier analysis\\ndf = pd.DataFrame(train_data)\\n\\n# Check target distribution\\nprint(\\\"Target distribution:\\\")\\nprint(df['requester_received_pizza'].value_counts())\\nprint(f\\\"\\\\nPercentage with pizza: {df['requester_received_pizza'].mean():.3f}\\\")\\n\\n# Check missing values\\nprint(f\\\"\\\\nMissing values:\\\")\\nprint(df.isnull().sum().head(10))\\n\\n# Check data types\\nprint(f\\\"\\\\nData types:\\\")\\nprint(df.dtypes.head(15))\"}}",
        "tool.output": "{\"content\": \"Added code cell at 1\", \"is_error\": false}",
        "tool.duration_ms": 2.1209716796875
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "b4c26e7ebf3d1641",
      "parent_span_id": "4df94b9b0f13c589",
      "name": "ExecuteCellRangeTool",
      "kind": "INTERNAL",
      "start_time": 1767939734042703654,
      "end_time": 1767939734149294435,
      "duration": 0.106590781,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "ExecuteCellRangeTool",
        "cascade.agent_name": "ExplorerAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.notebook.ExecuteCellRangeTool object at 0x738bf6c14150>\", \"input\": {\"start_cell\": 1, \"duration\": 30}}",
        "tool.output": "{\"content\": \"Executed cells 1-1\\n==================================================\\n\\nCell 1:\\n```\\n# Convert to DataFrame for easier analysis\\ndf = pd.DataFrame(train_data)\\n\\n# Check target distribution\\nprint(\\\"Target distribution:\\\")\\nprint(df['requester_received_pizza'].value_counts())\\nprint(f\\\"\\\\nPercentage with pizza: {df['requester_received_pizza'].mean():.3f}\\\")\\n\\n# Check missing values\\nprint(f\\\"\\\\nMissing values:\\\")\\nprint(df.isnull().sum().head(10))\\n\\n# Check data types\\nprint(f\\\"\\\\nData types:\\\")\\nprint(df.dtypes.head(15))\\n```\\nOutput:\\nTarget distribution:\\nrequester_received_pizza\\nFalse    2163\\nTrue      715\\nName: count, dtype: int64\\n\\nPercentage with pizza: 0.248\\n\\nMissing values:\\ngiver_username_if_known                        0\\nnumber_of_downvotes_of_request_at_retrieval    0\\nnumber_of_upvotes_of_request_at_retrieval      0\\npost_was_edited                                0\\nrequest_id                                     0\\nrequest_number_of_comments_at_retrieval        0\\nrequest_text                                   0\\nrequest_text_edit_aware                        0\\nrequest_title                                  0\\nrequester_account_age_in_days_at_request       0\\ndtype: int64\\n\\nData types:\\ngiver_username_if_known                                  object\\nnumber_of_downvotes_of_request_at_retrieval               int64\\nnumber_of_upvotes_of_request_at_retrieval                 int64\\npost_was_edited                                          object\\nrequest_id                                               object\\nrequest_number_of_comments_at_retrieval                   int64\\nrequest_text                                             object\\nrequest_text_edit_aware                                  object\\nrequest_title                                            object\\nrequester_account_age_in_days_at_request                float64\\nrequester_account_age_in_days_at_retrieval              float64\\nrequester_days_since_first_post_on_raop_at_request      float64\\nrequester_days_since_first_post_on_raop_at_retrieval    float64\\nrequester_number_of_comments_at_request                   int64\\nrequester_number_of_comments_at_retrieval                 int64\\ndtype: object\\n\", \"is_error\": false}",
        "tool.duration_ms": 106.66775703430176
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "d6fc3748f51a954d",
      "parent_span_id": "4df94b9b0f13c589",
      "name": "AddNotebookCellTool",
      "kind": "INTERNAL",
      "start_time": 1767939755469924107,
      "end_time": 1767939755471993885,
      "duration": 0.002069778,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "AddNotebookCellTool",
        "cascade.agent_name": "ExplorerAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.notebook.AddNotebookCellTool object at 0x738bd1df65d0>\", \"input\": {\"cell_type\": \"code\", \"content\": \"# Explore text features\\nprint(\\\"Sample request title:\\\")\\nprint(df['request_title'].iloc[0][:200])\\nprint(\\\"\\\\n\\\" + \\\"=\\\"*50)\\n\\nprint(\\\"Sample request text:\\\")\\nprint(df['request_text'].iloc[0][:300])\\nprint(\\\"\\\\n\\\" + \\\"=\\\"*50)\\n\\n# Text length statistics\\nprint(\\\"Text length statistics:\\\")\\ndf['title_length'] = df['request_title'].str.len()\\ndf['text_length'] = df['request_text'].str.len()\\n\\nprint(f\\\"Title length - Mean: {df['title_length'].mean():.1f}, Max: {df['title_length'].max()}\\\")\\nprint(f\\\"Text length - Mean: {df['text_length'].mean():.1f}, Max: {df['text_length'].max()}\\\")\\n\\n# Check some key numerical features\\nprint(\\\"\\\\n\\\" + \\\"=\\\"*50)\\nprint(\\\"Key numerical features correlation with target:\\\")\\nnumerical_features = ['number_of_upvotes_of_request_at_retrieval', \\n                      'request_number_of_comments_at_retrieval',\\n                      'requester_account_age_in_days_at_request',\\n                      'requester_number_of_comments_at_request']\\n\\nfor feature in numerical_features:\\n    corr = df[feature].corr(df['requester_received_pizza'])\\n    print(f\\\"{feature}: {corr:.3f}\\\")\"}}",
        "tool.output": "{\"content\": \"Added code cell at 2\", \"is_error\": false}",
        "tool.duration_ms": 2.1409988403320312
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "ef45c662a4218141",
      "parent_span_id": "4df94b9b0f13c589",
      "name": "ExecuteCellRangeTool",
      "kind": "INTERNAL",
      "start_time": 1767939765500734637,
      "end_time": 1767939765528417474,
      "duration": 0.027682837,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "ExecuteCellRangeTool",
        "cascade.agent_name": "ExplorerAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.notebook.ExecuteCellRangeTool object at 0x738bf6c14150>\", \"input\": {\"start_cell\": 2, \"duration\": 30}}",
        "tool.output": "{\"content\": \"Executed cells 2-2\\n==================================================\\n\\nCell 2:\\n```\\n# Explore text features\\nprint(\\\"Sample request title:\\\")\\nprint(df['request_title'].iloc[0][:200])\\nprint(\\\"\\\\n\\\" + \\\"=\\\"*50)\\n\\nprint(\\\"Sample request text:\\\")\\nprint(df['request_text'].iloc[0][:300])\\nprint(\\\"\\\\n\\\" + \\\"=\\\"*50)\\n\\n# Text length statistics\\nprint(\\\"Text length statistics:\\\")\\ndf['title_length'] = df['request_title'].str.len()\\ndf['text_length'] = df['request_text'].str.len()\\n\\nprint(f\\\"Title length - Mean: {df['title_length'].mean():.1f}, Max: {df['title_length'].max()}\\\")\\nprint(f\\\"Text length - Mean: {df['te\\n```\\nOutput:\\nSample request title:\\n[REQUEST] Oceanside, Ca. USA-  US Marine getting ready to deploy.\\n\\n==================================================\\nSample request text:\\nI will soon be going on a long deployment which I'm not aloud to discuss but willing to give some info if you ask. Just wanna eat some of the stuff America has to offer before I leave for a long time to Afganistan.\\n\\n==================================================\\nText length statistics:\\nTitle length - Mean: 71.6, Max: 272\\nText length - Mean: 402.5, Max: 4460\\n\\n==================================================\\nKey numerical features correlation with target:\\nnumber_of_upvotes_of_request_at_retrieval: 0.091\\nrequest_number_of_comments_at_retrieval: 0.291\\nrequester_account_age_in_days_at_request: 0.043\\nrequester_number_of_comments_at_request: 0.037\\n\", \"is_error\": false}",
        "tool.duration_ms": 27.768850326538086
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "54d31968a6dd5a0b",
      "parent_span_id": "4df94b9b0f13c589",
      "name": "WebSearchTool",
      "kind": "INTERNAL",
      "start_time": 1767939778909670514,
      "end_time": 1767939786706437273,
      "duration": 7.796766759,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "WebSearchTool",
        "cascade.agent_name": "ExplorerAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.research.WebSearchTool object at 0x738bf6c14210>\", \"input\": {\"query\": \"What are winning approaches for text classification with metadata features on Kaggle competitions?\"}}",
        "tool.output": "{\"content\": \"SEARCH RESULTS (9 found)\\n==================================================\\n\\n--- Result 1 ---\\nTitle: ANSWER\\n\\nContent:\\nWinning Kaggle solutions for text classification that also have metadata usually treat the non‑text fields as first‑class inputs rather than an after‑thought.  A common recipe is to **encode the text with a pre‑trained transformer** (e.g., BERT, RoBERTa) and **encode each metadata column separately** – categorical variables with embedding layers, numeric variables with scaling or bucketisation – then concatenate all vectors before the final classification head.  This “dual‑tower” design lets the model learn interactions between language and auxiliary signals while keeping each modality in a suitable representation space ([FreeAgent blog](https://engineering.freeagent.com/2024/05/17/combining-text-with-numerical-and-categorical-features-for-classification)).  \\n\\nA simpler but surprisingly effective trick is to **inject metadata directly into the transformer’s token stream**.  By joining the raw fields with a special separator token (e.g., `[SEP]`) the model sees the amount, category, timestamp, etc., as part of the same sequence, which often yields a quick performance bump and works well when the metadata can be expressed as short text ([FreeAgent blog](https://engineering.freeagent.com/2024/05/17/combining-text-with-numerical-and-categorical-features-for-classification)).  More sophisticated pipelines build **dedicated neural blocks for each metadata type** (image, audio, timestamps, sender IDs) and train them jointly with the text encoder, allowing cross‑modal attention and richer feature fusion; the authors of the MESSAGENET paper report consistent gains over plain‑text baselines ([arXiv 2301.01808](https://export.arxiv.org/pdf/2301.01808v1.pdf)).  \\n\\nBeyond architecture, top teams also exploit **metadata‑driven weak supervision**.  The META framework treats metadata (author, venue, time) as a source of noisy label cues, constructs a text‑rich graph, extracts high‑confidence “seed motifs”, and bootstraps a classifier that iteratively expands both seed words and motifs.  This approach has shown superior accuracy on real‑world datasets where metadata carries strong label signals ([EMNLP 2020 META](https://aclanthology.org/2020.emnlp-main.670.pdf)).  In practice, winning solutions combine these ideas with classic Kaggle tricks—large‑scale pre‑training, careful cross‑validation, and ensembling transformer‑based models with gradient‑boosted trees that consume the raw metadata features ([Neptune tips](https://neptune.ai/blog/text-classification-tips-and-tricks-kaggle-competitions)).  Together, these strategies turn metadata from a peripheral attribute into a powerful driver of classification performance.\\n\\n--- Result 2 ---\\nTitle: Text Classification: All Tips and Tricks from 5 Kaggle Competitions\\nURL: https://neptune.ai/blog/text-classification-tips-and-tricks-kaggle-competitions\\n\\nContent:\\nIn this article, I will discuss some great tips and tricks to [improve the performance](https://neptune.ai/blog/improving-machine-learning-deep-learning-models) of your text classification model. These tricks are obtained from solutions of some of Kaggle’s top NLP competitions.\\n\\nNamely, I’ve gone through:\\n\\n- [Jigsaw Unintended Bias in Toxicity Classification](https://www.kaggle.com/c/jigsaw-unintended-bias-in-toxicity-classification) – $65,000\\n- [Toxic Comment Classification Challenge](https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/) – $35,000\\n- [Quora Insincere Questions Classification](http://kaggle.com/c/quora-insincere-questions-classification) – $25,000\\n- [Google QUEST Q&A Labeling](https://www.kaggle.com/c/google-quest-challenge) – $25,000\\n- [TensorFlow 2.0 Question Answering](https://www.kaggle.com/c/tensorflow2-question-answering) – $50,000\\n\\nand found a ton of great ideas.\\n\\nWithout much lag, let’s begin.\\n\\n## Dealing with larger datasets\\n\\nOne issue you might face in any machine learning competition is the size of your data set. If the size of your data is large, that is 3GB + for Kaggle kernels and more basic laptops you could find it difficult to load and process with limited resources. Here is the link to some of the articles and kernels that I have found useful in such situations.\\n\\n- Optimize the memory by [reducing the size of some attributes](https://www.kaggle.com/shrutimechlearn/large-data-loading-trick-with-ms-malware-data)\\n- Use open-source libraries such as [Dask to read and manipulate the data](https://www.kaggle.com/yuliagm/how-to-work-with-big-datasets-on-16g-ram-dask), it performs parallel computing and saves up memory space\\n- Use [cudf](https://github.com/rapidsai/cudf)\\n- Convert data to [parquet](https://arrow.apache.org/docs/python/parquet.html) format\\n- Convert data to [feather](https://medium.com/@snehotosh.banerjee/feather-a-fast-on-disk-format-for-r-and-python-data-frames-de33d0516b03) format\\n\\n## Small datasets and external data\\n\\nBut, what can one do if the dataset is small? Let’s see some techniques to tackle this situation.\\n\\nOne way to increase the performance of any machine learning model is to use some external data frame that contains some variables that influence the predicate variable.\\n\\nLet’s see some of the external datasets.\\n\\n- Use of [squad](https://rajpurkar.github.io/SQuAD-explorer/) data for Question Answering tasks\\n- Other [datasets](http://nlpprogress.com/english/question_answering.html) for QA tasks\\n- Wikitext long term dependency language modeling [dataset](https://www.salesforce.com/products/einstein/ai-research/the-wikitext-dependency-language-modeling-dataset/)\\n- [Stackexchange data](https://archive.org/download/stackexchange)\\n- Prepare a dictionary of commonly misspelled words and corrected words.\\n- Use of [helper datasets](https://www.kaggle.com/kyakovlev/jigsaw-general-helper-public) for cleaning\\n- [Pseudo labeling](https://www.kaggle.com/cdeotte/pseudo-labeling-qda-0-969/) is the process of adding confidently predicted test data to your training data\\n- Use different data [sampling methods](https://www.kaggle.com/shahules/tackling-class-imbalance)\\n- Text augmentation by [Exchanging words with synonym](https://arxiv.org/pdf/1502.01710.pdf) [s](https://arxiv.org/pdf/1502.01710.pdf)\\n- Text augmentation by [noising in RNN](https://arxiv.org/pdf/1703.02573.pdf)\\n- Text augmentation by [translation to other languages and back](https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/48038)\\n\\n## Data exploration and gaining insights\\n\\nData exploration always helps to better understand the data and gain insights from it. Before starting to develop machine learning models, top competitors always read/do a lot of exploratory data analysis for the data. This helps in feature engineering and cleaning of the data.\\n\\n- Twitter data [exploration methods](https://www.kaggle.com/jagangupta/stop-the-s-toxic-comments-eda)\\n- Simple [EDA for tweets](https://www.kaggle.com/nz0722/simple-eda-text-preprocessing-jigsaw)\\n- [EDA](https://www.kaggle.com/tunguz/just-some-simple-eda) for Quora data\\n- [EDA](https://www.kaggle.com/kailex/r-eda-for-q-gru) in  R for Quora data\\n- Complete [EDA](https://www.kaggle.com/codename007/start-from-here-quest-complete-eda-fe) with stack exchange data\\n- My previous article on [EDA for natural language processing](https://neptune.ai/blog/exploratory-data-analysis-natural-language-processing-tools)\\n\\n## Data cleaning\\n\\nData cleaning is one of the important and integral parts of any NLP problem. Text data always needs some preprocessing and cleaning before we can represent it in a suitable form.\\n\\n- Use this [notebook](https://www.kaggle.com/sudalairajkumar/getting-started-with-text-preprocessing) to clean social media data\\n- [Data cleaning](https://www.kaggle.com/kyakovlev/preprocessing-bert-public) for BERT\\n- Use [textblob](https://textblob.readthedocs.io/en/dev/quickstart.html) to correct misspellings\\n- [Cleaning](https://www.kaggle.com/theoviel/improve-your-score-with-some-text-preprocessing) for pre-trained embeddings\\n- [Language detection and translation](https://www.pythonprogramming.in/language-detection-and-translation-using-textblob.html) for multilingual tasks\\n- Preprocessing for Glove [part 1](https://www.kaggle.com/christofhenkel/how-to-preprocessing-for-glove-part1-eda) and [part 2](https://www.kaggle.com/christofhenkel/how-to-preprocessing-for-glove-part2-usage)\\n- [Increasing word coverage](https://www.kaggle.com/sunnymarkliu/more-text-cleaning-to-increase-word-coverage) to get more from pre-trained word embeddings\\n\\n## Text representations\\n\\nBefore we feed our text data to the Neural network or ML model, the text input needs to be represented in a suitable format. These representations determine the performance of the model to a large extent.\\n\\n- Pretrained [Glove](https://nlp.stanford.edu/projects/glove/) vectors\\n- Pretrained [fasttext](https://fasttext.cc/docs/en/english-vectors.html) vectors\\n- Pretrained [word2vec](https://radimrehurek.com/gensim/models/word2vec.html) vectors\\n- My previous article on these [3 embeddings](https://neptune.ai/blog/document-classification-small-datasets)\\n- Combining [pre-trained vectors](https://www.kaggle.com/c/quora-insincere-questions-classification/discussion/71778/). This can help in better representation of text and decreasing OOV words\\n- [Paragram](https://cogcomp.seas.upenn.edu/page/resource_view/106) embeddings\\n- [Universal Sentence Encoder](https://tfhub.dev/google/universal-sentence-encoder/1)\\n- Use USE to generate [sentence-level features](https://www.kaggle.com/abhishek/distilbert-use-features-oof)\\n- 3 methods to [combine embeddings](https://www.kaggle.com/c/quora-insincere-questions-classification/discussion/71778)\\n\\nContextual embeddings models\\n\\n- [BERT](https://github.com/google-research/bert) Bidirectional Encoder Representations from Transformers\\n- [GPT](https://github.com/openai/finetune-transformer-lm)\\n- [Roberta](https://github.com/pytorch/fairseq/tree/master/examples/roberta) a Robustly Optimized BERT\\n- [Albert](https://github.com/google-research/ALBERT) a Lite BERT for Self-supervised Learning of Language Representations\\n- [Distilbert](https://github.com/huggingface/transformers/tree/master/examples/distillation) a lighter version of BERT\\n- [XLNET](https://github.com/zihangdai/xlnet/)\\n\\n## Modeling\\n\\n### Model architecture\\n\\nChoosing the right architecture is important to develop a proper machine learning model, sequence to sequence models like LSTMs, GRUs perform well in NLP problems and is always worth trying. Stacking 2 layers of LSTM/GRU networks is a common approach.\\n\\n- [Stacking Bidirectional CuDNNLSTM](https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52644/)\\n- [Stacking LSTM networks](https://www.kaggle.com/sakami/google-quest-single-lstm/)\\n- [LSTM and 5 fold Attention](https://www.kaggle.com/christofhenkel/keras-baseline-lstm-attention-5-fold/)\\n- [Bi...\\n\\n--- Result 3 ---\\nTitle: Combining text with numerical and categorical features for classification\\nURL: https://engineering.freeagent.com/2024/05/17/combining-text-with-numerical-and-categorical-features-for-classification\\n\\nContent:\\n[Skip to content](https://engineering.freeagent.com/engineering.freeagent.com#content)\\n\\n# Classification with transformer models\\n\\nA common approach for classification tasks with text data is to fine-tune a pre-trained transformer model on domain-specific data. At FreeAgent we apply this approach to [automatically categorise bank transactions](https://www.freeagent.com/blog/how-freeagent-uses-ai/), using raw inputs that are a mixture of text, numerical and categorical data types.\\n\\nThe current approach is to concatenate the input features for each transaction into a single string before passing to the model.\\n\\nFor example a transaction with the following set of features:\\n\\n|     |     |     |\\n| --- | --- | --- |\\n| **Description** | **Amount** | **Industry** |\\n| Plastic pipes | £-7.99 | Plumbing |\\n\\ncould be represented by the string:  `Plastic pipes [SEP] -7.99 [SEP] Plumbing` with `[SEP]` being a special token indicating the boundaries between sentences, which is used to separate the features. This is a simple way to combine features that have yielded positive performance. We’ve even noticed that the model exhibits unexpectedly good interpretations of the amount feature.\\n\\nThis approach however doesn’t feel like the most natural way to represent the information contained in a numerical feature like the transaction amount. An alternative approach is to use the transformer model to extract a vector representation of the text features, concatenate this with features extracted from non-text data types and pass the combination to a classifier.\\n\\nIn this post we compare the performance of these two approaches using a dataset of wine reviews to classify wines into 3 classes (neutral, good and excellent). Diagrams 1 and 2 below give an overview of the process for getting from input features to output categories in the two approaches.\\n\\nDiagram 1: Concatenating all inputs into a single string to fine-tune a base transformer model.\\n\\nDiagram 2: Preprocessing numerical and categorical features independently from the text, extracting the description vector representation and train a lightGBM classifier.\\n\\n# Public wine reviews dataset\\n\\nWe use the [Kaggle wine reviews dataset](https://www.kaggle.com/datasets/zynicide/wine-reviews) for this experiment, which contains a variety of descriptive features for just under 130,000 wines, including a wine score. The wine score is a number between 1-100, with 100 being the best, although this dataset only includes reviews for wines that score over 80. For the purpose of this blog post, we created the wine rating from the scores – wines between 80 and 86 (incl) were flagged as “neutral”, between 87 and 93 as “good” and greater than 94 as “excellent”.\\n\\nTo keep things simple we will use just the wine description, price and variety to attempt to classify the wines into these 3 ratings.\\n\\nWe loaded the data and created a target variable `rating` to split the wine scores into the 3 target categories (neutral, good, excellent).\\n\\n```\\nimport pandas as pd\\n\\nwine_df = pd.read_csv(\\\"data/wine_data.csv\\\")\\nbins = [0, 87, 94, np.inf]\\nnames = [\\\"neutral\\\", \\\"good\\\", \\\"excellent\\\"]\\n\\nwine_df[\\\"rating\\\"] = pd.cut(wine_df[\\\"points\\\"], bins, labels=names)\\n\\n```\\n\\nWe can then keep a DataFrame of the features and target. For the purpose of putting together this example we have limited the model input features to the wine variety (the type of grapes used to make the wine), the price (cost for a bottle of wine) and the wine description.\\n\\n```\\nNUMERICAL_FEATURE = \\\"price\\\"\\nCATEGORICAL_FEATURE = \\\"variety\\\"\\nTEXT_FEATURE = \\\"description\\\"\\nTARGET = \\\"rating\\\"\\nFEATURES = [TEXT_FEATURE, NUMERICAL_FEATURE, CATEGORICAL_FEATURE]\\n\\nwine_df = wine_df[FEATURES + [TARGET]]\\n\\n```\\n\\nWe then split our wine dataframe into an 80:20 training:evaluation split.\\n\\n```\\nfrom sklearn.model_selection import train_test_split\\n\\ntrain_df, test_df = train_test_split(wine_df, test_size=0.2)\\n\\n```\\n\\n## LightGBM classifier approach\\n\\n### Preprocessing\\n\\n#### Preprocessing numerical and categorical features\\n\\nIn a first step we will preprocess the numerical and categorical features using SKLearn’s ColumnTransformer.  For the numerical features (price) we decided to fill missing values using the median wine price and scale them using a StandardScaler.\\n\\nWe preprocessed the categorical features by filling missing values with “other” and OneHot encoded them.\\n\\nWe saved the output of the ColumnTransformer as a pandas DataFrame to concatenate it later with the vector representation of the text.\\n\\n```\\nimport numpy as np\\n\\nfrom sklearn.compose import ColumnTransformer\\nfrom sklearn.impute import SimpleImputer\\nfrom sklearn.pipeline import make_pipeline\\nfrom sklearn.preprocessing import (\\n    OneHotEncoder,\\n    StandardScaler,\\n)\\n\\ndef preprocess_number():\\n    return make_pipeline(\\n        SimpleImputer(strategy=\\\"median\\\"),\\n        StandardScaler(),\\n    )\\n\\ndef preprocess_categories():\\n    return make_pipeline(\\n       SimpleImputer(strategy=\\\"constant\\\", fill_value=\\\"other\\\", missing_values=np.nan),\\n       OneHotEncoder(handle_unknown=\\\"ignore\\\", sparse_output=False),\\n    )\\n\\ndef create_preprocessor():\\n\\n    transformers = [\\n        (\\\"num_preprocessor\\\", preprocess_number(), [NUMERICAL_FEATURE]),\\n        (\\\"cat_preprocessor\\\", preprocess_categories(), [CATEGORICAL_FEATURE]),\\n    ]\\n\\n    return ColumnTransformer(transformers=transformers, remainder=\\\"drop\\\")\\n\\ncolumn_transformer = create_preprocessor()\\ncolumn_transformer.set_output(transform=\\\"pandas\\\")\\npreprocessed_num_cat_features_df = column_transformer.fit_transform(\\n    train_df[[NUMERICAL_FEATURE, CATEGORICAL_FEATURE]]\\n)\\n\\n```\\n\\n#### Extracting text vector representation with a transformer model\\n\\nWe then moved on to the preprocessing of the text features. We decided to use `distilbert-base-uncased` as the base transformer model to extract the vector representation of the wine description.\\n\\nBERT-type models use stacks of [transformer encoder layers](https://arxiv.org/pdf/1706.03762.pdf). Each of these blocks processes the tokenized text through a multi-headed self-attention step and a feed-forward neural network, before passing outputs to the next layer. The hidden state is the output of a given layer. The \\\\[CLS\\\\] token (short for classification) is a special token that represents an entire text sequence. We choose the hidden state of the \\\\[CLS\\\\] token in the final layer as the vector representation of our wine descriptions.\\n\\nIn order to extract the \\\\[CLS\\\\] representations, we first transform the text inputs into a Dataset of tokenized PyTorch tensors.\\n\\nFor this step we tokenized batches of 128 wine descriptions padded to a fixed length of 120 suitable for our wine descriptions of ~40 words. The max\\\\_length is one of the parameters which should be adjusted depending on the length of the text feature to prevent truncating longer inputs. The padding is necessary to ensure we will process fixed-shape inputs with the transformer model. The tokenizer returns a dictionary of input\\\\_ids, attention\\\\_mask and token\\\\_type\\\\_ids. Only the input\\\\_ids (the indices of each token in the wine description) and the attention mask (binary tensor indicating the position of the padded indice) are required inputs to the model.\\n\\nThe code for the tokenization is shown below:\\n\\n```\\nfrom datasets import Dataset\\nfrom transformers import AutoTokenizer\\n\\nMODEL_NAME = \\\"distilbert-base-uncased\\\"\\n\\ndef tokenized_pytorch_tensors(\\n        df: pd.DataFrame,\\n        column_list: list\\n    ) -> Dataset:\\n\\n    tokenizer = AutoTokenizer.from_pretrained(MODEL_NAME)\\n    transformers_dataset = Dataset.from_pandas(df)\\n\\n    def tokenize(model_inputs_batch: Dataset) -> Dataset:\\n        return tokenizer(\\n            model_inputs_batch[TEXT_FEATURE],\\n            padding=True,\\n            max_length=120,\\n            truncation=True,\\n        )\\n\\n    tokenized_dataset = transformers_dataset.map(\\n        tokenize,\\n        batched=True,\\n        batch_size=128\\n    )\\n\\n    tokenized_dataset.set_format(\\n        \\\"torch\\\",\\n        columns=column_list\\n    )\\n\\n    columns_t...\\n\\n--- Result 4 ---\\nURL: https://export.arxiv.org/pdf/2301.01808v1.pdf\\n\\nContent:\\nAdar Kahana adarkahana@microsoft.com\\nMicrosoft R&D center\\nILDC\\nOren Elisha orelisha@microsoft.com\\nMicrosoft R&D center\\nILDC\\nMESSAGENET: MESSAGE CLASSIFICATION USING NATURAL LANGUAGE PROCESSING AND META-DATA\\nMessage classification · Meta data injection · Deep learning · Natural language processing\\nIn this paper we propose a new Deep Learning (DL) approach for message classification. Our method is based on the state-of-the-art Natural Language Processing (NLP) building blocks, combined with a novel technique for infusing the meta-data input that is typically available in messages such as the sender information, timestamps, attached image, audio, affiliations, and more. As we demonstrate throughout the paper, going beyond the mere text by leveraging all available channels in the message, could yield an improved representation and higher classification accuracy. To achieve message representation, each type of input is processed in a dedicated block in the neural network architecture that is suitable for the data type. Such an implementation enables training all blocks together simultaneously, and forming cross channels features in the network. We show in the Experiments Section that in some cases, message's meta-data holds an additional information that cannot be extracted just from the text, and when using this information we achieve better performance. Furthermore, we demonstrate that our multi-modality block approach outperforms other approaches for injecting the meta data to the the text classifier.Many real world applications require message classification and regression, such as handling spam emails [1], ticket routing [2], article sentiment review [3] and more. Accurate message classification could improve critical scenarios such as in call centers (routing tickets based on topic) [2], alert systems (flagging highly important alert messages) [4], and categorizing incoming messages (automatically unclutter emails)[1,5]. The main distinction between text and message classification is the availability of additional attributes, such as the sender information, timestamps, attached image, audio, affiliations, and more. New message classification contests often appear in the prominent platforms (i.e., Kaggle [6]), showing how this topic is sought after. There are already many data-sets to explore in this field, but no clear winner algorithm that fits all scenarios with high accuracy, efficiency and simplicity (in terms of implementation and interpretation).A notable advancement in the field of NLP is the attention based transformers architecture[7]. This family of methods excels in finding local connections between words, and better understanding the meaning of a sentence. A leading example is the Bidirectional Encoder Representations from Transformers (BERT) [8] as well as its variations [9, 10, 11], winning certain benchmarks[12,13]. Several packages, such as Huggingface Transformers[14], make such models accessible and easy to use as well as provide pre-trained versions. In addition, one can use transfer learning [15] to further train BERT on their on data, creating a tailored model for the specific task at hand.BERT, and often other transformer based models, are designed to handle text. They operate on the words of a given text by encoding them into tokens, and by the connections between the tokens they learn the context of sentences. This approach is limited, since sometimes more information can be extracted and used, not necessarily textual. Throughout this paper we refer to this information as meta-data to distinguish it from the main stream of textual content (though one may recognize it as the core data, depending on the application). For example, a meta-data could be the time stamp of when the text was written, sent, published, etc. Another example is the writer of the text, when dealing with a small\\nlist of writers of a corpus. There have been some attempts to incorporate these into BERT models, for example by assigning artificial tokens for writers or for temporal segments (token per month for example) [16]. This approach is limited since not all meta-data entries are suitable for encoding by tokenization. In the example of temporal segments, more segments introduce more tokens, leading to large computational resources consumption, and less segments cause loss of information. Another approach is to concatenate the embeddings, created by the transformer module, with the outputs of an embedding module for the meta-data. In this approach, a transformer for the text is trained (using direct or transfer learning) on the text, and other separate modules (time series embedding, senders embeddings, etc.) are used to embed the meta-data. All the embeddings are\\n\\n--- Result 5 ---\\nURL: https://aclanthology.org/2020.emnlp-main.670.pdf\\n\\nContent:\\nProceedings of the 2020 Conference on Empirical Methods in Natural Language Processing, pages 8351–8361,\\nNovember 16–20, 2020. \\rc 2020 Association for Computational Linguistics\\n8351\\nMETA: Metadata-Empowered Weak Supervision for Text Classification\\nDheeraj Mekala1 Xinyang Zhang2 Jingbo Shang1,3\\n1 Department of Computer Science and Engineering, University of California San Diego, CA, USA\\n2 Department of Computer Science, University of at Illinois Urbana-Champaign, IL, USA\\n3 Halıcıoglu Data Science Institute, University of California San Diego, CA, USA ˘\\n1,3\\n{dmekala, jshang}@ucsd.edu 2 xz43@illinois.edu\\nAbstract\\nRecent advances in weakly supervised learn\\u0002ing enable training high-quality text classifiers\\nby only providing a few user-provided seed\\nwords. Existing methods mainly use text data\\nalone to generate pseudo-labels despite the\\nfact that metadata information (e.g., author\\nand timestamp) is widely available across var\\u0002ious domains. Strong label indicators exist in\\nthe metadata and it has been long overlooked\\nmainly due to the following challenges: (1)\\nmetadata is multi-typed, requiring systematic\\nmodeling of different types and their combi\\u0002nations, (2) metadata is noisy, some metadata\\nentities (e.g., authors, venues) are more com\\u0002pelling label indicators than others. In this\\npaper, we propose a novel framework, META,\\nwhich goes beyond the existing paradigm and\\nleverages metadata as an additional source of\\nweak supervision. Specifically, we organize\\nthe text data and metadata together into a\\ntext-rich network and adopt network motifs to\\ncapture appropriate combinations of metadata.\\nBased on seed words, we rank and filter mo\\u0002tif instances to distill highly label-indicative\\nones as “seed motifs”, which provide addi\\u0002tional weak supervision. Following a boot\\u0002strapping manner, we train the classifier and\\nexpand the seed words and seed motifs itera\\u0002tively. Extensive experiments and case stud\\u0002ies on real-world datasets demonstrate supe\\u0002rior performance and significant advantages of\\nleveraging metadata as weak supervision.\\n1 Introduction\\nWeakly supervised text classification has recently\\ngained much attention from the researchers because\\nit reduces the burden of annotating the data. So far,\\nthe major source of weak supervision lies in text\\ndata itself (Agichtein and Gravano, 2000; Kuipers\\net al., 2006; Riloff et al., 2003; Tao et al., 2015;\\nMeng et al., 2018; Mekala and Shang, 2020). These\\nmethods typically require a few user-provided seed\\nPaper Authors Year Category\\nP1 G. Hinton, S. Osindero, YW. Teh 2006 ML\\nP2 G. Hinton, O. Vinyals, J. Dean 2015 ML\\nP3 J. Dean, S.Ghemawat 2008 Sys\\n(a) Examples of research papers with metadata.\\nO. Vinyals\\nG. Hinton\\n2016\\nneural\\nsystem\\ndata\\nlearning\\nJ. Dean Doc\\nAuthor 1 Author 2\\nP2\\nO. Vinyals G. Hinton\\nP1 P2\\n… …\\n…\\n(b) A text-rich network view of \\nthe papers.\\n(c) A motif pattern and \\na motif instance.\\nFigure 1: Text corpus, text-rich network, and motif.\\nwords for each class as weak supervision. They ex\\u0002pand seed words with generated pseudo labels and\\nimprove their text classifier in an iterative fashion.\\nMetadata information (e.g., author, published\\nyear) in addition to textual information, is widely\\navailable across various domains (e.g., news arti\\u0002cles, social media posts, and scientific papers) and\\nit could serve as a strong, complementary weak\\nsupervision source. Take a look at the research\\npapers in Figure 1(a) as an example. It shall be\\nlearned in a data-driven manner that G. Hinton is a\\nhighly-reputed machine learning researcher, thus\\nhis presence is a strong indicator of a paper belong\\u0002ing to the Machine Learning category.\\nDistilling effective metadata for weak supervi\\u0002sion faces several major challenges. Metadata is\\noften multi-typed, each type and the type combi\\u0002nations could have very different semantics and\\nmay not be equally important. Moreover, even en\\u0002tities within a single metadata type could be noisy.\\nContinuing our example in Figure 1(a), we shall\\nnotice that year is less helpful than an author to do\\nclassification. Among the authors, J. Dean might\\nbe an important figure but has research interests\\n8352\\nm1,1 .95 .01 .04\\nm1,2 .32 .30 .38\\nText Classifier\\nSeed Words ① Pseudo Label Generation ③ Motif Ranking & …\\nC1 Neural Network\\nC2 Image Classification\\nC3 Translation\\nPaper\\nAuthor 1 Author 2\\nM1\\nM2\\nm2,1 .03 .89 .08\\nm2,2 .31 .26 .43\\nInstance C1 C2 C3\\nKlein Manning\\nP1 P2\\n② Classifier Training / Prediction\\nRecursion\\nUser Given\\nMotif Pattern\\nMatched (Seed)\\nMotif Instances\\n…\\n…\\nC1 m1,1 m1,6 m2,3 m1,4 …\\nC2 m2,1 m2,4 m1,2 m1,4 …\\nC3 m1,3 m2,5 m2,2 m1,7 …\\n... Expansion\\nExpand from high score to low\\nNew seed set cutoff\\nFigure 2: Our META framework. In each iteration, we generate pseudo labels for documents, train the text classifier,\\nand rank all words and motif instances in a unified ranking framework. We then expand seed sets until an automatic\\ncutoff is reached. The quality of the classifier and the seed sets are improved through iterations.\\nspanning across different domains. However, if we\\njoin the author with year, it carries more accurate\\nsemantics, and we may discover J. Dean has more\\ninterest in machine learning in recent years, thus\\nbecoming highly label-indicative.\\nBearing the challenges in mind, we propose\\nMETA, a principled framework for metadata\\u0002empowered weakly-supervised text classification.\\nAs illustrated in Figure 1 and Figure 2, we first\\norganize the text data and metadata together into\\na text-rich network. The network structure gives\\nus a holistic view of the corpus and enables us to\\nrank and select useful metadata entities. We lever\\u0002age motif patterns (Benson et al., 2016; Milo et al.,\\n2002; Shang et al., 2020) to model typed metadata\\nas well as their combinations. A motif pattern is\\na subgraph pattern at the meta-level that captures\\nhigher-order connections and the semantics repre\\u0002sented by these connections. It serves as a useful\\ntool to model typed edges, typed paths (a.k.a. meta\\u0002paths) (Sun et al., 2011), and higher-order struc\\u0002tures in the network. With little effort, users can\\nspecify a few possibly useful motif patterns as in\\u0002put to our model. We develop a unified, principled\\nranking mechanism to select label-indicative motif\\ninstances and words, forming expanded weak su\\u0002pervision. Note that, such instance-level selection\\nprocess also implicitly refines the motif patterns,\\nensuring the robust performance of META even\\nwhen irrelevant motif patterns exist in input. It is\\nworth a mention that META is compatible with any\\ntext classifiers.\\nOur contributions are summarized as follows:\\n• We explore to incorporate metadata information\\nas an additional source of weak supervision for\\ntext classification along with seed words.\\n• We propose a novel framework META, which in\\u0002troduces motif patterns to capture the high-order\\ncombinations among different types of metadata\\nand conducts a unified ranking and selection of\\nlabel-indicative motif instances and words.\\n• We conduct experiments on two real-world\\ndatasets. The results and case studies demon\\u0002strate the superiority of incorporating metadata\\nas parts of weak supervision and verify the effec\\u0002tiveness of META.\\nReproducibility. Our code is made publicly avail\\u0002able at GitHub1\\n.\\n2 Preliminaries\\n2.1 Documents as Text-rich Network\\nGiven a collection of n text documents D =\\n{D1, D2, . . . , Dn}, and their corresponding meta\\u0002data, we propose to organize them into a text-rich\\nnetwork, as illustrated in Figure 1(b). A text-rich\\nnetwork is a heterogeneous network with docu\\u0002ments, words, different types of metadata as nodes,\\nand their associations as edges. For example, our\\ntext-rich network for research papers has papers,\\nwords, authors, and publication years as nodes.\\nEach paper is connected to its associated words\\nand metadata nodes. Such a network provides a\\nholistic and structured representation of the input.\\n2.2 Seed Words and Motif Patterns\\nUsers are asked to provide a few seed words S\\n= {Sw\\n1\\n, S\\nw\\n2\\n, . . . , S\\nw\\nl\\n} for each of l classes (i.e.,\\nC1, C2, . . . , ...\\n\\n--- Result 6 ---\\nTitle: 20% Accuracy Bump in Text Classification with ME-ULMFiT\\nURL: https://medium.com/novetta/20-accuracy-bump-in-text-classification-with-me-ulmfit-4545e993aa78\\n\\nContent:\\n[Open in app](https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F4545e993aa78&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------)\\n\\nSign up\\n\\n[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2Fnovetta%2F20-accuracy-bump-in-text-classification-with-me-ulmfit-4545e993aa78&source=post_page---two_column_layout_nav-----------------------global_nav-----------)\\n\\n[Write](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_topnav-----------)\\n\\nSign up\\n\\n[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2Fnovetta%2F20-accuracy-bump-in-text-classification-with-me-ulmfit-4545e993aa78&source=post_page---two_column_layout_nav-----------------------global_nav-----------)\\n\\n![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)\\n\\n# 20% Accuracy Bump in Text Classification with ME-ULMFiT\\n\\n[![Matthew Teschke](https://miro.medium.com/v2/resize:fill:88:88/0*nsQhCoB0HTmu_sw5.)](https://medium.com/@mteschke?source=post_page-----4545e993aa78--------------------------------)[![Novetta](https://miro.medium.com/v2/resize:fill:48:48/1*FLKm3lgYky637lUrGUFvrA.png)](https://medium.com/novetta?source=post_page-----4545e993aa78--------------------------------)\\n\\n[Matthew Teschke](https://medium.com/@mteschke?source=post_page-----4545e993aa78--------------------------------)\\n\\n·\\n\\n[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fcb8201a221b3&operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnovetta%2F20-accuracy-bump-in-text-classification-with-me-ulmfit-4545e993aa78&user=Matthew+Teschke&userId=cb8201a221b3&source=post_page-cb8201a221b3----4545e993aa78---------------------post_header-----------)\\n\\nPublished in\\n\\n[Novetta](https://medium.com/novetta?source=post_page-----4545e993aa78--------------------------------)\\n\\n·\\n\\n5 min read\\n\\n·\\n\\nMar 31, 2020\\n\\n10\\n\\n[Listen](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2Fplans%3Fdimension%3Dpost_audio_button%26postId%3D4545e993aa78&operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnovetta%2F20-accuracy-bump-in-text-classification-with-me-ulmfit-4545e993aa78&source=-----4545e993aa78---------------------post_audio_button-----------)\\n\\nShare\\n\\n_By incorporating metadata into the text before training, we see as much as a 20% increase in accuracy_\\n\\n# Introduction\\n\\nIn a [previous post](https://www.novetta.com/2019/03/introducing_me_ulmfit/), we discussed an enhanced method of passing additional data to the ULMFiT¹ algorithm for unstructured text classification, which improved accuracy by up to 9%. In follow-on experiments, we have demonstrated that this approach — in which we prepend metadata to the text to provide more information to the model — increased accuracy by up to 20%, in relative terms. This improvement required just a few lines of Python, such that the performance boost comes at essentially no cost.\\n\\nThis blog post explains the findings of this more-detailed evaluation, where we have compared how the following affect accuracy:\\n\\n1. Each individual piece of metadata\\n2. Different combinations of metadata\\n3. Different ways of passing the metadata to the model\\n\\nFor the evaluation, we worked with six [Novetta Mission Analytics](https://www.novetta.com/products/novetta-mission-analytics/) datasets, described below. The objective is to assign metadata tags to quotes, using granular categories called Submessages.\\n\\nSome highlights from our results include:\\n\\n- Source-related metadata tags consistently performed the best, confirming our original hypothesis. Sources (e.g. UN Official) are the metadata most closely associated with the quotes we are tagging, so it makes sense that sources add the most information.\\n- Including media name (e.g. New York Times) either decreased accuracy or showed little improvement. We found this surprising as we had assumed that including metadata would only improve accuracy.\\n- Adding more metadata tags to the model did not always improve performance.\\n- For five of the six datasets, using metadata tags that distinguish between columns in our data performed better than the approach (currently suggested by the fast.ai library) in which each field was demarcated by xxfld.\\n\\n# Dataset Overview\\n\\nWe conducted evaluations on the six datasets listed in Table 1. For each dataset, we made the following splits time-based between training and validation, where later data is held out for validation. We used 80% of the data for training and 17% for validation on the language model. Using that 97% of the data, we then trained the classifier, reserving the last 3% for the final validation.\\n\\n![](https://miro.medium.com/v2/resize:fit:700/1*WtQcwQm1EIIoHz3Gy6EoaA.png)\\n\\nTable 1: Characteristics of Datasets Used in ME-ULMFiT Evaluation\\n\\n# Experiment 1: Individual Metadata\\n\\nOur first experiment evaluated how individual pieces of metadata impacted performance of the model. Working with six types of metadata (Author Name, Media Name, Media Nation, Source Name, Source Nation, Source Type), we created a model that prepended only that piece of information to the quote text. For example, a Source Name of “Steffen Seibert” prepended to a quote results in:\\n\\n```\\nsource_name source_name_Steffen_Seibert quote_text that “we have started down the path” towards the NATO goal.\\n```\\n\\nThe results of Experiment 1 are shown in the following heat map:\\n\\n![](https://miro.medium.com/v2/resize:fit:432/1*6-wTYPDfG1meArIiwnA1oA.png)\\n\\nFigure 1: Heat map showing relative change in accuracy of ME-ULMFiT with individual types of metadata compared to the baseline ULMFiT model with no metadata\\n\\nFrom the heat map, we made the following observations:\\n\\n- Source-related metadata tags generally performed the best\\n- The Media Name metadata tag performed the worst for four out of six datasets\\n- Datasets with fewer Submessage labels saw less improvement from the inclusion of metadata than those with more Submessage labels\\n\\n# Experiment 2: Combinations of Metadata\\n\\nIn the second experiment, we evaluated how different combinations of metadata impacted model accuracy. Our intuition suggested that more metadata would always lead to better performance, but as shown in Figure 2, this was not the case. We will be conducting further investigation into why.\\n\\nWe examined five different combinations of metadata as follows:\\n\\n- The top-2 performing metadata tags from Experiment 1\\n- The top-3 performing metadata tags from Experiment 1\\n- The top-4 performing metadata tags from Experiment 1\\n- All metadata tags\\n- Fast.ai built-in tags, which utilized all metadata but whose fields are separated by xxfld instead of column-specific tags. In this method, values within the data are not concatenated (e.g., The New York Times was not converted to xxfld\\\\_The\\\\_New\\\\_York\\\\_Times)\\n\\n![](https://miro.medium.com/v2/resize:fit:432/1*UQW6om7aQzCpUEp9pvyQpQ.png)\\n\\nFigure 2: Heat map showing relative change in accuracy of ME-ULMFiT with combinations of metadata compared to the baseline ULMFiT model with no metadata\\n\\nWhile we see that more often than not multiple tags improve performance over the best baseline, that is not always the case. For only one dataset did the model with all metadata perform the best and it generally underperformed the most accurate individual metadata model. We believe this has to do with the way batches are created within the model, so we will explore further to see why more data is not always improving accuracy.\\n\\n# Experiment 3: Methods of Passing Metadata\\n\\nLastly, for the models that included all metadata, we wanted to compare different methods of passing in metadata. Our [original post](https://www.novetta.com/2019/03/introducing_me_ulmfit/) describes our method of using separate tags for each metadata field and concatenating all valu...\\n\\n--- Result 7 ---\\nTitle: A Journey Through Kaggle Text Data Competitions From 2021 to 2023\\nURL: https://medium.com/@sblaizer/a-journey-through-kaggle-text-data-competitions-from-2021-to-2023-631a79f96312\\n\\nContent:\\nA Journey Through Kaggle Text Data Competitions From 2021 to 2023 | by Salomon Marquez | Medium\\n[Sitemap](https://medium.com/sitemap/sitemap.xml)\\n[Open in app](https://play.google.com/store/apps/details?id=com.medium.reader&amp;referrer=utm_source=mobileNavBar&amp;source=post_page---top_nav_layout_nav-----------------------------------------)\\nSign up\\n[Sign in](https://medium.com/m/signin?operation=login&amp;redirect=https://medium.com/@sblaizer/a-journey-through-kaggle-text-data-competitions-from-2021-to-2023-631a79f96312&amp;source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\\n[Medium Logo](https://medium.com/?source=post_page---top_nav_layout_nav-----------------------------------------)\\n[\\nWrite\\n](https://medium.com/m/signin?operation=register&amp;redirect=https://medium.com/new-story&amp;source=---top_nav_layout_nav-----------------------new_post_topnav------------------)\\n[\\nSearch\\n](https://medium.com/search?source=post_page---top_nav_layout_nav-----------------------------------------)\\nSign up\\n[Sign in](https://medium.com/m/signin?operation=login&amp;redirect=https://medium.com/@sblaizer/a-journey-through-kaggle-text-data-competitions-from-2021-to-2023-631a79f96312&amp;source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\\n![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)\\n# A Journey Through Kaggle Text Data Competitions From 2021 to 2023\\n[\\n![Salomon Marquez](https://miro.medium.com/v2/da:true/resize:fill:64:64/0*hbSxb57OAqPdRqks)\\n](https://medium.com/@sblaizer?source=post_page---byline--631a79f96312---------------------------------------)\\n[Salomon Marquez](https://medium.com/@sblaizer?source=post_page---byline--631a79f96312---------------------------------------)\\n18 min read\\n·Apr 28, 2024\\n[\\n](https://medium.com/m/signin?actionUrl=https://medium.com/_/vote/p/631a79f96312&amp;operation=register&amp;redirect=https://medium.com/@sblaizer/a-journey-through-kaggle-text-data-competitions-from-2021-to-2023-631a79f96312&amp;user=Salomon+Marquez&amp;userId=1a60dea97a2c&amp;source=---header_actions--631a79f96312---------------------clap_footer------------------)\\n--\\n[](https://medium.com/m/signin?actionUrl=https://medium.com/_/bookmark/p/631a79f96312&amp;operation=register&amp;redirect=https://medium.com/@sblaizer/a-journey-through-kaggle-text-data-competitions-from-2021-to-2023-631a79f96312&amp;source=---header_actions--631a79f96312---------------------bookmark_footer------------------)\\nListen\\nShare\\n*Authors:*[*Liliana Badillo*](https://www.kaggle.com/sophieb)*and*[*Salomon Marquez*](https://www.kaggle.com/sblaizer)\\n**> Note:\\n**> I created this Medium post to provide more visibility to our original report. Please refer to our [> A Journey Throuhgh Text Data Competitions\\n](https://www.kaggle.com/code/sophieb/a-journey-through-text-data-competitions)> notebook for further details.\\nN**atural Language Processing (NLP)**, the branch of artificial intelligence that enables computers to understand human language, has witnessed remarkable growth and transformative advancements in recent years. This surge has been driven by the increasing availability of vast amounts of text data and the rapid development of sophisticated machine-learning techniques.\\n*> “It is estimated that 90% of the world’s data was generated in the last two years alone”\\n*> by [> Amount of Data Created Daily (2023)\\n](https://explodingtopics.com/blog/data-generated-per-day)\\n[**Kaggle**](https://www.kaggle.com/)is an online platform that hosts machine learning and data science competitions. Among these competitions, text data competitions specifically focus on tasks related to NLP and text analysis. Participants are provided with text datasets and are tasked with developing models and algorithms to solve language-related challenges such as sentiment analysis, text classification, and machine translation. These competitions are instrumental in advancing NLP techniques and provide participants with valuable experience and knowledge exchange opportunities.\\nAccessing and learning about the latest techniques employed in text data Kaggle competitions can be challenging due to their dispersion within discussions and winning solution write-ups.**Valuable information about these cutting-edge approaches tends to get buried, making it difficult to stay updated on the evolving landscape of text data techniques.**\\nIn this essay, our objective is to offer valuable insights into key lessons learned by the Kaggle community during their engagement in text data competitions spanning from 2021 to 2023. We will focus on**four pivotal topics**that have emerged as the foundation for successful solutions in recent years:**model architectures**,**pseudo labeling**,**adversarial weight perturbation**, and**mask language modeling**. By examining these four key areas, we aim to provide a comprehensive understanding of the essential elements driving winning strategies in text data competitions.\\n## Methodology\\nTo gain a better understanding of the text data landscape, we carried out the following tasks:\\n* **Analyze 27 write-ups from nine Kaggle competitions specifically related to text data**. We dove deeper into the top three solutions for text data competitions held from 2021 to 2023, see**Figure 1**. Also, we explore a range of topics, including the prevalent techniques and methodologies employed, the most effective model architectures utilized, and the challenges encountered and overcame. This analysis enabled us to gain deeper insights into the problem-solving approaches and thought processes employed by Kagglers in developing their successful solutions.\\n* **Perform a general but not exhaustive analysis of the**[**arXiv dataset**](https://www.kaggle.com/datasets/Cornell-University/arxiv). We filter out categories with the potential to include NLP papers published within the past two years. By leveraging a predefined list of keywords associated with text data, we directed our efforts towards uncovering the specific problem domains and top leading model architectures [1][2] that have garnered attention within the research community.\\nPress enter or click to view image in full size\\n![]()\\n**Figure 1.**Kaggle text data competitions held from 2021 to 2023\\n## Key Discoveries of Text Data Competitions\\nThe result of the analysis of the 27 write-ups and their most notable comments can be seen in[Table I of Appendix A](https://www.kaggle.com/code/sophieb/a-journey-through-text-data-competitions#Appendix-A)and[Table II of Appendix B](https://www.kaggle.com/code/sophieb/a-journey-through-text-data-competitions#Appendix-B), respectively.**Table I**provides information about the top three winning solutions in each Kaggle competition related to text, highlighting aspects such as model architectures, parameters like PB and LB, optimizers, ensembles, and the most innovative proposed ideas, among others. On the other hand,**Table II**presents a summary of comments from the write-ups in a question-like format. Additionally, the analysis of the arXiv dataset has allowed us to unveil, on a larger scale, how the use of certain model architectures and their application to specific text domains compares to the solutions presented in text-oriented Kaggle competitions over the past two years. For more details, please refer to[EDA Kaggle and Arxiv datasets](https://www.kaggle.com/code/sophieb/eda-kaggle-and-arxiv-datasets)notebook.\\nAs**Figure 2**shows, out of the nine competitions, five focused on text classification tasks, two aimed at information extraction tasks, while the remaining targeted text matching and question-and-answer tasks. Interestingly,**Figure 3**shows that with the frequency of the term “question answering” exceeding 400 times, it can be inferred that the scientific community has placed greater importance on domains related to this field. While Kaggle competitions have only hosted one question-and-answer competition, there seems ...\\n\\n--- Result 8 ---\\nTitle: How To Run Text Categorization: All Tips and Tricks from 5 Kaggle Competitions\\nURL: https://hackernoon.com/how-to-run-text-categorization-all-tips-and-tricks-from-5-kaggle-competitions-7e1h3uyh\\n\\nContent:\\nHow To Run Text Categorization: All Tips and Tricks from 5 Kaggle Competitions | HackerNoon\\nDiscover Anything**\\n[\\n![Hackernoon logo](https://hackernoon.imgix.net/hn-icon.png?auto=format&amp;fit=max&amp;w=128)\\nHackernoon](https://hackernoon.com/)\\nSignup[Write](https://app.hackernoon.com/new)\\n******\\n**139reads\\n# How To Run Text Categorization: All Tips and Tricks from 5 Kaggle Competitions\\nby\\n**neptune.ai Jakub Czakon**\\n[\\n![](https://cdn.hackernoon.com/images%2FL4OCiGu7n6cUBUyJKe9Rs0MX1d73-8x03wsi.jpeg?alt=media&amp;token=dc8a460d-ab44-4c8e-a72e-559d894a3fbc)\\nbyneptune.ai Jakub Czakon@neptuneAI\\\\_jakub](https://hackernoon.com/u/neptuneAI_jakub)\\nSenior data scientist building experiment tracking tools for ML projects at https://neptune.ai\\nSubscribe\\nAugust 23rd, 2020\\nTLDR**\\n![neptune.ai Jakub Czakon](https://cdn.hackernoon.com/images%2FL4OCiGu7n6cUBUyJKe9Rs0MX1d73-8x03wsi.jpeg?alt=media&amp;token=dc8a460d-ab44-4c8e-a72e-559d894a3fbc)\\nbyneptune.ai Jakub Czakon@neptuneAI\\\\_jakub\\n[\\n![](https://cdn.hackernoon.com/images%2FL4OCiGu7n6cUBUyJKe9Rs0MX1d73-8x03wsi.jpeg?alt=media&amp;token=dc8a460d-ab44-4c8e-a72e-559d894a3fbc)\\nbyneptune.ai Jakub Czakon@neptuneAI\\\\_jakub](https://hackernoon.com/u/neptuneAI_jakub)\\nSenior data scientist building experiment tracking tools for ML projects at https://neptune.ai\\nSubscribe\\n****\\n**********[**](<mailto:?subject=I'd like to share a link with you &amp;body=>)\\n[\\n![](https://cdn.hackernoon.com/images%2FL4OCiGu7n6cUBUyJKe9Rs0MX1d73-8x03wsi.jpeg?alt=media&amp;token=dc8a460d-ab44-4c8e-a72e-559d894a3fbc)\\nbyneptune.ai Jakub Czakon@neptuneAI\\\\_jakub](https://hackernoon.com/u/neptuneAI_jakub)\\nSenior data scientist building experiment tracking tools for ML projects at https://neptune.ai\\nSubscribe\\n****\\n**********[**](<mailto:?subject=I'd like to share a link with you &amp;body=>)\\n[\\n←Previous\\nHyperparameter Tuning on Any Python Script in 3 EasySteps [A How-To Guide]\\n](https://hackernoon.com/hyperparameter-tuning-on-any-python-script-in-3-easy-steps-a-how-to-guide-5u4g329e)\\n### About Author\\n[](https://hackernoon.com/u/neptuneAI_jakub)\\n[**neptune.ai Jakub Czakon**@neptuneAI\\\\_jakub](https://hackernoon.com/u/neptuneAI_jakub)\\nSenior data scientist building experiment tracking tools for ML projects at https://neptune.ai\\n[Read my stories](https://hackernoon.com/u/neptuneAI_jakub)[Learn More](https://hackernoon.com/about/neptuneAI_jakub)\\n#### Comments\\n#### TOPICS\\n[**machine-learning](https://hackernoon.com/c/machine-learning)[#machine-learning](https://hackernoon.com/tagged/machine-learning)[#binary-classification](https://hackernoon.com/tagged/binary-classification)[#data-science](https://hackernoon.com/tagged/data-science)[#kaggle](https://hackernoon.com/tagged/kaggle)[#tips-and-tricks](https://hackernoon.com/tagged/tips-and-tricks)[#ml](https://hackernoon.com/tagged/ml)[#kaggle-competition](https://hackernoon.com/tagged/kaggle-competition)[#tutorial](https://hackernoon.com/tagged/tutorial)\\n#### THIS ARTICLE WAS FEATURED IN\\n[\\n](https://sia.hackernoon.com/how-to-run-text-categorization-all-tips-and-tricks-from-5-kaggle-competitions-7e1h3uyh)[\\n**\\nArweave\\n](https://www.arweave.net/ithJ8kJytzNBq5ZLT_ZTN24PAqZ047UthexwscEqhQw)[\\nViewBlock\\n](https://viewblock.io/arweave/tx/ithJ8kJytzNBq5ZLT_ZTN24PAqZ047UthexwscEqhQw)[Terminal](https://terminal.hackernoon.com/how-to-run-text-categorization-all-tips-and-tricks-from-5-kaggle-competitions-7e1h3uyh?ref=hackernoon)[Lite](https://hackernoon.com/lite/how-to-run-text-categorization-all-tips-and-tricks-from-5-kaggle-competitions-7e1h3uyh?ref=hackernoon)[\\n![](https://t0.gstatic.com/faviconV2?client=SOCIAL&amp;type=FAVICON&amp;url=https://www.joyk.com/dig/detail/1707491664448324&amp;size=16)Joyk\\n](https://www.joyk.com/dig/detail/1707491664448324)[\\n![](https://t0.gstatic.com/faviconV2?client=SOCIAL&amp;type=FAVICON&amp;url=https://www.learnrepo.com/242-stories-to-learn-about-ml&amp;size=16)Learnrepo\\n](https://www.learnrepo.com/242-stories-to-learn-about-ml)[\\n![](https://t0.gstatic.com/faviconV2?client=SOCIAL&amp;type=FAVICON&amp;url=https://unni.io/domains/hackernoon.com/page/48760739&amp;size=16)Unni\\n](https://unni.io/domains/hackernoon.com/page/48760739)[\\n![](https://t0.gstatic.com/faviconV2?client=SOCIAL&amp;type=FAVICON&amp;url=https://learnrepo.hashnode.dev/833-stories-to-learn-about-tutorial&amp;size=16)Hashnode\\n](https://learnrepo.hashnode.dev/833-stories-to-learn-about-tutorial)[\\n![](https://t0.gstatic.com/faviconV2?client=SOCIAL&amp;type=FAVICON&amp;url=https://learnrepo.com/242-stories-to-learn-about-ml&amp;size=16)Learnrepo\\n](https://learnrepo.com/242-stories-to-learn-about-ml)[\\n![](https://t0.gstatic.com/faviconV2?client=SOCIAL&amp;type=FAVICON&amp;url=https://unni.io/domains/hackernoon.com/page/50536904&amp;size=16)Unni\\n](https://unni.io/domains/hackernoon.com/page/50536904)\\n#### Related Stories\\n[](https://hackernoon.com/a-completeish-guide-to-python-tools-you-can-use-to-analyse-text-data-13g53wgr)\\n[#MACHINE-LEARNING](https://hackernoon.com/tagged/machine-learning)\\n## [A Complete(ish) Guide to Python Tools You Can Use To Analyse Text Data](https://hackernoon.com/a-completeish-guide-to-python-tools-you-can-use-to-analyse-text-data-13g53wgr)\\n[neptune.ai Jakub Czakon](https://hackernoon.com/u/neptuneAI_jakub)\\nMar 23, 2020\\n[](https://hackernoon.com/beyond-recall-and-precision-rethinking-metrics-in-fraud-prevention)\\n[#METRICS](https://hackernoon.com/tagged/metrics)\\n## [Beyond Recall and Precision: Rethinking Metrics in Fraud Prevention](https://hackernoon.com/beyond-recall-and-precision-rethinking-metrics-in-fraud-prevention)\\n[Aleksei Toshchakov](https://hackernoon.com/u/toshchakov)\\nNov 11, 2023\\n[](https://hackernoon.com/binary-classification-understanding-activation-and-loss-functions-with-a-pytorch-example)\\n[#BINARY-CLASSIFICATION](https://hackernoon.com/tagged/binary-classification)\\n## [Binary Classification: Understanding Activation and Loss Functions with a PyTorch Example](https://hackernoon.com/binary-classification-understanding-activation-and-loss-functions-with-a-pytorch-example)\\n[Dmitrii Matveichev](https://hackernoon.com/u/owlgrey)\\nAug 15, 2023\\n[](https://hackernoon.com/confusion-matrix-in-machine-learning-everything-you-need-to-know)\\n[#MACHINE-LEARNING](https://hackernoon.com/tagged/machine-learning)\\n## [Confusion Matrix in Machine Learning: Everything You Need to Know](https://hackernoon.com/confusion-matrix-in-machine-learning-everything-you-need-to-know)\\n[Bala Priya C](https://hackernoon.com/u/balapriya)\\nFeb 03, 2022\\n[](https://hackernoon.com/model-calibration-in-machine-learning-an-important-but-inconspicuous-concept)\\n[#ARTIFICIAL-INTELLIGENCE](https://hackernoon.com/tagged/artificial-intelligence)\\n## [Model Calibration in Machine Learning: An Important but Inconspicuous Concept](https://hackernoon.com/model-calibration-in-machine-learning-an-important-but-inconspicuous-concept)\\n[Sanjay Kumar](https://hackernoon.com/u/sanjaykn170396)\\nJan 28, 2023\\n[](https://hackernoon.com/practical-tips-for-binary-classification-excellence-ape3w02)\\n[#MACHINE-LEARNING](https://hackernoon.com/tagged/machine-learning)\\n## [Practical Tips For Binary Classification Excellence](https://hackernoon.com/practical-tips-for-binary-classification-excellence-ape3w02)\\n[neptune.ai Patrycja Jenkner](https://hackernoon.com/u/neptuneAI_patrycja)\\nNov 09, 2020\\n[](https://hackernoon.com/a-completeish-guide-to-python-tools-you-can-use-to-analyse-text-data-13g53wgr)\\n[#MACHINE-LEARNING](https://hackernoon.com/tagged/machine-learning)\\n## [A Complete(ish) Guide to Python Tools You Can Use To Analyse Text Data](https://hackernoon.com/a-completeish-guide-to-python-tools-you-can-use-to-analyse-text-data-13g53wgr)\\n[neptune.ai Jakub Czakon](https://hackernoon.com/u/neptuneAI_jakub)\\nMar 23, 2020\\n[](https://hackernoon.com/beyond-recall-and-precision-rethinking-metrics-in-fraud-prevention)\\n[#METRICS](https://hackernoon.com/tagged/metrics)\\n## [Beyond Recall and Precision: Rethinking Metrics in Fraud Prevention](https://hackernoon.com/beyond-re...\\n\\n--- Result 9 ---\\nTitle: GitHub - AnakinHuang/kaggle-project-classification-of-tweets-from-northern-europe: Classifies 500K+ political tweets from Northern Europe using NLP and machine learning to analyze political discourse.\\nURL: https://github.com/AnakinHuang/kaggle-project-classification-of-tweets-from-northern-europe\\n\\nContent:\\n<div><div><article><p></p><h2>🐦 Kaggle Project: Classification of Tweets from Northern Europe</h2><a href=\\\"#-kaggle-project-classification-of-tweets-from-northern-europe\\\"></a><p></p>\\n<p><a href=\\\"https://camo.githubusercontent.com/439fd5ffe2ac21b3daa03ac6474978163be089da5fbba2790769ae2275464e35/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d425344253230332d2d436c617573652d626c75652e737667\\\"></a></p>\\n<p></p><h2>🚀 Overview</h2><a href=\\\"#-overview\\\"></a><p></p>\\n<p>This project analyzes a dataset of <strong>509,031 tweets</strong> from politicians across <strong>seven Northern European countries</strong>, aiming to classify tweets by <strong>political spectrum (Left, Right, Center)</strong> and <strong>geography</strong>. Using <strong>Natural Language Processing (NLP)</strong> and machine learning, we extracted key insights into political discourse and developed a classifier with strong performance.</p>\\n<hr/>\\n<p></p><h2>📊 Dataset</h2><a href=\\\"#-dataset\\\"></a><p></p>\\n<ul>\\n<li><strong>Countries:</strong> Belgium, Denmark, Iceland, Ireland, Netherlands, Norway, Sweden</li>\\n<li><strong>Time span:</strong> Dec 2008 – Jan 2023</li>\\n<li><strong>Dataset size:</strong> 509,031 tweets\\n<ul>\\n<li><strong>Training set:</strong> 407,223 tweets</li>\\n<li><strong>Test set:</strong> 101,808 tweets</li>\\n</ul>\\n</li>\\n</ul>\\n<p><strong>Attributes:</strong></p>\\n<ul>\\n<li>Tweet text</li>\\n<li>Country</li>\\n<li>Gender</li>\\n<li>Political spectrum label (for supervised learning)</li>\\n</ul>\\n<hr/>\\n<p></p><h2>🔬 Methods</h2><a href=\\\"#-methods\\\"></a><p></p>\\n<p></p><h3>Data Cleaning &amp; Preprocessing</h3><a href=\\\"#data-cleaning--preprocessing\\\"></a><p></p>\\n<ul>\\n<li>Text cleaning: Lowercasing, punctuation removal, stopword removal, lemmatization.</li>\\n<li>New feature creation: <code>text_clean_country_gender_user</code> combining multiple metadata.</li>\\n</ul>\\n<p></p><h3>Feature Engineering</h3><a href=\\\"#feature-engineering\\\"></a><p></p>\\n<ul>\\n<li><strong>Vectorization:</strong>\\n<ul>\\n<li>Count Vectorizer</li>\\n<li>TF-IDF transformation</li>\\n</ul>\\n</li>\\n</ul>\\n<p></p><h3>Modeling</h3><a href=\\\"#modeling\\\"></a><p></p>\\n<ul>\\n<li><strong>Classifier:</strong> Linear Support Vector Classifier (LinearSVC)</li>\\n<li><strong>Validation:</strong> 10-fold cross-validation</li>\\n</ul>\\n<p></p><h3>Topic Modeling</h3><a href=\\\"#topic-modeling\\\"></a><p></p>\\n<ul>\\n<li><strong>LDA (Latent Dirichlet Allocation)</strong></li>\\n<li><strong>NMF (Non-negative Matrix Factorization)</strong></li>\\n</ul>\\n<hr/>\\n<p></p><h2>📈 Results</h2><a href=\\\"#-results\\\"></a><p></p>\\n<p>✅ <strong>Key findings:</strong></p>\\n<ul>\\n<li>Tweets span diverse topics from <strong>domestic politics</strong> to <strong>international relations</strong>.</li>\\n<li>Different political leanings across countries: e.g., Netherlands leans Center, Iceland leans Left.</li>\\n<li>Gender distribution varies: Sweden had a <strong>female-majority</strong>, others skewed male.</li>\\n</ul>\\n<hr/>\\n<p></p><h2>🛠️ Requirements</h2><a href=\\\"#️-requirements\\\"></a><p></p>\\n<ul>\\n<li>Python 3.8+</li>\\n<li>Key libraries:\\n<ul>\\n<li>pandas, numpy</li>\\n<li>scikit-learn</li>\\n<li>nltk, spaCy</li>\\n<li>gensim</li>\\n<li>matplotlib, seaborn</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Install via:</p>\\n<div><pre>pip install -r requirements.txt</pre></div>\\n<hr/>\\n<p></p><h2>🖥️ Usage</h2><a href=\\\"#️-usage\\\"></a><p></p>\\n<p>1️⃣ <strong>Clone the repository:</strong></p>\\n<div><pre>git clone https://github.com/AnakinHuang/kaggle-project-classification-of-tweets-from-northern-europe.git\\n<span>cd</span> kaggle-project-classification-of-tweets-from-northern-europe</pre></div>\\n<p>2️⃣ <strong>Install dependencies:</strong></p>\\n<div><pre>pip install -r requirements.txt</pre></div>\\n<p>3️⃣ <strong>Run analysis:</strong></p>\\n<ul>\\n<li>Open <code>kaggle_project.ipynb</code> for full preprocessing, modeling, and evaluation workflows.</li>\\n</ul>\\n<hr/>\\n<p></p><h2>📂 Repository Structure</h2><a href=\\\"#-repository-structure\\\"></a><p></p>\\n<div><pre><code>├── data/ # Dataset (not included)\\n├── kaggle_project.ipynb # Main Jupyter notebook\\n├── kaggle_project_report.pdf # Final project report\\n├── README.md\\n├── requirements.txt # Dependencies\\n└── LICENSE\\n</code></pre></div>\\n<hr/>\\n<p></p><h2>👥 Contributors</h2><a href=\\\"#-contributors\\\"></a><p></p>\\n<ul>\\n<li><strong>Yuesong Huang</strong> (<a href=\\\"mailto:yhu116@u.rochester.edu\\\">yhu116@u.rochester.edu</a>)</li>\\n<li><strong>Junhua Huang</strong> (<a href=\\\"mailto:jhuang77@u.rochester.edu\\\">jhuang77@u.rochester.edu</a>)</li>\\n</ul>\\n<hr/>\\n<p></p><h2>📄 License</h2><a href=\\\"#-license\\\"></a><p></p>\\n<p>This project is licensed under the BSD 3-Clause License – see the <a href=\\\"https://github.com/AnakinHuang/kaggle-project-classification-of-tweets-from-northern-europe/blob/main/LICENSE\\\">LICENSE</a> file for details.</p>\\n<hr/>\\n</article></div></div>\\n\", \"is_error\": false, \"results\": [{\"title\": \"ANSWER\", \"text\": \"Winning Kaggle solutions for text classification that also have metadata usually treat the non‑text fields as first‑class inputs rather than an after‑thought.  A common recipe is to **encode the text with a pre‑trained transformer** (e.g., BERT, RoBERTa) and **encode each metadata column separately** – categorical variables with embedding layers, numeric variables with scaling or bucketisation – then concatenate all vectors before the final classification head.  This “dual‑tower” design lets the model learn interactions between language and auxiliary signals while keeping each modality in a suitable representation space ([FreeAgent blog](https://engineering.freeagent.com/2024/05/17/combining-text-with-numerical-and-categorical-features-for-classification)).  \\n\\nA simpler but surprisingly effective trick is to **inject metadata directly into the transformer’s token stream**.  By joining the raw fields with a special separator token (e.g., `[SEP]`) the model sees the amount, category, timestamp, etc., as part of the same sequence, which often yields a quick performance bump and works well when the metadata can be expressed as short text ([FreeAgent blog](https://engineering.freeagent.com/2024/05/17/combining-text-with-numerical-and-categorical-features-for-classification)).  More sophisticated pipelines build **dedicated neural blocks for each metadata type** (image, audio, timestamps, sender IDs) and train them jointly with the text encoder, allowing cross‑modal attention and richer feature fusion; the authors of the MESSAGENET paper report consistent gains over plain‑text baselines ([arXiv 2301.01808](https://export.arxiv.org/pdf/2301.01808v1.pdf)).  \\n\\nBeyond architecture, top teams also exploit **metadata‑driven weak supervision**.  The META framework treats metadata (author, venue, time) as a source of noisy label cues, constructs a text‑rich graph, extracts high‑confidence “seed motifs”, and bootstraps a classifier that iteratively expands both seed words and motifs.  This approach has shown superior accuracy on real‑world datasets where metadata carries strong label signals ([EMNLP 2020 META](https://aclanthology.org/2020.emnlp-main.670.pdf)).  In practice, winning solutions combine these ideas with classic Kaggle tricks—large‑scale pre‑training, careful cross‑validation, and ensembling transformer‑based models with gradient‑boosted trees that consume the raw metadata features ([Neptune tips](https://neptune.ai/blog/text-classification-tips-and-tricks-kaggle-competitions)).  Together, these strategies turn metadata from a peripheral attribute into a powerful driver of classification performance.\", \"url\": \"\"}, {\"title\": \"Text Classification: All Tips and Tricks from 5 Kaggle Competitions\", \"text\": \"In this article, I will discuss some great tips and tricks to [improve the performance](https://neptune.ai/blog/improving-machine-learning-deep-learning-models) of your text classification model. These tricks are obtained from solutions of some of Kaggle’s top NLP competitions.\\n\\nNamely, I’ve gone through:\\n\\n- [Jigsaw Unintended Bias in Toxicity Classification](https://www.kaggle.com/c/jigsaw-unintended-bias-in-toxicity-classification) – $65,000\\n- [Toxic Comment Classification Challenge](https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/) – $35,000\\n- [Quora Insincere Questions Classification](http://kaggle.com/c/quora-insincere-questions-classification) – $25,000\\n- [Google QUEST Q&A Labeling](https://www.kaggle.com/c/google-quest-challenge) – $25,000\\n- [TensorFlow 2.0 Question Answering](https://www.kaggle.com/c/tensorflow2-question-answering) – $50,000\\n\\nand found a ton of great ideas.\\n\\nWithout much lag, let’s begin.\\n\\n## Dealing with larger datasets\\n\\nOne issue you might face in any machine learning competition is the size of your data set. If the size of your data is large, that is 3GB + for Kaggle kernels and more basic laptops you could find it difficult to load and process with limited resources. Here is the link to some of the articles and kernels that I have found useful in such situations.\\n\\n- Optimize the memory by [reducing the size of some attributes](https://www.kaggle.com/shrutimechlearn/large-data-loading-trick-with-ms-malware-data)\\n- Use open-source libraries such as [Dask to read and manipulate the data](https://www.kaggle.com/yuliagm/how-to-work-with-big-datasets-on-16g-ram-dask), it performs parallel computing and saves up memory space\\n- Use [cudf](https://github.com/rapidsai/cudf)\\n- Convert data to [parquet](https://arrow.apache.org/docs/python/parquet.html) format\\n- Convert data to [feather](https://medium.com/@snehotosh.banerjee/feather-a-fast-on-disk-format-for-r-and-python-data-frames-de33d0516b03) format\\n\\n## Small datasets and external data\\n\\nBut, what can one do if the dataset is small? Let’s see some techniques to tackle this situation.\\n\\nOne way to increase the performance of any machine learning model is to use some external data frame that contains some variables that influence the predicate variable.\\n\\nLet’s see some of the external datasets.\\n\\n- Use of [squad](https://rajpurkar.github.io/SQuAD-explorer/) data for Question Answering tasks\\n- Other [datasets](http://nlpprogress.com/english/question_answering.html) for QA tasks\\n- Wikitext long term dependency language modeling [dataset](https://www.salesforce.com/products/einstein/ai-research/the-wikitext-dependency-language-modeling-dataset/)\\n- [Stackexchange data](https://archive.org/download/stackexchange)\\n- Prepare a dictionary of commonly misspelled words and corrected words.\\n- Use of [helper datasets](https://www.kaggle.com/kyakovlev/jigsaw-general-helper-public) for cleaning\\n- [Pseudo labeling](https://www.kaggle.com/cdeotte/pseudo-labeling-qda-0-969/) is the process of adding confidently predicted test data to your training data\\n- Use different data [sampling methods](https://www.kaggle.com/shahules/tackling-class-imbalance)\\n- Text augmentation by [Exchanging words with synonym](https://arxiv.org/pdf/1502.01710.pdf) [s](https://arxiv.org/pdf/1502.01710.pdf)\\n- Text augmentation by [noising in RNN](https://arxiv.org/pdf/1703.02573.pdf)\\n- Text augmentation by [translation to other languages and back](https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/48038)\\n\\n## Data exploration and gaining insights\\n\\nData exploration always helps to better understand the data and gain insights from it. Before starting to develop machine learning models, top competitors always read/do a lot of exploratory data analysis for the data. This helps in feature engineering and cleaning of the data.\\n\\n- Twitter data [exploration methods](https://www.kaggle.com/jagangupta/stop-the-s-toxic-comments-eda)\\n- Simple [EDA for tweets](https://www.kaggle.com/nz0722/simple-eda-text-preprocessing-jigsaw)\\n- [EDA](https://www.kaggle.com/tunguz/just-some-simple-eda) for Quora data\\n- [EDA](https://www.kaggle.com/kailex/r-eda-for-q-gru) in  R for Quora data\\n- Complete [EDA](https://www.kaggle.com/codename007/start-from-here-quest-complete-eda-fe) with stack exchange data\\n- My previous article on [EDA for natural language processing](https://neptune.ai/blog/exploratory-data-analysis-natural-language-processing-tools)\\n\\n## Data cleaning\\n\\nData cleaning is one of the important and integral parts of any NLP problem. Text data always needs some preprocessing and cleaning before we can represent it in a suitable form.\\n\\n- Use this [notebook](https://www.kaggle.com/sudalairajkumar/getting-started-with-text-preprocessing) to clean social media data\\n- [Data cleaning](https://www.kaggle.com/kyakovlev/preprocessing-bert-public) for BERT\\n- Use [textblob](https://textblob.readthedocs.io/en/dev/quickstart.html) to correct misspellings\\n- [Cleaning](https://www.kaggle.com/theoviel/improve-your-score-with-some-text-preprocessing) for pre-trained embeddings\\n- [Language detection and translation](https://www.pythonprogramming.in/language-detection-and-translation-using-textblob.html) for multilingual tasks\\n- Preprocessing for Glove [part 1](https://www.kaggle.com/christofhenkel/how-to-preprocessing-for-glove-part1-eda) and [part 2](https://www.kaggle.com/christofhenkel/how-to-preprocessing-for-glove-part2-usage)\\n- [Increasing word coverage](https://www.kaggle.com/sunnymarkliu/more-text-cleaning-to-increase-word-coverage) to get more from pre-trained word embeddings\\n\\n## Text representations\\n\\nBefore we feed our text data to the Neural network or ML model, the text input needs to be represented in a suitable format. These representations determine the performance of the model to a large extent.\\n\\n- Pretrained [Glove](https://nlp.stanford.edu/projects/glove/) vectors\\n- Pretrained [fasttext](https://fasttext.cc/docs/en/english-vectors.html) vectors\\n- Pretrained [word2vec](https://radimrehurek.com/gensim/models/word2vec.html) vectors\\n- My previous article on these [3 embeddings](https://neptune.ai/blog/document-classification-small-datasets)\\n- Combining [pre-trained vectors](https://www.kaggle.com/c/quora-insincere-questions-classification/discussion/71778/). This can help in better representation of text and decreasing OOV words\\n- [Paragram](https://cogcomp.seas.upenn.edu/page/resource_view/106) embeddings\\n- [Universal Sentence Encoder](https://tfhub.dev/google/universal-sentence-encoder/1)\\n- Use USE to generate [sentence-level features](https://www.kaggle.com/abhishek/distilbert-use-features-oof)\\n- 3 methods to [combine embeddings](https://www.kaggle.com/c/quora-insincere-questions-classification/discussion/71778)\\n\\nContextual embeddings models\\n\\n- [BERT](https://github.com/google-research/bert) Bidirectional Encoder Representations from Transformers\\n- [GPT](https://github.com/openai/finetune-transformer-lm)\\n- [Roberta](https://github.com/pytorch/fairseq/tree/master/examples/roberta) a Robustly Optimized BERT\\n- [Albert](https://github.com/google-research/ALBERT) a Lite BERT for Self-supervised Learning of Language Representations\\n- [Distilbert](https://github.com/huggingface/transformers/tree/master/examples/distillation) a lighter version of BERT\\n- [XLNET](https://github.com/zihangdai/xlnet/)\\n\\n## Modeling\\n\\n### Model architecture\\n\\nChoosing the right architecture is important to develop a proper machine learning model, sequence to sequence models like LSTMs, GRUs perform well in NLP problems and is always worth trying. Stacking 2 layers of LSTM/GRU networks is a common approach.\\n\\n- [Stacking Bidirectional CuDNNLSTM](https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52644/)\\n- [Stacking LSTM networks](https://www.kaggle.com/sakami/google-quest-single-lstm/)\\n- [LSTM and 5 fold Attention](https://www.kaggle.com/christofhenkel/keras-baseline-lstm-attention-5-fold/)\\n- [Bi...\", \"url\": \"https://neptune.ai/blog/text-classification-tips-and-tricks-kaggle-competitions\"}, {\"title\": \"Combining text with numerical and categorical features for classification\", \"text\": \"[Skip to content](https://engineering.freeagent.com/engineering.freeagent.com#content)\\n\\n# Classification with transformer models\\n\\nA common approach for classification tasks with text data is to fine-tune a pre-trained transformer model on domain-specific data. At FreeAgent we apply this approach to [automatically categorise bank transactions](https://www.freeagent.com/blog/how-freeagent-uses-ai/), using raw inputs that are a mixture of text, numerical and categorical data types.\\n\\nThe current approach is to concatenate the input features for each transaction into a single string before passing to the model.\\n\\nFor example a transaction with the following set of features:\\n\\n|     |     |     |\\n| --- | --- | --- |\\n| **Description** | **Amount** | **Industry** |\\n| Plastic pipes | £-7.99 | Plumbing |\\n\\ncould be represented by the string:  `Plastic pipes [SEP] -7.99 [SEP] Plumbing` with `[SEP]` being a special token indicating the boundaries between sentences, which is used to separate the features. This is a simple way to combine features that have yielded positive performance. We’ve even noticed that the model exhibits unexpectedly good interpretations of the amount feature.\\n\\nThis approach however doesn’t feel like the most natural way to represent the information contained in a numerical feature like the transaction amount. An alternative approach is to use the transformer model to extract a vector representation of the text features, concatenate this with features extracted from non-text data types and pass the combination to a classifier.\\n\\nIn this post we compare the performance of these two approaches using a dataset of wine reviews to classify wines into 3 classes (neutral, good and excellent). Diagrams 1 and 2 below give an overview of the process for getting from input features to output categories in the two approaches.\\n\\nDiagram 1: Concatenating all inputs into a single string to fine-tune a base transformer model.\\n\\nDiagram 2: Preprocessing numerical and categorical features independently from the text, extracting the description vector representation and train a lightGBM classifier.\\n\\n# Public wine reviews dataset\\n\\nWe use the [Kaggle wine reviews dataset](https://www.kaggle.com/datasets/zynicide/wine-reviews) for this experiment, which contains a variety of descriptive features for just under 130,000 wines, including a wine score. The wine score is a number between 1-100, with 100 being the best, although this dataset only includes reviews for wines that score over 80. For the purpose of this blog post, we created the wine rating from the scores – wines between 80 and 86 (incl) were flagged as “neutral”, between 87 and 93 as “good” and greater than 94 as “excellent”.\\n\\nTo keep things simple we will use just the wine description, price and variety to attempt to classify the wines into these 3 ratings.\\n\\nWe loaded the data and created a target variable `rating` to split the wine scores into the 3 target categories (neutral, good, excellent).\\n\\n```\\nimport pandas as pd\\n\\nwine_df = pd.read_csv(\\\"data/wine_data.csv\\\")\\nbins = [0, 87, 94, np.inf]\\nnames = [\\\"neutral\\\", \\\"good\\\", \\\"excellent\\\"]\\n\\nwine_df[\\\"rating\\\"] = pd.cut(wine_df[\\\"points\\\"], bins, labels=names)\\n\\n```\\n\\nWe can then keep a DataFrame of the features and target. For the purpose of putting together this example we have limited the model input features to the wine variety (the type of grapes used to make the wine), the price (cost for a bottle of wine) and the wine description.\\n\\n```\\nNUMERICAL_FEATURE = \\\"price\\\"\\nCATEGORICAL_FEATURE = \\\"variety\\\"\\nTEXT_FEATURE = \\\"description\\\"\\nTARGET = \\\"rating\\\"\\nFEATURES = [TEXT_FEATURE, NUMERICAL_FEATURE, CATEGORICAL_FEATURE]\\n\\nwine_df = wine_df[FEATURES + [TARGET]]\\n\\n```\\n\\nWe then split our wine dataframe into an 80:20 training:evaluation split.\\n\\n```\\nfrom sklearn.model_selection import train_test_split\\n\\ntrain_df, test_df = train_test_split(wine_df, test_size=0.2)\\n\\n```\\n\\n## LightGBM classifier approach\\n\\n### Preprocessing\\n\\n#### Preprocessing numerical and categorical features\\n\\nIn a first step we will preprocess the numerical and categorical features using SKLearn’s ColumnTransformer.  For the numerical features (price) we decided to fill missing values using the median wine price and scale them using a StandardScaler.\\n\\nWe preprocessed the categorical features by filling missing values with “other” and OneHot encoded them.\\n\\nWe saved the output of the ColumnTransformer as a pandas DataFrame to concatenate it later with the vector representation of the text.\\n\\n```\\nimport numpy as np\\n\\nfrom sklearn.compose import ColumnTransformer\\nfrom sklearn.impute import SimpleImputer\\nfrom sklearn.pipeline import make_pipeline\\nfrom sklearn.preprocessing import (\\n    OneHotEncoder,\\n    StandardScaler,\\n)\\n\\ndef preprocess_number():\\n    return make_pipeline(\\n        SimpleImputer(strategy=\\\"median\\\"),\\n        StandardScaler(),\\n    )\\n\\ndef preprocess_categories():\\n    return make_pipeline(\\n       SimpleImputer(strategy=\\\"constant\\\", fill_value=\\\"other\\\", missing_values=np.nan),\\n       OneHotEncoder(handle_unknown=\\\"ignore\\\", sparse_output=False),\\n    )\\n\\ndef create_preprocessor():\\n\\n    transformers = [\\n        (\\\"num_preprocessor\\\", preprocess_number(), [NUMERICAL_FEATURE]),\\n        (\\\"cat_preprocessor\\\", preprocess_categories(), [CATEGORICAL_FEATURE]),\\n    ]\\n\\n    return ColumnTransformer(transformers=transformers, remainder=\\\"drop\\\")\\n\\ncolumn_transformer = create_preprocessor()\\ncolumn_transformer.set_output(transform=\\\"pandas\\\")\\npreprocessed_num_cat_features_df = column_transformer.fit_transform(\\n    train_df[[NUMERICAL_FEATURE, CATEGORICAL_FEATURE]]\\n)\\n\\n```\\n\\n#### Extracting text vector representation with a transformer model\\n\\nWe then moved on to the preprocessing of the text features. We decided to use `distilbert-base-uncased` as the base transformer model to extract the vector representation of the wine description.\\n\\nBERT-type models use stacks of [transformer encoder layers](https://arxiv.org/pdf/1706.03762.pdf). Each of these blocks processes the tokenized text through a multi-headed self-attention step and a feed-forward neural network, before passing outputs to the next layer. The hidden state is the output of a given layer. The \\\\[CLS\\\\] token (short for classification) is a special token that represents an entire text sequence. We choose the hidden state of the \\\\[CLS\\\\] token in the final layer as the vector representation of our wine descriptions.\\n\\nIn order to extract the \\\\[CLS\\\\] representations, we first transform the text inputs into a Dataset of tokenized PyTorch tensors.\\n\\nFor this step we tokenized batches of 128 wine descriptions padded to a fixed length of 120 suitable for our wine descriptions of ~40 words. The max\\\\_length is one of the parameters which should be adjusted depending on the length of the text feature to prevent truncating longer inputs. The padding is necessary to ensure we will process fixed-shape inputs with the transformer model. The tokenizer returns a dictionary of input\\\\_ids, attention\\\\_mask and token\\\\_type\\\\_ids. Only the input\\\\_ids (the indices of each token in the wine description) and the attention mask (binary tensor indicating the position of the padded indice) are required inputs to the model.\\n\\nThe code for the tokenization is shown below:\\n\\n```\\nfrom datasets import Dataset\\nfrom transformers import AutoTokenizer\\n\\nMODEL_NAME = \\\"distilbert-base-uncased\\\"\\n\\ndef tokenized_pytorch_tensors(\\n        df: pd.DataFrame,\\n        column_list: list\\n    ) -> Dataset:\\n\\n    tokenizer = AutoTokenizer.from_pretrained(MODEL_NAME)\\n    transformers_dataset = Dataset.from_pandas(df)\\n\\n    def tokenize(model_inputs_batch: Dataset) -> Dataset:\\n        return tokenizer(\\n            model_inputs_batch[TEXT_FEATURE],\\n            padding=True,\\n            max_length=120,\\n            truncation=True,\\n        )\\n\\n    tokenized_dataset = transformers_dataset.map(\\n        tokenize,\\n        batched=True,\\n        batch_size=128\\n    )\\n\\n    tokenized_dataset.set_format(\\n        \\\"torch\\\",\\n        columns=column_list\\n    )\\n\\n    columns_t...\", \"url\": \"https://engineering.freeagent.com/2024/05/17/combining-text-with-numerical-and-categorical-features-for-classification\"}, {\"title\": \"\", \"text\": \"Adar Kahana adarkahana@microsoft.com\\nMicrosoft R&D center\\nILDC\\nOren Elisha orelisha@microsoft.com\\nMicrosoft R&D center\\nILDC\\nMESSAGENET: MESSAGE CLASSIFICATION USING NATURAL LANGUAGE PROCESSING AND META-DATA\\nMessage classification · Meta data injection · Deep learning · Natural language processing\\nIn this paper we propose a new Deep Learning (DL) approach for message classification. Our method is based on the state-of-the-art Natural Language Processing (NLP) building blocks, combined with a novel technique for infusing the meta-data input that is typically available in messages such as the sender information, timestamps, attached image, audio, affiliations, and more. As we demonstrate throughout the paper, going beyond the mere text by leveraging all available channels in the message, could yield an improved representation and higher classification accuracy. To achieve message representation, each type of input is processed in a dedicated block in the neural network architecture that is suitable for the data type. Such an implementation enables training all blocks together simultaneously, and forming cross channels features in the network. We show in the Experiments Section that in some cases, message's meta-data holds an additional information that cannot be extracted just from the text, and when using this information we achieve better performance. Furthermore, we demonstrate that our multi-modality block approach outperforms other approaches for injecting the meta data to the the text classifier.Many real world applications require message classification and regression, such as handling spam emails [1], ticket routing [2], article sentiment review [3] and more. Accurate message classification could improve critical scenarios such as in call centers (routing tickets based on topic) [2], alert systems (flagging highly important alert messages) [4], and categorizing incoming messages (automatically unclutter emails)[1,5]. The main distinction between text and message classification is the availability of additional attributes, such as the sender information, timestamps, attached image, audio, affiliations, and more. New message classification contests often appear in the prominent platforms (i.e., Kaggle [6]), showing how this topic is sought after. There are already many data-sets to explore in this field, but no clear winner algorithm that fits all scenarios with high accuracy, efficiency and simplicity (in terms of implementation and interpretation).A notable advancement in the field of NLP is the attention based transformers architecture[7]. This family of methods excels in finding local connections between words, and better understanding the meaning of a sentence. A leading example is the Bidirectional Encoder Representations from Transformers (BERT) [8] as well as its variations [9, 10, 11], winning certain benchmarks[12,13]. Several packages, such as Huggingface Transformers[14], make such models accessible and easy to use as well as provide pre-trained versions. In addition, one can use transfer learning [15] to further train BERT on their on data, creating a tailored model for the specific task at hand.BERT, and often other transformer based models, are designed to handle text. They operate on the words of a given text by encoding them into tokens, and by the connections between the tokens they learn the context of sentences. This approach is limited, since sometimes more information can be extracted and used, not necessarily textual. Throughout this paper we refer to this information as meta-data to distinguish it from the main stream of textual content (though one may recognize it as the core data, depending on the application). For example, a meta-data could be the time stamp of when the text was written, sent, published, etc. Another example is the writer of the text, when dealing with a small\\nlist of writers of a corpus. There have been some attempts to incorporate these into BERT models, for example by assigning artificial tokens for writers or for temporal segments (token per month for example) [16]. This approach is limited since not all meta-data entries are suitable for encoding by tokenization. In the example of temporal segments, more segments introduce more tokens, leading to large computational resources consumption, and less segments cause loss of information. Another approach is to concatenate the embeddings, created by the transformer module, with the outputs of an embedding module for the meta-data. In this approach, a transformer for the text is trained (using direct or transfer learning) on the text, and other separate modules (time series embedding, senders embeddings, etc.) are used to embed the meta-data. All the embeddings are\", \"url\": \"https://export.arxiv.org/pdf/2301.01808v1.pdf\"}, {\"title\": \"\", \"text\": \"Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing, pages 8351–8361,\\nNovember 16–20, 2020. \\rc 2020 Association for Computational Linguistics\\n8351\\nMETA: Metadata-Empowered Weak Supervision for Text Classification\\nDheeraj Mekala1 Xinyang Zhang2 Jingbo Shang1,3\\n1 Department of Computer Science and Engineering, University of California San Diego, CA, USA\\n2 Department of Computer Science, University of at Illinois Urbana-Champaign, IL, USA\\n3 Halıcıoglu Data Science Institute, University of California San Diego, CA, USA ˘\\n1,3\\n{dmekala, jshang}@ucsd.edu 2 xz43@illinois.edu\\nAbstract\\nRecent advances in weakly supervised learn\\u0002ing enable training high-quality text classifiers\\nby only providing a few user-provided seed\\nwords. Existing methods mainly use text data\\nalone to generate pseudo-labels despite the\\nfact that metadata information (e.g., author\\nand timestamp) is widely available across var\\u0002ious domains. Strong label indicators exist in\\nthe metadata and it has been long overlooked\\nmainly due to the following challenges: (1)\\nmetadata is multi-typed, requiring systematic\\nmodeling of different types and their combi\\u0002nations, (2) metadata is noisy, some metadata\\nentities (e.g., authors, venues) are more com\\u0002pelling label indicators than others. In this\\npaper, we propose a novel framework, META,\\nwhich goes beyond the existing paradigm and\\nleverages metadata as an additional source of\\nweak supervision. Specifically, we organize\\nthe text data and metadata together into a\\ntext-rich network and adopt network motifs to\\ncapture appropriate combinations of metadata.\\nBased on seed words, we rank and filter mo\\u0002tif instances to distill highly label-indicative\\nones as “seed motifs”, which provide addi\\u0002tional weak supervision. Following a boot\\u0002strapping manner, we train the classifier and\\nexpand the seed words and seed motifs itera\\u0002tively. Extensive experiments and case stud\\u0002ies on real-world datasets demonstrate supe\\u0002rior performance and significant advantages of\\nleveraging metadata as weak supervision.\\n1 Introduction\\nWeakly supervised text classification has recently\\ngained much attention from the researchers because\\nit reduces the burden of annotating the data. So far,\\nthe major source of weak supervision lies in text\\ndata itself (Agichtein and Gravano, 2000; Kuipers\\net al., 2006; Riloff et al., 2003; Tao et al., 2015;\\nMeng et al., 2018; Mekala and Shang, 2020). These\\nmethods typically require a few user-provided seed\\nPaper Authors Year Category\\nP1 G. Hinton, S. Osindero, YW. Teh 2006 ML\\nP2 G. Hinton, O. Vinyals, J. Dean 2015 ML\\nP3 J. Dean, S.Ghemawat 2008 Sys\\n(a) Examples of research papers with metadata.\\nO. Vinyals\\nG. Hinton\\n2016\\nneural\\nsystem\\ndata\\nlearning\\nJ. Dean Doc\\nAuthor 1 Author 2\\nP2\\nO. Vinyals G. Hinton\\nP1 P2\\n… …\\n…\\n(b) A text-rich network view of \\nthe papers.\\n(c) A motif pattern and \\na motif instance.\\nFigure 1: Text corpus, text-rich network, and motif.\\nwords for each class as weak supervision. They ex\\u0002pand seed words with generated pseudo labels and\\nimprove their text classifier in an iterative fashion.\\nMetadata information (e.g., author, published\\nyear) in addition to textual information, is widely\\navailable across various domains (e.g., news arti\\u0002cles, social media posts, and scientific papers) and\\nit could serve as a strong, complementary weak\\nsupervision source. Take a look at the research\\npapers in Figure 1(a) as an example. It shall be\\nlearned in a data-driven manner that G. Hinton is a\\nhighly-reputed machine learning researcher, thus\\nhis presence is a strong indicator of a paper belong\\u0002ing to the Machine Learning category.\\nDistilling effective metadata for weak supervi\\u0002sion faces several major challenges. Metadata is\\noften multi-typed, each type and the type combi\\u0002nations could have very different semantics and\\nmay not be equally important. Moreover, even en\\u0002tities within a single metadata type could be noisy.\\nContinuing our example in Figure 1(a), we shall\\nnotice that year is less helpful than an author to do\\nclassification. Among the authors, J. Dean might\\nbe an important figure but has research interests\\n8352\\nm1,1 .95 .01 .04\\nm1,2 .32 .30 .38\\nText Classifier\\nSeed Words ① Pseudo Label Generation ③ Motif Ranking & …\\nC1 Neural Network\\nC2 Image Classification\\nC3 Translation\\nPaper\\nAuthor 1 Author 2\\nM1\\nM2\\nm2,1 .03 .89 .08\\nm2,2 .31 .26 .43\\nInstance C1 C2 C3\\nKlein Manning\\nP1 P2\\n② Classifier Training / Prediction\\nRecursion\\nUser Given\\nMotif Pattern\\nMatched (Seed)\\nMotif Instances\\n…\\n…\\nC1 m1,1 m1,6 m2,3 m1,4 …\\nC2 m2,1 m2,4 m1,2 m1,4 …\\nC3 m1,3 m2,5 m2,2 m1,7 …\\n... Expansion\\nExpand from high score to low\\nNew seed set cutoff\\nFigure 2: Our META framework. In each iteration, we generate pseudo labels for documents, train the text classifier,\\nand rank all words and motif instances in a unified ranking framework. We then expand seed sets until an automatic\\ncutoff is reached. The quality of the classifier and the seed sets are improved through iterations.\\nspanning across different domains. However, if we\\njoin the author with year, it carries more accurate\\nsemantics, and we may discover J. Dean has more\\ninterest in machine learning in recent years, thus\\nbecoming highly label-indicative.\\nBearing the challenges in mind, we propose\\nMETA, a principled framework for metadata\\u0002empowered weakly-supervised text classification.\\nAs illustrated in Figure 1 and Figure 2, we first\\norganize the text data and metadata together into\\na text-rich network. The network structure gives\\nus a holistic view of the corpus and enables us to\\nrank and select useful metadata entities. We lever\\u0002age motif patterns (Benson et al., 2016; Milo et al.,\\n2002; Shang et al., 2020) to model typed metadata\\nas well as their combinations. A motif pattern is\\na subgraph pattern at the meta-level that captures\\nhigher-order connections and the semantics repre\\u0002sented by these connections. It serves as a useful\\ntool to model typed edges, typed paths (a.k.a. meta\\u0002paths) (Sun et al., 2011), and higher-order struc\\u0002tures in the network. With little effort, users can\\nspecify a few possibly useful motif patterns as in\\u0002put to our model. We develop a unified, principled\\nranking mechanism to select label-indicative motif\\ninstances and words, forming expanded weak su\\u0002pervision. Note that, such instance-level selection\\nprocess also implicitly refines the motif patterns,\\nensuring the robust performance of META even\\nwhen irrelevant motif patterns exist in input. It is\\nworth a mention that META is compatible with any\\ntext classifiers.\\nOur contributions are summarized as follows:\\n• We explore to incorporate metadata information\\nas an additional source of weak supervision for\\ntext classification along with seed words.\\n• We propose a novel framework META, which in\\u0002troduces motif patterns to capture the high-order\\ncombinations among different types of metadata\\nand conducts a unified ranking and selection of\\nlabel-indicative motif instances and words.\\n• We conduct experiments on two real-world\\ndatasets. The results and case studies demon\\u0002strate the superiority of incorporating metadata\\nas parts of weak supervision and verify the effec\\u0002tiveness of META.\\nReproducibility. Our code is made publicly avail\\u0002able at GitHub1\\n.\\n2 Preliminaries\\n2.1 Documents as Text-rich Network\\nGiven a collection of n text documents D =\\n{D1, D2, . . . , Dn}, and their corresponding meta\\u0002data, we propose to organize them into a text-rich\\nnetwork, as illustrated in Figure 1(b). A text-rich\\nnetwork is a heterogeneous network with docu\\u0002ments, words, different types of metadata as nodes,\\nand their associations as edges. For example, our\\ntext-rich network for research papers has papers,\\nwords, authors, and publication years as nodes.\\nEach paper is connected to its associated words\\nand metadata nodes. Such a network provides a\\nholistic and structured representation of the input.\\n2.2 Seed Words and Motif Patterns\\nUsers are asked to provide a few seed words S\\n= {Sw\\n1\\n, S\\nw\\n2\\n, . . . , S\\nw\\nl\\n} for each of l classes (i.e.,\\nC1, C2, . . . , ...\", \"url\": \"https://aclanthology.org/2020.emnlp-main.670.pdf\"}, {\"title\": \"20% Accuracy Bump in Text Classification with ME-ULMFiT\", \"text\": \"[Open in app](https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F4545e993aa78&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------)\\n\\nSign up\\n\\n[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2Fnovetta%2F20-accuracy-bump-in-text-classification-with-me-ulmfit-4545e993aa78&source=post_page---two_column_layout_nav-----------------------global_nav-----------)\\n\\n[Write](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_topnav-----------)\\n\\nSign up\\n\\n[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2Fnovetta%2F20-accuracy-bump-in-text-classification-with-me-ulmfit-4545e993aa78&source=post_page---two_column_layout_nav-----------------------global_nav-----------)\\n\\n![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)\\n\\n# 20% Accuracy Bump in Text Classification with ME-ULMFiT\\n\\n[![Matthew Teschke](https://miro.medium.com/v2/resize:fill:88:88/0*nsQhCoB0HTmu_sw5.)](https://medium.com/@mteschke?source=post_page-----4545e993aa78--------------------------------)[![Novetta](https://miro.medium.com/v2/resize:fill:48:48/1*FLKm3lgYky637lUrGUFvrA.png)](https://medium.com/novetta?source=post_page-----4545e993aa78--------------------------------)\\n\\n[Matthew Teschke](https://medium.com/@mteschke?source=post_page-----4545e993aa78--------------------------------)\\n\\n·\\n\\n[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fcb8201a221b3&operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnovetta%2F20-accuracy-bump-in-text-classification-with-me-ulmfit-4545e993aa78&user=Matthew+Teschke&userId=cb8201a221b3&source=post_page-cb8201a221b3----4545e993aa78---------------------post_header-----------)\\n\\nPublished in\\n\\n[Novetta](https://medium.com/novetta?source=post_page-----4545e993aa78--------------------------------)\\n\\n·\\n\\n5 min read\\n\\n·\\n\\nMar 31, 2020\\n\\n10\\n\\n[Listen](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2Fplans%3Fdimension%3Dpost_audio_button%26postId%3D4545e993aa78&operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnovetta%2F20-accuracy-bump-in-text-classification-with-me-ulmfit-4545e993aa78&source=-----4545e993aa78---------------------post_audio_button-----------)\\n\\nShare\\n\\n_By incorporating metadata into the text before training, we see as much as a 20% increase in accuracy_\\n\\n# Introduction\\n\\nIn a [previous post](https://www.novetta.com/2019/03/introducing_me_ulmfit/), we discussed an enhanced method of passing additional data to the ULMFiT¹ algorithm for unstructured text classification, which improved accuracy by up to 9%. In follow-on experiments, we have demonstrated that this approach — in which we prepend metadata to the text to provide more information to the model — increased accuracy by up to 20%, in relative terms. This improvement required just a few lines of Python, such that the performance boost comes at essentially no cost.\\n\\nThis blog post explains the findings of this more-detailed evaluation, where we have compared how the following affect accuracy:\\n\\n1. Each individual piece of metadata\\n2. Different combinations of metadata\\n3. Different ways of passing the metadata to the model\\n\\nFor the evaluation, we worked with six [Novetta Mission Analytics](https://www.novetta.com/products/novetta-mission-analytics/) datasets, described below. The objective is to assign metadata tags to quotes, using granular categories called Submessages.\\n\\nSome highlights from our results include:\\n\\n- Source-related metadata tags consistently performed the best, confirming our original hypothesis. Sources (e.g. UN Official) are the metadata most closely associated with the quotes we are tagging, so it makes sense that sources add the most information.\\n- Including media name (e.g. New York Times) either decreased accuracy or showed little improvement. We found this surprising as we had assumed that including metadata would only improve accuracy.\\n- Adding more metadata tags to the model did not always improve performance.\\n- For five of the six datasets, using metadata tags that distinguish between columns in our data performed better than the approach (currently suggested by the fast.ai library) in which each field was demarcated by xxfld.\\n\\n# Dataset Overview\\n\\nWe conducted evaluations on the six datasets listed in Table 1. For each dataset, we made the following splits time-based between training and validation, where later data is held out for validation. We used 80% of the data for training and 17% for validation on the language model. Using that 97% of the data, we then trained the classifier, reserving the last 3% for the final validation.\\n\\n![](https://miro.medium.com/v2/resize:fit:700/1*WtQcwQm1EIIoHz3Gy6EoaA.png)\\n\\nTable 1: Characteristics of Datasets Used in ME-ULMFiT Evaluation\\n\\n# Experiment 1: Individual Metadata\\n\\nOur first experiment evaluated how individual pieces of metadata impacted performance of the model. Working with six types of metadata (Author Name, Media Name, Media Nation, Source Name, Source Nation, Source Type), we created a model that prepended only that piece of information to the quote text. For example, a Source Name of “Steffen Seibert” prepended to a quote results in:\\n\\n```\\nsource_name source_name_Steffen_Seibert quote_text that “we have started down the path” towards the NATO goal.\\n```\\n\\nThe results of Experiment 1 are shown in the following heat map:\\n\\n![](https://miro.medium.com/v2/resize:fit:432/1*6-wTYPDfG1meArIiwnA1oA.png)\\n\\nFigure 1: Heat map showing relative change in accuracy of ME-ULMFiT with individual types of metadata compared to the baseline ULMFiT model with no metadata\\n\\nFrom the heat map, we made the following observations:\\n\\n- Source-related metadata tags generally performed the best\\n- The Media Name metadata tag performed the worst for four out of six datasets\\n- Datasets with fewer Submessage labels saw less improvement from the inclusion of metadata than those with more Submessage labels\\n\\n# Experiment 2: Combinations of Metadata\\n\\nIn the second experiment, we evaluated how different combinations of metadata impacted model accuracy. Our intuition suggested that more metadata would always lead to better performance, but as shown in Figure 2, this was not the case. We will be conducting further investigation into why.\\n\\nWe examined five different combinations of metadata as follows:\\n\\n- The top-2 performing metadata tags from Experiment 1\\n- The top-3 performing metadata tags from Experiment 1\\n- The top-4 performing metadata tags from Experiment 1\\n- All metadata tags\\n- Fast.ai built-in tags, which utilized all metadata but whose fields are separated by xxfld instead of column-specific tags. In this method, values within the data are not concatenated (e.g., The New York Times was not converted to xxfld\\\\_The\\\\_New\\\\_York\\\\_Times)\\n\\n![](https://miro.medium.com/v2/resize:fit:432/1*UQW6om7aQzCpUEp9pvyQpQ.png)\\n\\nFigure 2: Heat map showing relative change in accuracy of ME-ULMFiT with combinations of metadata compared to the baseline ULMFiT model with no metadata\\n\\nWhile we see that more often than not multiple tags improve performance over the best baseline, that is not always the case. For only one dataset did the model with all metadata perform the best and it generally underperformed the most accurate individual metadata model. We believe this has to do with the way batches are created within the model, so we will explore further to see why more data is not always improving accuracy.\\n\\n# Experiment 3: Methods of Passing Metadata\\n\\nLastly, for the models that included all metadata, we wanted to compare different methods of passing in metadata. Our [original post](https://www.novetta.com/2019/03/introducing_me_ulmfit/) describes our method of using separate tags for each metadata field and concatenating all valu...\", \"url\": \"https://medium.com/novetta/20-accuracy-bump-in-text-classification-with-me-ulmfit-4545e993aa78\"}, {\"title\": \"A Journey Through Kaggle Text Data Competitions From 2021 to 2023\", \"text\": \"A Journey Through Kaggle Text Data Competitions From 2021 to 2023 | by Salomon Marquez | Medium\\n[Sitemap](https://medium.com/sitemap/sitemap.xml)\\n[Open in app](https://play.google.com/store/apps/details?id=com.medium.reader&amp;referrer=utm_source=mobileNavBar&amp;source=post_page---top_nav_layout_nav-----------------------------------------)\\nSign up\\n[Sign in](https://medium.com/m/signin?operation=login&amp;redirect=https://medium.com/@sblaizer/a-journey-through-kaggle-text-data-competitions-from-2021-to-2023-631a79f96312&amp;source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\\n[Medium Logo](https://medium.com/?source=post_page---top_nav_layout_nav-----------------------------------------)\\n[\\nWrite\\n](https://medium.com/m/signin?operation=register&amp;redirect=https://medium.com/new-story&amp;source=---top_nav_layout_nav-----------------------new_post_topnav------------------)\\n[\\nSearch\\n](https://medium.com/search?source=post_page---top_nav_layout_nav-----------------------------------------)\\nSign up\\n[Sign in](https://medium.com/m/signin?operation=login&amp;redirect=https://medium.com/@sblaizer/a-journey-through-kaggle-text-data-competitions-from-2021-to-2023-631a79f96312&amp;source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\\n![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)\\n# A Journey Through Kaggle Text Data Competitions From 2021 to 2023\\n[\\n![Salomon Marquez](https://miro.medium.com/v2/da:true/resize:fill:64:64/0*hbSxb57OAqPdRqks)\\n](https://medium.com/@sblaizer?source=post_page---byline--631a79f96312---------------------------------------)\\n[Salomon Marquez](https://medium.com/@sblaizer?source=post_page---byline--631a79f96312---------------------------------------)\\n18 min read\\n·Apr 28, 2024\\n[\\n](https://medium.com/m/signin?actionUrl=https://medium.com/_/vote/p/631a79f96312&amp;operation=register&amp;redirect=https://medium.com/@sblaizer/a-journey-through-kaggle-text-data-competitions-from-2021-to-2023-631a79f96312&amp;user=Salomon+Marquez&amp;userId=1a60dea97a2c&amp;source=---header_actions--631a79f96312---------------------clap_footer------------------)\\n--\\n[](https://medium.com/m/signin?actionUrl=https://medium.com/_/bookmark/p/631a79f96312&amp;operation=register&amp;redirect=https://medium.com/@sblaizer/a-journey-through-kaggle-text-data-competitions-from-2021-to-2023-631a79f96312&amp;source=---header_actions--631a79f96312---------------------bookmark_footer------------------)\\nListen\\nShare\\n*Authors:*[*Liliana Badillo*](https://www.kaggle.com/sophieb)*and*[*Salomon Marquez*](https://www.kaggle.com/sblaizer)\\n**> Note:\\n**> I created this Medium post to provide more visibility to our original report. Please refer to our [> A Journey Throuhgh Text Data Competitions\\n](https://www.kaggle.com/code/sophieb/a-journey-through-text-data-competitions)> notebook for further details.\\nN**atural Language Processing (NLP)**, the branch of artificial intelligence that enables computers to understand human language, has witnessed remarkable growth and transformative advancements in recent years. This surge has been driven by the increasing availability of vast amounts of text data and the rapid development of sophisticated machine-learning techniques.\\n*> “It is estimated that 90% of the world’s data was generated in the last two years alone”\\n*> by [> Amount of Data Created Daily (2023)\\n](https://explodingtopics.com/blog/data-generated-per-day)\\n[**Kaggle**](https://www.kaggle.com/)is an online platform that hosts machine learning and data science competitions. Among these competitions, text data competitions specifically focus on tasks related to NLP and text analysis. Participants are provided with text datasets and are tasked with developing models and algorithms to solve language-related challenges such as sentiment analysis, text classification, and machine translation. These competitions are instrumental in advancing NLP techniques and provide participants with valuable experience and knowledge exchange opportunities.\\nAccessing and learning about the latest techniques employed in text data Kaggle competitions can be challenging due to their dispersion within discussions and winning solution write-ups.**Valuable information about these cutting-edge approaches tends to get buried, making it difficult to stay updated on the evolving landscape of text data techniques.**\\nIn this essay, our objective is to offer valuable insights into key lessons learned by the Kaggle community during their engagement in text data competitions spanning from 2021 to 2023. We will focus on**four pivotal topics**that have emerged as the foundation for successful solutions in recent years:**model architectures**,**pseudo labeling**,**adversarial weight perturbation**, and**mask language modeling**. By examining these four key areas, we aim to provide a comprehensive understanding of the essential elements driving winning strategies in text data competitions.\\n## Methodology\\nTo gain a better understanding of the text data landscape, we carried out the following tasks:\\n* **Analyze 27 write-ups from nine Kaggle competitions specifically related to text data**. We dove deeper into the top three solutions for text data competitions held from 2021 to 2023, see**Figure 1**. Also, we explore a range of topics, including the prevalent techniques and methodologies employed, the most effective model architectures utilized, and the challenges encountered and overcame. This analysis enabled us to gain deeper insights into the problem-solving approaches and thought processes employed by Kagglers in developing their successful solutions.\\n* **Perform a general but not exhaustive analysis of the**[**arXiv dataset**](https://www.kaggle.com/datasets/Cornell-University/arxiv). We filter out categories with the potential to include NLP papers published within the past two years. By leveraging a predefined list of keywords associated with text data, we directed our efforts towards uncovering the specific problem domains and top leading model architectures [1][2] that have garnered attention within the research community.\\nPress enter or click to view image in full size\\n![]()\\n**Figure 1.**Kaggle text data competitions held from 2021 to 2023\\n## Key Discoveries of Text Data Competitions\\nThe result of the analysis of the 27 write-ups and their most notable comments can be seen in[Table I of Appendix A](https://www.kaggle.com/code/sophieb/a-journey-through-text-data-competitions#Appendix-A)and[Table II of Appendix B](https://www.kaggle.com/code/sophieb/a-journey-through-text-data-competitions#Appendix-B), respectively.**Table I**provides information about the top three winning solutions in each Kaggle competition related to text, highlighting aspects such as model architectures, parameters like PB and LB, optimizers, ensembles, and the most innovative proposed ideas, among others. On the other hand,**Table II**presents a summary of comments from the write-ups in a question-like format. Additionally, the analysis of the arXiv dataset has allowed us to unveil, on a larger scale, how the use of certain model architectures and their application to specific text domains compares to the solutions presented in text-oriented Kaggle competitions over the past two years. For more details, please refer to[EDA Kaggle and Arxiv datasets](https://www.kaggle.com/code/sophieb/eda-kaggle-and-arxiv-datasets)notebook.\\nAs**Figure 2**shows, out of the nine competitions, five focused on text classification tasks, two aimed at information extraction tasks, while the remaining targeted text matching and question-and-answer tasks. Interestingly,**Figure 3**shows that with the frequency of the term “question answering” exceeding 400 times, it can be inferred that the scientific community has placed greater importance on domains related to this field. While Kaggle competitions have only hosted one question-and-answer competition, there seems ...\", \"url\": \"https://medium.com/@sblaizer/a-journey-through-kaggle-text-data-competitions-from-2021-to-2023-631a79f96312\"}, {\"title\": \"How To Run Text Categorization: All Tips and Tricks from 5 Kaggle Competitions\", \"text\": \"How To Run Text Categorization: All Tips and Tricks from 5 Kaggle Competitions | HackerNoon\\nDiscover Anything**\\n[\\n![Hackernoon logo](https://hackernoon.imgix.net/hn-icon.png?auto=format&amp;fit=max&amp;w=128)\\nHackernoon](https://hackernoon.com/)\\nSignup[Write](https://app.hackernoon.com/new)\\n******\\n**139reads\\n# How To Run Text Categorization: All Tips and Tricks from 5 Kaggle Competitions\\nby\\n**neptune.ai Jakub Czakon**\\n[\\n![](https://cdn.hackernoon.com/images%2FL4OCiGu7n6cUBUyJKe9Rs0MX1d73-8x03wsi.jpeg?alt=media&amp;token=dc8a460d-ab44-4c8e-a72e-559d894a3fbc)\\nbyneptune.ai Jakub Czakon@neptuneAI\\\\_jakub](https://hackernoon.com/u/neptuneAI_jakub)\\nSenior data scientist building experiment tracking tools for ML projects at https://neptune.ai\\nSubscribe\\nAugust 23rd, 2020\\nTLDR**\\n![neptune.ai Jakub Czakon](https://cdn.hackernoon.com/images%2FL4OCiGu7n6cUBUyJKe9Rs0MX1d73-8x03wsi.jpeg?alt=media&amp;token=dc8a460d-ab44-4c8e-a72e-559d894a3fbc)\\nbyneptune.ai Jakub Czakon@neptuneAI\\\\_jakub\\n[\\n![](https://cdn.hackernoon.com/images%2FL4OCiGu7n6cUBUyJKe9Rs0MX1d73-8x03wsi.jpeg?alt=media&amp;token=dc8a460d-ab44-4c8e-a72e-559d894a3fbc)\\nbyneptune.ai Jakub Czakon@neptuneAI\\\\_jakub](https://hackernoon.com/u/neptuneAI_jakub)\\nSenior data scientist building experiment tracking tools for ML projects at https://neptune.ai\\nSubscribe\\n****\\n**********[**](<mailto:?subject=I'd like to share a link with you &amp;body=>)\\n[\\n![](https://cdn.hackernoon.com/images%2FL4OCiGu7n6cUBUyJKe9Rs0MX1d73-8x03wsi.jpeg?alt=media&amp;token=dc8a460d-ab44-4c8e-a72e-559d894a3fbc)\\nbyneptune.ai Jakub Czakon@neptuneAI\\\\_jakub](https://hackernoon.com/u/neptuneAI_jakub)\\nSenior data scientist building experiment tracking tools for ML projects at https://neptune.ai\\nSubscribe\\n****\\n**********[**](<mailto:?subject=I'd like to share a link with you &amp;body=>)\\n[\\n←Previous\\nHyperparameter Tuning on Any Python Script in 3 EasySteps [A How-To Guide]\\n](https://hackernoon.com/hyperparameter-tuning-on-any-python-script-in-3-easy-steps-a-how-to-guide-5u4g329e)\\n### About Author\\n[](https://hackernoon.com/u/neptuneAI_jakub)\\n[**neptune.ai Jakub Czakon**@neptuneAI\\\\_jakub](https://hackernoon.com/u/neptuneAI_jakub)\\nSenior data scientist building experiment tracking tools for ML projects at https://neptune.ai\\n[Read my stories](https://hackernoon.com/u/neptuneAI_jakub)[Learn More](https://hackernoon.com/about/neptuneAI_jakub)\\n#### Comments\\n#### TOPICS\\n[**machine-learning](https://hackernoon.com/c/machine-learning)[#machine-learning](https://hackernoon.com/tagged/machine-learning)[#binary-classification](https://hackernoon.com/tagged/binary-classification)[#data-science](https://hackernoon.com/tagged/data-science)[#kaggle](https://hackernoon.com/tagged/kaggle)[#tips-and-tricks](https://hackernoon.com/tagged/tips-and-tricks)[#ml](https://hackernoon.com/tagged/ml)[#kaggle-competition](https://hackernoon.com/tagged/kaggle-competition)[#tutorial](https://hackernoon.com/tagged/tutorial)\\n#### THIS ARTICLE WAS FEATURED IN\\n[\\n](https://sia.hackernoon.com/how-to-run-text-categorization-all-tips-and-tricks-from-5-kaggle-competitions-7e1h3uyh)[\\n**\\nArweave\\n](https://www.arweave.net/ithJ8kJytzNBq5ZLT_ZTN24PAqZ047UthexwscEqhQw)[\\nViewBlock\\n](https://viewblock.io/arweave/tx/ithJ8kJytzNBq5ZLT_ZTN24PAqZ047UthexwscEqhQw)[Terminal](https://terminal.hackernoon.com/how-to-run-text-categorization-all-tips-and-tricks-from-5-kaggle-competitions-7e1h3uyh?ref=hackernoon)[Lite](https://hackernoon.com/lite/how-to-run-text-categorization-all-tips-and-tricks-from-5-kaggle-competitions-7e1h3uyh?ref=hackernoon)[\\n![](https://t0.gstatic.com/faviconV2?client=SOCIAL&amp;type=FAVICON&amp;url=https://www.joyk.com/dig/detail/1707491664448324&amp;size=16)Joyk\\n](https://www.joyk.com/dig/detail/1707491664448324)[\\n![](https://t0.gstatic.com/faviconV2?client=SOCIAL&amp;type=FAVICON&amp;url=https://www.learnrepo.com/242-stories-to-learn-about-ml&amp;size=16)Learnrepo\\n](https://www.learnrepo.com/242-stories-to-learn-about-ml)[\\n![](https://t0.gstatic.com/faviconV2?client=SOCIAL&amp;type=FAVICON&amp;url=https://unni.io/domains/hackernoon.com/page/48760739&amp;size=16)Unni\\n](https://unni.io/domains/hackernoon.com/page/48760739)[\\n![](https://t0.gstatic.com/faviconV2?client=SOCIAL&amp;type=FAVICON&amp;url=https://learnrepo.hashnode.dev/833-stories-to-learn-about-tutorial&amp;size=16)Hashnode\\n](https://learnrepo.hashnode.dev/833-stories-to-learn-about-tutorial)[\\n![](https://t0.gstatic.com/faviconV2?client=SOCIAL&amp;type=FAVICON&amp;url=https://learnrepo.com/242-stories-to-learn-about-ml&amp;size=16)Learnrepo\\n](https://learnrepo.com/242-stories-to-learn-about-ml)[\\n![](https://t0.gstatic.com/faviconV2?client=SOCIAL&amp;type=FAVICON&amp;url=https://unni.io/domains/hackernoon.com/page/50536904&amp;size=16)Unni\\n](https://unni.io/domains/hackernoon.com/page/50536904)\\n#### Related Stories\\n[](https://hackernoon.com/a-completeish-guide-to-python-tools-you-can-use-to-analyse-text-data-13g53wgr)\\n[#MACHINE-LEARNING](https://hackernoon.com/tagged/machine-learning)\\n## [A Complete(ish) Guide to Python Tools You Can Use To Analyse Text Data](https://hackernoon.com/a-completeish-guide-to-python-tools-you-can-use-to-analyse-text-data-13g53wgr)\\n[neptune.ai Jakub Czakon](https://hackernoon.com/u/neptuneAI_jakub)\\nMar 23, 2020\\n[](https://hackernoon.com/beyond-recall-and-precision-rethinking-metrics-in-fraud-prevention)\\n[#METRICS](https://hackernoon.com/tagged/metrics)\\n## [Beyond Recall and Precision: Rethinking Metrics in Fraud Prevention](https://hackernoon.com/beyond-recall-and-precision-rethinking-metrics-in-fraud-prevention)\\n[Aleksei Toshchakov](https://hackernoon.com/u/toshchakov)\\nNov 11, 2023\\n[](https://hackernoon.com/binary-classification-understanding-activation-and-loss-functions-with-a-pytorch-example)\\n[#BINARY-CLASSIFICATION](https://hackernoon.com/tagged/binary-classification)\\n## [Binary Classification: Understanding Activation and Loss Functions with a PyTorch Example](https://hackernoon.com/binary-classification-understanding-activation-and-loss-functions-with-a-pytorch-example)\\n[Dmitrii Matveichev](https://hackernoon.com/u/owlgrey)\\nAug 15, 2023\\n[](https://hackernoon.com/confusion-matrix-in-machine-learning-everything-you-need-to-know)\\n[#MACHINE-LEARNING](https://hackernoon.com/tagged/machine-learning)\\n## [Confusion Matrix in Machine Learning: Everything You Need to Know](https://hackernoon.com/confusion-matrix-in-machine-learning-everything-you-need-to-know)\\n[Bala Priya C](https://hackernoon.com/u/balapriya)\\nFeb 03, 2022\\n[](https://hackernoon.com/model-calibration-in-machine-learning-an-important-but-inconspicuous-concept)\\n[#ARTIFICIAL-INTELLIGENCE](https://hackernoon.com/tagged/artificial-intelligence)\\n## [Model Calibration in Machine Learning: An Important but Inconspicuous Concept](https://hackernoon.com/model-calibration-in-machine-learning-an-important-but-inconspicuous-concept)\\n[Sanjay Kumar](https://hackernoon.com/u/sanjaykn170396)\\nJan 28, 2023\\n[](https://hackernoon.com/practical-tips-for-binary-classification-excellence-ape3w02)\\n[#MACHINE-LEARNING](https://hackernoon.com/tagged/machine-learning)\\n## [Practical Tips For Binary Classification Excellence](https://hackernoon.com/practical-tips-for-binary-classification-excellence-ape3w02)\\n[neptune.ai Patrycja Jenkner](https://hackernoon.com/u/neptuneAI_patrycja)\\nNov 09, 2020\\n[](https://hackernoon.com/a-completeish-guide-to-python-tools-you-can-use-to-analyse-text-data-13g53wgr)\\n[#MACHINE-LEARNING](https://hackernoon.com/tagged/machine-learning)\\n## [A Complete(ish) Guide to Python Tools You Can Use To Analyse Text Data](https://hackernoon.com/a-completeish-guide-to-python-tools-you-can-use-to-analyse-text-data-13g53wgr)\\n[neptune.ai Jakub Czakon](https://hackernoon.com/u/neptuneAI_jakub)\\nMar 23, 2020\\n[](https://hackernoon.com/beyond-recall-and-precision-rethinking-metrics-in-fraud-prevention)\\n[#METRICS](https://hackernoon.com/tagged/metrics)\\n## [Beyond Recall and Precision: Rethinking Metrics in Fraud Prevention](https://hackernoon.com/beyond-re...\", \"url\": \"https://hackernoon.com/how-to-run-text-categorization-all-tips-and-tricks-from-5-kaggle-competitions-7e1h3uyh\"}, {\"title\": \"GitHub - AnakinHuang/kaggle-project-classification-of-tweets-from-northern-europe: Classifies 500K+ political tweets from Northern Europe using NLP and machine learning to analyze political discourse.\", \"text\": \"<div><div><article><p></p><h2>🐦 Kaggle Project: Classification of Tweets from Northern Europe</h2><a href=\\\"#-kaggle-project-classification-of-tweets-from-northern-europe\\\"></a><p></p>\\n<p><a href=\\\"https://camo.githubusercontent.com/439fd5ffe2ac21b3daa03ac6474978163be089da5fbba2790769ae2275464e35/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d425344253230332d2d436c617573652d626c75652e737667\\\"></a></p>\\n<p></p><h2>🚀 Overview</h2><a href=\\\"#-overview\\\"></a><p></p>\\n<p>This project analyzes a dataset of <strong>509,031 tweets</strong> from politicians across <strong>seven Northern European countries</strong>, aiming to classify tweets by <strong>political spectrum (Left, Right, Center)</strong> and <strong>geography</strong>. Using <strong>Natural Language Processing (NLP)</strong> and machine learning, we extracted key insights into political discourse and developed a classifier with strong performance.</p>\\n<hr/>\\n<p></p><h2>📊 Dataset</h2><a href=\\\"#-dataset\\\"></a><p></p>\\n<ul>\\n<li><strong>Countries:</strong> Belgium, Denmark, Iceland, Ireland, Netherlands, Norway, Sweden</li>\\n<li><strong>Time span:</strong> Dec 2008 – Jan 2023</li>\\n<li><strong>Dataset size:</strong> 509,031 tweets\\n<ul>\\n<li><strong>Training set:</strong> 407,223 tweets</li>\\n<li><strong>Test set:</strong> 101,808 tweets</li>\\n</ul>\\n</li>\\n</ul>\\n<p><strong>Attributes:</strong></p>\\n<ul>\\n<li>Tweet text</li>\\n<li>Country</li>\\n<li>Gender</li>\\n<li>Political spectrum label (for supervised learning)</li>\\n</ul>\\n<hr/>\\n<p></p><h2>🔬 Methods</h2><a href=\\\"#-methods\\\"></a><p></p>\\n<p></p><h3>Data Cleaning &amp; Preprocessing</h3><a href=\\\"#data-cleaning--preprocessing\\\"></a><p></p>\\n<ul>\\n<li>Text cleaning: Lowercasing, punctuation removal, stopword removal, lemmatization.</li>\\n<li>New feature creation: <code>text_clean_country_gender_user</code> combining multiple metadata.</li>\\n</ul>\\n<p></p><h3>Feature Engineering</h3><a href=\\\"#feature-engineering\\\"></a><p></p>\\n<ul>\\n<li><strong>Vectorization:</strong>\\n<ul>\\n<li>Count Vectorizer</li>\\n<li>TF-IDF transformation</li>\\n</ul>\\n</li>\\n</ul>\\n<p></p><h3>Modeling</h3><a href=\\\"#modeling\\\"></a><p></p>\\n<ul>\\n<li><strong>Classifier:</strong> Linear Support Vector Classifier (LinearSVC)</li>\\n<li><strong>Validation:</strong> 10-fold cross-validation</li>\\n</ul>\\n<p></p><h3>Topic Modeling</h3><a href=\\\"#topic-modeling\\\"></a><p></p>\\n<ul>\\n<li><strong>LDA (Latent Dirichlet Allocation)</strong></li>\\n<li><strong>NMF (Non-negative Matrix Factorization)</strong></li>\\n</ul>\\n<hr/>\\n<p></p><h2>📈 Results</h2><a href=\\\"#-results\\\"></a><p></p>\\n<p>✅ <strong>Key findings:</strong></p>\\n<ul>\\n<li>Tweets span diverse topics from <strong>domestic politics</strong> to <strong>international relations</strong>.</li>\\n<li>Different political leanings across countries: e.g., Netherlands leans Center, Iceland leans Left.</li>\\n<li>Gender distribution varies: Sweden had a <strong>female-majority</strong>, others skewed male.</li>\\n</ul>\\n<hr/>\\n<p></p><h2>🛠️ Requirements</h2><a href=\\\"#️-requirements\\\"></a><p></p>\\n<ul>\\n<li>Python 3.8+</li>\\n<li>Key libraries:\\n<ul>\\n<li>pandas, numpy</li>\\n<li>scikit-learn</li>\\n<li>nltk, spaCy</li>\\n<li>gensim</li>\\n<li>matplotlib, seaborn</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Install via:</p>\\n<div><pre>pip install -r requirements.txt</pre></div>\\n<hr/>\\n<p></p><h2>🖥️ Usage</h2><a href=\\\"#️-usage\\\"></a><p></p>\\n<p>1️⃣ <strong>Clone the repository:</strong></p>\\n<div><pre>git clone https://github.com/AnakinHuang/kaggle-project-classification-of-tweets-from-northern-europe.git\\n<span>cd</span> kaggle-project-classification-of-tweets-from-northern-europe</pre></div>\\n<p>2️⃣ <strong>Install dependencies:</strong></p>\\n<div><pre>pip install -r requirements.txt</pre></div>\\n<p>3️⃣ <strong>Run analysis:</strong></p>\\n<ul>\\n<li>Open <code>kaggle_project.ipynb</code> for full preprocessing, modeling, and evaluation workflows.</li>\\n</ul>\\n<hr/>\\n<p></p><h2>📂 Repository Structure</h2><a href=\\\"#-repository-structure\\\"></a><p></p>\\n<div><pre><code>├── data/ # Dataset (not included)\\n├── kaggle_project.ipynb # Main Jupyter notebook\\n├── kaggle_project_report.pdf # Final project report\\n├── README.md\\n├── requirements.txt # Dependencies\\n└── LICENSE\\n</code></pre></div>\\n<hr/>\\n<p></p><h2>👥 Contributors</h2><a href=\\\"#-contributors\\\"></a><p></p>\\n<ul>\\n<li><strong>Yuesong Huang</strong> (<a href=\\\"mailto:yhu116@u.rochester.edu\\\">yhu116@u.rochester.edu</a>)</li>\\n<li><strong>Junhua Huang</strong> (<a href=\\\"mailto:jhuang77@u.rochester.edu\\\">jhuang77@u.rochester.edu</a>)</li>\\n</ul>\\n<hr/>\\n<p></p><h2>📄 License</h2><a href=\\\"#-license\\\"></a><p></p>\\n<p>This project is licensed under the BSD 3-Clause License – see the <a href=\\\"https://github.com/AnakinHuang/kaggle-project-classification-of-tweets-from-northern-europe/blob/main/LICENSE\\\">LICENSE</a> file for details.</p>\\n<hr/>\\n</article></div></div>\", \"url\": \"https://github.com/AnakinHuang/kaggle-project-classification-of-tweets-from-northern-europe\"}]}",
        "tool.duration_ms": 7795.800685882568
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "821386ecdaeb67a8",
      "parent_span_id": "4df94b9b0f13c589",
      "name": "WebSearchTool",
      "kind": "INTERNAL",
      "start_time": 1767939800004834385,
      "end_time": 1767939804281793012,
      "duration": 4.276958627,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "WebSearchTool",
        "cascade.agent_name": "ExplorerAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.research.WebSearchTool object at 0x738bf6c14210>\", \"input\": {\"query\": \"How do Kaggle winners handle class imbalance in text classification competitions?\"}}",
        "tool.output": "{\"content\": \"SEARCH RESULTS (9 found)\\n==================================================\\n\\n--- Result 1 ---\\nTitle: ANSWER\\n\\nContent:\\nBased on the strategies described by Kaggle winners in the Jigsaw‑toxic‑comment and other text‑classification contests, the most common ways to tame severe class imbalance are:\\n\\n1. **Analyze the label distribution and set class‑wise loss weights** – compute the frequency of each class and pass the inverse frequencies (or a smoothed version) to the loss function (e.g., weighted binary‑cross‑entropy or focal loss). This forces the model to pay more attention to rare toxic or insincere labels. ([Towards Data Science](https://towardsdatascience.com/how-i-handled-imbalanced-text-data-ba9b757ab1d8))  \\n\\n2. **Oversample the minority class at the data‑loader level** – duplicate or augment under‑represented samples so each training batch contains a roughly balanced mix. Simple duplication works well, and many winners combine it with text‑augmentation (back‑translation, synonym replacement) to increase diversity. ([Towards Data Science](https://towardsdatascience.com/how-i-handled-imbalanced-text-data-ba9b757ab1d8))  \\n\\n3. **Use stratified K‑fold splits** – ensure every fold preserves the original class ratios, preventing the validation set from being overly easy or hard and giving a reliable estimate of performance on the imbalanced target. ([Neptune blog on text‑classification tips](https://neptune.ai/blog/text-classification-tips-and-tricks-kaggle-competitions))  \\n\\n4. **Apply a balanced‑batch sampler or custom DataLoader** – instead of random sampling, build each batch by drawing an equal number of examples from each class (or from groups of similar frequency). This keeps gradient updates stable throughout training. ([Towards Data Science](https://towardsdatascience.com/how-i-handled-imbalanced-text-data-ba9b757ab1d8))  \\n\\n5. **Leverage ensemble blending with models trained on different sampling schemes** – many top teams train one model on the original data, another on an oversampled version, and then blend their predictions. The diversity of sampling strategies often yields a boost on the leaderboard. ([Neptune blog on text‑classification tips](https://neptune.ai/blog/text-classification-tips-and-tricks-kaggle-competitions))  \\n\\n**Quick checklist for a new competition**\\n\\n- Compute class frequencies → set `pos_weight` or class‑wise weights in the loss.  \\n- Create an oversampled/augmented training set for the rare classes.  \\n- Split with `StratifiedKFold` (or `StratifiedGroupKFold` if needed).  \\n- Implement a balanced‑batch sampler (e.g., `torch.utils.data.WeightedRandomSampler`).  \\n- Train at least two models (original vs. oversampled) and blend their probabilities.  \\n\\nFollowing these steps mirrors the proven workflow of Kaggle winners handling class‑imbalanced text classification problems.\\n\\n--- Result 2 ---\\nTitle: Text Classification: All Tips and Tricks from 5 Kaggle Competitions\\nURL: https://neptune.ai/blog/text-classification-tips-and-tricks-kaggle-competitions\\n\\nContent:\\nIn this article, I will discuss some great tips and tricks to [improve the performance](https://neptune.ai/blog/improving-machine-learning-deep-learning-models) of your text classification model. These tricks are obtained from solutions of some of Kaggle’s top NLP competitions.\\n\\nNamely, I’ve gone through:\\n\\n- [Jigsaw Unintended Bias in Toxicity Classification](https://www.kaggle.com/c/jigsaw-unintended-bias-in-toxicity-classification) – $65,000\\n- [Toxic Comment Classification Challenge](https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/) – $35,000\\n- [Quora Insincere Questions Classification](http://kaggle.com/c/quora-insincere-questions-classification) – $25,000\\n- [Google QUEST Q&A Labeling](https://www.kaggle.com/c/google-quest-challenge) – $25,000\\n- [TensorFlow 2.0 Question Answering](https://www.kaggle.com/c/tensorflow2-question-answering) – $50,000\\n\\nand found a ton of great ideas.\\n\\nWithout much lag, let’s begin.\\n\\n## Dealing with larger datasets\\n\\nOne issue you might face in any machine learning competition is the size of your data set. If the size of your data is large, that is 3GB + for Kaggle kernels and more basic laptops you could find it difficult to load and process with limited resources. Here is the link to some of the articles and kernels that I have found useful in such situations.\\n\\n- Optimize the memory by [reducing the size of some attributes](https://www.kaggle.com/shrutimechlearn/large-data-loading-trick-with-ms-malware-data)\\n- Use open-source libraries such as [Dask to read and manipulate the data](https://www.kaggle.com/yuliagm/how-to-work-with-big-datasets-on-16g-ram-dask), it performs parallel computing and saves up memory space\\n- Use [cudf](https://github.com/rapidsai/cudf)\\n- Convert data to [parquet](https://arrow.apache.org/docs/python/parquet.html) format\\n- Convert data to [feather](https://medium.com/@snehotosh.banerjee/feather-a-fast-on-disk-format-for-r-and-python-data-frames-de33d0516b03) format\\n\\n## Small datasets and external data\\n\\nBut, what can one do if the dataset is small? Let’s see some techniques to tackle this situation.\\n\\nOne way to increase the performance of any machine learning model is to use some external data frame that contains some variables that influence the predicate variable.\\n\\nLet’s see some of the external datasets.\\n\\n- Use of [squad](https://rajpurkar.github.io/SQuAD-explorer/) data for Question Answering tasks\\n- Other [datasets](http://nlpprogress.com/english/question_answering.html) for QA tasks\\n- Wikitext long term dependency language modeling [dataset](https://www.salesforce.com/products/einstein/ai-research/the-wikitext-dependency-language-modeling-dataset/)\\n- [Stackexchange data](https://archive.org/download/stackexchange)\\n- Prepare a dictionary of commonly misspelled words and corrected words.\\n- Use of [helper datasets](https://www.kaggle.com/kyakovlev/jigsaw-general-helper-public) for cleaning\\n- [Pseudo labeling](https://www.kaggle.com/cdeotte/pseudo-labeling-qda-0-969/) is the process of adding confidently predicted test data to your training data\\n- Use different data [sampling methods](https://www.kaggle.com/shahules/tackling-class-imbalance)\\n- Text augmentation by [Exchanging words with synonym](https://arxiv.org/pdf/1502.01710.pdf) [s](https://arxiv.org/pdf/1502.01710.pdf)\\n- Text augmentation by [noising in RNN](https://arxiv.org/pdf/1703.02573.pdf)\\n- Text augmentation by [translation to other languages and back](https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/48038)\\n\\n## Data exploration and gaining insights\\n\\nData exploration always helps to better understand the data and gain insights from it. Before starting to develop machine learning models, top competitors always read/do a lot of exploratory data analysis for the data. This helps in feature engineering and cleaning of the data.\\n\\n- Twitter data [exploration methods](https://www.kaggle.com/jagangupta/stop-the-s-toxic-comments-eda)\\n- Simple [EDA for tweets](https://www.kaggle.com/nz0722/simple-eda-text-preprocessing-jigsaw)\\n- [EDA](https://www.kaggle.com/tunguz/just-some-simple-eda) for Quora data\\n- [EDA](https://www.kaggle.com/kailex/r-eda-for-q-gru) in  R for Quora data\\n- Complete [EDA](https://www.kaggle.com/codename007/start-from-here-quest-complete-eda-fe) with stack exchange data\\n- My previous article on [EDA for natural language processing](https://neptune.ai/blog/exploratory-data-analysis-natural-language-processing-tools)\\n\\n## Data cleaning\\n\\nData cleaning is one of the important and integral parts of any NLP problem. Text data always needs some preprocessing and cleaning before we can represent it in a suitable form.\\n\\n- Use this [notebook](https://www.kaggle.com/sudalairajkumar/getting-started-with-text-preprocessing) to clean social media data\\n- [Data cleaning](https://www.kaggle.com/kyakovlev/preprocessing-bert-public) for BERT\\n- Use [textblob](https://textblob.readthedocs.io/en/dev/quickstart.html) to correct misspellings\\n- [Cleaning](https://www.kaggle.com/theoviel/improve-your-score-with-some-text-preprocessing) for pre-trained embeddings\\n- [Language detection and translation](https://www.pythonprogramming.in/language-detection-and-translation-using-textblob.html) for multilingual tasks\\n- Preprocessing for Glove [part 1](https://www.kaggle.com/christofhenkel/how-to-preprocessing-for-glove-part1-eda) and [part 2](https://www.kaggle.com/christofhenkel/how-to-preprocessing-for-glove-part2-usage)\\n- [Increasing word coverage](https://www.kaggle.com/sunnymarkliu/more-text-cleaning-to-increase-word-coverage) to get more from pre-trained word embeddings\\n\\n## Text representations\\n\\nBefore we feed our text data to the Neural network or ML model, the text input needs to be represented in a suitable format. These representations determine the performance of the model to a large extent.\\n\\n- Pretrained [Glove](https://nlp.stanford.edu/projects/glove/) vectors\\n- Pretrained [fasttext](https://fasttext.cc/docs/en/english-vectors.html) vectors\\n- Pretrained [word2vec](https://radimrehurek.com/gensim/models/word2vec.html) vectors\\n- My previous article on these [3 embeddings](https://neptune.ai/blog/document-classification-small-datasets)\\n- Combining [pre-trained vectors](https://www.kaggle.com/c/quora-insincere-questions-classification/discussion/71778/). This can help in better representation of text and decreasing OOV words\\n- [Paragram](https://cogcomp.seas.upenn.edu/page/resource_view/106) embeddings\\n- [Universal Sentence Encoder](https://tfhub.dev/google/universal-sentence-encoder/1)\\n- Use USE to generate [sentence-level features](https://www.kaggle.com/abhishek/distilbert-use-features-oof)\\n- 3 methods to [combine embeddings](https://www.kaggle.com/c/quora-insincere-questions-classification/discussion/71778)\\n\\nContextual embeddings models\\n\\n- [BERT](https://github.com/google-research/bert) Bidirectional Encoder Representations from Transformers\\n- [GPT](https://github.com/openai/finetune-transformer-lm)\\n- [Roberta](https://github.com/pytorch/fairseq/tree/master/examples/roberta) a Robustly Optimized BERT\\n- [Albert](https://github.com/google-research/ALBERT) a Lite BERT for Self-supervised Learning of Language Representations\\n- [Distilbert](https://github.com/huggingface/transformers/tree/master/examples/distillation) a lighter version of BERT\\n- [XLNET](https://github.com/zihangdai/xlnet/)\\n\\n## Modeling\\n\\n### Model architecture\\n\\nChoosing the right architecture is important to develop a proper machine learning model, sequence to sequence models like LSTMs, GRUs perform well in NLP problems and is always worth trying. Stacking 2 layers of LSTM/GRU networks is a common approach.\\n\\n- [Stacking Bidirectional CuDNNLSTM](https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52644/)\\n- [Stacking LSTM networks](https://www.kaggle.com/sakami/google-quest-single-lstm/)\\n- [LSTM and 5 fold Attention](https://www.kaggle.com/christofhenkel/keras-baseline-lstm-attention-5-fold/)\\n- [Bi...\\n\\n--- Result 3 ---\\nTitle: Tabular Data Binary Classification: All Tips and Tricks from 5 Kaggle Competitions\\nURL: https://neptune.ai/blog/tabular-data-binary-classification-tips-and-tricks-from-5-kaggle-competitions\\n\\nContent:\\nTabular Data Binary Classification: All Tips and Tricks from 5 Kaggle Competitions[\\n**📣 BIG NEWS:****Neptune is joining OpenAI!**→ Read the message from our CEO 📣![](https://neptune.ai/wp-content/themes/neptune/img/image-ratio-holder.svg)](https://neptune.ai/blog/we-are-joining-openai)\\n[![logo](https://neptune.ai/wp-content/themes/neptune/img/logo-neptune.svg)](https://neptune.ai)\\n![search](https://neptune.ai/wp-content/themes/neptune/img/icon-search.svg)\\nWhat do you want to find?\\nSearch\\n![cancel](https://neptune.ai/wp-content/themes/neptune/img/image-ratio-holder.svg)\\n[Log in](https://app.neptune.ai/login)[Contact us](https://neptune.ai/contact-us)\\n[![Home](https://neptune.ai/wp-content/themes/neptune/img/icon-breadcrumbs-home.svg)](https://neptune.ai/)&gt;[Blog](https://neptune.ai/blog)&gt;[ML Model Development](https://neptune.ai/blog/category/machine-learning-model-development)\\nSearch in Blog...\\n![search](https://neptune.ai/wp-content/themes/neptune/img/image-ratio-holder.svg)\\n![search](https://neptune.ai/wp-content/themes/neptune/img/icon-search.svg)![cancel](https://neptune.ai/wp-content/themes/neptune/img/image-ratio-holder.svg)\\nSearch in Blog...\\n![search](https://neptune.ai/wp-content/themes/neptune/img/image-ratio-holder.svg)\\n[Neptune Blog](https://neptune.ai/blog)# Tabular Data Binary Classification: All Tips and Tricks from 5 Kaggle Competitions\\n![Author image](https://i0.wp.com/neptune.ai/wp-content/uploads/2022/11/Shahul-Es-new-scaled.jpeg?fit=2560%2C1920&ssl=1)\\n[Shahul ES](https://neptune.ai/blog/author/shahules)\\n![](https://neptune.ai/wp-content/themes/neptune/img/icon-meta-time.svg)3 min\\n![](https://neptune.ai/wp-content/themes/neptune/img/icon-meta-date.svg)1st September, 2023\\n[ML Model Development](https://neptune.ai/blog/category/machine-learning-model-development)[Tabular Data](https://neptune.ai/blog/category/tabular-data)\\nIn this article, I will discuss some great tips and tricks to improve the performance of your structured data binary classification model. These tricks are obtained from solutions of some of Kaggle’s top tabular data competitions. Without much lag, let’s begin.\\nThese are the five competitions that I have gone through to create this article:\\n* [**Home credit default risk**](https://www.kaggle.com/c/home-credit-default-risk/)\\n* [**Santander Customer Transaction Prediction**](https://www.kaggle.com/c/santander-customer-transaction-prediction/notebooks)\\n* [**VSB Power Line Fault Detection**](https://www.kaggle.com/c/vsb-power-line-fault-detection/overview/evaluation)\\n* [**Microsoft Malware Prediction**](https://www.kaggle.com/c/microsoft-malware-prediction/overview)\\n* [**IEEE-CIS Fraud Detection**](https://www.kaggle.com/c/ieee-fraud-detection/overview/evaluation/)## Dealing with larger datasets\\nOne issue you might face in any machine learning competition is the size of your data set. If the size of your data is large, that is 3GB + for kaggle kernels and more basic laptops you could find it difficult to load and process with limited resources. Here is the link to some of the articles and kernels that I have found useful in such situations.\\n* Faster[data loading with pandas.](https://www.kaggle.com/c/home-credit-default-risk/discussion/59575)\\n* Data compression techniques to[reduce the size of data by 70%](https://www.kaggle.com/nickycan/compress-70-of-dataset).\\n* Optimize the memory by r[educing the size of some attributes.](https://www.kaggle.com/shrutimechlearn/large-data-loading-trick-with-ms-malware-data)\\n* Use open-source libraries such as[Dask to read and manipulate the data](https://www.kaggle.com/yuliagm/how-to-work-with-big-datasets-on-16g-ram-dask), it performs parallel computing and saves up memory space.\\n* Use[cudf](https://github.com/rapidsai/cudf).\\n* Convert data to[parquet](https://arrow.apache.org/docs/python/parquet.html)format.\\n* Converting data to[feather](https://medium.com/@snehotosh.banerjee/feather-a-fast-on-disk-format-for-r-and-python-data-frames-de33d0516b03)format.\\n* Reducing memory usage for[optimizing RAM](https://www.kaggle.com/mjbahmani/reducing-memory-size-for-ieee).## Data exploration\\nData exploration always helps to better understand the data and gain insights from it. Before starting to develop machine learning models, top competitors always read/do a lot of exploratory data analysis for the data. This helps in feature engineering and cleaning of the data.\\n* EDA for microsoft[malware detection.](https://www.kaggle.com/youhanlee/my-eda-i-want-to-see-all)\\n* Time Series[EDA for malware detection.](https://www.kaggle.com/cdeotte/time-split-validation-malware-0-68)\\n* Complete[EDA for home credit loan prediction](https://www.kaggle.com/codename007/home-credit-complete-eda-feature-importance).\\n* Complete[EDA for Santader prediction.](https://www.kaggle.com/gpreda/santander-eda-and-prediction)\\n* EDA for[VSB Power Line Fault Detection.](https://www.kaggle.com/go1dfish/basic-eda)## Data preparation\\nAfter data exploration, the first thing to do is to use those insights to prepare the data. To tackle issues like class imbalance, encoding categorical data, etc. Let’s see the methods used to do it.\\n* Methods to t[ackle class imbalance](https://www.kaggle.com/shahules/tackling-class-imbalance).\\n* Data augmentation by[Synthetic Minority Oversampling Technique](https://machinelearningmastery.com/smote-oversampling-for-imbalanced-classification/).\\n* Fast inplace[shuffle for augmentation](https://www.kaggle.com/jiweiliu/fast-inplace-shuffle-for-augmentation).\\n* Finding[synthetic samples in the dataset.](https://www.kaggle.com/yag320/list-of-fake-samples-and-public-private-lb-split)\\n* [Signal denoising](https://www.kaggle.com/jackvial/dwt-signal-denoising)used in signal processing competitions.\\n* Finding[patterns of missing data](https://www.kaggle.com/jpmiller/patterns-of-missing-data).\\n* Methods to handle[missing data](https://towardsdatascience.com/6-different-ways-to-compensate-for-missing-values-data-imputation-with-examples-6022d9ca0779).\\n* An overview of various[encoding techniques for categorical data.](https://www.kaggle.com/shahules/an-overview-of-encoding-techniques)\\n* Building[model to predict missing values.](https://www.kaggle.com/c/home-credit-default-risk/discussion/64598)\\n* Random[shuffling of data](https://www.kaggle.com/brandenkmurray/randomly-shuffled-data-also-works)to create new synthetic training set.## Feature engineering\\nNext, you can check the most popular feature and feature engineering techniques used in these top kaggle competitions. The feature engineering part varies from problem to problem depending on the domain.\\n* Target[encoding cross validation](https://medium.com/@pouryaayria/k-fold-target-encoding-dfe9a594874b/)for better encoding.\\n* Entity embedding to[handle categories](https://www.kaggle.com/abhishek/entity-embeddings-to-handle-categories).\\n* Encoding c[yclic features for deep learning.](https://www.kaggle.com/avanwyk/encoding-cyclical-features-for-deep-learning)\\n* Manual[feature engineering methods](https://www.kaggle.com/willkoehrsen/introduction-to-manual-feature-engineering).\\n* Automated feature engineering techniques[using featuretools](https://www.kaggle.com/willkoehrsen/automated-feature-engineering-basics).\\n* Top hard crafted features used in[microsoft malware detection](https://www.kaggle.com/sanderf/7th-place-solution-microsoft-malware-prediction).\\n* Denoising NN for[feature extraction](https://towardsdatascience.com/applied-deep-learning-part-3-autoencoders-1c083af4d798).\\n* Feature engineering[using RAPIDS framework.](https://www.kaggle.com/cdeotte/rapids-feature-engineering-fraud-0-96/)\\n* Things to remember while processing f[eatures using LGBM.](https://www.kaggle.com/c/ieee-fraud-detection/discussion/108575)\\n* [Lag features and moving averages.](https://www.kaggle.com/c/home-credit-default-risk/discussion/64593)\\n* [Principal component analysis](https://medium.com/machine-learning-researcher/dimensionality-reduction-pca-and-lda-6be91734f567)for...\\n\\n--- Result 4 ---\\nTitle: How I handled imbalanced text data - Towards Data Science\\nURL: https://towardsdatascience.com/how-i-handled-imbalanced-text-data-ba9b757ab1d8?gi=f37886eebb72\\n\\nContent:\\n[Open in app](https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2Fba9b757ab1d8&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------)\\n\\n[Sign up](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-i-handled-imbalanced-text-data-ba9b757ab1d8&source=post_page---two_column_layout_nav-----------------------global_nav-----------)\\n\\n[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-i-handled-imbalanced-text-data-ba9b757ab1d8&source=post_page---two_column_layout_nav-----------------------global_nav-----------)\\n\\n[Write](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_topnav-----------)\\n\\n[Sign up](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-i-handled-imbalanced-text-data-ba9b757ab1d8&source=post_page---two_column_layout_nav-----------------------global_nav-----------)\\n\\n[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-i-handled-imbalanced-text-data-ba9b757ab1d8&source=post_page---two_column_layout_nav-----------------------global_nav-----------)\\n\\n![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)\\n\\n# **How I handled imbalanced text data**\\n\\n## Blueprint to tackle one of the most common problems in AI\\n\\n[![Yogesh Kothiya](https://miro.medium.com/v2/resize:fill:88:88/1*zNkUFlexn9RWHc--UuuQ5w.jpeg)](https://medium.com/@kothiya.yogesh?source=post_page-----ba9b757ab1d8--------------------------------)[![Towards Data Science](https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg)](https://towardsdatascience.com/?source=post_page-----ba9b757ab1d8--------------------------------)\\n\\n[Yogesh Kothiya](https://medium.com/@kothiya.yogesh?source=post_page-----ba9b757ab1d8--------------------------------)\\n\\n·\\n\\n[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fd310856a9437&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-i-handled-imbalanced-text-data-ba9b757ab1d8&user=Yogesh+Kothiya&userId=d310856a9437&source=post_page-d310856a9437----ba9b757ab1d8---------------------post_header-----------)\\n\\nPublished in\\n\\n[Towards Data Science](https://towardsdatascience.com/?source=post_page-----ba9b757ab1d8--------------------------------)\\n\\n·\\n\\n5 min read\\n\\n·\\n\\nMay 15, 2019\\n\\n--\\n\\n2\\n\\nListen\\n\\nShare\\n\\nPhoto by [Form](https://unsplash.com/@theformfitness?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)\\n\\nThe problem of imbalanced class distribution is prevalent in the field of data science and ML engineers come across it frequently. I am a chatbot developer at [IMImoble Pvt Ltd](https://imimobile.com/) and faced this scenario recently while training intent classification module. Any live business chatbot accessible to real-world users is bound to attract a significant number of out-of-scope queries along with messages pertaining to the task it is designed to perform. Even among the relevant task-oriented messages, imbalances are to be expected as all topics covered by the bot can’t be equally popular. For example, in a banking use case, balance inquiries will outnumber home loan applications.\\n\\nBot building is not similar to traditional application development. While the latter is relatively stable and is updated less often, the former needs frequent updates to improve user experience and intelligence of the bot. The imbalanced dataset is the problem where data belonging to one class is significantly higher or lower than that belonging to other classes. Most ML/DL classification algorithms aren’t equipped to handle imbalanced classes and tend to get biased towards majority classes.\\n\\n# **Why accuracy is a sham in the case of an imbalanced dataset**\\n\\nAiming only for high accuracy for the imbalanced dataset can be counter-productive because standard classifier algorithms like Decision Trees and Logistic Regression do not have the ability to handle imbalanced classes incorporated into them. This leads to a heavy bias towards larger classes and classes with fewer data points are treated as noise and are often ignored. The result is a higher misclassification rate for minority classes compared to the majority classes. Therefore, the accuracy metric is not as relevant when evaluating the performance of a model trained on imbalanced data.\\n\\nConsider the following case: you have two classes — A and B. Class A is 95% of your dataset and class B is the other 5%. You can reach an accuracy of 95% by simply predicting class A every time, but this provides a useless classifier for your intended use case. Instead, a properly calibrated method may achieve a lower accuracy but would have a substantially higher true positive rate (or recall), which is really the metric you should have been optimizing for.\\n\\n[This](https://www.analyticsvidhya.com/blog/2017/03/imbalanced-classification-problem/) article explains several methods to handle imbalanced dataset but most of them don’t work well for text data. In this article, I am sharing all the tricks and techniques I have used to balance my dataset along with the code which boosted f1-score by 30%.\\n\\n# Strategies for handling Imbalanced Datasets:\\n\\n**Can you gather more data?**\\n\\nYou might think that this is not the solution you’re looking for but gathering more meaningful and diverse data is always better than sampling original data or generating artificial data from existing data points.\\n\\n**Removing data redundancy:**\\n\\n1. Removing duplicate data — The dataset I was dealing with contained a lot of similar and even duplicate data points. “Where is my order” and “Where is the order” has the same semantic meaning. Removing such duplicate message will help you reduce the size of your majority class.\\n2. There were many messages which had the same semantic meaning, for example, consider the following messages, which convey the same meaning. Keeping one or two such utterances and removing others also helps in balancing classes. Well, you can use those messages in the validation set. There are many ways to find text similarity but I have used Jaccard Similarity because it is very easy to implement and it considers only unique sets of words while calculating similarity. You can look at other techniques in [this](https://medium.com/@adriensieg/text-similarities-da019229c894) article.\\n\\n_Can I change the delivery time for my delivery?_\\n\\n_Can I change time of my delivery?_\\n\\n_Can I change delivery time?_\\n\\n3\\\\. Merge minority classes — Sometimes multiple classes have overlapping features. It’s better to merge those multiple minority classes. This trick helped me improve f1-score by more than 10%.\\n\\n**Resample training dataset:**\\n\\nThe simplest way to fix imbalanced dataset is simply balancing them by oversampling instances of the minority class or undersampling instances of the majority class. Using advanced techniques like SMOTE(Synthetic Minority Over-sampling Technique) will help you create new synthetic instances from minority class.\\n\\n1. Undersampling — An effort to eliminate data point from the majority class randomly until the classes are balanced. There is a likelihood of information loss which might lead to poor model training.\\n2. Oversampling — This is the process to replicate minority class instances randomly. This approach can overfit and lead to inaccurate predictions on test data.\\n3. SMOTE — SMOTE generates synthetic samples by taking each minority class sample and introducing synthetic examples along the line segments joining any/all of the k minority class nearest neighbors as shown in below GIF. More importantly, this approach effectively forces the decision region of the minority class to beco...\\n\\n--- Result 5 ---\\nTitle: AIcrowd | Dealing with Class Imbalance | Posts\\nURL: https://www.aicrowd.com/showcase/dealing-with-class-imbalance\\n\\nContent:\\nLoading\\n\\n#### [ADDI Alzheimers Detection Challenge](https://www.aicrowd.com/challenges/addi-alzheimers-detection-challenge)\\n\\n# Dealing with Class Imbalance\\n\\nLooking at different ways to address class imbalance in this dataset\\n\\nJohnowhitaker7 May 2021\\n\\n[20](https://www.aicrowd.com/participants/sign_in) [Open in Colab](https://colab.research.google.com/gist/aicrowd-bot/d9ed51a8b9be2026f0ff96c2b5cad9c2)\\n\\nIn this notebook I take a close look at some different ways we can address the difference in class balance between train and validation (and presumably test)\\n\\nWe look at changing sample weights, over and under-sampling, SMOTE and some other tips and tricks.\\n\\nI hope you find it helpful :)\\n\\n# Introduction [¶](https://www.aicrowd.com/www.aicrowd.com\\\\#Introduction)\\n\\nSo you've made your first model for this challenge and it's getting a log loss of ~0.9 - a ways behind the leaders on 0.6X. You're starting to think about feature engineering, adding more models to your ensemble, maybe trying one of those tabular deep learning models the cool kids are talking about. **STOP!** Before any of that, there is one BIG issue we need to deal with: class (im)balance.\\n\\nThe validation set (and presumably the test set) has a different class distribution to the training data. In this notebook we will look at many different ways we can correct for this class imbalance - picking one of these will boost your score tremendously (we're taking ~0.66 with a single simple random forest model). So, let's dive in.\\n\\n# Setup [¶](https://www.aicrowd.com/www.aicrowd.com\\\\#Setup)\\n\\nImporting the libraries we'll be using, loading the data and getting ready to run our experiments.\\n\\nIn \\\\[1\\\\]:\\n\\n```\\nimport pandas as pd\\nimport numpy as np\\nfrom sklearn.ensemble import RandomForestClassifier\\nfrom catboost import CatBoostClassifier, Pool\\nfrom sklearn.metrics import f1_score, log_loss\\nfrom imblearn.over_sampling import SMOTE\\nfrom imblearn.under_sampling import RandomUnderSampler\\nfrom imblearn.pipeline import Pipeline\\n```\\n\\nIn \\\\[2\\\\]:\\n\\n```\\n#The training data\\ndf = pd.read_csv('ds_shared_drive/train.csv')\\nprint(df.shape)\\ndf.head(2)\\n```\\n\\n```\\n(32777, 122)\\n\\n```\\n\\nOut\\\\[2\\\\]:\\n\\n| row\\\\_id | number\\\\_of\\\\_digits | missing\\\\_digit\\\\_1 | missing\\\\_digit\\\\_2 | missing\\\\_digit\\\\_3 | missing\\\\_digit\\\\_4 | missing\\\\_digit\\\\_5 | missing\\\\_digit\\\\_6 | missing\\\\_digit\\\\_7 | missing\\\\_digit\\\\_8 | ... | bottom\\\\_area\\\\_perc | left\\\\_area\\\\_perc | right\\\\_area\\\\_perc | hor\\\\_count | vert\\\\_count | eleven\\\\_ten\\\\_error | other\\\\_error | time\\\\_diff | centre\\\\_dot\\\\_detect | diagnosis |\\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\\n| 0 | S0CIXBKIUEOUBNURP | 12.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | ... | 0.52617 | 0.524975 | 0.474667 | 0 | 0 | 0 | 1 | -105.0 | 0.0 | normal |\\n| 1 | IW1Z4Z3H720OPW8LL | 12.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | ... | 0.00081 | 0.516212 | 0.483330 | 0 | 1 | 0 | 1 | NaN | NaN | normal |\\n\\n2 rows × 122 columns\\n\\nIn \\\\[3\\\\]:\\n\\n```\\n# The validation data (we merge in the labels for convenience)\\nval = pd.read_csv('ds_shared_drive/validation.csv')\\nval = pd.merge(val, pd.read_csv('ds_shared_drive/validation_ground_truth.csv'),\\n               how='left', on='row_id')\\nprint(val.shape)\\nval.head()\\n```\\n\\n```\\n(362, 122)\\n\\n```\\n\\nOut\\\\[3\\\\]:\\n\\n| row\\\\_id | number\\\\_of\\\\_digits | missing\\\\_digit\\\\_1 | missing\\\\_digit\\\\_2 | missing\\\\_digit\\\\_3 | missing\\\\_digit\\\\_4 | missing\\\\_digit\\\\_5 | missing\\\\_digit\\\\_6 | missing\\\\_digit\\\\_7 | missing\\\\_digit\\\\_8 | ... | bottom\\\\_area\\\\_perc | left\\\\_area\\\\_perc | right\\\\_area\\\\_perc | hor\\\\_count | vert\\\\_count | eleven\\\\_ten\\\\_error | other\\\\_error | time\\\\_diff | centre\\\\_dot\\\\_detect | diagnosis |\\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\\n| 0 | LA9JQ1JZMJ9D2MBZV | 11.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | ... | 0.499368 | 0.553194 | 0.446447 | 0 | 0 | 0 | 1 | NaN | NaN | post\\\\_alzheimer |\\n| 1 | PSSRCWAPTAG72A1NT | 6.0 | 1.0 | 1.0 | 0.0 | 1.0 | 1.0 | 0.0 | 0.0 | 0.0 | ... | 0.427196 | 0.496352 | 0.503273 | 0 | 1 | 0 | 1 | NaN | NaN | normal |\\n| 2 | GCTODIZJB42VCBZRZ | 11.0 | 0.0 | 0.0 | 0.0 | 0.0 | 1.0 | 0.0 | 0.0 | 0.0 | ... | 0.505583 | 0.503047 | 0.496615 | 1 | 0 | 0 | 0 | 0.0 | 0.0 | normal |\\n| 3 | 7YMVQGV1CDB1WZFNE | 3.0 | 1.0 | 0.0 | 1.0 | 0.0 | 1.0 | 1.0 | 1.0 | 1.0 | ... | 0.444633 | 0.580023 | 0.419575 | 0 | 1 | 0 | 1 | NaN | NaN | post\\\\_alzheimer |\\n| 4 | PHEQC6DV3LTFJYIJU | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 0.0 | ... | 0.395976 | 0.494990 | 0.504604 | 0 | 0 | 0 | 1 | 150.0 | 0.0 | normal |\\n\\n5 rows × 122 columns\\n\\nIn \\\\[4\\\\]:\\n\\n```\\n# We'll keep track of how different approaches perform\\nresults = []\\n```\\n\\n# Baseline \\\\#1 - Training on all data [¶](https://www.aicrowd.com/www.aicrowd.com\\\\#Baseline-%231---Training-on-all-data)\\n\\nThis is a case where we don't do any correction for the class imbalance. Some models will do better than others - tree-based models like CatBoost will be less sensitive than some other model types, but they will still over-estimate the probability that a given sample will fall into the majority class when making predicitons on the validation set (since the 'normal' class is so much more common in the training data).\\n\\nIn \\\\[5\\\\]:\\n\\n```\\n# Prep the data\\nX = df.drop(['row_id', 'diagnosis'], axis=1).fillna(0)\\ny = df['diagnosis']\\nX_val = val.drop(['row_id', 'diagnosis'], axis=1).fillna(0)\\ny_val = val['diagnosis']\\n\\n# Train the model\\nmodel = CatBoostClassifier(verbose=False, cat_features=['intersection_pos_rel_centre'])\\n\\n# Evaluate on val set\\nmodel.fit(X, y, eval_set = (X_val, y_val), early_stopping_rounds = 30)\\n\\n# Store results\\nr = {'Approach':'No modifications',\\n     'Log Loss':log_loss(y_val, model.predict_proba(X_val)),\\n     'F1':f1_score(y_val, model.predict(X_val), average='macro')\\n    }\\nresults.append(r)\\n\\nprint(r) # Show results\\n```\\n\\n```\\n{'Approach': 'No modifications', 'Log Loss': 0.6745549053231596, 'F1': 0.2848101265822785}\\n\\n```\\n\\nA log loss of 0.67 on the validation set isn't terrible. We are using the validation set for early stopping - without that in place we get a log loss of 0.78 on our validation set and 0.8X on the leaderboard. So in a way, by using the validation set for early stopping we are already starting to combat our class balance problem... but we can do much better!\\n\\n# Adjusting Sample Weights [¶](https://www.aicrowd.com/www.aicrowd.com\\\\#Adjusting-Sample-Weights)\\n\\nModels like CatBoost allow us to assign more weight to specific samples. In this case, we use this to place less weight on samples in the over-represented classes, combating the bias introduced by the imbalance:\\n\\nIn \\\\[6\\\\]:\\n\\n```\\n# Prep the data\\nX = df.drop(['row_id', 'diagnosis'], axis=1).fillna(0)\\ny = df['diagnosis']\\nX_val = val.drop(['row_id', 'diagnosis'], axis=1).fillna(0)\\ny_val = val['diagnosis']\\n\\n#Our class weights\\nweights = {\\n    'normal':9/74, # Chosen based on some quick mental maths comparing the distribution of train vs val\\n    'post_alzheimer':0.85,\\n    'pre_alzheimer':1\\n}\\n\\n# Applying these weights as sample weights by using Pool to wrap our training data\\ntrain_data = Pool(\\n    data = X,\\n    label = y,\\n    weight = y.map(weights), # << The important bit\\n    cat_features = [list(X.columns).index('intersection_pos_rel_centre')]\\n)\\n\\neval_data = Pool(\\n    data = X_val,\\n    label = y_val,\\n    weight = y_val.map(lambda x: 1.0), # all validation samples get a weight of 1\\n    cat_features = [list(X.columns).index('intersection_pos_rel_centre')]\\n)\\n\\n# Train the model\\nmodel = CatBoostClassifier(verbose=False)\\n\\n# Evaluate on val set\\nmodel.fit(train_data, eval_set = eval_data, early_stopping_rounds = 30)\\n\\n# Store results\\nr = {'Approach':'Modifying Sample Weights',\\n     'Log Loss':log_loss(y_val, model.predict_proba(X_val)),\\n     'F1':f1_score(y_val, model.predict(X_val), average='macro')\\n    }\\nresults.append(r)\\n\\nprint(r) # Show results\\n```\\n\\n```\\n{'Approach': 'Modifying Sample Weights', 'Log Loss': 0.5593949556085255, 'F1': 0.4727603953181...\\n\\n--- Result 6 ---\\nURL: https://blog.ceshine.net/post/kaggle-toxic-comment-classification-challenge\\n\\nContent:\\n<div><section>\\n <figure><figcaption>\\n <p><a href=\\\"https://pixabay.com/en/pollution-toxic-products-environment-3075857/\\\">Photo Credit</a></p>\\n </figcaption>\\n</figure>\\n<h2>Introduction</h2>\\n<p><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge\\\">Jigsaw toxic comment classification challenge</a> features a multi-label text classification problem with a highly imbalanced dataset. The test set used originally was revealed to be already public on the Internet, so <a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/47835\\\">a new dataset was released</a> mid-competition, and the evaluation metric was <a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/48639\\\">changed from Log Loss to AUC</a>.</p>\\n<p>I tried a few ideas after building up my PyTorch pipeline but did not find any innovative approach that looks promising. Text normalization is the only strategy I had found to give solid improvements, but it is very time consuming. The final result (105th place/about top 3%) was quite fitting IMO given the time I spent on this competition(not a lot).</p>\\n<p>(There were some <a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52574\\\">heated discussion</a> around the topic of some top-ranking teams with Kaggle grand masters getting disqualified after the competition ended.)</p>\\n<p>Public kernel blends performed well in this competition (i.e. did not over-fit the public leaderboard too much). I expected it to overfit, but still selected one final submission that used the best public blend of blends to play it safe. Fortunately it paid off and gave me a 0.0001 boost in AUC on private leaderboard:</p>\\n<figure><figcaption>\\n <p><a href=\\\"https://docs.google.com/spreadsheets/d/1R3u6tXDa9CVByaRW9FY8FpxRTqwZsBWfLYuqC1gu8A8/edit?usp=sharing\\\">Table 1: Selected submissions in descending order of private scores</a></p>\\n </figcaption>\\n</figure>\\n<p>In this post, I’ll review some of the techniques used and shared by top competitors. I do not have enough time to test every one of them myself. Part 2 of this series will be implementing a top 5 solution by my own, if I ever find time to do it.</p>\\n<h2>List of Techniques</h2>\\n<p>I tired to attribute techniques to all appropriate sources, but I’m sure I’ve missed some sources here and there. <strong><em>Not all techniques are covered because of the vast amount of contents shared by generous Kagglers</em></strong>. I might come back and edit this list in the near future.</p>\\n<ul>\\n<li>Translation as Augmentation (test time and train time) [1][2][13]</li>\\n<li>Pseudo-labelling [1]</li>\\n<li>Text normalization [3][4]</li>\\n<li>Multi-level stacking — 4 levels [3]; 2 levels [11]; 1level stacking + 1 level weighted averaging [12]</li>\\n<li>Non-English embeddings [2]</li>\\n<li>Diverse pre-trained embeddings — Train multiple model separately on different embeddings</li>\\n<li>Combine several pre-trained embeddings — concatenate after a RNN layer [3]; Concatenate at embedding level [5]; Variant of <a href=\\\"https://arxiv.org/abs/1705.02798\\\">Reinforced Mnemonic Reader</a> [7]</li>\\n<li>When truncating texts, retain both head and tail of the texts [1]</li>\\n<li>K-max pooling[6]</li>\\n<li>Multiple-level of stacking [3]</li>\\n<li>Deepmoji-style attention model [3]</li>\\n<li>(NN) Additional row-level features:<em>“Unique words rate” and “Rate of all-caps words”</em>[4]</li>\\n<li>(NN) Additional word-level feature(s): If a word contains only capital letters [4]</li>\\n<li>(GBM) Engineered features other than tf-idf [12]</li>\\n<li>BytePair Encoding [5][8]</li>\\n<li><a href=\\\"https://www.microsoft.com/en-us/research/wp-content/uploads/2017/05/r-net.pdf\\\">R-net</a> [7]</li>\\n<li>CapsuleNet [11]</li>\\n<li>Label aware attention layer [7]</li>\\n<li>(20180413 Update) leaky information — small overlaps of IPs between training and testing dataset. One overlapping username. [14]</li>\\n</ul>\\n<h2>Pseudo-labelling and Head-Tail Truncating</h2>\\n<p>I’ve already tried these two techniques and trained a couple of models for each.</p>\\n<p>Head-tail truncating (keeping 250 tokens at head, 50 tokens at tail) helped only a bit for bi-GRU, but not for QRNN. It basically had no effect on my final ensemble.</p>\\n<p>For pseudo-labelling(PL), I used the test-set predictions from my best ensemble as suggested in [1], and they improved the final ensemble a little (see table 1). I’d assume that adding more model trained with PL will further boost the final AUC. However, the problem of this approach is the leakage it produces. The ensemble model had seen the the all the validation data, and that information leaked into its test set predictions. So the local CV will be distorted and not comparable to those trained without PL. Nonetheless, this technique does create the best single model, so it’ll be quite useful for production deployment.</p>\\n<p>I think the more conservative way of doing PL is to repeat the train-predict-train(with PL) process, so the model is trained twice for every fold. But that’ll definitely takes more time.</p>\\n<h2>References:</h2>\\n<ol>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52557\\\">The 1st place solution overview</a> by <a href=\\\"https://www.kaggle.com/leecming\\\">Chun Ming Lee</a> from team <em>Toxic Crusaders</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52612\\\">The 2nd place solution overview</a> by <a href=\\\"https://www.kaggle.com/neongen\\\">neongen</a> from team <em>neongen &amp; Computer says no</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52762\\\">The 3rd place solution overview</a> by <a href=\\\"https://www.kaggle.com/tunguz\\\">Bojan Tunguz</a> from team <em>Adversarial Autoencoder</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52644\\\">About my 0.9872 single model</a> by <a href=\\\"https://www.kaggle.com/mrboor\\\">Alexander Burmistrov</a> from team <em>Adversarial Autoencoder</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52630\\\">The 5th place brief solution</a> by <a href=\\\"https://www.kaggle.com/kazanova\\\">Μαριος Μιχαηλιδης KazAnova</a> from team <em>TPMPM</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52526\\\">Congrats (from ghost 11th team)</a> by <a href=\\\"https://www.kaggle.com/cpmpml\\\">CPMP</a></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52702\\\">The 12th place single model solution share</a> by <a href=\\\"https://www.kaggle.com/goldenlock\\\">BackFactoryVillage</a> from team <em>Knights of the Round Table</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52563\\\">The 15th solution summary: Byte Pair Encoding</a> by <a href=\\\"https://www.kaggle.com/tezdhar\\\">Mohsin hasan</a> from team <em>Zehar 2.0</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52647\\\">The 25th Place Notes (0.9872 public; 0.9873 private)</a> by <a href=\\\"https://www.kaggle.com/jtrotman\\\">James Trotman</a> (solo)</li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52719\\\">The 27th place solution overview</a> by <a href=\\\"https://www.kaggle.com/zake7749\\\">Justin Yang</a> from team <em>Sotoxic</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52666\\\">The 33rd Place Solution Using Embedding Imputation (0.9872 private, 0.9876 public)</a> by <a href=\\\"https://www.kaggle.com/mmotoki\\\">Matt Motoki</a> (solo)</li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52645\\\">The 34th, Lots of FE and Poor Understanding of NNs [CODE INCLUDED]</a> by <a href=\\\"https://www...\\n\\n--- Result 7 ---\\nTitle: Classification on imbalanced data \\n\\n    \\n    \\n       \\n    \\n\\n     \\n      \\n      Stay organized with collections\\n     \\n     \\n      \\n      Save and categorize content based on your preferences.\\nURL: https://www.tensorflow.org/tutorials/structured_data/imbalanced_data\\n\\nContent:\\nClassification on imbalanced data | TensorFlow Core[Skip to main content](#main-content)\\n[![TensorFlow](https://www.gstatic.com/devrel-devsite/prod/ve08add287a6b4bdf8961ab8a1be50bf551be3816cdd70b7cc934114ff3ad5f10/tensorflow/images/lockup.svg)](https://www.tensorflow.org/)\\n* /\\n* English\\n* Español –América Latina\\n* Français\\n* Indonesia\\n* Italiano\\n* Polski\\n* Português –Brasil\\n* Tiếng Việt\\n* Türkçe\\n* Русский* עברית* العربيّة* فارسی* हिंदी* বাংলা* ภาษาไทย* 中文–简体* 日本語* 한국어[GitHub](https://github.com/tensorflow)Sign in\\n* [TensorFlow Core](https://www.tensorflow.org/tutorials)\\n* [TensorFlow](https://www.tensorflow.org/)\\n* [Learn](https://www.tensorflow.org/learn)\\n* [TensorFlow Core](https://www.tensorflow.org/tutorials)\\n# Classification on imbalanced dataStay organized with collectionsSave and categorize content based on your preferences.\\n[![](https://www.tensorflow.org/images/tf_logo_32px.png)View on TensorFlow.org](https://www.tensorflow.org/tutorials/structured_data/imbalanced_data)|[![](https://www.tensorflow.org/images/colab_logo_32px.png)Run in Google Colab](https://colab.research.google.com/github/tensorflow/docs/blob/master/site/en/tutorials/structured_data/imbalanced_data.ipynb)|[![](https://www.tensorflow.org/images/GitHub-Mark-32px.png)View source on GitHub](https://github.com/tensorflow/docs/blob/master/site/en/tutorials/structured_data/imbalanced_data.ipynb)|[![](https://www.tensorflow.org/images/download_logo_32px.png)Download notebook](https://storage.googleapis.com/tensorflow_docs/docs/site/en/tutorials/structured_data/imbalanced_data.ipynb)|\\nThis tutorial demonstrates how to classify a highly imbalanced dataset in which the number of examples in one class greatly outnumbers the examples in another. You will work with the[Credit Card Fraud Detection](https://www.kaggle.com/mlg-ulb/creditcardfraud)dataset hosted on Kaggle. The aim is to detect a mere 492 fraudulent transactions from 284,807 transactions in total. You will use[Keras](https://www.tensorflow.org/guide/keras/overview)to define the model and[class weights](https://www.tensorflow.org/versions/r2.0/api_docs/python/tf/keras/Model)to help the model learn from the imbalanced data. .\\nThis tutorial contains complete code to:\\n* Load a CSV file using Pandas.\\n* Create train, validation, and test sets.\\n* Define and train a model using Keras (including setting class weights).\\n* Evaluate the model using various metrics (including precision and recall).\\n* Select a threshold for a probabilistic classifier to get a deterministic classifier.\\n* Try and compare with class weighted modelling and oversampling.## Setup\\n```\\n`importtensorflowastffromtensorflowimportkerasimportosimporttempfileimportmatplotlibasmplimportmatplotlib.pyplotaspltimportnumpyasnpimportpandasaspdimportseabornassnsimportsklearnfromsklearn.metricsimportconfusion\\\\_matrixfromsklearn.model\\\\_selectionimporttrain\\\\_test\\\\_splitfromsklearn.preprocessingimportStandardScaler`\\n```\\n```\\n2024-08-20 01:23:52.305388: E external/local\\\\_xla/xla/stream\\\\_executor/cuda/cuda\\\\_fft.cc:485] Unable to register cuFFT factory: Attempting to register factory for plugin cuFFT when one has already been registered\\n2024-08-20 01:23:52.326935: E external/local\\\\_xla/xla/stream\\\\_executor/cuda/cuda\\\\_dnn.cc:8454] Unable to register cuDNN factory: Attempting to register factory for plugin cuDNN when one has already been registered\\n2024-08-20 01:23:52.333533: E external/local\\\\_xla/xla/stream\\\\_executor/cuda/cuda\\\\_blas.cc:1452] Unable to register cuBLAS factory: Attempting to register factory for plugin cuBLAS when one has already been registered\\n```\\n```\\n`mpl.rcParams['figure.figsize']=(12,10)colors=plt.rcParams['axes.prop\\\\_cycle'].by\\\\_key()['color']`\\n```\\n## Data processing and exploration\\n### Download the Kaggle Credit Card Fraud data set\\nPandas is a Python library with many helpful utilities for loading and working with structured data. It can be used to download CSVs into a Pandas[DataFrame](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas.DataFrame).\\n**Note:**This dataset has been collected and analysed during a research collaboration of Worldline and the[Machine Learning Group](http://mlg.ulb.ac.be)of ULB (Université Libre de Bruxelles) on big data mining and fraud detection. More details on current and past projects on related topics are available[here](https://www.researchgate.net/project/Fraud-detection-5)and the page of the[DefeatFraud](https://mlg.ulb.ac.be/wordpress/portfolio_page/defeatfraud-assessment-and-validation-of-deep-feature-engineering-and-learning-solutions-for-fraud-detection/)project\\n```\\n`file=tf.keras.utilsraw\\\\_df=pd.read\\\\_csv('https://storage.googleapis.com/download.tensorflow.org/data/creditcard.csv')raw\\\\_df.head()`\\n```\\n```\\n`raw\\\\_df[['Time','V1','V2','V3','V4','V5','V26','V27','V28','Amount','Class']].describe()`\\n```\\n### Examine the class label imbalance\\nLet's look at the dataset imbalance:\\n```\\n`neg,pos=np.bincount(raw\\\\_df['Class'])total=neg+posprint('Examples:\\\\\\\\nTotal:{}\\\\\\\\nPositive:{}({:.2f}% of total)\\\\\\\\n'.format(total,pos,100\\\\*pos/total))`\\n```\\n```\\nExamples:\\nTotal: 284807\\nPositive: 492 (0.17% of total)\\n```\\nThis shows the small fraction of positive samples.\\n### Clean, split and normalize the data\\nThe raw data has a few issues. First the`Time`and`Amount`columns are too variable to use directly. Drop the`Time`column (since it's not clear what it means) and take the log of the`Amount`column to reduce its range.\\n```\\n`cleaned\\\\_df=raw\\\\_df.copy()# You don't want the `Time` column.cleaned\\\\_df.pop('Time')# The `Amount` column covers a huge range. Convert to log-space.eps=0.001# 0 =&gt; 0.1¢cleaned\\\\_df['Log Amount']=np.log(cleaned\\\\_df.pop('Amount')+eps)`\\n```\\nSplit the dataset into train, validation, and test sets. The validation set is used during the model fitting to evaluate the loss and any metrics, however the model is not fit with this data. The test set is completely unused during the training phase and is only used at the end to evaluate how well the model generalizes to new data. This is especially important with imbalanced datasets where[overfitting](https://developers.google.com/machine-learning/crash-course/generalization/peril-of-overfitting)is a significant concern from the lack of training data.\\n```\\n`# Use a utility from sklearn to split and shuffle your dataset.train\\\\_df,test\\\\_df=train\\\\_test\\\\_split(cleaned\\\\_df,test\\\\_size=0.2)train\\\\_df,val\\\\_df=train\\\\_test\\\\_split(train\\\\_df,test\\\\_size=0.2)# Form np arrays of labels and features.train\\\\_labels=np.array(train\\\\_df.pop('Class')).reshape(-1,1)bool\\\\_train\\\\_labels=train\\\\_labels[:,0]!=0val\\\\_labels=np.array(val\\\\_df.pop('Class')).reshape(-1,1)test\\\\_labels=np.array(test\\\\_df.pop('Class')).reshape(-1,1)train\\\\_features=np.array(train\\\\_df)val\\\\_features=np.array(val\\\\_df)test\\\\_features=np.array(test\\\\_df)`\\n```\\nWe check whether the distribution of the classes in the three sets is about the same or not.\\n```\\n`print(f'Average class probability in training set:{train\\\\_labels.mean():.4f}')print(f'Average class probability in validation set:{val\\\\_labels.mean():.4f}')print(f'Average class probability in test set:{test\\\\_labels.mean():.4f}')`\\n```\\n```\\nAverage class probability in training set: 0.0017\\nAverage class probability in validation set: 0.0018\\nAverage class probability in test set: 0.0018\\n```\\nGiven the small number of positive labels, this seems about right.\\nNormalize the input features using the sklearn StandardScaler.\\nThis will set the mean to 0 and standard deviation to 1.\\n**Note:**The`StandardScaler`is only fit using the`train\\\\_features`to be sure the model is not peeking at the validation or test sets.\\n```\\n`scaler=StandardScaler()train\\\\_features=scaler.fit\\\\_transform(train\\\\_features)val\\\\_features=scaler.transform(val\\\\_features)test\\\\_features=scaler.transform(test\\\\_features)train\\\\_features=np.clip(train\\\\_features,-5,5)val\\\\_features=np.clip(val\\\\_features,-5,5)test\\\\_features=np.clip(test\\\\_features,-5,5)print('Training labels shape:',train\\\\_labels.shape)print('Validation labels shape:',...\\n\\n--- Result 8 ---\\nTitle: GitHub - rafiko1/jigsaw-multilingual-competition: TensorFlow code used by the 1st place winner of the 2020 Kaggle multilingual Toxic Comments competition\\nURL: https://github.com/rafiko1/jigsaw-multilingual-competition\\n\\nContent:\\n[Skip to content](https://github.com/rafiko1/jigsaw-multilingual-competition#start-of-content)\\n\\nYou signed in with another tab or window. [Reload](https://github.com/rafiko1/jigsaw-multilingual-competition) to refresh your session.You signed out in another tab or window. [Reload](https://github.com/rafiko1/jigsaw-multilingual-competition) to refresh your session.You switched accounts on another tab or window. [Reload](https://github.com/rafiko1/jigsaw-multilingual-competition) to refresh your session.Dismiss alert\\n\\n{{ message }}\\n\\n[rafiko1](https://github.com/rafiko1)/ **[jigsaw-multilingual-competition](https://github.com/rafiko1/jigsaw-multilingual-competition)** Public\\n\\n- [Notifications](https://github.com/login?return_to=%2Frafiko1%2Fjigsaw-multilingual-competition) You must be signed in to change notification settings\\n- [Fork\\\\\\n0](https://github.com/login?return_to=%2Frafiko1%2Fjigsaw-multilingual-competition)\\n- [Star\\\\\\n4](https://github.com/login?return_to=%2Frafiko1%2Fjigsaw-multilingual-competition)\\n\\n\\nTensorFlow code used by the 1st place winner of the 2020 Kaggle multilingual Toxic Comments competition\\n\\n[4\\\\\\nstars](https://github.com/rafiko1/jigsaw-multilingual-competition/stargazers) [0\\\\\\nforks](https://github.com/rafiko1/jigsaw-multilingual-competition/forks) [Branches](https://github.com/rafiko1/jigsaw-multilingual-competition/branches) [Tags](https://github.com/rafiko1/jigsaw-multilingual-competition/tags) [Activity](https://github.com/rafiko1/jigsaw-multilingual-competition/activity)\\n\\n[Star](https://github.com/login?return_to=%2Frafiko1%2Fjigsaw-multilingual-competition)\\n\\n[Notifications](https://github.com/login?return_to=%2Frafiko1%2Fjigsaw-multilingual-competition) You must be signed in to change notification settings\\n\\n# rafiko1/jigsaw-multilingual-competition\\n\\nThis commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.\\n\\nmaster\\n\\n[Branches](https://github.com/rafiko1/jigsaw-multilingual-competition/branches) [Tags](https://github.com/rafiko1/jigsaw-multilingual-competition/tags)\\n\\nGo to file\\n\\nCode\\n\\n## Folders and files\\n\\n| Name | Name | Last commit message | Last commit date |\\n| --- | --- | --- | --- |\\n| ## Latest commit<br>## History<br>[74 Commits](https://github.com/rafiko1/jigsaw-multilingual-competition/commits/master/) |\\n| [README.md](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/README.md) | [README.md](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/README.md) |  |  |\\n| [post\\\\_processing\\\\_example.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/post_processing_example.ipynb) | [post\\\\_processing\\\\_example.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/post_processing_example.ipynb) |  |  |\\n| [template-es-it-tr.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-es-it-tr.ipynb) | [template-es-it-tr.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-es-it-tr.ipynb) |  |  |\\n| [template-pt-ru-fr.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-pt-ru-fr.ipynb) | [template-pt-ru-fr.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-pt-ru-fr.ipynb) |  |  |\\n| [template-train-bias.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-train-bias.ipynb) | [template-train-bias.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-train-bias.ipynb) |  |  |\\n| View all files |\\n\\n## Repository files navigation\\n\\n### Introduction\\n\\nThe Tensorflow code released here, was implemented using Kaggle TPUv3 by the 1st place winner of the [2020 Jigsaw Multilingual Kaggle competition](https://www.kaggle.com/c/jigsaw-multilingual-toxic-comment-classification). It was the 3rd annual competition organized by the Jigsaw team. It followed [Toxic Comment Classification Challenge](https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge), the original 2018 competition, and [Jigsaw Unintended Bias in Toxicity Classification](https://www.kaggle.com/c/jigsaw-unintended-bias-in-toxicity-classification) in 2019.\\n\\nThe goal was to run multilingual toxicity predictions on six different languages (i.e. es, tr, it, ru, pt and fr), and promote the usage of TPU.\\n\\nOur solution is detailed in this [Kaggle forum post](https://www.kaggle.com/c/jigsaw-multilingual-toxic-comment-classification/discussion/160862).\\n\\nThe code is part of the overall solution with another part leveraging similar [Pytorch models](https://github.com/leecming/jigsaw-multilingual) trained locally.\\n\\n### Recipe for training:\\n\\n1. Bootstrap test-set predictions (pseudo-labels) for all languages using the\\nXLM-Roberta-Large multilingual model (XLM-R)\\n2. Train a monolingual/multilingual\\nmodel, and predict test-set samples in the relevant language(s)\\n3. Blend predictions from the current model with the previous ensemble\\npredictions - update pseudo-labels\\n4. Repeat steps 2 and 3 with various pretrained monolingual and multilingual\\nmodels.\\n\\nRelevant upgrades to training:\\n\\n1. Implement pseudolabels togehter with train labels in step 2\\n2. Use a post-processing technique\\n\\nWe provide 3 sets of sample pseudo-labels (scoring on public LB: 9372, 9500, 9537) for you to test training monolingual and multilingual models against.\\n\\nFor post-processing, we also provide 11 pseudolabels where subsequent Russian labels were updated after training.\\n\\nYou can refer to the **Data and model files** section below for more info.\\n\\n### Getting started\\n\\n- Training a XLM-R Spanish baseline [here](https://www.kaggle.com/rafiko1/1st-place-baseline-xlm-r-es-it-tr)\\n- Make use of the post-processing technique on Russian examples [here](https://www.kaggle.com/rafiko1/1st-place-jigsaw-post-processing-example)\\n\\n### Code\\n\\n| Training | Comment |\\n| --- | --- |\\n| [Template for es/it/tr](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-es-it-tr.ipynb) | monolingual approach for languages with validation set (es/it/tr). Default model: XLM-R |\\n| [Template for pt/ru/fr](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-pt-ru-fr.ipynb) | monolingual approach for languages without validation set (pt/ru/fr). Default model: XLM-R |\\n| [Template train-bias](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-train-bias.ipynb) | monolingual approach using train-bias dataset. Default model: XLM-R |\\n\\n| Post-processing | Comment |\\n| --- | --- |\\n| [Post-processing example](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/post-processing-example.ipynb) | Post-processing technique using Russian-specific pseudolabels as example |\\n\\n### Data and model files\\n\\n1. HuggingFace models are downloaded directly via API so there is no need to manually download them.\\n2. Public kernel [Jigsaw TPU: XLM-Roberta](https://www.kaggle.com/xhlulu/jigsaw-tpu-xlm-roberta) that inspired the code (can be used as bootstrap labels)\\n3. Translations of the Toxic 2018 dataset and pseudo-labels for public LB 9372, public LB 9500, public LB 9537 can be found [here](https://www.kaggle.com/leecming/multilingual-toxic-comments-training-data).\\n4. Translation of the Toxic 2019 Unintended bias dataset is found [here](https://www.kaggle.com/rafiko1/translated-train-bias-all-langs)\\n5. Post-processing intended: 11 Russian-specific updated pseudolabels [here](https://www.kaggle.com/rafiko1/ru-changed-subs)\\n\\n### Notes\\n\\n1. Below lists the various pretrained HuggingFace transformer models we used -\\n\\n| Language | Models |\\n| --- | --- |\\n| All | jplu/tf-xlm-roberta-large |\\n| French | camembert-base, camembert/camembert-large, flaubert/flaubert\\\\_large\\\\_cased |\\n| Italian | dbmdz/bert-base-italian-xxl-cased, dbmdz/bert-base-italian-xxl-uncased, m-polignano-uniba/bert\\\\_uncased\\\\_L-12\\\\_H-768\\\\_A-12\\\\_italian\\\\_alb3rt0 |\\n| Portuguese | neuralmind...\\n\\n--- Result 9 ---\\nTitle: Jigsaw Unintended Bias in Toxicity Classification — Kaggle Competition\\nURL: https://medium.com/@vaibhavb837/jigsaw-unintended-bias-in-toxicity-classification-kaggle-competition-48c799fe2046\\n\\nContent:\\n[Open in app](https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F48c799fe2046&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderUser&source=post_page---top_nav_layout_nav-----------------------------------------)\\n\\nSign up\\n\\n[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2F%40vaibhavb837%2Fjigsaw-unintended-bias-in-toxicity-classification-kaggle-competition-48c799fe2046&source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\\n\\n[Write](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---top_nav_layout_nav-----------------------new_post_topnav------------------)\\n\\nSign up\\n\\n[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2F%40vaibhavb837%2Fjigsaw-unintended-bias-in-toxicity-classification-kaggle-competition-48c799fe2046&source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\\n\\n![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)\\n\\n# Jigsaw Unintended Bias in Toxicity Classification — Kaggle Competition\\n\\n[![Vaibhavb](https://miro.medium.com/v2/da:true/resize:fill:64:64/0*CS05pEhg6ng-uxS7)](https://medium.com/@vaibhavb837?source=post_page---byline--48c799fe2046---------------------------------------)\\n\\n[Vaibhavb](https://medium.com/@vaibhavb837?source=post_page---byline--48c799fe2046---------------------------------------)\\n\\nFollow\\n\\n10 min read\\n\\n·\\n\\nOct 17, 2020\\n\\n--\\n\\n1\\n\\nListen\\n\\nShare\\n\\n> Jigsaw is a unit within Google that forecasts and confronts emerging threats, creating future-defining research and technology to keep our world safer.\\n\\n> The Conversation AI team, a research initiative founded by Jigsaw and Google (both part of Alphabet), builds technology to protect voices in the conversation. A main area of focus is machine learning models that can identify toxicity in online conversations, where toxicity is defined as anything rude, disrespectful, or otherwise likely to make someone leave a discussion.\\n\\n# Business Problem:\\n\\n**Problem source:**\\n\\n[**Jigsaw Unintended Bias in Toxicity Classification** \\\\\\n\\\\\\n**Detect toxicity across a diverse range of conversations**\\\\\\n\\\\\\nwww.kaggle.com](https://www.kaggle.com/c/jigsaw-unintended-bias-in-toxicity-classification/overview/description?source=post_page-----48c799fe2046---------------------------------------)\\n\\n## Problem statement:\\n\\nWhen the **Conversation AI** team first built toxicity models, they found that the models incorrectly learned to associate the names of frequently attacked identities with toxicity. Models predicted a high likelihood of toxicity for comments containing those identities (e.g. “gay”), even when those comments were not actually toxic (such as “I am a gay woman”). This happens because training data was pulled from available sources where, unfortunately, certain identities are overwhelmingly referred to in offensive ways. Training a model from data with these imbalances risks simply mirroring those biases back to users.\\n\\n**Task:** We have to build a model that recognizes toxicity and minimizes this type of unintended bias concerning mentions of identities. We’ll be using a dataset labeled for identity mentions and optimizing a metric designed to measure unintended bias.\\n\\n**_Disclaimer:_** _The dataset for this competition contains text that may be considered profane, vulgar, or offensive._\\n\\n## Data collection:\\n\\n**File descriptions:** Data Size: 0.8 GB\\n\\n- **train.csv** — the training set, which includes toxicity labels and subgroups\\n- **test.csv**— the test set, which does not include toxicity labels or subgroups\\n- **sample\\\\_submission.csv** — a sample submission file in the correct format\\n\\n## Background:\\n\\nAt the end of 2017, the [**Civil Comments**](https://medium.com/@aja_15265/saying-goodbye-to-civil-comments-41859d3a2b1d) platform shut down and chose to make their ~2m public comments from their platform available in a lasting open archive so that researchers could understand and improve civility in online conversations for years to come. Jigsaw sponsored this effort and extended annotation of this data by human raters for various toxic conversational attributes.\\n\\nIn the data supplied for this competition, the text of the individual comment is found in the comment\\\\_text column. Each comment in Train has a toxicity label (target), and models should predict the target toxicity for the Test data. This attribute (and all others) are fractional values which represent the fraction of human raters who believed the attribute applied to the given comment. For evaluation, the test set examples with target >= 0.5 will be considered to be in a positive class (toxic).\\n\\n## Competition Evaluation:\\n\\nThis competition will use a newly developed metric that combines several submatrices to balance overall performance with various aspects of unintended bias.\\n\\nFirst, we’ll define each submatrix.\\n\\n**Overall AUC:** This is the ROC-AUC for the full evaluation set.\\n\\n**Generalized Mean of Bias AUCs:**\\n\\n**Generalized Mean of Bias AUCs**\\n\\n**Mₚ** = the _p_ ᵗʰ power-mean function\\n\\n**mₛ** = the bias metric **_m_** calculated for subgroup **_s_**\\n\\n**N** = number of identity subgroups\\n\\n> For this competition, we use a p value of -5 to encourage competitors to improve the model for the identity subgroups with the lowest model performance.\\n\\n## **Final Metric:**\\n\\n**A** = number of submatrices (3)\\n\\n**mₛ**, **ₐ** = bias metric for identity subgroup **_s_** using submatrix **_a_**\\n\\n**wₐ** = a weighting for the relative importance of each submatrix; all four **_w_** values set to 0.25\\n\\n# Loading Data:\\n\\n```\\n# TRAIN DATA\\ntrain = pd.read_csv(‘project_dataset/train.csv’)# TEST DATA\\ntest = pd.read_csv('project_dataset/test.csv')\\n```\\n\\n> **Dimensions:**\\n>\\n> _Train_\\\\- (1804874, 45)\\n>\\n> _Test_ \\\\- (97320, 2)\\n\\nTrain Dataset ( **train.head()**)\\n\\nTest Dataset ( **test.head()**)\\n\\n**Point:** In this competition, **target** >= 0.5 will be considered to be in a positive class (toxic)\\n\\n```\\nt_c = (train['target'].values>=0.5).astype(np.int).sum()\\nprint(\\\"Total number of toxic comments in the dataset:\\\", t_c)nt_c = (train['target'].values<=0.5).astype(np.int).sum()\\nprint(\\\"Total number of non-toxic comments in the dataset:\\\", nt_c)\\n```\\n\\n> Total number of toxic comments in the dataset: 144334\\n>\\n> Total number of non-toxic comments in the dataset: 1698436\\n\\nChecking if their’s any null elements in the dataset:\\n\\n```\\ntrain.isnull().sum()\\n```\\n\\n**Note:** There are **1399744** number of null entries in several columns in the training dataset.\\n\\nThe data also has several additional toxicity subtype attributes. Models do not need to predict these attributes for the competition, they are included as an additional avenue for research. Subtype attributes are:\\n\\n1. severe\\\\_toxicity\\n2. obscene\\n3. threat\\n4. insult\\n5. identity\\\\_attack\\n6. sexual\\\\_explicit\\n\\n**Plotting number of comments VS comment types**\\n\\nThe dataset is highly imbalanced in nature. Here, we can observe that most of the dataset is clean and we have very few comments where the comment is considered as severely toxic.\\n\\n**Violin Plot of Comment length and toxicity (0 or 1)**\\n\\nWe can observe some outliers in the training dataset but the average length of a comment is similar in both the train and test dataset.\\n\\n**The dataset also provides us the time of comments so we can also check how time has affected the type of comments**\\n\\nWhat we observe are as follows:\\n\\n1. White identity in the comments is used the most.\\n2. when it comes to religious basis then Muslim identity is used most frequently.\\n3. homosexual identity is used most commonly in comments.\\n4. comments about transgender people have been commented on most.\\n\\nWe have done the necessary EDA for our data now let’s build the model to tackle this problem. For this NLP problem, we are going to use LSTM and BERT models.\\n\\n**What is LSTM?**\\n\\nLet me put it in simple words, LSTM is **Long short-term memory** networks a type of R...\\n\", \"is_error\": false, \"results\": [{\"title\": \"ANSWER\", \"text\": \"Based on the strategies described by Kaggle winners in the Jigsaw‑toxic‑comment and other text‑classification contests, the most common ways to tame severe class imbalance are:\\n\\n1. **Analyze the label distribution and set class‑wise loss weights** – compute the frequency of each class and pass the inverse frequencies (or a smoothed version) to the loss function (e.g., weighted binary‑cross‑entropy or focal loss). This forces the model to pay more attention to rare toxic or insincere labels. ([Towards Data Science](https://towardsdatascience.com/how-i-handled-imbalanced-text-data-ba9b757ab1d8))  \\n\\n2. **Oversample the minority class at the data‑loader level** – duplicate or augment under‑represented samples so each training batch contains a roughly balanced mix. Simple duplication works well, and many winners combine it with text‑augmentation (back‑translation, synonym replacement) to increase diversity. ([Towards Data Science](https://towardsdatascience.com/how-i-handled-imbalanced-text-data-ba9b757ab1d8))  \\n\\n3. **Use stratified K‑fold splits** – ensure every fold preserves the original class ratios, preventing the validation set from being overly easy or hard and giving a reliable estimate of performance on the imbalanced target. ([Neptune blog on text‑classification tips](https://neptune.ai/blog/text-classification-tips-and-tricks-kaggle-competitions))  \\n\\n4. **Apply a balanced‑batch sampler or custom DataLoader** – instead of random sampling, build each batch by drawing an equal number of examples from each class (or from groups of similar frequency). This keeps gradient updates stable throughout training. ([Towards Data Science](https://towardsdatascience.com/how-i-handled-imbalanced-text-data-ba9b757ab1d8))  \\n\\n5. **Leverage ensemble blending with models trained on different sampling schemes** – many top teams train one model on the original data, another on an oversampled version, and then blend their predictions. The diversity of sampling strategies often yields a boost on the leaderboard. ([Neptune blog on text‑classification tips](https://neptune.ai/blog/text-classification-tips-and-tricks-kaggle-competitions))  \\n\\n**Quick checklist for a new competition**\\n\\n- Compute class frequencies → set `pos_weight` or class‑wise weights in the loss.  \\n- Create an oversampled/augmented training set for the rare classes.  \\n- Split with `StratifiedKFold` (or `StratifiedGroupKFold` if needed).  \\n- Implement a balanced‑batch sampler (e.g., `torch.utils.data.WeightedRandomSampler`).  \\n- Train at least two models (original vs. oversampled) and blend their probabilities.  \\n\\nFollowing these steps mirrors the proven workflow of Kaggle winners handling class‑imbalanced text classification problems.\", \"url\": \"\"}, {\"title\": \"Text Classification: All Tips and Tricks from 5 Kaggle Competitions\", \"text\": \"In this article, I will discuss some great tips and tricks to [improve the performance](https://neptune.ai/blog/improving-machine-learning-deep-learning-models) of your text classification model. These tricks are obtained from solutions of some of Kaggle’s top NLP competitions.\\n\\nNamely, I’ve gone through:\\n\\n- [Jigsaw Unintended Bias in Toxicity Classification](https://www.kaggle.com/c/jigsaw-unintended-bias-in-toxicity-classification) – $65,000\\n- [Toxic Comment Classification Challenge](https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/) – $35,000\\n- [Quora Insincere Questions Classification](http://kaggle.com/c/quora-insincere-questions-classification) – $25,000\\n- [Google QUEST Q&A Labeling](https://www.kaggle.com/c/google-quest-challenge) – $25,000\\n- [TensorFlow 2.0 Question Answering](https://www.kaggle.com/c/tensorflow2-question-answering) – $50,000\\n\\nand found a ton of great ideas.\\n\\nWithout much lag, let’s begin.\\n\\n## Dealing with larger datasets\\n\\nOne issue you might face in any machine learning competition is the size of your data set. If the size of your data is large, that is 3GB + for Kaggle kernels and more basic laptops you could find it difficult to load and process with limited resources. Here is the link to some of the articles and kernels that I have found useful in such situations.\\n\\n- Optimize the memory by [reducing the size of some attributes](https://www.kaggle.com/shrutimechlearn/large-data-loading-trick-with-ms-malware-data)\\n- Use open-source libraries such as [Dask to read and manipulate the data](https://www.kaggle.com/yuliagm/how-to-work-with-big-datasets-on-16g-ram-dask), it performs parallel computing and saves up memory space\\n- Use [cudf](https://github.com/rapidsai/cudf)\\n- Convert data to [parquet](https://arrow.apache.org/docs/python/parquet.html) format\\n- Convert data to [feather](https://medium.com/@snehotosh.banerjee/feather-a-fast-on-disk-format-for-r-and-python-data-frames-de33d0516b03) format\\n\\n## Small datasets and external data\\n\\nBut, what can one do if the dataset is small? Let’s see some techniques to tackle this situation.\\n\\nOne way to increase the performance of any machine learning model is to use some external data frame that contains some variables that influence the predicate variable.\\n\\nLet’s see some of the external datasets.\\n\\n- Use of [squad](https://rajpurkar.github.io/SQuAD-explorer/) data for Question Answering tasks\\n- Other [datasets](http://nlpprogress.com/english/question_answering.html) for QA tasks\\n- Wikitext long term dependency language modeling [dataset](https://www.salesforce.com/products/einstein/ai-research/the-wikitext-dependency-language-modeling-dataset/)\\n- [Stackexchange data](https://archive.org/download/stackexchange)\\n- Prepare a dictionary of commonly misspelled words and corrected words.\\n- Use of [helper datasets](https://www.kaggle.com/kyakovlev/jigsaw-general-helper-public) for cleaning\\n- [Pseudo labeling](https://www.kaggle.com/cdeotte/pseudo-labeling-qda-0-969/) is the process of adding confidently predicted test data to your training data\\n- Use different data [sampling methods](https://www.kaggle.com/shahules/tackling-class-imbalance)\\n- Text augmentation by [Exchanging words with synonym](https://arxiv.org/pdf/1502.01710.pdf) [s](https://arxiv.org/pdf/1502.01710.pdf)\\n- Text augmentation by [noising in RNN](https://arxiv.org/pdf/1703.02573.pdf)\\n- Text augmentation by [translation to other languages and back](https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/48038)\\n\\n## Data exploration and gaining insights\\n\\nData exploration always helps to better understand the data and gain insights from it. Before starting to develop machine learning models, top competitors always read/do a lot of exploratory data analysis for the data. This helps in feature engineering and cleaning of the data.\\n\\n- Twitter data [exploration methods](https://www.kaggle.com/jagangupta/stop-the-s-toxic-comments-eda)\\n- Simple [EDA for tweets](https://www.kaggle.com/nz0722/simple-eda-text-preprocessing-jigsaw)\\n- [EDA](https://www.kaggle.com/tunguz/just-some-simple-eda) for Quora data\\n- [EDA](https://www.kaggle.com/kailex/r-eda-for-q-gru) in  R for Quora data\\n- Complete [EDA](https://www.kaggle.com/codename007/start-from-here-quest-complete-eda-fe) with stack exchange data\\n- My previous article on [EDA for natural language processing](https://neptune.ai/blog/exploratory-data-analysis-natural-language-processing-tools)\\n\\n## Data cleaning\\n\\nData cleaning is one of the important and integral parts of any NLP problem. Text data always needs some preprocessing and cleaning before we can represent it in a suitable form.\\n\\n- Use this [notebook](https://www.kaggle.com/sudalairajkumar/getting-started-with-text-preprocessing) to clean social media data\\n- [Data cleaning](https://www.kaggle.com/kyakovlev/preprocessing-bert-public) for BERT\\n- Use [textblob](https://textblob.readthedocs.io/en/dev/quickstart.html) to correct misspellings\\n- [Cleaning](https://www.kaggle.com/theoviel/improve-your-score-with-some-text-preprocessing) for pre-trained embeddings\\n- [Language detection and translation](https://www.pythonprogramming.in/language-detection-and-translation-using-textblob.html) for multilingual tasks\\n- Preprocessing for Glove [part 1](https://www.kaggle.com/christofhenkel/how-to-preprocessing-for-glove-part1-eda) and [part 2](https://www.kaggle.com/christofhenkel/how-to-preprocessing-for-glove-part2-usage)\\n- [Increasing word coverage](https://www.kaggle.com/sunnymarkliu/more-text-cleaning-to-increase-word-coverage) to get more from pre-trained word embeddings\\n\\n## Text representations\\n\\nBefore we feed our text data to the Neural network or ML model, the text input needs to be represented in a suitable format. These representations determine the performance of the model to a large extent.\\n\\n- Pretrained [Glove](https://nlp.stanford.edu/projects/glove/) vectors\\n- Pretrained [fasttext](https://fasttext.cc/docs/en/english-vectors.html) vectors\\n- Pretrained [word2vec](https://radimrehurek.com/gensim/models/word2vec.html) vectors\\n- My previous article on these [3 embeddings](https://neptune.ai/blog/document-classification-small-datasets)\\n- Combining [pre-trained vectors](https://www.kaggle.com/c/quora-insincere-questions-classification/discussion/71778/). This can help in better representation of text and decreasing OOV words\\n- [Paragram](https://cogcomp.seas.upenn.edu/page/resource_view/106) embeddings\\n- [Universal Sentence Encoder](https://tfhub.dev/google/universal-sentence-encoder/1)\\n- Use USE to generate [sentence-level features](https://www.kaggle.com/abhishek/distilbert-use-features-oof)\\n- 3 methods to [combine embeddings](https://www.kaggle.com/c/quora-insincere-questions-classification/discussion/71778)\\n\\nContextual embeddings models\\n\\n- [BERT](https://github.com/google-research/bert) Bidirectional Encoder Representations from Transformers\\n- [GPT](https://github.com/openai/finetune-transformer-lm)\\n- [Roberta](https://github.com/pytorch/fairseq/tree/master/examples/roberta) a Robustly Optimized BERT\\n- [Albert](https://github.com/google-research/ALBERT) a Lite BERT for Self-supervised Learning of Language Representations\\n- [Distilbert](https://github.com/huggingface/transformers/tree/master/examples/distillation) a lighter version of BERT\\n- [XLNET](https://github.com/zihangdai/xlnet/)\\n\\n## Modeling\\n\\n### Model architecture\\n\\nChoosing the right architecture is important to develop a proper machine learning model, sequence to sequence models like LSTMs, GRUs perform well in NLP problems and is always worth trying. Stacking 2 layers of LSTM/GRU networks is a common approach.\\n\\n- [Stacking Bidirectional CuDNNLSTM](https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52644/)\\n- [Stacking LSTM networks](https://www.kaggle.com/sakami/google-quest-single-lstm/)\\n- [LSTM and 5 fold Attention](https://www.kaggle.com/christofhenkel/keras-baseline-lstm-attention-5-fold/)\\n- [Bi...\", \"url\": \"https://neptune.ai/blog/text-classification-tips-and-tricks-kaggle-competitions\"}, {\"title\": \"Tabular Data Binary Classification: All Tips and Tricks from 5 Kaggle Competitions\", \"text\": \"Tabular Data Binary Classification: All Tips and Tricks from 5 Kaggle Competitions[\\n**📣 BIG NEWS:****Neptune is joining OpenAI!**→ Read the message from our CEO 📣![](https://neptune.ai/wp-content/themes/neptune/img/image-ratio-holder.svg)](https://neptune.ai/blog/we-are-joining-openai)\\n[![logo](https://neptune.ai/wp-content/themes/neptune/img/logo-neptune.svg)](https://neptune.ai)\\n![search](https://neptune.ai/wp-content/themes/neptune/img/icon-search.svg)\\nWhat do you want to find?\\nSearch\\n![cancel](https://neptune.ai/wp-content/themes/neptune/img/image-ratio-holder.svg)\\n[Log in](https://app.neptune.ai/login)[Contact us](https://neptune.ai/contact-us)\\n[![Home](https://neptune.ai/wp-content/themes/neptune/img/icon-breadcrumbs-home.svg)](https://neptune.ai/)&gt;[Blog](https://neptune.ai/blog)&gt;[ML Model Development](https://neptune.ai/blog/category/machine-learning-model-development)\\nSearch in Blog...\\n![search](https://neptune.ai/wp-content/themes/neptune/img/image-ratio-holder.svg)\\n![search](https://neptune.ai/wp-content/themes/neptune/img/icon-search.svg)![cancel](https://neptune.ai/wp-content/themes/neptune/img/image-ratio-holder.svg)\\nSearch in Blog...\\n![search](https://neptune.ai/wp-content/themes/neptune/img/image-ratio-holder.svg)\\n[Neptune Blog](https://neptune.ai/blog)# Tabular Data Binary Classification: All Tips and Tricks from 5 Kaggle Competitions\\n![Author image](https://i0.wp.com/neptune.ai/wp-content/uploads/2022/11/Shahul-Es-new-scaled.jpeg?fit=2560%2C1920&ssl=1)\\n[Shahul ES](https://neptune.ai/blog/author/shahules)\\n![](https://neptune.ai/wp-content/themes/neptune/img/icon-meta-time.svg)3 min\\n![](https://neptune.ai/wp-content/themes/neptune/img/icon-meta-date.svg)1st September, 2023\\n[ML Model Development](https://neptune.ai/blog/category/machine-learning-model-development)[Tabular Data](https://neptune.ai/blog/category/tabular-data)\\nIn this article, I will discuss some great tips and tricks to improve the performance of your structured data binary classification model. These tricks are obtained from solutions of some of Kaggle’s top tabular data competitions. Without much lag, let’s begin.\\nThese are the five competitions that I have gone through to create this article:\\n* [**Home credit default risk**](https://www.kaggle.com/c/home-credit-default-risk/)\\n* [**Santander Customer Transaction Prediction**](https://www.kaggle.com/c/santander-customer-transaction-prediction/notebooks)\\n* [**VSB Power Line Fault Detection**](https://www.kaggle.com/c/vsb-power-line-fault-detection/overview/evaluation)\\n* [**Microsoft Malware Prediction**](https://www.kaggle.com/c/microsoft-malware-prediction/overview)\\n* [**IEEE-CIS Fraud Detection**](https://www.kaggle.com/c/ieee-fraud-detection/overview/evaluation/)## Dealing with larger datasets\\nOne issue you might face in any machine learning competition is the size of your data set. If the size of your data is large, that is 3GB + for kaggle kernels and more basic laptops you could find it difficult to load and process with limited resources. Here is the link to some of the articles and kernels that I have found useful in such situations.\\n* Faster[data loading with pandas.](https://www.kaggle.com/c/home-credit-default-risk/discussion/59575)\\n* Data compression techniques to[reduce the size of data by 70%](https://www.kaggle.com/nickycan/compress-70-of-dataset).\\n* Optimize the memory by r[educing the size of some attributes.](https://www.kaggle.com/shrutimechlearn/large-data-loading-trick-with-ms-malware-data)\\n* Use open-source libraries such as[Dask to read and manipulate the data](https://www.kaggle.com/yuliagm/how-to-work-with-big-datasets-on-16g-ram-dask), it performs parallel computing and saves up memory space.\\n* Use[cudf](https://github.com/rapidsai/cudf).\\n* Convert data to[parquet](https://arrow.apache.org/docs/python/parquet.html)format.\\n* Converting data to[feather](https://medium.com/@snehotosh.banerjee/feather-a-fast-on-disk-format-for-r-and-python-data-frames-de33d0516b03)format.\\n* Reducing memory usage for[optimizing RAM](https://www.kaggle.com/mjbahmani/reducing-memory-size-for-ieee).## Data exploration\\nData exploration always helps to better understand the data and gain insights from it. Before starting to develop machine learning models, top competitors always read/do a lot of exploratory data analysis for the data. This helps in feature engineering and cleaning of the data.\\n* EDA for microsoft[malware detection.](https://www.kaggle.com/youhanlee/my-eda-i-want-to-see-all)\\n* Time Series[EDA for malware detection.](https://www.kaggle.com/cdeotte/time-split-validation-malware-0-68)\\n* Complete[EDA for home credit loan prediction](https://www.kaggle.com/codename007/home-credit-complete-eda-feature-importance).\\n* Complete[EDA for Santader prediction.](https://www.kaggle.com/gpreda/santander-eda-and-prediction)\\n* EDA for[VSB Power Line Fault Detection.](https://www.kaggle.com/go1dfish/basic-eda)## Data preparation\\nAfter data exploration, the first thing to do is to use those insights to prepare the data. To tackle issues like class imbalance, encoding categorical data, etc. Let’s see the methods used to do it.\\n* Methods to t[ackle class imbalance](https://www.kaggle.com/shahules/tackling-class-imbalance).\\n* Data augmentation by[Synthetic Minority Oversampling Technique](https://machinelearningmastery.com/smote-oversampling-for-imbalanced-classification/).\\n* Fast inplace[shuffle for augmentation](https://www.kaggle.com/jiweiliu/fast-inplace-shuffle-for-augmentation).\\n* Finding[synthetic samples in the dataset.](https://www.kaggle.com/yag320/list-of-fake-samples-and-public-private-lb-split)\\n* [Signal denoising](https://www.kaggle.com/jackvial/dwt-signal-denoising)used in signal processing competitions.\\n* Finding[patterns of missing data](https://www.kaggle.com/jpmiller/patterns-of-missing-data).\\n* Methods to handle[missing data](https://towardsdatascience.com/6-different-ways-to-compensate-for-missing-values-data-imputation-with-examples-6022d9ca0779).\\n* An overview of various[encoding techniques for categorical data.](https://www.kaggle.com/shahules/an-overview-of-encoding-techniques)\\n* Building[model to predict missing values.](https://www.kaggle.com/c/home-credit-default-risk/discussion/64598)\\n* Random[shuffling of data](https://www.kaggle.com/brandenkmurray/randomly-shuffled-data-also-works)to create new synthetic training set.## Feature engineering\\nNext, you can check the most popular feature and feature engineering techniques used in these top kaggle competitions. The feature engineering part varies from problem to problem depending on the domain.\\n* Target[encoding cross validation](https://medium.com/@pouryaayria/k-fold-target-encoding-dfe9a594874b/)for better encoding.\\n* Entity embedding to[handle categories](https://www.kaggle.com/abhishek/entity-embeddings-to-handle-categories).\\n* Encoding c[yclic features for deep learning.](https://www.kaggle.com/avanwyk/encoding-cyclical-features-for-deep-learning)\\n* Manual[feature engineering methods](https://www.kaggle.com/willkoehrsen/introduction-to-manual-feature-engineering).\\n* Automated feature engineering techniques[using featuretools](https://www.kaggle.com/willkoehrsen/automated-feature-engineering-basics).\\n* Top hard crafted features used in[microsoft malware detection](https://www.kaggle.com/sanderf/7th-place-solution-microsoft-malware-prediction).\\n* Denoising NN for[feature extraction](https://towardsdatascience.com/applied-deep-learning-part-3-autoencoders-1c083af4d798).\\n* Feature engineering[using RAPIDS framework.](https://www.kaggle.com/cdeotte/rapids-feature-engineering-fraud-0-96/)\\n* Things to remember while processing f[eatures using LGBM.](https://www.kaggle.com/c/ieee-fraud-detection/discussion/108575)\\n* [Lag features and moving averages.](https://www.kaggle.com/c/home-credit-default-risk/discussion/64593)\\n* [Principal component analysis](https://medium.com/machine-learning-researcher/dimensionality-reduction-pca-and-lda-6be91734f567)for...\", \"url\": \"https://neptune.ai/blog/tabular-data-binary-classification-tips-and-tricks-from-5-kaggle-competitions\"}, {\"title\": \"How I handled imbalanced text data - Towards Data Science\", \"text\": \"[Open in app](https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2Fba9b757ab1d8&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------)\\n\\n[Sign up](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-i-handled-imbalanced-text-data-ba9b757ab1d8&source=post_page---two_column_layout_nav-----------------------global_nav-----------)\\n\\n[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-i-handled-imbalanced-text-data-ba9b757ab1d8&source=post_page---two_column_layout_nav-----------------------global_nav-----------)\\n\\n[Write](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_topnav-----------)\\n\\n[Sign up](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-i-handled-imbalanced-text-data-ba9b757ab1d8&source=post_page---two_column_layout_nav-----------------------global_nav-----------)\\n\\n[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-i-handled-imbalanced-text-data-ba9b757ab1d8&source=post_page---two_column_layout_nav-----------------------global_nav-----------)\\n\\n![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)\\n\\n# **How I handled imbalanced text data**\\n\\n## Blueprint to tackle one of the most common problems in AI\\n\\n[![Yogesh Kothiya](https://miro.medium.com/v2/resize:fill:88:88/1*zNkUFlexn9RWHc--UuuQ5w.jpeg)](https://medium.com/@kothiya.yogesh?source=post_page-----ba9b757ab1d8--------------------------------)[![Towards Data Science](https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg)](https://towardsdatascience.com/?source=post_page-----ba9b757ab1d8--------------------------------)\\n\\n[Yogesh Kothiya](https://medium.com/@kothiya.yogesh?source=post_page-----ba9b757ab1d8--------------------------------)\\n\\n·\\n\\n[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fd310856a9437&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-i-handled-imbalanced-text-data-ba9b757ab1d8&user=Yogesh+Kothiya&userId=d310856a9437&source=post_page-d310856a9437----ba9b757ab1d8---------------------post_header-----------)\\n\\nPublished in\\n\\n[Towards Data Science](https://towardsdatascience.com/?source=post_page-----ba9b757ab1d8--------------------------------)\\n\\n·\\n\\n5 min read\\n\\n·\\n\\nMay 15, 2019\\n\\n--\\n\\n2\\n\\nListen\\n\\nShare\\n\\nPhoto by [Form](https://unsplash.com/@theformfitness?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)\\n\\nThe problem of imbalanced class distribution is prevalent in the field of data science and ML engineers come across it frequently. I am a chatbot developer at [IMImoble Pvt Ltd](https://imimobile.com/) and faced this scenario recently while training intent classification module. Any live business chatbot accessible to real-world users is bound to attract a significant number of out-of-scope queries along with messages pertaining to the task it is designed to perform. Even among the relevant task-oriented messages, imbalances are to be expected as all topics covered by the bot can’t be equally popular. For example, in a banking use case, balance inquiries will outnumber home loan applications.\\n\\nBot building is not similar to traditional application development. While the latter is relatively stable and is updated less often, the former needs frequent updates to improve user experience and intelligence of the bot. The imbalanced dataset is the problem where data belonging to one class is significantly higher or lower than that belonging to other classes. Most ML/DL classification algorithms aren’t equipped to handle imbalanced classes and tend to get biased towards majority classes.\\n\\n# **Why accuracy is a sham in the case of an imbalanced dataset**\\n\\nAiming only for high accuracy for the imbalanced dataset can be counter-productive because standard classifier algorithms like Decision Trees and Logistic Regression do not have the ability to handle imbalanced classes incorporated into them. This leads to a heavy bias towards larger classes and classes with fewer data points are treated as noise and are often ignored. The result is a higher misclassification rate for minority classes compared to the majority classes. Therefore, the accuracy metric is not as relevant when evaluating the performance of a model trained on imbalanced data.\\n\\nConsider the following case: you have two classes — A and B. Class A is 95% of your dataset and class B is the other 5%. You can reach an accuracy of 95% by simply predicting class A every time, but this provides a useless classifier for your intended use case. Instead, a properly calibrated method may achieve a lower accuracy but would have a substantially higher true positive rate (or recall), which is really the metric you should have been optimizing for.\\n\\n[This](https://www.analyticsvidhya.com/blog/2017/03/imbalanced-classification-problem/) article explains several methods to handle imbalanced dataset but most of them don’t work well for text data. In this article, I am sharing all the tricks and techniques I have used to balance my dataset along with the code which boosted f1-score by 30%.\\n\\n# Strategies for handling Imbalanced Datasets:\\n\\n**Can you gather more data?**\\n\\nYou might think that this is not the solution you’re looking for but gathering more meaningful and diverse data is always better than sampling original data or generating artificial data from existing data points.\\n\\n**Removing data redundancy:**\\n\\n1. Removing duplicate data — The dataset I was dealing with contained a lot of similar and even duplicate data points. “Where is my order” and “Where is the order” has the same semantic meaning. Removing such duplicate message will help you reduce the size of your majority class.\\n2. There were many messages which had the same semantic meaning, for example, consider the following messages, which convey the same meaning. Keeping one or two such utterances and removing others also helps in balancing classes. Well, you can use those messages in the validation set. There are many ways to find text similarity but I have used Jaccard Similarity because it is very easy to implement and it considers only unique sets of words while calculating similarity. You can look at other techniques in [this](https://medium.com/@adriensieg/text-similarities-da019229c894) article.\\n\\n_Can I change the delivery time for my delivery?_\\n\\n_Can I change time of my delivery?_\\n\\n_Can I change delivery time?_\\n\\n3\\\\. Merge minority classes — Sometimes multiple classes have overlapping features. It’s better to merge those multiple minority classes. This trick helped me improve f1-score by more than 10%.\\n\\n**Resample training dataset:**\\n\\nThe simplest way to fix imbalanced dataset is simply balancing them by oversampling instances of the minority class or undersampling instances of the majority class. Using advanced techniques like SMOTE(Synthetic Minority Over-sampling Technique) will help you create new synthetic instances from minority class.\\n\\n1. Undersampling — An effort to eliminate data point from the majority class randomly until the classes are balanced. There is a likelihood of information loss which might lead to poor model training.\\n2. Oversampling — This is the process to replicate minority class instances randomly. This approach can overfit and lead to inaccurate predictions on test data.\\n3. SMOTE — SMOTE generates synthetic samples by taking each minority class sample and introducing synthetic examples along the line segments joining any/all of the k minority class nearest neighbors as shown in below GIF. More importantly, this approach effectively forces the decision region of the minority class to beco...\", \"url\": \"https://towardsdatascience.com/how-i-handled-imbalanced-text-data-ba9b757ab1d8?gi=f37886eebb72\"}, {\"title\": \"AIcrowd | Dealing with Class Imbalance | Posts\", \"text\": \"Loading\\n\\n#### [ADDI Alzheimers Detection Challenge](https://www.aicrowd.com/challenges/addi-alzheimers-detection-challenge)\\n\\n# Dealing with Class Imbalance\\n\\nLooking at different ways to address class imbalance in this dataset\\n\\nJohnowhitaker7 May 2021\\n\\n[20](https://www.aicrowd.com/participants/sign_in) [Open in Colab](https://colab.research.google.com/gist/aicrowd-bot/d9ed51a8b9be2026f0ff96c2b5cad9c2)\\n\\nIn this notebook I take a close look at some different ways we can address the difference in class balance between train and validation (and presumably test)\\n\\nWe look at changing sample weights, over and under-sampling, SMOTE and some other tips and tricks.\\n\\nI hope you find it helpful :)\\n\\n# Introduction [¶](https://www.aicrowd.com/www.aicrowd.com\\\\#Introduction)\\n\\nSo you've made your first model for this challenge and it's getting a log loss of ~0.9 - a ways behind the leaders on 0.6X. You're starting to think about feature engineering, adding more models to your ensemble, maybe trying one of those tabular deep learning models the cool kids are talking about. **STOP!** Before any of that, there is one BIG issue we need to deal with: class (im)balance.\\n\\nThe validation set (and presumably the test set) has a different class distribution to the training data. In this notebook we will look at many different ways we can correct for this class imbalance - picking one of these will boost your score tremendously (we're taking ~0.66 with a single simple random forest model). So, let's dive in.\\n\\n# Setup [¶](https://www.aicrowd.com/www.aicrowd.com\\\\#Setup)\\n\\nImporting the libraries we'll be using, loading the data and getting ready to run our experiments.\\n\\nIn \\\\[1\\\\]:\\n\\n```\\nimport pandas as pd\\nimport numpy as np\\nfrom sklearn.ensemble import RandomForestClassifier\\nfrom catboost import CatBoostClassifier, Pool\\nfrom sklearn.metrics import f1_score, log_loss\\nfrom imblearn.over_sampling import SMOTE\\nfrom imblearn.under_sampling import RandomUnderSampler\\nfrom imblearn.pipeline import Pipeline\\n```\\n\\nIn \\\\[2\\\\]:\\n\\n```\\n#The training data\\ndf = pd.read_csv('ds_shared_drive/train.csv')\\nprint(df.shape)\\ndf.head(2)\\n```\\n\\n```\\n(32777, 122)\\n\\n```\\n\\nOut\\\\[2\\\\]:\\n\\n| row\\\\_id | number\\\\_of\\\\_digits | missing\\\\_digit\\\\_1 | missing\\\\_digit\\\\_2 | missing\\\\_digit\\\\_3 | missing\\\\_digit\\\\_4 | missing\\\\_digit\\\\_5 | missing\\\\_digit\\\\_6 | missing\\\\_digit\\\\_7 | missing\\\\_digit\\\\_8 | ... | bottom\\\\_area\\\\_perc | left\\\\_area\\\\_perc | right\\\\_area\\\\_perc | hor\\\\_count | vert\\\\_count | eleven\\\\_ten\\\\_error | other\\\\_error | time\\\\_diff | centre\\\\_dot\\\\_detect | diagnosis |\\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\\n| 0 | S0CIXBKIUEOUBNURP | 12.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | ... | 0.52617 | 0.524975 | 0.474667 | 0 | 0 | 0 | 1 | -105.0 | 0.0 | normal |\\n| 1 | IW1Z4Z3H720OPW8LL | 12.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | ... | 0.00081 | 0.516212 | 0.483330 | 0 | 1 | 0 | 1 | NaN | NaN | normal |\\n\\n2 rows × 122 columns\\n\\nIn \\\\[3\\\\]:\\n\\n```\\n# The validation data (we merge in the labels for convenience)\\nval = pd.read_csv('ds_shared_drive/validation.csv')\\nval = pd.merge(val, pd.read_csv('ds_shared_drive/validation_ground_truth.csv'),\\n               how='left', on='row_id')\\nprint(val.shape)\\nval.head()\\n```\\n\\n```\\n(362, 122)\\n\\n```\\n\\nOut\\\\[3\\\\]:\\n\\n| row\\\\_id | number\\\\_of\\\\_digits | missing\\\\_digit\\\\_1 | missing\\\\_digit\\\\_2 | missing\\\\_digit\\\\_3 | missing\\\\_digit\\\\_4 | missing\\\\_digit\\\\_5 | missing\\\\_digit\\\\_6 | missing\\\\_digit\\\\_7 | missing\\\\_digit\\\\_8 | ... | bottom\\\\_area\\\\_perc | left\\\\_area\\\\_perc | right\\\\_area\\\\_perc | hor\\\\_count | vert\\\\_count | eleven\\\\_ten\\\\_error | other\\\\_error | time\\\\_diff | centre\\\\_dot\\\\_detect | diagnosis |\\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\\n| 0 | LA9JQ1JZMJ9D2MBZV | 11.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | ... | 0.499368 | 0.553194 | 0.446447 | 0 | 0 | 0 | 1 | NaN | NaN | post\\\\_alzheimer |\\n| 1 | PSSRCWAPTAG72A1NT | 6.0 | 1.0 | 1.0 | 0.0 | 1.0 | 1.0 | 0.0 | 0.0 | 0.0 | ... | 0.427196 | 0.496352 | 0.503273 | 0 | 1 | 0 | 1 | NaN | NaN | normal |\\n| 2 | GCTODIZJB42VCBZRZ | 11.0 | 0.0 | 0.0 | 0.0 | 0.0 | 1.0 | 0.0 | 0.0 | 0.0 | ... | 0.505583 | 0.503047 | 0.496615 | 1 | 0 | 0 | 0 | 0.0 | 0.0 | normal |\\n| 3 | 7YMVQGV1CDB1WZFNE | 3.0 | 1.0 | 0.0 | 1.0 | 0.0 | 1.0 | 1.0 | 1.0 | 1.0 | ... | 0.444633 | 0.580023 | 0.419575 | 0 | 1 | 0 | 1 | NaN | NaN | post\\\\_alzheimer |\\n| 4 | PHEQC6DV3LTFJYIJU | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 0.0 | ... | 0.395976 | 0.494990 | 0.504604 | 0 | 0 | 0 | 1 | 150.0 | 0.0 | normal |\\n\\n5 rows × 122 columns\\n\\nIn \\\\[4\\\\]:\\n\\n```\\n# We'll keep track of how different approaches perform\\nresults = []\\n```\\n\\n# Baseline \\\\#1 - Training on all data [¶](https://www.aicrowd.com/www.aicrowd.com\\\\#Baseline-%231---Training-on-all-data)\\n\\nThis is a case where we don't do any correction for the class imbalance. Some models will do better than others - tree-based models like CatBoost will be less sensitive than some other model types, but they will still over-estimate the probability that a given sample will fall into the majority class when making predicitons on the validation set (since the 'normal' class is so much more common in the training data).\\n\\nIn \\\\[5\\\\]:\\n\\n```\\n# Prep the data\\nX = df.drop(['row_id', 'diagnosis'], axis=1).fillna(0)\\ny = df['diagnosis']\\nX_val = val.drop(['row_id', 'diagnosis'], axis=1).fillna(0)\\ny_val = val['diagnosis']\\n\\n# Train the model\\nmodel = CatBoostClassifier(verbose=False, cat_features=['intersection_pos_rel_centre'])\\n\\n# Evaluate on val set\\nmodel.fit(X, y, eval_set = (X_val, y_val), early_stopping_rounds = 30)\\n\\n# Store results\\nr = {'Approach':'No modifications',\\n     'Log Loss':log_loss(y_val, model.predict_proba(X_val)),\\n     'F1':f1_score(y_val, model.predict(X_val), average='macro')\\n    }\\nresults.append(r)\\n\\nprint(r) # Show results\\n```\\n\\n```\\n{'Approach': 'No modifications', 'Log Loss': 0.6745549053231596, 'F1': 0.2848101265822785}\\n\\n```\\n\\nA log loss of 0.67 on the validation set isn't terrible. We are using the validation set for early stopping - without that in place we get a log loss of 0.78 on our validation set and 0.8X on the leaderboard. So in a way, by using the validation set for early stopping we are already starting to combat our class balance problem... but we can do much better!\\n\\n# Adjusting Sample Weights [¶](https://www.aicrowd.com/www.aicrowd.com\\\\#Adjusting-Sample-Weights)\\n\\nModels like CatBoost allow us to assign more weight to specific samples. In this case, we use this to place less weight on samples in the over-represented classes, combating the bias introduced by the imbalance:\\n\\nIn \\\\[6\\\\]:\\n\\n```\\n# Prep the data\\nX = df.drop(['row_id', 'diagnosis'], axis=1).fillna(0)\\ny = df['diagnosis']\\nX_val = val.drop(['row_id', 'diagnosis'], axis=1).fillna(0)\\ny_val = val['diagnosis']\\n\\n#Our class weights\\nweights = {\\n    'normal':9/74, # Chosen based on some quick mental maths comparing the distribution of train vs val\\n    'post_alzheimer':0.85,\\n    'pre_alzheimer':1\\n}\\n\\n# Applying these weights as sample weights by using Pool to wrap our training data\\ntrain_data = Pool(\\n    data = X,\\n    label = y,\\n    weight = y.map(weights), # << The important bit\\n    cat_features = [list(X.columns).index('intersection_pos_rel_centre')]\\n)\\n\\neval_data = Pool(\\n    data = X_val,\\n    label = y_val,\\n    weight = y_val.map(lambda x: 1.0), # all validation samples get a weight of 1\\n    cat_features = [list(X.columns).index('intersection_pos_rel_centre')]\\n)\\n\\n# Train the model\\nmodel = CatBoostClassifier(verbose=False)\\n\\n# Evaluate on val set\\nmodel.fit(train_data, eval_set = eval_data, early_stopping_rounds = 30)\\n\\n# Store results\\nr = {'Approach':'Modifying Sample Weights',\\n     'Log Loss':log_loss(y_val, model.predict_proba(X_val)),\\n     'F1':f1_score(y_val, model.predict(X_val), average='macro')\\n    }\\nresults.append(r)\\n\\nprint(r) # Show results\\n```\\n\\n```\\n{'Approach': 'Modifying Sample Weights', 'Log Loss': 0.5593949556085255, 'F1': 0.4727603953181...\", \"url\": \"https://www.aicrowd.com/showcase/dealing-with-class-imbalance\"}, {\"title\": \"\", \"text\": \"<div><section>\\n <figure><figcaption>\\n <p><a href=\\\"https://pixabay.com/en/pollution-toxic-products-environment-3075857/\\\">Photo Credit</a></p>\\n </figcaption>\\n</figure>\\n<h2>Introduction</h2>\\n<p><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge\\\">Jigsaw toxic comment classification challenge</a> features a multi-label text classification problem with a highly imbalanced dataset. The test set used originally was revealed to be already public on the Internet, so <a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/47835\\\">a new dataset was released</a> mid-competition, and the evaluation metric was <a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/48639\\\">changed from Log Loss to AUC</a>.</p>\\n<p>I tried a few ideas after building up my PyTorch pipeline but did not find any innovative approach that looks promising. Text normalization is the only strategy I had found to give solid improvements, but it is very time consuming. The final result (105th place/about top 3%) was quite fitting IMO given the time I spent on this competition(not a lot).</p>\\n<p>(There were some <a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52574\\\">heated discussion</a> around the topic of some top-ranking teams with Kaggle grand masters getting disqualified after the competition ended.)</p>\\n<p>Public kernel blends performed well in this competition (i.e. did not over-fit the public leaderboard too much). I expected it to overfit, but still selected one final submission that used the best public blend of blends to play it safe. Fortunately it paid off and gave me a 0.0001 boost in AUC on private leaderboard:</p>\\n<figure><figcaption>\\n <p><a href=\\\"https://docs.google.com/spreadsheets/d/1R3u6tXDa9CVByaRW9FY8FpxRTqwZsBWfLYuqC1gu8A8/edit?usp=sharing\\\">Table 1: Selected submissions in descending order of private scores</a></p>\\n </figcaption>\\n</figure>\\n<p>In this post, I’ll review some of the techniques used and shared by top competitors. I do not have enough time to test every one of them myself. Part 2 of this series will be implementing a top 5 solution by my own, if I ever find time to do it.</p>\\n<h2>List of Techniques</h2>\\n<p>I tired to attribute techniques to all appropriate sources, but I’m sure I’ve missed some sources here and there. <strong><em>Not all techniques are covered because of the vast amount of contents shared by generous Kagglers</em></strong>. I might come back and edit this list in the near future.</p>\\n<ul>\\n<li>Translation as Augmentation (test time and train time) [1][2][13]</li>\\n<li>Pseudo-labelling [1]</li>\\n<li>Text normalization [3][4]</li>\\n<li>Multi-level stacking — 4 levels [3]; 2 levels [11]; 1level stacking + 1 level weighted averaging [12]</li>\\n<li>Non-English embeddings [2]</li>\\n<li>Diverse pre-trained embeddings — Train multiple model separately on different embeddings</li>\\n<li>Combine several pre-trained embeddings — concatenate after a RNN layer [3]; Concatenate at embedding level [5]; Variant of <a href=\\\"https://arxiv.org/abs/1705.02798\\\">Reinforced Mnemonic Reader</a> [7]</li>\\n<li>When truncating texts, retain both head and tail of the texts [1]</li>\\n<li>K-max pooling[6]</li>\\n<li>Multiple-level of stacking [3]</li>\\n<li>Deepmoji-style attention model [3]</li>\\n<li>(NN) Additional row-level features:<em>“Unique words rate” and “Rate of all-caps words”</em>[4]</li>\\n<li>(NN) Additional word-level feature(s): If a word contains only capital letters [4]</li>\\n<li>(GBM) Engineered features other than tf-idf [12]</li>\\n<li>BytePair Encoding [5][8]</li>\\n<li><a href=\\\"https://www.microsoft.com/en-us/research/wp-content/uploads/2017/05/r-net.pdf\\\">R-net</a> [7]</li>\\n<li>CapsuleNet [11]</li>\\n<li>Label aware attention layer [7]</li>\\n<li>(20180413 Update) leaky information — small overlaps of IPs between training and testing dataset. One overlapping username. [14]</li>\\n</ul>\\n<h2>Pseudo-labelling and Head-Tail Truncating</h2>\\n<p>I’ve already tried these two techniques and trained a couple of models for each.</p>\\n<p>Head-tail truncating (keeping 250 tokens at head, 50 tokens at tail) helped only a bit for bi-GRU, but not for QRNN. It basically had no effect on my final ensemble.</p>\\n<p>For pseudo-labelling(PL), I used the test-set predictions from my best ensemble as suggested in [1], and they improved the final ensemble a little (see table 1). I’d assume that adding more model trained with PL will further boost the final AUC. However, the problem of this approach is the leakage it produces. The ensemble model had seen the the all the validation data, and that information leaked into its test set predictions. So the local CV will be distorted and not comparable to those trained without PL. Nonetheless, this technique does create the best single model, so it’ll be quite useful for production deployment.</p>\\n<p>I think the more conservative way of doing PL is to repeat the train-predict-train(with PL) process, so the model is trained twice for every fold. But that’ll definitely takes more time.</p>\\n<h2>References:</h2>\\n<ol>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52557\\\">The 1st place solution overview</a> by <a href=\\\"https://www.kaggle.com/leecming\\\">Chun Ming Lee</a> from team <em>Toxic Crusaders</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52612\\\">The 2nd place solution overview</a> by <a href=\\\"https://www.kaggle.com/neongen\\\">neongen</a> from team <em>neongen &amp; Computer says no</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52762\\\">The 3rd place solution overview</a> by <a href=\\\"https://www.kaggle.com/tunguz\\\">Bojan Tunguz</a> from team <em>Adversarial Autoencoder</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52644\\\">About my 0.9872 single model</a> by <a href=\\\"https://www.kaggle.com/mrboor\\\">Alexander Burmistrov</a> from team <em>Adversarial Autoencoder</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52630\\\">The 5th place brief solution</a> by <a href=\\\"https://www.kaggle.com/kazanova\\\">Μαριος Μιχαηλιδης KazAnova</a> from team <em>TPMPM</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52526\\\">Congrats (from ghost 11th team)</a> by <a href=\\\"https://www.kaggle.com/cpmpml\\\">CPMP</a></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52702\\\">The 12th place single model solution share</a> by <a href=\\\"https://www.kaggle.com/goldenlock\\\">BackFactoryVillage</a> from team <em>Knights of the Round Table</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52563\\\">The 15th solution summary: Byte Pair Encoding</a> by <a href=\\\"https://www.kaggle.com/tezdhar\\\">Mohsin hasan</a> from team <em>Zehar 2.0</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52647\\\">The 25th Place Notes (0.9872 public; 0.9873 private)</a> by <a href=\\\"https://www.kaggle.com/jtrotman\\\">James Trotman</a> (solo)</li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52719\\\">The 27th place solution overview</a> by <a href=\\\"https://www.kaggle.com/zake7749\\\">Justin Yang</a> from team <em>Sotoxic</em></li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52666\\\">The 33rd Place Solution Using Embedding Imputation (0.9872 private, 0.9876 public)</a> by <a href=\\\"https://www.kaggle.com/mmotoki\\\">Matt Motoki</a> (solo)</li>\\n<li><a href=\\\"https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/discussion/52645\\\">The 34th, Lots of FE and Poor Understanding of NNs [CODE INCLUDED]</a> by <a href=\\\"https://www...\", \"url\": \"https://blog.ceshine.net/post/kaggle-toxic-comment-classification-challenge\"}, {\"title\": \"Classification on imbalanced data \\n\\n    \\n    \\n       \\n    \\n\\n     \\n      \\n      Stay organized with collections\\n     \\n     \\n      \\n      Save and categorize content based on your preferences.\", \"text\": \"Classification on imbalanced data | TensorFlow Core[Skip to main content](#main-content)\\n[![TensorFlow](https://www.gstatic.com/devrel-devsite/prod/ve08add287a6b4bdf8961ab8a1be50bf551be3816cdd70b7cc934114ff3ad5f10/tensorflow/images/lockup.svg)](https://www.tensorflow.org/)\\n* /\\n* English\\n* Español –América Latina\\n* Français\\n* Indonesia\\n* Italiano\\n* Polski\\n* Português –Brasil\\n* Tiếng Việt\\n* Türkçe\\n* Русский* עברית* العربيّة* فارسی* हिंदी* বাংলা* ภาษาไทย* 中文–简体* 日本語* 한국어[GitHub](https://github.com/tensorflow)Sign in\\n* [TensorFlow Core](https://www.tensorflow.org/tutorials)\\n* [TensorFlow](https://www.tensorflow.org/)\\n* [Learn](https://www.tensorflow.org/learn)\\n* [TensorFlow Core](https://www.tensorflow.org/tutorials)\\n# Classification on imbalanced dataStay organized with collectionsSave and categorize content based on your preferences.\\n[![](https://www.tensorflow.org/images/tf_logo_32px.png)View on TensorFlow.org](https://www.tensorflow.org/tutorials/structured_data/imbalanced_data)|[![](https://www.tensorflow.org/images/colab_logo_32px.png)Run in Google Colab](https://colab.research.google.com/github/tensorflow/docs/blob/master/site/en/tutorials/structured_data/imbalanced_data.ipynb)|[![](https://www.tensorflow.org/images/GitHub-Mark-32px.png)View source on GitHub](https://github.com/tensorflow/docs/blob/master/site/en/tutorials/structured_data/imbalanced_data.ipynb)|[![](https://www.tensorflow.org/images/download_logo_32px.png)Download notebook](https://storage.googleapis.com/tensorflow_docs/docs/site/en/tutorials/structured_data/imbalanced_data.ipynb)|\\nThis tutorial demonstrates how to classify a highly imbalanced dataset in which the number of examples in one class greatly outnumbers the examples in another. You will work with the[Credit Card Fraud Detection](https://www.kaggle.com/mlg-ulb/creditcardfraud)dataset hosted on Kaggle. The aim is to detect a mere 492 fraudulent transactions from 284,807 transactions in total. You will use[Keras](https://www.tensorflow.org/guide/keras/overview)to define the model and[class weights](https://www.tensorflow.org/versions/r2.0/api_docs/python/tf/keras/Model)to help the model learn from the imbalanced data. .\\nThis tutorial contains complete code to:\\n* Load a CSV file using Pandas.\\n* Create train, validation, and test sets.\\n* Define and train a model using Keras (including setting class weights).\\n* Evaluate the model using various metrics (including precision and recall).\\n* Select a threshold for a probabilistic classifier to get a deterministic classifier.\\n* Try and compare with class weighted modelling and oversampling.## Setup\\n```\\n`importtensorflowastffromtensorflowimportkerasimportosimporttempfileimportmatplotlibasmplimportmatplotlib.pyplotaspltimportnumpyasnpimportpandasaspdimportseabornassnsimportsklearnfromsklearn.metricsimportconfusion\\\\_matrixfromsklearn.model\\\\_selectionimporttrain\\\\_test\\\\_splitfromsklearn.preprocessingimportStandardScaler`\\n```\\n```\\n2024-08-20 01:23:52.305388: E external/local\\\\_xla/xla/stream\\\\_executor/cuda/cuda\\\\_fft.cc:485] Unable to register cuFFT factory: Attempting to register factory for plugin cuFFT when one has already been registered\\n2024-08-20 01:23:52.326935: E external/local\\\\_xla/xla/stream\\\\_executor/cuda/cuda\\\\_dnn.cc:8454] Unable to register cuDNN factory: Attempting to register factory for plugin cuDNN when one has already been registered\\n2024-08-20 01:23:52.333533: E external/local\\\\_xla/xla/stream\\\\_executor/cuda/cuda\\\\_blas.cc:1452] Unable to register cuBLAS factory: Attempting to register factory for plugin cuBLAS when one has already been registered\\n```\\n```\\n`mpl.rcParams['figure.figsize']=(12,10)colors=plt.rcParams['axes.prop\\\\_cycle'].by\\\\_key()['color']`\\n```\\n## Data processing and exploration\\n### Download the Kaggle Credit Card Fraud data set\\nPandas is a Python library with many helpful utilities for loading and working with structured data. It can be used to download CSVs into a Pandas[DataFrame](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas.DataFrame).\\n**Note:**This dataset has been collected and analysed during a research collaboration of Worldline and the[Machine Learning Group](http://mlg.ulb.ac.be)of ULB (Université Libre de Bruxelles) on big data mining and fraud detection. More details on current and past projects on related topics are available[here](https://www.researchgate.net/project/Fraud-detection-5)and the page of the[DefeatFraud](https://mlg.ulb.ac.be/wordpress/portfolio_page/defeatfraud-assessment-and-validation-of-deep-feature-engineering-and-learning-solutions-for-fraud-detection/)project\\n```\\n`file=tf.keras.utilsraw\\\\_df=pd.read\\\\_csv('https://storage.googleapis.com/download.tensorflow.org/data/creditcard.csv')raw\\\\_df.head()`\\n```\\n```\\n`raw\\\\_df[['Time','V1','V2','V3','V4','V5','V26','V27','V28','Amount','Class']].describe()`\\n```\\n### Examine the class label imbalance\\nLet's look at the dataset imbalance:\\n```\\n`neg,pos=np.bincount(raw\\\\_df['Class'])total=neg+posprint('Examples:\\\\\\\\nTotal:{}\\\\\\\\nPositive:{}({:.2f}% of total)\\\\\\\\n'.format(total,pos,100\\\\*pos/total))`\\n```\\n```\\nExamples:\\nTotal: 284807\\nPositive: 492 (0.17% of total)\\n```\\nThis shows the small fraction of positive samples.\\n### Clean, split and normalize the data\\nThe raw data has a few issues. First the`Time`and`Amount`columns are too variable to use directly. Drop the`Time`column (since it's not clear what it means) and take the log of the`Amount`column to reduce its range.\\n```\\n`cleaned\\\\_df=raw\\\\_df.copy()# You don't want the `Time` column.cleaned\\\\_df.pop('Time')# The `Amount` column covers a huge range. Convert to log-space.eps=0.001# 0 =&gt; 0.1¢cleaned\\\\_df['Log Amount']=np.log(cleaned\\\\_df.pop('Amount')+eps)`\\n```\\nSplit the dataset into train, validation, and test sets. The validation set is used during the model fitting to evaluate the loss and any metrics, however the model is not fit with this data. The test set is completely unused during the training phase and is only used at the end to evaluate how well the model generalizes to new data. This is especially important with imbalanced datasets where[overfitting](https://developers.google.com/machine-learning/crash-course/generalization/peril-of-overfitting)is a significant concern from the lack of training data.\\n```\\n`# Use a utility from sklearn to split and shuffle your dataset.train\\\\_df,test\\\\_df=train\\\\_test\\\\_split(cleaned\\\\_df,test\\\\_size=0.2)train\\\\_df,val\\\\_df=train\\\\_test\\\\_split(train\\\\_df,test\\\\_size=0.2)# Form np arrays of labels and features.train\\\\_labels=np.array(train\\\\_df.pop('Class')).reshape(-1,1)bool\\\\_train\\\\_labels=train\\\\_labels[:,0]!=0val\\\\_labels=np.array(val\\\\_df.pop('Class')).reshape(-1,1)test\\\\_labels=np.array(test\\\\_df.pop('Class')).reshape(-1,1)train\\\\_features=np.array(train\\\\_df)val\\\\_features=np.array(val\\\\_df)test\\\\_features=np.array(test\\\\_df)`\\n```\\nWe check whether the distribution of the classes in the three sets is about the same or not.\\n```\\n`print(f'Average class probability in training set:{train\\\\_labels.mean():.4f}')print(f'Average class probability in validation set:{val\\\\_labels.mean():.4f}')print(f'Average class probability in test set:{test\\\\_labels.mean():.4f}')`\\n```\\n```\\nAverage class probability in training set: 0.0017\\nAverage class probability in validation set: 0.0018\\nAverage class probability in test set: 0.0018\\n```\\nGiven the small number of positive labels, this seems about right.\\nNormalize the input features using the sklearn StandardScaler.\\nThis will set the mean to 0 and standard deviation to 1.\\n**Note:**The`StandardScaler`is only fit using the`train\\\\_features`to be sure the model is not peeking at the validation or test sets.\\n```\\n`scaler=StandardScaler()train\\\\_features=scaler.fit\\\\_transform(train\\\\_features)val\\\\_features=scaler.transform(val\\\\_features)test\\\\_features=scaler.transform(test\\\\_features)train\\\\_features=np.clip(train\\\\_features,-5,5)val\\\\_features=np.clip(val\\\\_features,-5,5)test\\\\_features=np.clip(test\\\\_features,-5,5)print('Training labels shape:',train\\\\_labels.shape)print('Validation labels shape:',...\", \"url\": \"https://www.tensorflow.org/tutorials/structured_data/imbalanced_data\"}, {\"title\": \"GitHub - rafiko1/jigsaw-multilingual-competition: TensorFlow code used by the 1st place winner of the 2020 Kaggle multilingual Toxic Comments competition\", \"text\": \"[Skip to content](https://github.com/rafiko1/jigsaw-multilingual-competition#start-of-content)\\n\\nYou signed in with another tab or window. [Reload](https://github.com/rafiko1/jigsaw-multilingual-competition) to refresh your session.You signed out in another tab or window. [Reload](https://github.com/rafiko1/jigsaw-multilingual-competition) to refresh your session.You switched accounts on another tab or window. [Reload](https://github.com/rafiko1/jigsaw-multilingual-competition) to refresh your session.Dismiss alert\\n\\n{{ message }}\\n\\n[rafiko1](https://github.com/rafiko1)/ **[jigsaw-multilingual-competition](https://github.com/rafiko1/jigsaw-multilingual-competition)** Public\\n\\n- [Notifications](https://github.com/login?return_to=%2Frafiko1%2Fjigsaw-multilingual-competition) You must be signed in to change notification settings\\n- [Fork\\\\\\n0](https://github.com/login?return_to=%2Frafiko1%2Fjigsaw-multilingual-competition)\\n- [Star\\\\\\n4](https://github.com/login?return_to=%2Frafiko1%2Fjigsaw-multilingual-competition)\\n\\n\\nTensorFlow code used by the 1st place winner of the 2020 Kaggle multilingual Toxic Comments competition\\n\\n[4\\\\\\nstars](https://github.com/rafiko1/jigsaw-multilingual-competition/stargazers) [0\\\\\\nforks](https://github.com/rafiko1/jigsaw-multilingual-competition/forks) [Branches](https://github.com/rafiko1/jigsaw-multilingual-competition/branches) [Tags](https://github.com/rafiko1/jigsaw-multilingual-competition/tags) [Activity](https://github.com/rafiko1/jigsaw-multilingual-competition/activity)\\n\\n[Star](https://github.com/login?return_to=%2Frafiko1%2Fjigsaw-multilingual-competition)\\n\\n[Notifications](https://github.com/login?return_to=%2Frafiko1%2Fjigsaw-multilingual-competition) You must be signed in to change notification settings\\n\\n# rafiko1/jigsaw-multilingual-competition\\n\\nThis commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.\\n\\nmaster\\n\\n[Branches](https://github.com/rafiko1/jigsaw-multilingual-competition/branches) [Tags](https://github.com/rafiko1/jigsaw-multilingual-competition/tags)\\n\\nGo to file\\n\\nCode\\n\\n## Folders and files\\n\\n| Name | Name | Last commit message | Last commit date |\\n| --- | --- | --- | --- |\\n| ## Latest commit<br>## History<br>[74 Commits](https://github.com/rafiko1/jigsaw-multilingual-competition/commits/master/) |\\n| [README.md](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/README.md) | [README.md](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/README.md) |  |  |\\n| [post\\\\_processing\\\\_example.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/post_processing_example.ipynb) | [post\\\\_processing\\\\_example.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/post_processing_example.ipynb) |  |  |\\n| [template-es-it-tr.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-es-it-tr.ipynb) | [template-es-it-tr.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-es-it-tr.ipynb) |  |  |\\n| [template-pt-ru-fr.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-pt-ru-fr.ipynb) | [template-pt-ru-fr.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-pt-ru-fr.ipynb) |  |  |\\n| [template-train-bias.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-train-bias.ipynb) | [template-train-bias.ipynb](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-train-bias.ipynb) |  |  |\\n| View all files |\\n\\n## Repository files navigation\\n\\n### Introduction\\n\\nThe Tensorflow code released here, was implemented using Kaggle TPUv3 by the 1st place winner of the [2020 Jigsaw Multilingual Kaggle competition](https://www.kaggle.com/c/jigsaw-multilingual-toxic-comment-classification). It was the 3rd annual competition organized by the Jigsaw team. It followed [Toxic Comment Classification Challenge](https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge), the original 2018 competition, and [Jigsaw Unintended Bias in Toxicity Classification](https://www.kaggle.com/c/jigsaw-unintended-bias-in-toxicity-classification) in 2019.\\n\\nThe goal was to run multilingual toxicity predictions on six different languages (i.e. es, tr, it, ru, pt and fr), and promote the usage of TPU.\\n\\nOur solution is detailed in this [Kaggle forum post](https://www.kaggle.com/c/jigsaw-multilingual-toxic-comment-classification/discussion/160862).\\n\\nThe code is part of the overall solution with another part leveraging similar [Pytorch models](https://github.com/leecming/jigsaw-multilingual) trained locally.\\n\\n### Recipe for training:\\n\\n1. Bootstrap test-set predictions (pseudo-labels) for all languages using the\\nXLM-Roberta-Large multilingual model (XLM-R)\\n2. Train a monolingual/multilingual\\nmodel, and predict test-set samples in the relevant language(s)\\n3. Blend predictions from the current model with the previous ensemble\\npredictions - update pseudo-labels\\n4. Repeat steps 2 and 3 with various pretrained monolingual and multilingual\\nmodels.\\n\\nRelevant upgrades to training:\\n\\n1. Implement pseudolabels togehter with train labels in step 2\\n2. Use a post-processing technique\\n\\nWe provide 3 sets of sample pseudo-labels (scoring on public LB: 9372, 9500, 9537) for you to test training monolingual and multilingual models against.\\n\\nFor post-processing, we also provide 11 pseudolabels where subsequent Russian labels were updated after training.\\n\\nYou can refer to the **Data and model files** section below for more info.\\n\\n### Getting started\\n\\n- Training a XLM-R Spanish baseline [here](https://www.kaggle.com/rafiko1/1st-place-baseline-xlm-r-es-it-tr)\\n- Make use of the post-processing technique on Russian examples [here](https://www.kaggle.com/rafiko1/1st-place-jigsaw-post-processing-example)\\n\\n### Code\\n\\n| Training | Comment |\\n| --- | --- |\\n| [Template for es/it/tr](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-es-it-tr.ipynb) | monolingual approach for languages with validation set (es/it/tr). Default model: XLM-R |\\n| [Template for pt/ru/fr](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-pt-ru-fr.ipynb) | monolingual approach for languages without validation set (pt/ru/fr). Default model: XLM-R |\\n| [Template train-bias](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/template-train-bias.ipynb) | monolingual approach using train-bias dataset. Default model: XLM-R |\\n\\n| Post-processing | Comment |\\n| --- | --- |\\n| [Post-processing example](https://github.com/rafiko1/jigsaw-multilingual-competition/blob/master/post-processing-example.ipynb) | Post-processing technique using Russian-specific pseudolabels as example |\\n\\n### Data and model files\\n\\n1. HuggingFace models are downloaded directly via API so there is no need to manually download them.\\n2. Public kernel [Jigsaw TPU: XLM-Roberta](https://www.kaggle.com/xhlulu/jigsaw-tpu-xlm-roberta) that inspired the code (can be used as bootstrap labels)\\n3. Translations of the Toxic 2018 dataset and pseudo-labels for public LB 9372, public LB 9500, public LB 9537 can be found [here](https://www.kaggle.com/leecming/multilingual-toxic-comments-training-data).\\n4. Translation of the Toxic 2019 Unintended bias dataset is found [here](https://www.kaggle.com/rafiko1/translated-train-bias-all-langs)\\n5. Post-processing intended: 11 Russian-specific updated pseudolabels [here](https://www.kaggle.com/rafiko1/ru-changed-subs)\\n\\n### Notes\\n\\n1. Below lists the various pretrained HuggingFace transformer models we used -\\n\\n| Language | Models |\\n| --- | --- |\\n| All | jplu/tf-xlm-roberta-large |\\n| French | camembert-base, camembert/camembert-large, flaubert/flaubert\\\\_large\\\\_cased |\\n| Italian | dbmdz/bert-base-italian-xxl-cased, dbmdz/bert-base-italian-xxl-uncased, m-polignano-uniba/bert\\\\_uncased\\\\_L-12\\\\_H-768\\\\_A-12\\\\_italian\\\\_alb3rt0 |\\n| Portuguese | neuralmind...\", \"url\": \"https://github.com/rafiko1/jigsaw-multilingual-competition\"}, {\"title\": \"Jigsaw Unintended Bias in Toxicity Classification — Kaggle Competition\", \"text\": \"[Open in app](https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F48c799fe2046&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderUser&source=post_page---top_nav_layout_nav-----------------------------------------)\\n\\nSign up\\n\\n[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2F%40vaibhavb837%2Fjigsaw-unintended-bias-in-toxicity-classification-kaggle-competition-48c799fe2046&source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\\n\\n[Write](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---top_nav_layout_nav-----------------------new_post_topnav------------------)\\n\\nSign up\\n\\n[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2F%40vaibhavb837%2Fjigsaw-unintended-bias-in-toxicity-classification-kaggle-competition-48c799fe2046&source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\\n\\n![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)\\n\\n# Jigsaw Unintended Bias in Toxicity Classification — Kaggle Competition\\n\\n[![Vaibhavb](https://miro.medium.com/v2/da:true/resize:fill:64:64/0*CS05pEhg6ng-uxS7)](https://medium.com/@vaibhavb837?source=post_page---byline--48c799fe2046---------------------------------------)\\n\\n[Vaibhavb](https://medium.com/@vaibhavb837?source=post_page---byline--48c799fe2046---------------------------------------)\\n\\nFollow\\n\\n10 min read\\n\\n·\\n\\nOct 17, 2020\\n\\n--\\n\\n1\\n\\nListen\\n\\nShare\\n\\n> Jigsaw is a unit within Google that forecasts and confronts emerging threats, creating future-defining research and technology to keep our world safer.\\n\\n> The Conversation AI team, a research initiative founded by Jigsaw and Google (both part of Alphabet), builds technology to protect voices in the conversation. A main area of focus is machine learning models that can identify toxicity in online conversations, where toxicity is defined as anything rude, disrespectful, or otherwise likely to make someone leave a discussion.\\n\\n# Business Problem:\\n\\n**Problem source:**\\n\\n[**Jigsaw Unintended Bias in Toxicity Classification** \\\\\\n\\\\\\n**Detect toxicity across a diverse range of conversations**\\\\\\n\\\\\\nwww.kaggle.com](https://www.kaggle.com/c/jigsaw-unintended-bias-in-toxicity-classification/overview/description?source=post_page-----48c799fe2046---------------------------------------)\\n\\n## Problem statement:\\n\\nWhen the **Conversation AI** team first built toxicity models, they found that the models incorrectly learned to associate the names of frequently attacked identities with toxicity. Models predicted a high likelihood of toxicity for comments containing those identities (e.g. “gay”), even when those comments were not actually toxic (such as “I am a gay woman”). This happens because training data was pulled from available sources where, unfortunately, certain identities are overwhelmingly referred to in offensive ways. Training a model from data with these imbalances risks simply mirroring those biases back to users.\\n\\n**Task:** We have to build a model that recognizes toxicity and minimizes this type of unintended bias concerning mentions of identities. We’ll be using a dataset labeled for identity mentions and optimizing a metric designed to measure unintended bias.\\n\\n**_Disclaimer:_** _The dataset for this competition contains text that may be considered profane, vulgar, or offensive._\\n\\n## Data collection:\\n\\n**File descriptions:** Data Size: 0.8 GB\\n\\n- **train.csv** — the training set, which includes toxicity labels and subgroups\\n- **test.csv**— the test set, which does not include toxicity labels or subgroups\\n- **sample\\\\_submission.csv** — a sample submission file in the correct format\\n\\n## Background:\\n\\nAt the end of 2017, the [**Civil Comments**](https://medium.com/@aja_15265/saying-goodbye-to-civil-comments-41859d3a2b1d) platform shut down and chose to make their ~2m public comments from their platform available in a lasting open archive so that researchers could understand and improve civility in online conversations for years to come. Jigsaw sponsored this effort and extended annotation of this data by human raters for various toxic conversational attributes.\\n\\nIn the data supplied for this competition, the text of the individual comment is found in the comment\\\\_text column. Each comment in Train has a toxicity label (target), and models should predict the target toxicity for the Test data. This attribute (and all others) are fractional values which represent the fraction of human raters who believed the attribute applied to the given comment. For evaluation, the test set examples with target >= 0.5 will be considered to be in a positive class (toxic).\\n\\n## Competition Evaluation:\\n\\nThis competition will use a newly developed metric that combines several submatrices to balance overall performance with various aspects of unintended bias.\\n\\nFirst, we’ll define each submatrix.\\n\\n**Overall AUC:** This is the ROC-AUC for the full evaluation set.\\n\\n**Generalized Mean of Bias AUCs:**\\n\\n**Generalized Mean of Bias AUCs**\\n\\n**Mₚ** = the _p_ ᵗʰ power-mean function\\n\\n**mₛ** = the bias metric **_m_** calculated for subgroup **_s_**\\n\\n**N** = number of identity subgroups\\n\\n> For this competition, we use a p value of -5 to encourage competitors to improve the model for the identity subgroups with the lowest model performance.\\n\\n## **Final Metric:**\\n\\n**A** = number of submatrices (3)\\n\\n**mₛ**, **ₐ** = bias metric for identity subgroup **_s_** using submatrix **_a_**\\n\\n**wₐ** = a weighting for the relative importance of each submatrix; all four **_w_** values set to 0.25\\n\\n# Loading Data:\\n\\n```\\n# TRAIN DATA\\ntrain = pd.read_csv(‘project_dataset/train.csv’)# TEST DATA\\ntest = pd.read_csv('project_dataset/test.csv')\\n```\\n\\n> **Dimensions:**\\n>\\n> _Train_\\\\- (1804874, 45)\\n>\\n> _Test_ \\\\- (97320, 2)\\n\\nTrain Dataset ( **train.head()**)\\n\\nTest Dataset ( **test.head()**)\\n\\n**Point:** In this competition, **target** >= 0.5 will be considered to be in a positive class (toxic)\\n\\n```\\nt_c = (train['target'].values>=0.5).astype(np.int).sum()\\nprint(\\\"Total number of toxic comments in the dataset:\\\", t_c)nt_c = (train['target'].values<=0.5).astype(np.int).sum()\\nprint(\\\"Total number of non-toxic comments in the dataset:\\\", nt_c)\\n```\\n\\n> Total number of toxic comments in the dataset: 144334\\n>\\n> Total number of non-toxic comments in the dataset: 1698436\\n\\nChecking if their’s any null elements in the dataset:\\n\\n```\\ntrain.isnull().sum()\\n```\\n\\n**Note:** There are **1399744** number of null entries in several columns in the training dataset.\\n\\nThe data also has several additional toxicity subtype attributes. Models do not need to predict these attributes for the competition, they are included as an additional avenue for research. Subtype attributes are:\\n\\n1. severe\\\\_toxicity\\n2. obscene\\n3. threat\\n4. insult\\n5. identity\\\\_attack\\n6. sexual\\\\_explicit\\n\\n**Plotting number of comments VS comment types**\\n\\nThe dataset is highly imbalanced in nature. Here, we can observe that most of the dataset is clean and we have very few comments where the comment is considered as severely toxic.\\n\\n**Violin Plot of Comment length and toxicity (0 or 1)**\\n\\nWe can observe some outliers in the training dataset but the average length of a comment is similar in both the train and test dataset.\\n\\n**The dataset also provides us the time of comments so we can also check how time has affected the type of comments**\\n\\nWhat we observe are as follows:\\n\\n1. White identity in the comments is used the most.\\n2. when it comes to religious basis then Muslim identity is used most frequently.\\n3. homosexual identity is used most commonly in comments.\\n4. comments about transgender people have been commented on most.\\n\\nWe have done the necessary EDA for our data now let’s build the model to tackle this problem. For this NLP problem, we are going to use LSTM and BERT models.\\n\\n**What is LSTM?**\\n\\nLet me put it in simple words, LSTM is **Long short-term memory** networks a type of R...\", \"url\": \"https://medium.com/@vaibhavb837/jigsaw-unintended-bias-in-toxicity-classification-kaggle-competition-48c799fe2046\"}]}",
        "tool.duration_ms": 4275.863170623779
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "8de36b77aff48c22",
      "parent_span_id": "4df94b9b0f13c589",
      "name": "llm.openai/o1",
      "kind": "CLIENT",
      "start_time": 1767939820712049120,
      "end_time": 1767939845618232608,
      "duration": 24.906183488,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "llm",
        "llm.model": "openai/o1",
        "llm.provider": "openai",
        "cascade.agent_name": "ExplorerAgent",
        "llm.max_tokens": 4000,
        "llm.prompt": "user: Evaluate subagent ExplorerAgent at loop 0 for potential RL update.\n\nCompetition: random-acts-of-pizza\nMetric: higher is better\n\nCall log contains 0 LLM interactions to evaluate.\n\nCALL LOG:\n\n--- Tool Call: ListFilesTool ---\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.file_tools.ListFilesTool object at 0x738bd1a8a590>\", \"input\": {\"directory_path\": \"/home/data\"}}\nOutput: {\"content\": \"/home/data:\\n[FILE] description.md (7.0KB)\\n[FILE] sampleSubmission.csv (13.0KB)\\n[FILE] test.json (2.0MB)\\n[FILE] test.zip (433.1KB)\\n[FILE] train.json (8.4MB)\\n[FILE] train.zip (1.3MB)\", \"is_error\": false}\n\n--- Tool Call: ReadTool ---\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.file_tools.ReadTool object at 0x738bd1a8a490>\", \"input\": {\"file_path\": \"/home/data/description.md\"}}\nOutput: {\"content\": \"# Overview\\n\\n## Description\\n\\n[Get started on this competition through Kaggle Scripts](https://www.kaggle.com/c/random-acts-of-pizza/forums/t/14286/kaggle-scripts-enabled-on-random-acts-of-pizza)\\n\\nIn machine learning, it is often said there are [no free lunches](http://en.wikipedia....\n\n--- Tool Call: CreateNotebookTool ---\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.notebook.CreateNotebookTool object at 0x738bd1a8a7d0>\", \"input\": {\"notebook_path\": \"eda.ipynb\", \"cells\": [{\"cell_type\": \"code\", \"content\": \"import pandas as pd\\nimport numpy as np\\nimport json\\n\\n# Load the training data\\ntrain_path = \\\"/home/data/train.jso...\nOutput: {\"content\": \"Created: /home/code/exploration/eda.ipynb\\n\\nStrong Note: OOM is unrecoverable. Use strong models - just estimate memory first.\", \"is_error\": false}\n\n--- Tool Call: ExecuteCellRangeTool ---\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.notebook.ExecuteCellRangeTool object at 0x738bf6c14150>\", \"input\": {\"start_cell\": 0, \"duration\": 30}}\nOutput: {\"content\": \"Executed cells 0-0\\n==================================================\\n\\nCell 0:\\n```\\nimport pandas as pd\\nimport numpy as np\\nimport json\\n\\n# Load the training data\\ntrain_path = \\\"/home/data/train.json\\\"\\n\\n# Read the JSON file\\nwith open(train_path, 'r') as f:\\n    train_data = js...\n\n--- Tool Call: AddNotebookCellTool ---\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.notebook.AddNotebookCellTool object at 0x738bd1df65d0>\", \"input\": {\"cell_type\": \"code\", \"content\": \"# Convert to DataFrame for easier analysis\\ndf = pd.DataFrame(train_data)\\n\\n# Check target distribution\\nprint(\\\"Target distribution:\\\")\\nprint(df['requeste...\nOutput: {\"content\": \"Added code cell at 1\", \"is_error\": false}\n\n--- Tool Call: ExecuteCellRangeTool ---\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.notebook.ExecuteCellRangeTool object at 0x738bf6c14150>\", \"input\": {\"start_cell\": 1, \"duration\": 30}}\nOutput: {\"content\": \"Executed cells 1-1\\n==================================================\\n\\nCell 1:\\n```\\n# Convert to DataFrame for easier analysis\\ndf = pd.DataFrame(train_data)\\n\\n# Check target distribution\\nprint(\\\"Target distribution:\\\")\\nprint(df['requester_received_pizza'].value_counts())\\nprint(...\n\n--- Tool Call: AddNotebookCellTool ---\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.notebook.AddNotebookCellTool object at 0x738bd1df65d0>\", \"input\": {\"cell_type\": \"code\", \"content\": \"# Explore text features\\nprint(\\\"Sample request title:\\\")\\nprint(df['request_title'].iloc[0][:200])\\nprint(\\\"\\\\n\\\" + \\\"=\\\"*50)\\n\\nprint(\\\"Sample request text...\nOutput: {\"content\": \"Added code cell at 2\", \"is_error\": false}\n\n--- Tool Call: ExecuteCellRangeTool ---\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.notebook.ExecuteCellRangeTool object at 0x738bf6c14150>\", \"input\": {\"start_cell\": 2, \"duration\": 30}}\nOutput: {\"content\": \"Executed cells 2-2\\n==================================================\\n\\nCell 2:\\n```\\n# Explore text features\\nprint(\\\"Sample request title:\\\")\\nprint(df['request_title'].iloc[0][:200])\\nprint(\\\"\\\\n\\\" + \\\"=\\\"*50)\\n\\nprint(\\\"Sample request text:\\\")\\nprint(df['request_text'].iloc[0][:30...\n\n--- Tool Call: WebSearchTool ---\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.research.WebSearchTool object at 0x738bf6c14210>\", \"input\": {\"query\": \"What are winning approaches for text classification with metadata features on Kaggle competitions?\"}}\nOutput: {\"content\": \"SEARCH RESULTS (9 found)\\n==================================================\\n\\n--- Result 1 ---\\nTitle: ANSWER\\n\\nContent:\\nWinning Kaggle solutions for text classification that also have metadata usually treat the non‑text fields as first‑class inputs rather than an after‑thought.  A ...\n\n--- Tool Call: WebSearchTool ---\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.research.WebSearchTool object at 0x738bf6c14210>\", \"input\": {\"query\": \"How do Kaggle winners handle class imbalance in text classification competitions?\"}}\nOutput: {\"content\": \"SEARCH RESULTS (9 found)\\n==================================================\\n\\n--- Result 1 ---\\nTitle: ANSWER\\n\\nContent:\\nBased on the strategies described by Kaggle winners in the Jigsaw‑toxic‑comment and other text‑classification contests, the most common ways to tame severe class ...\n\nUse the reward function rubric to score progress and identify failed calls.",
        "llm.messages": "[{'role': 'user', 'content': 'Evaluate subagent ExplorerAgent at loop 0 for potential RL update.\\n\\nCompetition: random-acts-of-pizza\\nMetric: higher is better\\n\\nCall log contains 0 LLM interactions to evaluate.\\n\\nCALL LOG:\\n\\n--- Tool Call: ListFilesTool ---\\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.file_tools.ListFilesTool object at 0x738bd1a8a590>\", \"input\": {\"directory_path\": \"/home/data\"}}\\nOutput: {\"content\": \"/home/data:\\\\n[FILE] description.md (7.0KB)\\\\n[FILE] sampleSubmission.csv (13.0KB)\\\\n[FILE] test.json (2.0MB)\\\\n[FILE] test.zip (433.1KB)\\\\n[FILE] train.json (8.4MB)\\\\n[FILE] train.zip (1.3MB)\", \"is_error\": false}\\n\\n--- Tool Call: ReadTool ---\\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.file_tools.ReadTool object at 0x738bd1a8a490>\", \"input\": {\"file_path\": \"/home/data/description.md\"}}\\nOutput: {\"content\": \"# Overview\\\\n\\\\n## Description\\\\n\\\\n[Get started on this competition through Kaggle Scripts](https://www.kaggle.com/c/random-acts-of-pizza/forums/t/14286/kaggle-scripts-enabled-on-random-acts-of-pizza)\\\\n\\\\nIn machine learning, it is often said\\xa0there are\\xa0[no free lunches](http://en.wikipedia....\\n\\n--- Tool Call: CreateNotebookTool ---\\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.notebook.CreateNotebookTool object at 0x738bd1a8a7d0>\", \"input\": {\"notebook_path\": \"eda.ipynb\", \"cells\": [{\"cell_type\": \"code\", \"content\": \"import pandas as pd\\\\nimport numpy as np\\\\nimport json\\\\n\\\\n# Load the training data\\\\ntrain_path = \\\\\"/home/data/train.jso...\\nOutput: {\"content\": \"Created: /home/code/exploration/eda.ipynb\\\\n\\\\nStrong Note: OOM is unrecoverable. Use strong models - just estimate memory first.\", \"is_error\": false}\\n\\n--- Tool Call: ExecuteCellRangeTool ---\\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.notebook.ExecuteCellRangeTool object at 0x738bf6c14150>\", \"input\": {\"start_cell\": 0, \"duration\": 30}}\\nOutput: {\"content\": \"Executed cells 0-0\\\\n==================================================\\\\n\\\\nCell 0:\\\\n```\\\\nimport pandas as pd\\\\nimport numpy as np\\\\nimport json\\\\n\\\\n# Load the training data\\\\ntrain_path = \\\\\"/home/data/train.json\\\\\"\\\\n\\\\n# Read the JSON file\\\\nwith open(train_path, \\'r\\') as f:\\\\n    train_data = js...\\n\\n--- Tool Call: AddNotebookCellTool ---\\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.notebook.AddNotebookCellTool object at 0x738bd1df65d0>\", \"input\": {\"cell_type\": \"code\", \"content\": \"# Convert to DataFrame for easier analysis\\\\ndf = pd.DataFrame(train_data)\\\\n\\\\n# Check target distribution\\\\nprint(\\\\\"Target distribution:\\\\\")\\\\nprint(df[\\'requeste...\\nOutput: {\"content\": \"Added code cell at 1\", \"is_error\": false}\\n\\n--- Tool Call: ExecuteCellRangeTool ---\\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.notebook.ExecuteCellRangeTool object at 0x738bf6c14150>\", \"input\": {\"start_cell\": 1, \"duration\": 30}}\\nOutput: {\"content\": \"Executed cells 1-1\\\\n==================================================\\\\n\\\\nCell 1:\\\\n```\\\\n# Convert to DataFrame for easier analysis\\\\ndf = pd.DataFrame(train_data)\\\\n\\\\n# Check target distribution\\\\nprint(\\\\\"Target distribution:\\\\\")\\\\nprint(df[\\'requester_received_pizza\\'].value_counts())\\\\nprint(...\\n\\n--- Tool Call: AddNotebookCellTool ---\\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.notebook.AddNotebookCellTool object at 0x738bd1df65d0>\", \"input\": {\"cell_type\": \"code\", \"content\": \"# Explore text features\\\\nprint(\\\\\"Sample request title:\\\\\")\\\\nprint(df[\\'request_title\\'].iloc[0][:200])\\\\nprint(\\\\\"\\\\\\\\n\\\\\" + \\\\\"=\\\\\"*50)\\\\n\\\\nprint(\\\\\"Sample request text...\\nOutput: {\"content\": \"Added code cell at 2\", \"is_error\": false}\\n\\n--- Tool Call: ExecuteCellRangeTool ---\\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.notebook.ExecuteCellRangeTool object at 0x738bf6c14150>\", \"input\": {\"start_cell\": 2, \"duration\": 30}}\\nOutput: {\"content\": \"Executed cells 2-2\\\\n==================================================\\\\n\\\\nCell 2:\\\\n```\\\\n# Explore text features\\\\nprint(\\\\\"Sample request title:\\\\\")\\\\nprint(df[\\'request_title\\'].iloc[0][:200])\\\\nprint(\\\\\"\\\\\\\\n\\\\\" + \\\\\"=\\\\\"*50)\\\\n\\\\nprint(\\\\\"Sample request text:\\\\\")\\\\nprint(df[\\'request_text\\'].iloc[0][:30...\\n\\n--- Tool Call: WebSearchTool ---\\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.research.WebSearchTool object at 0x738bf6c14210>\", \"input\": {\"query\": \"What are winning approaches for text classification with metadata features on Kaggle competitions?\"}}\\nOutput: {\"content\": \"SEARCH RESULTS (9 found)\\\\n==================================================\\\\n\\\\n--- Result 1 ---\\\\nTitle: ANSWER\\\\n\\\\nContent:\\\\nWinning Kaggle solutions for text classification that also have\\u202fmetadata\\u202fusually treat the non‑text fields as first‑class inputs rather than an after‑thought.  A ...\\n\\n--- Tool Call: WebSearchTool ---\\nInput: {\"self\": \"<agent_v7_live.agents.core.tools.research.WebSearchTool object at 0x738bf6c14210>\", \"input\": {\"query\": \"How do Kaggle winners handle class imbalance in text classification competitions?\"}}\\nOutput: {\"content\": \"SEARCH RESULTS (9 found)\\\\n==================================================\\\\n\\\\n--- Result 1 ---\\\\nTitle: ANSWER\\\\n\\\\nContent:\\\\nBased on the strategies described by Kaggle winners in the Jigsaw‑toxic‑comment and other text‑classification contests, the most common ways to tame severe class ...\\n\\nUse the reward function rubric to score progress and identify failed calls.'}]",
        "llm.input_tokens": 4717,
        "llm.output_tokens": 1277,
        "llm.total_tokens": 5994,
        "llm.latency_ms": 24906.152963638306,
        "llm.completion": "SCORE=0.4 TRIGGER=1\n{\n  \"score\": 0.4,\n  \"trigger_rl\": true,\n  \"llm_calls_to_rl\": [],\n  \"overall_failure_reason\": \"Only initial EDA steps performed; no modeling or metric-focused progress yet.\"\n}",
        "llm.cost_usd": 0.033305999999999995
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "4df94b9b0f13c589",
      "parent_span_id": "f632c9af536032ce",
      "name": "ExplorerAgent",
      "kind": "INTERNAL",
      "start_time": 1767939662409643621,
      "end_time": 1767939845620210482,
      "duration": 183.210566861,
      "status": {
        "status_code": "ERROR",
        "description": "ExplorationTimeoutException: ExplorationTimeoutException"
      },
      "attributes": {
        "cascade.span_type": "agent",
        "cascade.agent_name": "ExplorerAgent"
      },
      "events": [
        {
          "name": "exception",
          "timestamp": 1767939845619427797,
          "attributes": {
            "exception.type": "agent_v7_live.agents.explorer_agent.exceptions.ExplorationTimeoutException",
            "exception.message": "ExplorationTimeoutException",
            "exception.stacktrace": "Traceback (most recent call last):\n  File \"/opt/conda/envs/agent/lib/python3.11/site-packages/cascade/tracing.py\", line 354, in trace_agent\n    yield span\n  File \"/home/agent/agent_v7_live/main.py\", line 490, in run_explorer\n    await agent.run()\n  File \"/home/agent/agent_v7_live/agents/explorer_agent/agent.py\", line 399, in run\n    raise ExplorationTimeoutException(\nagent_v7_live.agents.explorer_agent.exceptions.ExplorationTimeoutException: ExplorationTimeoutException\n",
            "exception.escaped": "False"
          }
        },
        {
          "name": "exception",
          "timestamp": 1767939845620186205,
          "attributes": {
            "exception.type": "agent_v7_live.agents.explorer_agent.exceptions.ExplorationTimeoutException",
            "exception.message": "ExplorationTimeoutException",
            "exception.stacktrace": "Traceback (most recent call last):\n  File \"/opt/conda/envs/agent/lib/python3.11/site-packages/opentelemetry/trace/__init__.py\", line 589, in use_span\n    yield span\n  File \"/opt/conda/envs/agent/lib/python3.11/site-packages/opentelemetry/sdk/trace/__init__.py\", line 1105, in start_as_current_span\n    yield span\n  File \"/opt/conda/envs/agent/lib/python3.11/site-packages/cascade/tracing.py\", line 354, in trace_agent\n    yield span\n  File \"/home/agent/agent_v7_live/main.py\", line 490, in run_explorer\n    await agent.run()\n  File \"/home/agent/agent_v7_live/agents/explorer_agent/agent.py\", line 399, in run\n    raise ExplorationTimeoutException(\nagent_v7_live.agents.explorer_agent.exceptions.ExplorationTimeoutException: ExplorationTimeoutException\n",
            "exception.escaped": "False"
          }
        }
      ]
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "69ebb46559c86661",
      "parent_span_id": "5688fe1bfcee210f",
      "name": "ReadTool",
      "kind": "INTERNAL",
      "start_time": 1767939855482058727,
      "end_time": 1767939855482482006,
      "duration": 0.000423279,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "ReadTool",
        "cascade.agent_name": "ExecutorAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.file_tools.ReadTool object at 0x738b73928b90>\", \"input\": {\"file_path\": \"/home/session_state.json\"}}",
        "tool.output": "{\"content\": \"Error: [Errno 2] No such file or directory: '/home/session_state.json'\", \"is_error\": true}",
        "tool.duration_ms": 0.46515464782714844
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "348a1f54d5bef70d",
      "parent_span_id": "5688fe1bfcee210f",
      "name": "ReadTool",
      "kind": "INTERNAL",
      "start_time": 1767939865123370657,
      "end_time": 1767939865123719871,
      "duration": 0.000349214,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "ReadTool",
        "cascade.agent_name": "ExecutorAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.file_tools.ReadTool object at 0x738b73928b90>\", \"input\": {\"file_path\": \"/home/instructions.txt\"}}",
        "tool.output": "{\"content\": \"You are participating in a machine learning benchmark competition.\\n\\nYou will be given a machine learning task. You must solve the task by training a model and running the model on the test set to produce a submission file.\\n\\nINSTRUCTIONS\\n------\\n- **Competition-specific instructions**: The instructions for the competition are available in `/home/data/description.md`. Read this file to understand the problem setup.\\n- **Dataset**: The dataset files for the competition are available in `/home/data/`.\\n- **Submission**: You MUST produce a submission file at `/home/submission/submission.csv`. Failure to submit at this path will result in a failed attempt.\\n- **Test set**: The dataset you see in `/home/data/` may differ slightly from what is described in the competition instructions. Proceed with the train/test splits available to you.\\n\\nYour submission will be graded based on the metric in the competition-specific instructions. Your goal is to achieve a GOLD medal score on the competition task.\\n\", \"is_error\": false}",
        "tool.duration_ms": 0.39768218994140625
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "b9f43ba4d4b827fb",
      "parent_span_id": "5688fe1bfcee210f",
      "name": "ReadTool",
      "kind": "INTERNAL",
      "start_time": 1767939873708562218,
      "end_time": 1767939873708898630,
      "duration": 0.000336412,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "ReadTool",
        "cascade.agent_name": "ExecutorAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.file_tools.ReadTool object at 0x738b73928b90>\", \"input\": {\"file_path\": \"/home/data/description.md\"}}",
        "tool.output": "{\"content\": \"# Overview\\n\\n## Description\\n\\n[Get started on this competition through Kaggle Scripts](https://www.kaggle.com/c/random-acts-of-pizza/forums/t/14286/kaggle-scripts-enabled-on-random-acts-of-pizza)\\n\\nIn machine learning, it is often said there are [no free lunches](http://en.wikipedia.org/wiki/No_free_lunch_theorem). *How wrong we were.*\\n\\nThis competition contains a dataset with 5671 textual requests for pizza from the Reddit community [Random Acts of Pizza](http://www.reddit.com/r/Random_Acts_Of_Pizza/) together with their outcome (successful/unsuccessful) and meta-data. Participants must create an algorithm capable of predicting which requests will garner a cheesy (but sincere!) act of kindness.\\n\\n\\\"I'll write a poem, sing a song, do a dance, play an instrument, whatever! I just want a pizza,\\\" says one hopeful poster. What about making an algorithm?\\n\\n![Pizzas](https://storage.googleapis.com/kaggle-media/competitions/kaggle/3949/media/pizzas.png)\\n\\nKaggle is hosting this competition for the machine learning community to use for fun and practice. This [data](http://cs.stanford.edu/~althoff/raop-dataset/) was collected and graciously shared by [Althoff](http://www.timalthoff.com/) et al. (Buy them a pizza -- data collection is a thankless and tedious job!) We encourage participants to explore their [accompanying paper](http://cs.stanford.edu/~althoff/raop-dataset/altruistic_requests_icwsm.pdf) and ask that you cite the following reference in any publications that result from your work:\\n\\nTim Althoff, Cristian Danescu-Niculescu-Mizil, Dan Jurafsky. *How to Ask for a Favor: A Case Study on the Success of Altruistic Requests*, Proceedings of ICWSM, 2014.\\n\\n~*Pizza icons designed by Matthew Dera from the [Noun Project](http://thenounproject.com/term/pizza/30194/)*~\\n\\n### Evaluation\\n\\nSubmissions are evaluated on [area under the ROC curve](http://en.wikipedia.org/wiki/Receiver_operating_characteristic) between the predicted probability that a request will get pizza and the observed outcomes.\\n\\n### Submission File\\n\\nFor each request in the test set, you should predict a real-valued probability that it resulted in a pizza. The file should contain a header and have the following format:\\n\\n```\\nrequest_id,requester_received_pizza\\nt3_i8iy4,0\\nt3_1mfqi0,0\\nt3_lclka,0\\n...\\n...\\n```\\n\\n### Citation\\n\\nWill Cukierski. (2014). Random Acts of Pizza. Kaggle. https://kaggle.com/competitions/random-acts-of-pizza\\n\\n\\n# Data\\n\\n## Dataset Description\\n\\n[See, fork, and run a random forest benchmark model through Kaggle Scripts](https://www.kaggle.com/users/993/ben-hamner/random-acts-of-pizza/simple-julia-benchmark)\\n\\nThis dataset includes 5671 requests collected from the Reddit community [Random Acts of Pizza](http://www.reddit.com/r/Random_Acts_Of_Pizza/) between December 8, 2010 and September 29, 2013 (retrieved on September 30, 2013). All requests ask for the same thing: a free pizza. The outcome of each request -- whether its author received a pizza or not -- is known. Meta-data includes information such as: time of the request, activity of the requester, community-age of the requester, etc.\\n\\nEach JSON entry corresponds to one request (the first and only request by the requester on Random Acts of Pizza). We have removed fields from the test set which would not be available at the time of posting.\\n\\n## Data fields\\n\\n\\\"giver_username_if_known\\\": Reddit username of giver if known, i.e. the person satisfying the request (\\\"N/A\\\" otherwise).\\n\\n\\\"number_of_downvotes_of_request_at_retrieval\\\": Number of downvotes at the time the request was collected.\\n\\n\\\"number_of_upvotes_of_request_at_retrieval\\\": Number of upvotes at the time the request was collected.\\n\\n\\\"post_was_edited\\\": Boolean indicating whether this post was edited (from Reddit).\\n\\n\\\"request_id\\\": Identifier of the post on Reddit, e.g. \\\"t3_w5491\\\".\\n\\n\\\"request_number_of_comments_at_retrieval\\\": Number of comments for the request at time of retrieval.\\n\\n\\\"request_text\\\": Full text of the request.\\n\\n\\\"request_text_edit_aware\\\": Edit aware version of \\\"request_text\\\". We use a set of rules to strip edited comments indicating the success of the request such as \\\"EDIT: Thanks /u/foo, the pizza was delicous\\\".\\n\\n\\\"request_title\\\": Title of the request.\\n\\n\\\"requester_account_age_in_days_at_request\\\": Account age of requester in days at time of request.\\n\\n\\\"requester_account_age_in_days_at_retrieval\\\": Account age of requester in days at time of retrieval.\\n\\n\\\"requester_days_since_first_post_on_raop_at_request\\\": Number of days between requesters first post on RAOP and this request (zero if requester has never posted before on RAOP).\\n\\n\\\"requester_days_since_first_post_on_raop_at_retrieval\\\": Number of days between requesters first post on RAOP and time of retrieval.\\n\\n\\\"requester_number_of_comments_at_request\\\": Total number of comments on Reddit by requester at time of request.\\n\\n\\\"requester_number_of_comments_at_retrieval\\\": Total number of comments on Reddit by requester at time of retrieval.\\n\\n\\\"requester_number_of_comments_in_raop_at_request\\\": Total number of comments in RAOP by requester at time of request.\\n\\n\\\"requester_number_of_comments_in_raop_at_retrieval\\\": Total number of comments in RAOP by requester at time of retrieval.\\n\\n\\\"requester_number_of_posts_at_request\\\": Total number of posts on Reddit by requester at time of request.\\n\\n\\\"requester_number_of_posts_at_retrieval\\\": Total number of posts on Reddit by requester at time of retrieval.\\n\\n\\\"requester_number_of_posts_on_raop_at_request\\\": Total number of posts in RAOP by requester at time of request.\\n\\n\\\"requester_number_of_posts_on_raop_at_retrieval\\\": Total number of posts in RAOP by requester at time of retrieval.\\n\\n\\\"requester_number_of_subreddits_at_request\\\": The number of subreddits in which the author had already posted in at the time of request.\\n\\n\\\"requester_received_pizza\\\": Boolean indicating the success of the request, i.e., whether the requester received pizza.\\n\\n\\\"requester_subreddits_at_request\\\": The list of subreddits in which the author had already posted in at the time of request.\\n\\n\\\"requester_upvotes_minus_downvotes_at_request\\\": Difference of total upvotes and total downvotes of requester at time of request.\\n\\n\\\"requester_upvotes_minus_downvotes_at_retrieval\\\": Difference of total upvotes and total downvotes of requester at time of retrieval.\\n\\n\\\"requester_upvotes_plus_downvotes_at_request\\\": Sum of total upvotes and total downvotes of requester at time of request.\\n\\n\\\"requester_upvotes_plus_downvotes_at_retrieval\\\": Sum of total upvotes and total downvotes of requester at time of retrieval.\\n\\n\\\"requester_user_flair\\\": Users on RAOP receive badges (Reddit calls them flairs) which is a small picture next to their username. In our data set the user flair is either None (neither given nor received pizza, N=4282), \\\"shroom\\\" (received pizza, but not given, N=1306), or \\\"PIF\\\" (pizza given after having received, N=83).\\n\\n\\\"requester_username\\\": Reddit username of requester.\\n\\n\\\"unix_timestamp_of_request\\\": Unix timestamp of request (supposedly in timezone of user, but in most cases it is equal to the UTC timestamp -- which is incorrect since most RAOP users are from the USA).\\n\\n\\\"unix_timestamp_of_request_utc\\\": Unit timestamp of request in UTC.\", \"is_error\": false}",
        "tool.duration_ms": 0.3745555877685547
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "ee513171fb606f59",
      "parent_span_id": "5688fe1bfcee210f",
      "name": "ListFilesTool",
      "kind": "INTERNAL",
      "start_time": 1767939879870764687,
      "end_time": 1767939879871075904,
      "duration": 0.000311217,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "ListFilesTool",
        "cascade.agent_name": "ExecutorAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.file_tools.ListFilesTool object at 0x738b73928450>\", \"input\": {\"directory_path\": \"/home/data\"}}",
        "tool.output": "{\"content\": \"/home/data:\\n[FILE] description.md (7.0KB)\\n[FILE] sampleSubmission.csv (13.0KB)\\n[FILE] test.json (2.0MB)\\n[FILE] test.zip (433.1KB)\\n[FILE] train.json (8.4MB)\\n[FILE] train.zip (1.3MB)\", \"is_error\": false}",
        "tool.duration_ms": 0.3769397735595703
      }
    },
    {
      "trace_id": "d0c9ba8b5b1e8c2ccb9a71cf0d1c9b24",
      "span_id": "485f0c89816c7f3c",
      "parent_span_id": "5688fe1bfcee210f",
      "name": "ReadTool",
      "kind": "INTERNAL",
      "start_time": 1767939886431640831,
      "end_time": 1767939886432559879,
      "duration": 0.000919048,
      "status": {
        "status_code": "OK",
        "description": null
      },
      "attributes": {
        "cascade.span_type": "tool",
        "tool.name": "ReadTool",
        "cascade.agent_name": "ExecutorAgent",
        "tool.input": "{\"self\": \"<agent_v7_live.agents.core.tools.file_tools.ReadTool object at 0x738b73928b90>\", \"input\": {\"file_path\": \"/home/data/sampleSubmission.csv\", \"limit\": 10}}",
        "tool.output": "{\"content\": \"request_id,requester_received_pizza\\nt3_1aw5zf,0\\nt3_roiuw,0\\nt3_mjnbq,0\\nt3_t8wd1,0\\nt3_1m4zxu,0\\nt3_1jgnj6,0\\nt3_s4o1h,0\\nt3_1dg2a4,0\\nt3_trm7n,0\\nt3_s7k0h,0\\nt3_j2cxp,0\\nt3_jka9v,0\\nt3_lzjvv,0\\nt3_1epr8n,0\\nt3_1j1w1c,0\\nt3_1mx8pz,0\\nt3_l4llm,0\\nt3_m95c2,0\\nt3_yhec5,0\\nt3_kwqew,0\\nt3_121c2k,0\\nt3_m6v9p,0\\nt3_1l8aoa,0\\nt3_pkhyy,0\\nt3_n5je7,0\\nt3_vhvq1,0\\nt3_1o8uuk,0\\nt3_qdwgl,0\\nt3_s0t6p,0\\nt3_zqq84,0\\nt3_17gtl5,0\\nt3_ui761,0\\nt3_jc1u4,0\\nt3_r16t9,0\\nt3_lzkem,0\\nt3_m812c,0\\nt3_sotbx,0\\nt3_qqqde,0\\nt3_q22la,0\\nt3_12nnks,0\\nt3_1jx6ex,0\\nt3_jz46l,0\\nt3_10ukdp,0\\nt3_meys2,0\\nt3_1bo01c,0\\nt3_1g2xtg,0\\nt3_l0zas,0\\nt3_jhqic,0\\nt3_qht9n,0\\nt3_1fttue,0\\nt3_1cflvh,0\\nt3_17ihhv,0\\nt3_1091hq,0\\nt3_khd1w,0\\nt3_j4ms5,0\\nt3_t27zl,0\\nt3_1a94mq,0\\nt3_1i3qda,0\\nt3_1fy1og,0\\nt3_1j65wv,0\\nt3_lmy9r,0\\nt3_rmof0,0\\nt3_170xyf,0\\nt3_x00as,0\\nt3_kod7s,0\\nt3_kaip7,0\\nt3_tu076,0\\nt3_woken,0\\nt3_i9cf1,0\\nt3_jrp9c,0\\nt3_v477d,0\\nt3_hlvzn,0\\nt3_10h4k4,0\\nt3_1484sj,0\\nt3_lhgee,0\\nt3_n4zpe,0\\nt3_11fmfp,0\\nt3_qwy2m,0\\nt3_187oid,0\\nt3_m0nxw,0\\nt3_1g8kf3,0\\nt3_ignyn,0\\nt3_zwf27,0\\nt3_lhi6m,0\\nt3_yte0l,0\\nt3_11hoxm,0\\nt3_t0dvv,0\\nt3_1lulit,0\\nt3_i693s,0\\nt3_19o5oe,0\\nt3_1j64hc,0\\nt3_uhfo4,0\\nt3_16gep8,0\\nt3_1laja1,0\\nt3_14yhq1,0\\nt3_1hpzqs,0\\nt3_11vgte,0\\nt3_mco6j,0\\nt3_wko45,0\\nt3_zrzdo,0\\nt3_flezd,0\\nt3_1mgesx,0\\nt3_jg1tx,0\\nt3_1nd4dt,0\\nt3_189m64,0\\nt3_1ii7cp,0\\nt3_tj0s0,0\\nt3_12p0tt,0\\nt3_13qwpa,0\\nt3_1mdson,0\\nt3_ki3f0,0\\nt3_myf58,0\\nt3_jdy60,0\\nt3_tzuki,0\\nt3_r1cak,0\\nt3_1lbper,0\\nt3_rgg9c,0\\nt3_147zyr,0\\nt3_ihe06,0\\nt3_13jcdx,0\\nt3_zpn24,0\\nt3_1mmlp7,0\\nt3_1azv0d,0\\nt3_1291w9,0\\nt3_huju7,0\\nt3_1en7mg,0\\nt3_1db1jf,0\\nt3_1djsvl,0\\nt3_ts55w,0\\nt3_i8iq7,0\\nt3_n0a4q,0\\nt3_1ihmtb,0\\nt3_1mtdc3,0\\nt3_johrr,0\\nt3_lp00f,0\\nt3_m1rph,0\\nt3_1nb10u,0\\nt3_ywjco,0\\nt3_ys2bs,0\\nt3_pq07v,0\\nt3_1cfb3h,0\\nt3_iyrge,0\\nt3_yv9x1,0\\nt3_1krjd9,0\\nt3_v259r,0\\nt3_lgixi,0\\nt3_12rb3l,0\\nt3_pkin0,0\\nt3_z7mzq,0\\nt3_1j93fd,0\\nt3_jb396,0\\nt3_v0h9r,0\\nt3_xb4nc,0\\nt3_1hpv57,0\\nt3_lyldy,0\\nt3_idwhf,0\\nt3_kfxsm,0\\nt3_1f3ehu,0\\nt3_ux4gp,0\\nt3_j680o,0\\nt3_n36b7,0\\nt3_1kbspq,0\\nt3_lfdif,0\\nt3_jibiu,0\\nt3_wez2u,0\\nt3_hicex,0\\nt3_rcb83,0\\nt3_k5jz6,0\\nt3_1ld1zr,0\\nt3_matz6,0\\nt3_13lllw,0\\nt3_mh8t5,0\\nt3_x7wp5,0\\nt3_1gooei,0\\nt3_1elntj,0\\nt3_j6xaf,0\\nt3_1295t4,0\\nt3_18pvdc,0\\nt3_kfn62,0\\nt3_1lhw18,0\\nt3_mh41r,0\\nt3_lput5,0\\nt3_uj1h7,0\\nt3_nctcy,0\\nt3_rqgfm,0\\nt3_rblfk,0\\nt3_pynup,0\\nt3_ijcon,0\\nt3_wzdfb,0\\nt3_qfcrx,0\\nt3_jkv3u,0\\nt3_t4ez0,0\\nt3_182za3,0\\nt3_k3huv,0\\nt3_jjvsg,0\\nt3_13hmch,0\\nt3_uoddl,0\\nt3_kxvhy,0\\nt3_1ippsx,0\\nt3_17k605,0\\nt3_jfe2h,0\\nt3_q70zy,0\\nt3_i3ms5,0\\nt3_ny71q,0\\nt3_iieek,0\\nt3_irsb9,0\\nt3_1dxr4r,0\\nt3_lcoa8,0\\nt3_nylck,0\\nt3_16soun,0\\nt3_kxh3z,0\\nt3_kwj17,0\\nt3_11z0f9,0\\nt3_y1r33,0\\nt3_llc55,0\\nt3_j4mle,0\\nt3_ma4bd,0\\nt3_ja0xm,0\\nt3_thomi,0\\nt3_1a42uf,0\\nt3_1f2c2c,0\\nt3_13yr6a,0\\nt3_1epzt6,0\\nt3_lkn30,0\\nt3_ma690,0\\nt3_isvki,0\\nt3_1ht64o,0\\nt3_iqne8,0\\nt3_1fmkkt,0\\nt3_158xj0,0\\nt3_106jdn,0\\nt3_jruny,0\\nt3_14sl4k,0\\nt3_1ih4cz,0\\nt3_p5o8n,0\\nt3_k9jlk,0\\nt3_1l7zot,0\\nt3_1jx6nd,0\\nt3_ucleb,0\\nt3_1na78p,0\\nt3_10i6xc,0\\nt3_1mg1x9,0\\nt3_swk1k,0\\nt3_198a81,0\\nt3_p3j6h,0\\nt3_144v2r,0\\nt3_1lrg7w,0\\nt3_1n2fv2,0\\nt3_qsar9,0\\nt3_1kla7d,0\\nt3_144qbb,0\\nt3_qe4zn,0\\nt3_ic3dt,0\\nt3_p7iuv,0\\nt3_1ii4ol,0\\nt3_xb0l7,0\\nt3_xljod,0\\nt3_xz1f7,0\\nt3_hxha3,0\\nt3_1fxzpb,0\\nt3_jray4,0\\nt3_o8zvp,0\\nt3_1j6f12,0\\nt3_kai9o,0\\nt3_11zb19,0\\nt3_mz7kn,0\\nt3_icsm3,0\\nt3_lj9bn,0\\nt3_1jtr9y,0\\nt3_wdbar,0\\nt3_1moe8s,0\\nt3_o450c,0\\nt3_nwtb9,0\\nt3_ienv4,0\\nt3_vb27s,0\\nt3_1j4lyi,0\\nt3_1c796y,0\\nt3_121puf,0\\nt3_1loan8,0\\nt3_1imqzn,0\\nt3_m22z8,0\\nt3_1izqab,0\\nt3_1b9snd,0\\nt3_icsqz,0\\nt3_u3lgo,0\\nt3_n955o,0\\nt3_loudp,0\\nt3_11um5c,0\\nt3_kemps,0\\nt3_16ni9v,0\\nt3_ny0r1,0\\nt3_1ei0nh,0\\nt3_s71nl,0\\nt3_ieg2u,0\\nt3_1j2fdd,0\\nt3_1jzxz7,0\\nt3_1ih7n3,0\\nt3_j66zi,0\\nt3_jjv8e,0\\nt3_pvpg4,0\\nt3_r3l0v,0\\nt3_v5k8z,0\\nt3_1l7avh,0\\nt3_j7tkt,0\\nt3_oe3zg,0\\nt3_u5j5m,0\\nt3_jr1lq,0\\nt3_1kk8i1,0\\nt3_vk1v9,0\\nt3_mbyo8,0\\nt3_jod1x,0\\nt3_zpqs4,0\\nt3_vc4hg,0\\nt3_u3n8x,0\\nt3_1dbt8e,0\\nt3_p1xpj,0\\nt3_1017ti,0\\nt3_id8n9,0\\nt3_m14x5,0\\nt3_1apfqa,0\\nt3_lx5xj,0\\nt3_1866ui,0\\nt3_n840z,0\\nt3_1bezf4,0\\nt3_nacny,0\\nt3_1dyffq,0\\nt3_ocy5a,0\\nt3_10ogaj,0\\nt3_iaaw6,0\\nt3_1j4f8b,0\\nt3_x88qi,0\\nt3_1fches,0\\nt3_10ny1p,0\\nt3_ilwc6,0\\nt3_krx2p,0\\nt3_119not,0\\nt3_1gu3j5,0\\nt3_1bbbuz,0\\nt3_hxe8a,0\\nt3_j5qdl,0\\nt3_1mz84n,0\\nt3_i4y7l,0\\nt3_ibsys,0\\nt3_ydmzc,0\\nt3_19xmjp,0\\nt3_1l3540,0\\nt3_ktf2k,0\\nt3_k0hn0,0\\nt3_1ek27q,0\\nt3_wyilc,0\\nt3_1kaciz,0\\nt3_lkdh6,0\\nt3_j2o4w,0\\nt3_1czbz2,0\\nt3_vrm0z,0\\nt3_1cpt0u,0\\nt3_14xb3r,0\\nt3_ig6ya,0\\nt3_k6zox,0\\nt3_icbf1,0\\nt3_jak6v,0\\nt3_ni1uh,0\\nt3_i4d2s,0\\nt3_il2qy,0\\nt3_16wajn,0\\nt3_ibx3y,0\\nt3_k4b7c,0\\nt3_1copha,0\\nt3_ktlkm,0\\nt3_qprm5,0\\nt3_iyqth,0\\nt3_yvy67,0\\nt3_ycl16,0\\nt3_1izuji,0\\nt3_jhtmr,0\\nt3_1np61k,0\\nt3_1id2hk,0\\nt3_1enxtb,0\\nt3_yzjva,0\\nt3_13d6ne,0\\nt3_s5apt,0\\nt3_mqba5,0\\nt3_1kwu2y,0\\nt3_1jgf2f,0\\nt3_1a35ag,0\\nt3_lm2ge,0\\nt3_ytyy6,0\\nt3_leh9u,0\\nt3_xoxju,0\\nt3_1mgs2z,0\\nt3_1lngx7,0\\nt3_1jggjo,0\\nt3_14avuh,0\\nt3_ugq11,0\\nt3_jocl9,0\\nt3_1hs29l,0\\nt3_152asi,0\\nt3_l3a1p,0\\nt3_sybz5,0\\nt3_x1fef,0\\nt3_1c6tno,0\\nt3_yhpux,0\\nt3_nztz2,0\\nt3_lza8c,0\\nt3_1lzcwr,0\\nt3_lwhkp,0\\nt3_1dna10,0\\nt3_119rgh,0\\nt3_iapny,0\\nt3_kfk0a,0\\nt3_ibvsg,0\\nt3_o4fyx,0\\nt3_y3g5j,0\\nt3_l6lv4,0\\nt3_1kmqat,0\\nt3_162d1a,0\\nt3_ujkj0,0\\nt3_1erbgm,0\\nt3_ooexu,0\\nt3_19t19f,0\\nt3_ja4e2,0\\nt3_kt4mf,0\\nt3_wt7zz,0\\nt3_1lfquz,0\\nt3_18sldk,0\\nt3_htd91,0\\nt3_1h4w4n,0\\nt3_p8wrm,0\\nt3_154kz8,0\\nt3_sefhh,0\\nt3_1lix8p,0\\nt3_jlxn4,0\\nt3_11wso9,0\\nt3_101z2h,0\\nt3_1j8a3x,0\\nt3_wqh5d,0\\nt3_i7pfu,0\\nt3_wnhw8,0\\nt3_l5prn,0\\nt3_11xfys,0\\nt3_od50u,0\\nt3_im02c,0\\nt3_z5hnc,0\\nt3_l3b0f,0\\nt3_107e7j,0\\nt3_kerxb,0\\nt3_qx22x,0\\nt3_1eje4d,0\\nt3_1mo8zt,0\\nt3_1f84jw,0\\nt3_1j41yg,0\\nt3_1nbc0n,0\\nt3_jp7f2,0\\nt3_15pek8,0\\nt3_id8ti,0\\nt3_1mq5l0,0\\nt3_kgmij,0\\nt3_1mzn97,0\\nt3_1mkuh8,0\\nt3_l0we8,0\\nt3_17ci8s,0\\nt3_p8lc5,0\\nt3_1hdv69,0\\nt3_1loly5,0\\nt3_12f2yv,0\\nt3_uiv13,0\\nt3_jtbys,0\\nt3_j5z5a,0\\nt3_1996pd,0\\nt3_i3p8s,0\\nt3_j61o1,0\\nt3_17ytg3,0\\nt3_qt4v3,0\\nt3_x18at,0\\nt3_li286,0\\nt3_1gzq6z,0\\nt3_18o5oe,0\\nt3_1jg8a9,0\\nt3_sdado,0\\nt3_ibybv,0\\nt3_jl3qt,0\\nt3_m71dy,0\\nt3_j5agd,0\\nt3_kpnkh,0\\nt3_stuny,0\\nt3_1ddgqj,0\\nt3_1embfn,0\\nt3_jpw8a,0\\nt3_q745h,0\\nt3_1ml5ot,0\\nt3_1czj8l,0\\nt3_1fhq21,0\\nt3_1cfm07,0\\nt3_mihxn,0\\nt3_1lbmlb,0\\nt3_1nbkb1,0\\nt3_wzo6q,0\\nt3_v0ale,0\\nt3_lm8kd,0\\nt3_leebc,0\\nt3_idka5,0\\nt3_wkmpp,0\\nt3_kvqy9,0\\nt3_16s4f9,0\\nt3_qsrgg,0\\nt3_1adibf,0\\nt3_1kkqe9,0\\nt3_1laxa0,0\\nt3_j0r6n,0\\nt3_l18ch,0\\nt3_kzxb4,0\\nt3_1c3y33,0\\nt3_1k3bp9,0\\nt3_z2w4j,0\\nt3_s332h,0\\nt3_my19f,0\\nt3_1kbjq5,0\\nt3_wst3o,0\\nt3_v77cz,0\\nt3_jb0kw,0\\nt3_sov1j,0\\nt3_m3daq,0\\nt3_hutzt,0\\nt3_rehrg,0\\nt3_iesyg,0\\nt3_it7hc,0\\nt3_lu03g,0\\nt3_xyx9c,0\\nt3_n47ak,0\\nt3_16wb5q,0\\nt3_1ejygu,0\\nt3_tneil,0\\nt3_soowc,0\\nt3_mvmij,0\\nt3_1iudib,0\\nt3_jrysw,0\\nt3_vbswl,0\\nt3_kri7t,0\\nt3_1mz7p9,0\\nt3_11ti05,0\\nt3_i8n4m,0\\nt3_j0st7,0\\nt3_1lhdz9,0\\nt3_k78hk,0\\nt3_mu4o6,0\\nt3_kppwl,0\\nt3_nj0sk,0\\nt3_1niqoy,0\\nt3_yj539,0\\nt3_xu0dn,0\\nt3_jt3mq,0\\nt3_odnwf,0\\nt3_hux4g,0\\nt3_1j8ixk,0\\nt3_1dekja,0\\nt3_l460b,0\\nt3_1m52rm,0\\nt3_1e7pw1,0\\nt3_hue7e,0\\nt3_1i06ov,0\\nt3_11v41i,0\\nt3_l65kv,0\\nt3_sp1fg,0\\nt3_lqhfe,0\\nt3_15r2ea,0\\nt3_okh6v,0\\nt3_w50hm,0\\nt3_z7xdo,0\\nt3_1mwwu5,0\\nt3_q8zng,0\\nt3_1iayg1,0\\nt3_14vtze,0\\nt3_ryku2,0\\nt3_10aewu,0\\nt3_n2h3z,0\\nt3_vurl4,0\\nt3_n03eb,0\\nt3_rrcc9,0\\nt3_zz6p5,0\\nt3_kysd6,0\\nt3_12r721,0\\nt3_1f6b9w,0\\nt3_xx4f6,0\\nt3_jrd0h,0\\nt3_ide15,0\\nt3_mupj4,0\\nt3_uubek,0\\nt3_jotm5,0\\nt3_jlluy,0\\nt3_i4fmt,0\\nt3_iwjzw,0\\nt3_zvogg,0\\nt3_18yxt1,0\\nt3_oxp5l,0\\nt3_uqp0c,0\\nt3_17nyu7,0\\nt3_hu8l7,0\\nt3_1mjky0,0\\nt3_1kmi1j,0\\nt3_14oyob,0\\nt3_kde1y,0\\nt3_ijlic,0\\nt3_mk98a,0\\nt3_txxhe,0\\nt3_n8wlx,0\\nt3_j2nbu,0\\nt3_hub23,0\\nt3_vv6uo,0\\nt3_1ahck6,0\\nt3_o2vp7,0\\nt3_so8v3,0\\nt3_16sb6h,0\\nt3_1ekg5c,0\\nt3_p4bhk,0\\nt3_10q049,0\\nt3_mmptc,0\\nt3_kmqvq,0\\nt3_kr339,0\\nt3_y87jg,0\\nt3_1ivpg0,0\\nt3_j4gtp,0\\nt3_ifzpe,0\\nt3_junbn,0\\nt3_1mqs3k,0\\nt3_1mg5fg,0\\nt3_x11f8,0\\nt3_r4box,0\\nt3_lm901,0\\nt3_1iv1fe,0\\nt3_1b3bt4,0\\nt3_1fof55,0\\nt3_xc9l0,0\\nt3_k6557,0\\nt3_iqm6n,0\\nt3_lm0l0,0\\nt3_114c6l,0\\nt3_pedfi,0\\nt3_19mdz6,0\\nt3_1211sa,0\\nt3_xeelk,0\\nt3_14ym0h,0\\nt3_ibv3g,0\\nt3_wq5xv,0\\nt3_10opse,0\\nt3_upm24,0\\nt3_1cndjm,0\\nt3_uebcn,0\\nt3_1lel1x,0\\nt3_16f9ay,0\\nt3_n01xw,0\\nt3_14t9hd,0\\nt3_x0ymn,0\\nt3_1f3xe8,0\\nt3_1lhq2y,0\\nt3_urqtw,0\\nt3_16upcl,0\\nt3_nrc9b,0\\nt3_12m4dw,0\\nt3_jbkeh,0\\nt3_1i6486,0\\nt3_1iv92l,0\\nt3_1j8boj,0\\nt3_1iw58q,0\\nt3_1j6osm,0\\nt3_xcdxo,0\\nt3_1eqkcw,0\\nt3_1i5vnp,0\\nt3_w1pfu,0\\nt3_1eeqcs,0\\nt3_rpdiz,0\\nt3_t3uat,0\\nt3_1ayjhe,0\\nt3_13jfrb,0\\nt3_l8bnw,0\\nt3_14tjdf,0\\nt3_kse6r,0\\nt3_1gtb6m,0\\nt3_1mjf8o,0\\nt3_1mh8hd,0\\nt3_1kgiqn,0\\nt3_rdzac,0\\nt3_i98md,0\\nt3_rekw2,0\\nt3_1j57s5,0\\nt3_zkvfi,0\\nt3_1jwjz1,0\\nt3_18zn0d,0\\nt3_1ktyev,0\\nt3_m5ara,0\\nt3_1aex0q,0\\nt3_1l5diu,0\\nt3_lb3k5,0\\nt3_16gdbu,0\\nt3_11lvl7,0\\nt3_ltlev,0\\nt3_1cxvc5,0\\nt3_10pz0s,0\\nt3_1kj23h,0\\nt3_pgkkz,0\\nt3_iqrcx,0\\nt3_1i6786,0\\nt3_11kxvh,0\\nt3_10rvni,0\\nt3_1cta35,0\\nt3_njyij,0\\nt3_hhgic,0\\nt3_1hkyhy,0\\nt3_15nuxv,0\\nt3_icfj2,0\\nt3_p7my1,0\\nt3_phjlw,0\\nt3_1ld5j6,0\\nt3_1is4rs,0\\nt3_10pq58,0\\nt3_w3crb,0\\nt3_nonc4,0\\nt3_1ll0sz,0\\nt3_it4h2,0\\nt3_11pen3,0\\nt3_vcn3x,0\\nt3_1e7t7h,0\\nt3_17aq8d,0\\nt3_1lr3i8,0\\nt3_10nzqp,0\\nt3_1jp4vc,0\\nt3_y0ano,0\\nt3_ifeu9,0\\nt3_l8g1b,0\\nt3_r4k7g,0\\nt3_11tivy,0\\nt3_rdkc5,0\\nt3_knh6v,0\\nt3_195gj1,0\\nt3_m1t5z,0\\nt3_p6lib,0\\nt3_13lbzi,0\\nt3_tvwmt,0\\nt3_1da9ae,0\\nt3_svw8j,0\\nt3_1iwt3k,0\\nt3_mj5ju,0\\nt3_hy0vl,0\\nt3_1cbum9,0\\nt3_qvf9b,0\\nt3_ph959,0\\nt3_ickap,0\\nt3_15g1rr,0\\nt3_i3735,0\\nt3_umiaz,0\\nt3_112ec3,0\\nt3_uyapc,0\\nt3_1hfuh7,0\\nt3_iil4h,0\\nt3_12psv7,0\\nt3_wwdjm,0\\nt3_pdxll,0\\nt3_1l33kn,0\\nt3_t7fp4,0\\nt3_l55gf,0\\nt3_1lvypa,0\\nt3_1i92ag,0\\nt3_p9dk1,0\\nt3_kutpx,0\\nt3_19vzo3,0\\nt3_1llqlm,0\\nt3_1meso5,0\\nt3_18a6wc,0\\nt3_19d7h5,0\\nt3_1n0elq,0\\nt3_nylom,0\\nt3_j1hth,0\\nt3_ivd1a,0\\nt3_1jgp51,0\\nt3_1142bk,0\\nt3_qagim,0\\nt3_t12we,0\\nt3_sorhh,0\\nt3_js36w,0\\nt3_1dqrm6,0\\nt3_xqeim,0\\nt3_1ian7f,0\\nt3_16gqmg,0\\nt3_l4hr9,0\\nt3_ljfjh,0\\nt3_1fq4v3,0\\nt3_xu9k9,0\\nt3_zqykg,0\\nt3_1eo0kr,0\\nt3_v0bne,0\\nt3_1ilc22,0\\nt3_ozqyn,0\\nt3_p4ovq,0\\nt3_nakz9,0\\nt3_1j5piq,0\\nt3_1b34e5,0\\nt3_v7j8q,0\\nt3_ikg6e,0\\nt3_px5ws,0\\nt3_owlgk,0\\nt3_la5nq,0\\nt3_18vx3q,0\\nt3_idloh,0\\nt3_185l84,0\\nt3_td0yv,0\\nt3_mc8or,0\\nt3_1jy0x7,0\\nt3_tagb8,0\\nt3_1kd6kj,0\\nt3_srvli,0\\nt3_mxsww,0\\nt3_vuunv,0\\nt3_1i7mc9,0\\nt3_1e5gew,0\\nt3_lhdt0,0\\nt3_kx5g9,0\\nt3_jm28w,0\\nt3_tl7q7,0\\nt3_ifbuc,0\\nt3_1jhwvy,0\\nt3_1eecka,0\\nt3_ip3mm,0\\nt3_mwyh8,0\\nt3_ojsi7,0\\nt3_wos8r,0\\nt3_nejwm,0\\nt3_k9deb,0\\nt3_1btika,0\\nt3_j4hdb,0\\nt3_1ixzy0,0\\nt3_nwwmb,0\\nt3_133cg3,0\\nt3_yj8a6,0\\nt3_101uyy,0\\nt3_hyf1p,0\\nt3_s1us6,0\\nt3_xkg32,0\\nt3_icw5d,0\\nt3_jsbkc,0\\nt3_t5soc,0\\nt3_15uyq3,0\\nt3_huujf,0\\nt3_14gmeb,0\\nt3_lpzmu,0\\nt3_zo7x6,0\\nt3_1bwe1z,0\\nt3_oepok,0\\nt3_1d4ncf,0\\nt3_l268t,0\\nt3_1nv8jq,0\\nt3_lit9l,0\\nt3_wivqj,0\\nt3_ux6ka,0\\nt3_18g8j0,0\\nt3_ofpdj,0\\nt3_14bkx0,0\\nt3_1b2ij2,0\\nt3_jk2h2,0\\nt3_1bvr8d,0\\nt3_o7zs6,0\\nt3_1cwnn0,0\\nt3_jbtvg,0\\nt3_w1vg8,0\\nt3_o880l,0\\nt3_18ic2n,0\\nt3_1itzpp,0\\nt3_10sfld,0\\nt3_itf9z,0\\nt3_19elkp,0\\nt3_pfky1,0\\nt3_17kpe8,0\\nt3_ngp84,0\\nt3_vjsze,0\\nt3_13331n,0\\nt3_uuwgc,0\\nt3_ys1wm,0\\nt3_17g6l7,0\\nt3_mdvgl,0\\nt3_10j2a1,0\\nt3_13btoa,0\\nt3_mwbd6,0\\nt3_1jpu8l,0\\nt3_k3mbm,0\\nt3_1o48ha,0\\nt3_1mryfn,0\\nt3_18c24q,0\\nt3_qwu55,0\\nt3_1ktwwv,0\\nt3_pukrr,0\\nt3_1jd5t9,0\\nt3_i96xd,0\\nt3_i67so,0\\nt3_17pb84,0\\nt3_qseg2,0\\nt3_xevib,0\\nt3_mdb8o,0\\nt3_nyxfh,0\\nt3_jnosh,0\\nt3_17ma70,0\\nt3_1l2skl,0\\nt3_12s9wy,0\\nt3_14fcmj,0\\nt3_icnsj,0\\nt3_j3px1,0\\nt3_p84xp,0\\nt3_1iffmt,0\\nt3_qwlzl,0\\nt3_1ifykb,0\\nt3_pf7xu,0\\nt3_w1omy,0\\nt3_ibxcx,0\\nt3_16g44g,0\\nt3_1lzgcg,0\\nt3_11v2e3,0\\nt3_whggb,0\\nt3_yyutk,0\\nt3_jawug,0\\nt3_11h5fx,0\\nt3_ksmnr,0\\nt3_xixa9,0\\nt3_129hun,0\\nt3_10w3p4,0\\nt3_1aa9he,0\\nt3_1ea7ee,0\\nt3_17ghsm,0\\nt3_o7i9r,0\\nt3_lbanx,0\\nt3_192rjt,0\\nt3_u1pjd,0\\nt3_w8ha8,0\\nt3_12p7c1,0\\nt3_j4i0t,0\\nt3_jyqjt,0\\nt3_1235kc,0\\nt3_1drofn,0\\nt3_iskfp,0\\nt3_xnbcg,0\\nt3_1ejj7t,0\\nt3_iaoil,0\\nt3_j48po,0\\nt3_17mumg,0\\nt3_1naboz,0\\nt3_1a636c,0\\nt3_rlqw0,0\\nt3_17nxn9,0\\nt3_15qs5c,0\\nt3_tbdfc,0\\nt3_1d1niu,0\\nt3_1ejldw,0\\nt3_1jyxj8,0\\nt3_r9csz,0\\nt3_im138,0\\nt3_1fvlpz,0\\nt3_kma5h,0\\nt3_nb786,0\\nt3_1iarcu,0\\nt3_x9tks,0\\nt3_r022i,0\\nt3_ry4te,0\\nt3_si6hr,0\\nt3_kpi2z,0\\nt3_1adsra,0\\nt3_17ppx1,0\\nt3_vav2k,0\\nt3_1jkuj5,0\\nt3_1lixj3,0\\nt3_p25h6,0\\nt3_s36vf,0\\nt3_1lxspb,0\\nt3_1ccwpb,0\\nt3_1kghul,0\\nt3_1785hj,0\\nt3_oijja,0\\nt3_1a4uso,0\\nt3_jf70p,0\\nt3_tbnpe,0\\nt3_1cke6u,0\\nt3_veeyw,0\\nt3_1bkxgh,0\\nt3_11hkwu,0\\nt3_od42n,0\\nt3_ixy0f,0\\nt3_vwcvk,0\\nt3_o77z6,0\\nt3_139qw1,0\\nt3_1hftkm,0\\nt3_j1u1l,0\\nt3_1lnq58,0\\nt3_183j1t,0\\nt3_1948qi,0\\nt3_14kuxr,0\\nt3_jraz4,0\\nt3_o8nap,0\\nt3_1m28mz,0\\nt3_1j33z9,0\\nt3_15r3p6,0\\nt3_penyh,0\\nt3_ks7mt,0\\nt3_10rvrc,0\\nt3_14kzth,0\\nt3_zqs0z,0\\nt3_1ks9hw,0\\nt3_tfksg,0\\nt3_1dym29,0\\nt3_1iv792,0\\nt3_k87xw,0\\nt3_j7j1a,0\\nt3_1gtku5,0\\nt3_1je0om,0\\nt3_1fydsv,0\\nt3_1923em,0\\nt3_soxzw,0\\nt3_1mwb3m,0\\nt3_j0bk0,0\\nt3_y3otl,0\\nt3_1ejbbj,0\\nt3_1ehr1g,0\\nt3_vnmor,0\\nt3_i49s7,0\\nt3_1ezo2x,0\\nt3_k3zte,0\\nt3_px0sh,0\\nt3_r65sc,0\\nt3_ko3e1,0\\nt3_1jpq2m,0\\nt3_1do7ez,0\\nt3_pvqb0,0\\nt3_msef6,0\\nt3_14i72s,0\\nt3_1kkvey,0\\nt3_wanz0,0\\nt3_iv9ox,0\\nt3_krb3m,0\\nt3_ilau5,0\\nt3_1kj6vm,0\\nt3_1l0ugy,0\\nt3_1g8r0o,0\\nt3_1le5sz,0\\nt3_j869k,0\\nt3_xtx62,0\\nt3_1ivbrp,0\\nt3_s2w1y,0\\nt3_1ivgyp,0\\nt3_pe178,0\\nt3_s58wn,0\\nt3_1i3zr6,0\\nt3_wv24t,0\\nt3_sbnbg,0\\nt3_14f8ed,0\\nt3_1mt2g2,0\\nt3_1bvqrf,0\\nt3_1d673k,0\\nt3_k3k13,0\\nt3_10usdp,0\\nt3_o0m9i,0\\nt3_1mjrmt,0\\nt3_1lajal,0\\nt3_lyd1s,0\\nt3_1dayzb,0\\nt3_z409k,0\\nt3_1ipzb6,0\\nt3_i5c8j,0\\nt3_qt3v7,0\\nt3_igo1i,0\\nt3_i3una,0\\nt3_10u70o,0\\nt3_1e95a5,0\\nt3_ivhw5,0\\nt3_liw3m,0\\nt3_ra40d,0\\nt3_1glla8,0\\nt3_wy35k,0\\nt3_1ihhx4,0\\nt3_1idsgl,0\\nt3_kfq6s,0\\nt3_rzs62,0\\nt3_lpu5j,0\\nt3_l7y4a,0\\nt3_ixx53,0\\nt3_rrrzo,0\\nt3_14tc0g,0\\nt3_r8jj3,0\\nt3_1lr307,0\\nt3_mktvg,0\\nt3_usmgq,0\\nt3_162jlp,0\\nt3_iaeax,0\\nt3_ng075,0\\nt3_11zxa9,0\\nt3_i94gr,0\\nt3_ytnaq,0\\nt3_j7uxa,0\\nt3_1da8ub,0\\nt3_ssyae,0\\nt3_kvu06,0\\nt3_18zijt,0\\nt3_16ibe1,0\\nt3_idewk,0\\nt3_jq3x6,0\\nt3_1nc07j,0\\nt3_1eemqq,0\\nt3_iaftz,0\\nt3_1nvvnk,0\\nt3_1cfduv,0\\nt3_1l59g9,0\\nt3_icnyh,0\\nt3_13ump5,0\\nt3_m1twq,0\\nt3_12mhsp,0\\nt3_144ad5,0\\nt3_13fuev,0\\nt3_1jn7fx,0\\nt3_te3za,0\\nt3_yi4kv,0\\nt3_145qyc,0\\nt3_lboww,0\\nt3_ien0r,0\\nt3_1if61u,0\\nt3_19ulmv,0\\nt3_1btsrs,0\\nt3_t0fl6,0\\nt3_11e5xk,0\\nt3_w61sg,0\\nt3_x19zb,0\\nt3_1ju5fx,0\\nt3_vnnkb,0\\nt3_193tya,0\\nt3_1iv3bw,0\\nt3_1ltm59,0\\nt3_hj6s8,0\\nt3_pypw7,0\\nt3_1fiyu3,0\\nt3_1is1ux,0\\nt3_1310xx,0\\nt3_1jnsxo,0\\nt3_va5vp,0\\nt3_usk00,0\\nt3_1mg7w7,0\\nt3_1hc7aj,0\\nt3_1aulwp,0\\nt3_1ixemj,0\\nt3_1frcip,0\\nt3_wgk03,0\\nt3_k0l9j,0\\nt3_wd8ky,0\\nt3_nwamf,0\\nt3_l1xkw,0\\nt3_1ee34s,0\\nt3_17biu9,0\\nt3_12ge8l,0\\nt3_zqtrr,0\\nt3_oqsen,0\\nt3_rlqcj,0\\nt3_lkau4,0\\nt3_iu9ym,0\\nt3_11lmex,0\\nt3_sdi2k,0\\nt3_szbjh,0\\nt3_1342ph,0\\nt3_rk5ky,0\\nt3_hz7vk,0\\nt3_121ck5,0\\nt3_10ben6,0\\n\", \"is_error\": false}",
        "tool.duration_ms": 0.8444786071777344
      }
    }
  ],
  "metadata": {
    "span_count": 17,
    "last_updated": "2026-01-09T06:24:50.750723"
  }
}