{
  "query": "How can I use RDKit molecular descriptors for solvent property prediction in machine learning?",
  "results": [
    {
      "title": "ANSWER",
      "text": "Based on the RDKit documentation and recent examples of solvent\u2011property modeling, you can build a machine\u2011learning predictor with these core steps\u202f([RDKit\u202fDocs](https://rdkit.org/docs/source/rdkit.Chem.Descriptors.html), [RDKit\u202fML\u202fmodule](https://rdkit.org/docs/source/rdkit.ML.Descriptors.MoleculeDescriptors.html), [Inter\u2011Pol study](https://link.springer.com/article/10.1007/s10953-025-01508-6), [solubility tutorial](https://www.andersle.no/posts/2022/esol/esol.html)):\n\n1. **Set up the environment**  \n   ```bash\n   conda create -n solprop -c conda-forge rdkit scikit-learn pandas numpy\n   conda activate solprop\n   ```  \n   (RDKit 2025.x provides the descriptor functions you\u2019ll need.)\n\n2. **Load your solvent dataset** (e.g., a CSV with SMILES and the target property such as E\u2011T(30) or log\u202fS).  \n   ```python\n   import pandas as pd\n   df = pd.read_csv('solvents.csv')          # columns: smiles, target\n   ```\n\n3. **Convert SMILES to RDKit molecules and compute descriptors**  \n   ```python\n   from rdkit import Chem\n   from rdkit.Chem import Descriptors\n   from rdkit.ML.Descriptors.MoleculeDescriptors import MolecularDescriptorCalculator\n\n   # Choose a list of descriptor names (e.g., all 208 available)\n   desc_names = [name for name, _ in Descriptors._descList]          # 208 descriptors\n   calc = MolecularDescriptorCalculator(desc_names)\n\n   def mol_descriptors(smiles):\n       mol = Chem.MolFromSmiles(smiles)\n       return calc.CalcDescriptors(mol) if mol else [None]*len(desc_names)\n\n   X = df['smiles'].apply(mol_descriptors).tolist()\n   X = pd.DataFrame(X, columns=desc_names)\n   y = df['target']\n   ```\n\n4. **Clean and select informative features**  \n   - Remove columns with missing or constant values.  \n   - Optionally apply the same feature\u2011selection pipeline used in the Inter\u2011Pol work, which discards non\u2011informative fingerprint features and keeps the most predictive RDKit descriptors\u202f([Inter\u2011Pol paper](https://link.springer.com/article/10.1007/s10953-025-01508-6)).  \n   ```python\n   X = X.dropna(axis=1)                     # drop descriptors that failed\n   from sklearn.feature_selection import VarianceThreshold\n   X = X.loc[:, VarianceThreshold().fit(X).get_support()]\n   ```\n\n5. **Split the data and train a model** (e.g., RandomForestRegressor).  \n   ```python\n   from sklearn.model_selection import train_test_split\n   from sklearn.ensemble import RandomForestRegressor\n   from sklearn.metrics import mean_absolute_error\n\n   X_train, X_test, y_train, y_test = train_test_split(\n       X, y, test_size=0.2, random_state=42)\n\n   model = RandomForestRegressor(n_estimators=300, random_state=42)\n   model.fit(X_train, y_train)\n\n   preds = model.predict(X_test)\n   print('MAE:', mean_absolute_error(y_test, preds))\n   ```\n\n6. **Interpret and refine**  \n   - Examine feature importances to identify which RDKit descriptors drive the prediction (e.g., molecular weight, TPSA, logP).  \n   - Iterate: add/remove descriptors, try other algorithms (CatBoost, XGBoost), or use hyper\u2011parameter optimization tools such as DOPtools for QSPR modeling\u202f([DOPtools paper](https://pubs.rsc.org/en/content/articlehtml/2025/dd/d4dd00399c)).\n\n7. **Deploy** (optional) \u2013 serialize the fitted model with `joblib.dump` and reuse the same descriptor\u2011calculation pipeline to predict properties for new solvents.\n\nThese steps let you harness RDKit\u2019s built\u2011in molecular descriptors to train accurate, interpretable machine\u2011learning models for solvent property prediction.",
      "url": ""
    },
    {
      "title": "rdkit.ML.Descriptors.MoleculeDescriptors module \u00b6",
      "text": "rdkit.ML.Descriptors.MoleculeDescriptors module &#8212; The RDKit 2025.09.3 documentation\n### Navigation\n* [index](../genindex.html)\n* [modules](../py-modindex.html)|\n* [next](rdkit.ML.Descriptors.Parser.html)|\n* [previous](rdkit.ML.Descriptors.Descriptors.html)|\n* [The RDKit 2025.09.3 documentation](../index.html)&#187;\n* [Python API Reference](../api-docs.html)&#187;\n* [rdkit package](rdkit.html)&#187;\n* [rdkit.ML package](rdkit.ML.html)&#187;\n* [rdkit.ML.Descriptors package](rdkit.ML.Descriptors.html)&#187;\n* [rdkit.ML.Descriptors.MoleculeDescriptors module]()\n# rdkit.ML.Descriptors.MoleculeDescriptors module[\u00b6](#module-rdkit.ML.Descriptors.MoleculeDescriptors)\nVarious bits and pieces for calculating Molecular descriptors\n*class*rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator(*simpleList*,*\\*args*,*\\*\\*kwargs*)[\u00b6](#rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator)\nBases:[`DescriptorCalculator`](rdkit.ML.Descriptors.Descriptors.html#rdkit.ML.Descriptors.Descriptors.DescriptorCalculator)\nused for calculating descriptors for molecules\nConstructor\n**Arguments**\n> > * > > simpleList: list of simple descriptors to be calculated\n> (see below for format)\n> > > > > **Note**\n> > * > format of simpleList:\n> > > > > a list of strings which are functions in the rdkit.Chem.Descriptors module\n> > > > > CalcDescriptors(*mol*,*\\*args*,*\\*\\*kwargs*)[\u00b6](#rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator.CalcDescriptors)\ncalculates all descriptors for a given molecule\n**Arguments**\n> > * > mol: the molecule to be used\n> > **Returns**\na tuple of all descriptor values\nGetDescriptorFuncs()[\u00b6](#rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator.GetDescriptorFuncs)\nreturns a tuple of the functions used to generate this calculator\u2019s descriptors\nGetDescriptorNames()[\u00b6](#rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator.GetDescriptorNames)\nreturns a tuple of the names of the descriptors this calculator generates\nGetDescriptorSummaries()[\u00b6](#rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator.GetDescriptorSummaries)\nreturns a tuple of summaries for the descriptors this calculator generates\nGetDescriptorVersions()[\u00b6](#rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator.GetDescriptorVersions)\nreturns a tuple of the versions of the descriptor calculators\nSaveState(*fileName*)[\u00b6](#rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator.SaveState)\nWrites this calculator off to a file so that it can be easily loaded later\n**Arguments**\n> > * > fileName: the name of the file to be written\n> > [![Logo](../_static/logo.png)](../index.html)\n### [Table of Contents](../index.html)\n* [rdkit.ML.Descriptors.MoleculeDescriptors module](#)\n* [`MolecularDescriptorCalculator`](#rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator)\n* [`MolecularDescriptorCalculator.CalcDescriptors()`](#rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator.CalcDescriptors)\n* [`MolecularDescriptorCalculator.GetDescriptorFuncs()`](#rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator.GetDescriptorFuncs)\n* [`MolecularDescriptorCalculator.GetDescriptorNames()`](#rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator.GetDescriptorNames)\n* [`MolecularDescriptorCalculator.GetDescriptorSummaries()`](#rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator.GetDescriptorSummaries)\n* [`MolecularDescriptorCalculator.GetDescriptorVersions()`](#rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator.GetDescriptorVersions)\n* [`MolecularDescriptorCalculator.SaveState()`](#rdkit.ML.Descriptors.MoleculeDescriptors.MolecularDescriptorCalculator.SaveState)\n#### Previous topic\n[rdkit.ML.Descriptors.Descriptors module](rdkit.ML.Descriptors.Descriptors.html)\n#### Next topic\n[rdkit.ML.Descriptors.Parser module](rdkit.ML.Descriptors.Parser.html)\n### This Page\n* [Show Source](../_sources/source/rdkit.ML.Descriptors.MoleculeDescriptors.rst.txt)\n### Quick search\n### Navigation\n* [index](../genindex.html)\n* [modules](../py-modindex.html)|\n* [next](rdkit.ML.Descriptors.Parser.html)|\n* [previous](rdkit.ML.Descriptors.Descriptors.html)|\n* [The RDKit 2025.09.3 documentation](../index.html)&#187;\n* [Python API Reference](../api-docs.html)&#187;\n* [rdkit package](rdkit.html)&#187;\n* [rdkit.ML package](rdkit.ML.html)&#187;\n* [rdkit.ML.Descriptors package](rdkit.ML.Descriptors.html)&#187;\n* [rdkit.ML.Descriptors.MoleculeDescriptors module]()\n&#169; Copyright 2026, Greg Landrum and other RDKit contributors.\nCreated using[Sphinx](https://www.sphinx-doc.org/)7.2.6.",
      "url": "https://rdkit.org/docs/source/rdkit.ML.Descriptors.MoleculeDescriptors.html"
    },
    {
      "title": "rdkit.Chem.Descriptors module \u00b6",
      "text": "rdkit.Chem.Descriptors module &#8212; The RDKit 2025.09.3 documentation\n### Navigation\n* [index](../genindex.html)\n* [modules](../py-modindex.html)|\n* [next](rdkit.Chem.Descriptors3D.html)|\n* [previous](rdkit.Chem.Crippen.html)|\n* [The RDKit 2025.09.3 documentation](../index.html)&#187;\n* [Python API Reference](../api-docs.html)&#187;\n* [rdkit package](rdkit.html)&#187;\n* [rdkit.Chem package](rdkit.Chem.html)&#187;\n* [rdkit.Chem.Descriptors module]()\n# rdkit.Chem.Descriptors module[\u00b6](#module-rdkit.Chem.Descriptors)\nrdkit.Chem.Descriptors.CalcMolDescriptors(*mol*,*missingVal=None*,*silent=True*)[\u00b6](#rdkit.Chem.Descriptors.CalcMolDescriptors)\ncalculate the full set of descriptors for a molecule\nParameters:\n* **mol**(*RDKit molecule*) \u2013* **missingVal**(*float**,**optional*) \u2013This will be used if a particular descriptor cannot be calculated\n* **silent**(*bool**,**optional*) \u2013if True then exception messages from descriptors will be displayed\nReturns:\nA dictionary with decriptor names as keys and the descriptor values as values\nReturn type:\ndict\nrdkit.Chem.Descriptors.ExactMolWt(*\\*x*,*\\*\\*y*)[\u00b6](#rdkit.Chem.Descriptors.ExactMolWt)\nThe exact molecular weight of the molecule\n```\n&gt;&gt;&gt;ExactMolWt(Chem.MolFromSmiles(&#39;CC&#39;))30.04...&gt;&gt;&gt;ExactMolWt(Chem.MolFromSmiles(&#39;[13CH3]C&#39;))31.05...\n```\nrdkit.Chem.Descriptors.FpDensityMorgan1(*x*)[\u00b6](#rdkit.Chem.Descriptors.FpDensityMorgan1)rdkit.Chem.Descriptors.FpDensityMorgan2(*x*)[\u00b6](#rdkit.Chem.Descriptors.FpDensityMorgan2)rdkit.Chem.Descriptors.FpDensityMorgan3(*x*)[\u00b6](#rdkit.Chem.Descriptors.FpDensityMorgan3)rdkit.Chem.Descriptors.HeavyAtomMolWt(*x*)[\u00b6](#rdkit.Chem.Descriptors.HeavyAtomMolWt)\nThe average molecular weight of the molecule ignoring hydrogens\n```\n&gt;&gt;&gt;HeavyAtomMolWt(Chem.MolFromSmiles(&#39;CC&#39;))24.02...&gt;&gt;&gt;HeavyAtomMolWt(Chem.MolFromSmiles(&#39;[NH4+].[Cl-]&#39;))49.46\n```\nrdkit.Chem.Descriptors.MaxAbsPartialCharge(*mol*,*force=False*)[\u00b6](#rdkit.Chem.Descriptors.MaxAbsPartialCharge)rdkit.Chem.Descriptors.MaxPartialCharge(*mol*,*force=False*)[\u00b6](#rdkit.Chem.Descriptors.MaxPartialCharge)rdkit.Chem.Descriptors.MinAbsPartialCharge(*mol*,*force=False*)[\u00b6](#rdkit.Chem.Descriptors.MinAbsPartialCharge)rdkit.Chem.Descriptors.MinPartialCharge(*mol*,*force=False*)[\u00b6](#rdkit.Chem.Descriptors.MinPartialCharge)rdkit.Chem.Descriptors.MolWt(*\\*x*,*\\*\\*y*)[\u00b6](#rdkit.Chem.Descriptors.MolWt)\nThe average molecular weight of the molecule\n```\n&gt;&gt;&gt;MolWt(Chem.MolFromSmiles(&#39;CC&#39;))30.07&gt;&gt;&gt;MolWt(Chem.MolFromSmiles(&#39;[NH4+].[Cl-]&#39;))53.49...\n```\nrdkit.Chem.Descriptors.NumRadicalElectrons(*mol*)[\u00b6](#rdkit.Chem.Descriptors.NumRadicalElectrons)The number of radical electrons the molecule has\n(says nothing about spin state)\n```\n&gt;&gt;&gt;NumRadicalElectrons(Chem.MolFromSmiles(&#39;CC&#39;))0&gt;&gt;&gt;NumRadicalElectrons(Chem.MolFromSmiles(&#39;C[CH3]&#39;))0&gt;&gt;&gt;NumRadicalElectrons(Chem.MolFromSmiles(&#39;C[CH2]&#39;))1&gt;&gt;&gt;NumRadicalElectrons(Chem.MolFromSmiles(&#39;C[CH]&#39;))2&gt;&gt;&gt;NumRadicalElectrons(Chem.MolFromSmiles(&#39;C[C]&#39;))3\n```\nrdkit.Chem.Descriptors.NumValenceElectrons(*mol*)[\u00b6](#rdkit.Chem.Descriptors.NumValenceElectrons)\nThe number of valence electrons the molecule has\n```\n&gt;&gt;&gt;NumValenceElectrons(Chem.MolFromSmiles(&#39;CC&#39;))14&gt;&gt;&gt;NumValenceElectrons(Chem.MolFromSmiles(&#39;C(=O)O&#39;))18&gt;&gt;&gt;NumValenceElectrons(Chem.MolFromSmiles(&#39;C(=O)[O-]&#39;))18&gt;&gt;&gt;NumValenceElectrons(Chem.MolFromSmiles(&#39;C(=O)&#39;))12\n```\n*class*rdkit.Chem.Descriptors.PropertyFunctor(*(object)self*,*(object)callback*,*(str)name*,*(str)version*)[\u00b6](#rdkit.Chem.Descriptors.PropertyFunctor)\nBases:[`PythonPropertyFunctor`](rdkit.Chem.rdMolDescriptors.html#rdkit.Chem.rdMolDescriptors.PythonPropertyFunctor)\nCreates a python based property function that can be added to the\nglobal property list. To use, subclass this class and override the\n\\_\\_call\\_\\_ method. Then create an instance and add it to the\nregistry. The \\_\\_call\\_\\_ method should return a numeric value.\nExample\nclass NumAtoms(Descriptors.PropertyFunctor):def \\_\\_init\\_\\_(self):\nDescriptors.PropertyFunctor.\\_\\_init\\_\\_(self, \u201cNumAtoms\u201d, \u201c1.0.0\u201d)\ndef \\_\\_call\\_\\_(self, mol):\nreturn mol.GetNumAtoms()\nnumAtoms = NumAtoms()\nrdMolDescriptors.Properties.RegisterProperty(numAtoms)\nC++ signature :\nvoid \\_\\_init\\_\\_(\\_object\\*,\\_object\\*,std::\\_\\_cxx11::basic\\_string&lt;&lt;char, std::char\\_traits&lt;&lt;char&gt;&gt;, std::allocator&lt;&lt;char&gt;&gt; &gt;&gt;,std::\\_\\_cxx11::basic\\_string&lt;&lt;char, std::char\\_traits&lt;&lt;char&gt;&gt;, std::allocator&lt;&lt;char&gt;&gt; &gt;&gt;)\nrdkit.Chem.Descriptors.setupAUTOCorrDescriptors()[\u00b6](#rdkit.Chem.Descriptors.setupAUTOCorrDescriptors)\nAdds AUTOCORR descriptors to the default descriptor lists\n[![Logo](../_static/logo.png)](../index.html)\n### [Table of Contents](../index.html)\n* [rdkit.Chem.Descriptors module](#)\n* [`CalcMolDescriptors()`](#rdkit.Chem.Descriptors.CalcMolDescriptors)\n* [`ExactMolWt()`](#rdkit.Chem.Descriptors.ExactMolWt)\n* [`FpDensityMorgan1()`](#rdkit.Chem.Descriptors.FpDensityMorgan1)\n* [`FpDensityMorgan2()`](#rdkit.Chem.Descriptors.FpDensityMorgan2)\n* [`FpDensityMorgan3()`](#rdkit.Chem.Descriptors.FpDensityMorgan3)\n* [`HeavyAtomMolWt()`](#rdkit.Chem.Descriptors.HeavyAtomMolWt)\n* [`MaxAbsPartialCharge()`](#rdkit.Chem.Descriptors.MaxAbsPartialCharge)\n* [`MaxPartialCharge()`](#rdkit.Chem.Descriptors.MaxPartialCharge)\n* [`MinAbsPartialCharge()`](#rdkit.Chem.Descriptors.MinAbsPartialCharge)\n* [`MinPartialCharge()`](#rdkit.Chem.Descriptors.MinPartialCharge)\n* [`MolWt()`](#rdkit.Chem.Descriptors.MolWt)\n* [`NumRadicalElectrons()`](#rdkit.Chem.Descriptors.NumRadicalElectrons)\n* [`NumValenceElectrons()`](#rdkit.Chem.Descriptors.NumValenceElectrons)\n* [`PropertyFunctor`](#rdkit.Chem.Descriptors.PropertyFunctor)\n* [`setupAUTOCorrDescriptors()`](#rdkit.Chem.Descriptors.setupAUTOCorrDescriptors)\n#### Previous topic\n[rdkit.Chem.Crippen module](rdkit.Chem.Crippen.html)\n#### Next topic\n[rdkit.Chem.Descriptors3D module](rdkit.Chem.Descriptors3D.html)\n### This Page\n* [Show Source](../_sources/source/rdkit.Chem.Descriptors.rst.txt)\n### Quick search\n### Navigation\n* [index](../genindex.html)\n* [modules](../py-modindex.html)|\n* [next](rdkit.Chem.Descriptors3D.html)|\n* [previous](rdkit.Chem.Crippen.html)|\n* [The RDKit 2025.09.3 documentation](../index.html)&#187;\n* [Python API Reference](../api-docs.html)&#187;\n* [rdkit package](rdkit.html)&#187;\n* [rdkit.Chem package](rdkit.Chem.html)&#187;\n* [rdkit.Chem.Descriptors module]()\n&#169; Copyright 2026, Greg Landrum and other RDKit contributors.\nCreated using[Sphinx](https://www.sphinx-doc.org/)7.2.6.",
      "url": "https://rdkit.org/docs/source/rdkit.Chem.Descriptors.html"
    },
    {
      "title": "Predicting solubilities with molecular descriptors \u2014 andersle.no",
      "text": "On this page\n\n# Predicting solubilities with molecular descriptors [\\#](https://www.andersle.no/posts/2022/esol/esol.html\\#predicting-solubilities-with-molecular-descriptors)\n\n[\u2190 Previous](https://www.andersle.no/posts/2022/mo/mo.html#mo-mo) \\| [Next \u2192](https://www.andersle.no/posts/2022/acid/acid.html#acid-acid)\n\nJuly 28, 2022 (2022-07-28 13:00:00) by Anders Lervik \\| Category: [chemometrics](https://www.andersle.no/posts/categories.html#category-chemometrics)\n\nTagged: [catboost](https://www.andersle.no/posts/tags.html#tag-catboost) \\| [cheminformatics](https://www.andersle.no/posts/tags.html#tag-cheminformatics) \\| [chemistry](https://www.andersle.no/posts/tags.html#tag-chemistry) \\| [chemometrics](https://www.andersle.no/posts/tags.html#tag-chemometrics) \\| [descriptors](https://www.andersle.no/posts/tags.html#tag-descriptors) \\| [jupyter](https://www.andersle.no/posts/tags.html#tag-jupyter) \\| [machine-learning](https://www.andersle.no/posts/tags.html#tag-machine-learning) \\| [molecules](https://www.andersle.no/posts/tags.html#tag-molecules) \\| [python](https://www.andersle.no/posts/tags.html#tag-python) \\| [rdkit](https://www.andersle.no/posts/tags.html#tag-rdkit) \\| [shap](https://www.andersle.no/posts/tags.html#tag-shap)\n\n- [Introduction](https://www.andersle.no/posts/2022/esol/esol.html#introduction)\n\n- [Loading the raw data](https://www.andersle.no/posts/2022/esol/esol.html#loading-the-raw-data)\n\n- [Having a quick look at the raw data](https://www.andersle.no/posts/2022/esol/esol.html#having-a-quick-look-at-the-raw-data)\n\n- [Calculating molecular descriptors](https://www.andersle.no/posts/2022/esol/esol.html#calculating-molecular-descriptors)\n\n- [Creating a predictive model](https://www.andersle.no/posts/2022/esol/esol.html#creating-a-predictive-model)\n\n  - [Creating the training and test sets](https://www.andersle.no/posts/2022/esol/esol.html#creating-the-training-and-test-sets)\n\n  - [Training the model](https://www.andersle.no/posts/2022/esol/esol.html#training-the-model)\n- [Assessing the model](https://www.andersle.no/posts/2022/esol/esol.html#assessing-the-model)\n\n- [Inspecting the model and creating a simplified model](https://www.andersle.no/posts/2022/esol/esol.html#inspecting-the-model-and-creating-a-simplified-model)\n\n- [Summary](https://www.andersle.no/posts/2022/esol/esol.html#summary)\n\n\n## [Introduction](https://www.andersle.no/posts/2022/esol/esol.html\\#id1) [\\#](https://www.andersle.no/posts/2022/esol/esol.html\\#introduction)\n\nThe [ESOL (Estimated SOLubility)](https://pubs.acs.org/doi/10.1021/ci034243x)\nmodel is a simple model for predicting the aqueous solubility of molecules\ndirectly from the structure. In the ESOL model, the solubility (\\\\(S\\_w\\\\)) is calculated as,\n\n\\\\\\[\\\\log(S\\_w) = 0.16 - 0.63\\\\cdot \\\\text{clogP} - 0.0062\\\\cdot \\\\text{MWT} + 0.066\\\\cdot \\\\text{RB} - 0.74\\\\cdot \\\\text{AP}\\\\\\]\n\nwhere \\\\(\\\\text{clogP}\\\\) is the [logP](https://en.wikipedia.org/wiki/Partition_coefficient#Partition_coefficient_and_log_P)\n(as calculated by [Daylight](https://www.daylight.com/dayhtml/doc/clogp/)),\n\\\\(\\\\text{MWT}\\\\) is the molecular weight,\n\\\\(\\\\text{RB}\\\\) is the number of rotatable bonds, and\n\\\\(\\\\text{AP}\\\\) is the proportion of heavy atoms in the molecule\nthat are in an aromatic ring.\n\nThe ESOL model performs reasonably well but it has been some years since\nthe article describing it was published. Since (some of) the raw data\nis available in\nthe [supporting information](https://pubs.acs.org/doi/pdf/10.1021/ci034243x#_i13) accompanying the\narticle, I thought it would be fun to see how a more modern\nmachine learning method performs (with minimal effort) for predicting solubilities.\nSo here I will try out [CatBoost](https://catboost.ai/) -\na [gradient boosting method](https://en.wikipedia.org/wiki/Gradient_boosting).\n\n## [Loading the raw data](https://www.andersle.no/posts/2022/esol/esol.html\\#id2) [\\#](https://www.andersle.no/posts/2022/esol/esol.html\\#loading-the-raw-data)\n\n[![https://mybinder.org/badge_logo.svg](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/andersle/andersleno/main?urlpath=/tree/2022%2Fesol%2Fesol.ipynb)\n\nThe supporting information to the article [ESOL: Estimating Aqueous Solubility Directly from Molecular Structure](https://pubs.acs.org/doi/10.1021/ci034243x) contains a data set with molecules (smiles) and their measured and predicted (by the ESOL model described in the article) aqueous solubilities. We can (down)load this data from [GitHub](https://github.com/dataprofessor)):\n\n```\n[1]:\n\n```\n\n```\nimport pathlib\nimport requests\nimport pandas as pd\n\n```\n\n```\n[2]:\n\n```\n\n```\ndef download_data_file(url, output_file):\n    if pathlib.Path(output_file).is_file():\n        print(f\"File {output_file} exists - skipping download\")\n        return output_file\n    session = requests.Session()\n    session.headers.update(\n        {\n            \"User-Agent\": \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n        }\n    )\n    response = session.get(url, allow_redirects=True)\n    if response:\n        with open(output_file, \"w\") as output:\n            output.write(response.text)\n        print(f\"Downloaded file to: {output_file}\")\n        return output_file\n    else:\n        print(f\"Could not download file: {response.status_code}\")\n        return None\n\n```\n\n```\n[3]:\n\n```\n\n```\ndownload_data_file(\n    \"https://raw.githubusercontent.com/dataprofessor/data/master/delaney.csv\",\n    \"esol.csv\",\n)\n\n```\n\n```\nFile esol.csv exists - skipping download\n\n```\n\n```\n[3]:\n\n```\n\n```\n'esol.csv'\n\n```\n\n```\n[4]:\n\n```\n\n```\ndata = pd.read_csv(\"esol.csv\")\ndata\n\n```\n\n```\n[4]:\n\n```\n\n|  | Compound ID | measured log(solubility:mol/L) | ESOL predicted log(solubility:mol/L) | SMILES |\n| --- | --- | --- | --- | --- |\n| 0 | 1,1,1,2-Tetrachloroethane | -2.180 | -2.794 | ClCC(Cl)(Cl)Cl |\n| 1 | 1,1,1-Trichloroethane | -2.000 | -2.232 | CC(Cl)(Cl)Cl |\n| 2 | 1,1,2,2-Tetrachloroethane | -1.740 | -2.549 | ClC(Cl)C(Cl)Cl |\n| 3 | 1,1,2-Trichloroethane | -1.480 | -1.961 | ClCC(Cl)Cl |\n| 4 | 1,1,2-Trichlorotrifluoroethane | -3.040 | -3.077 | FC(F)(Cl)C(F)(Cl)Cl |\n| ... | ... | ... | ... | ... |\n| 1139 | vamidothion | 1.144 | -1.446 | CNC(=O)C(C)SCCSP(=O)(OC)(OC) |\n| 1140 | Vinclozolin | -4.925 | -4.377 | CC1(OC(=O)N(C1=O)c2cc(Cl)cc(Cl)c2)C=C |\n| 1141 | Warfarin | -3.893 | -3.913 | CC(=O)CC(c1ccccc1)c3c(O)c2ccccc2oc3=O |\n| 1142 | Xipamide | -3.790 | -3.642 | Cc1cccc(C)c1NC(=O)c2cc(c(Cl)cc2O)S(N)(=O)=O |\n| 1143 | XMC | -2.581 | -2.688 | CNC(=O)Oc1cc(C)cc(C)c1 |\n\n1144 rows \u00d7 4 columns\n\n```\n[5]:\n\n```\n\n```\nnames = data[\"Compound ID\"].values\nmeasured = data[\"measured log(solubility:mol/L)\"].values\nesol = data[\"ESOL predicted log(solubility:mol/L)\"].values\n\n```\n\n## [Having a quick look at the raw data](https://www.andersle.no/posts/2022/esol/esol.html\\#id3) [\\#](https://www.andersle.no/posts/2022/esol/esol.html\\#having-a-quick-look-at-the-raw-data)\n\nFirst, we will plot the distributions of the measured and predicted solubilities and calculate the [coefficient of determination](https://en.wikipedia.org/wiki/Coefficient_of_determination) and the [mean absolute error](https://en.wikipedia.org/wiki/Root-mean-square_deviation#Mean_absolute_error) for the ESOL model.\n\n```\n[6]:\n\n```\n\n```\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport numpy as np\nfrom sklearn.metrics import r2_score, mean_absolute_error\n\nplt.style.use(\"seaborn-talk\")\n%matplotlib inline\nsns.set_theme(style=\"ticks\", context=\"talk\", palette=\"muted\")\n\n```\n\n```\n[7]:\n\n```\n\n```\ndef add_scatterplot(ax, measured, predicted, model_name=None):\n    \"\"\"Add a measured vs. predicted scatter plot.\"\"\"\n    rsquared = r2_score(measured, predicted)\n    mae = mean_absolute_error(measured, predicted)\n    label = f\"R\u00b2: {rsquared:.2f}\\nMAE = {mae:.2f}\"\n    if model_name:\n        label = f\"{model_name}\\n{label}\"\n    ax.scatter(\n        measured,\n        predicted,\n        label=label,\n        alpha=0.8,\n    )\n\n```\n\n```\n[8]:\n\n```\n\n```\nfig, (ax1, ax2) = plt.subplots(\n    constr...",
      "url": "https://www.andersle.no/posts/2022/esol/esol.html"
    },
    {
      "title": "DOPtools: a Python platform for descriptor calculation and model optimization",
      "text": "[View\u00a0PDF\u00a0Version](https://pubs.rsc.org/en/content/articlepdf/2025/dd/d4dd00399c)[Previous\u00a0Article](https://pubs.rsc.org/en/content/articlehtml/2025/dd/d4dd00393d)[Next\u00a0Article](https://pubs.rsc.org/en/content/articlehtml/2025/dd/d4dd00380b)\n\nOpen Access Article\nThis Open Access Article is licensed under a [Creative Commons Attribution 3.0 Unported Licence](http://creativecommons.org/licenses/by/3.0/)\n\nDOI:\u00a0[10.1039/D4DD00399C](https://doi.org/10.1039/D4DD00399C)\n(Paper)\n[Digital Discovery](https://doi.org/10.1039/2635-098X/2022), 2025, **4**, 1188-1198\n\n# DOPtools: a Python platform for descriptor calculation and model optimization\n\nSaid\nByadi\na,\nPhilippe\nGantzer\na,\nTimur\nGimadiev\nb and Pavel\nSidorov\n\\*aaInstitute for Chemical Reaction Design and Discovery (WPI-ICReDD), Hokkaido University, Kita 21 Nishi 10, Kita-ku, Sapporo, 001-0021, Japan. E-mail: [pavel.sidorov@icredd.hokudai.ac.jp](mailto:pavel.sidorov@icredd.hokudai.ac.jp)bA.M. Butlerov Institute of Chemistry, Kazan Federal University, 18 Kremlyovskaya Str., Kazan, 420008, Russia\n\nReceived\n18th December 2024\n, Accepted 16th March 2025\n\nFirst published on 17th March 2025\n\n## Abstract\n\nThe DOPtools (Descriptors and Optimization tools) platform is a Python library for the calculation of chemical descriptors, hyperparameter optimization, and building and validation of QSPR models. In addition to the Python code that can be integrated in custom scripts, it provides a command line interface for the automatic calculation of various descriptors and for eventual hyperparameter optimization of statistical models, enabling its use in server applications for QSPR modeling. It is especially suited for modeling reaction properties via functions that calculate descriptors for all reaction components. While a variety of existing tools and libraries can calculate various molecular descriptors, their output format is often unique, which complicates their integration with standard machine learning libraries. DOPtools provides a unified API for the calculated descriptors as input for the scikit-learn library. The modular nature of the code allows easy addition of algorithms if required by the end user. The code for the platform is freely available at GitHub and can be installed through PyPI.\n\n## 1 Introduction\n\nQuantitative Structure\u2013Property Relationship (QSPR) modeling is, to this day, one of the largest application fields of chemoinformatics. [1](https://pubs.rsc.org/pubs.rsc.org#cit1) In a classical QSPR approach, to enable the prediction of properties, molecules must be encoded by numerical parameters \u2013 molecular descriptors, which are then used to train machine learning (ML) algorithms. The choice of the optimal molecular descriptors, as well as the ML algorithm, is often left to rigorous benchmarking prior to modeling itself. However, the lack of an open, unified pipeline to go from molecules to descriptors to model optimization necessitates piecing together disjointed steps produced by different software or scripts.\n\nNumerous software tools have been specifically tailored for the generation of molecular descriptors, providing user-friendly platforms via graphical user interfaces (GUIs) for inputting chemical structures and extracting a diverse array of molecular information. Commercial tools developed by OpenEye Scientific Software, [2](https://pubs.rsc.org/pubs.rsc.org#cit2) Molecular Operating Environment (MOE), [3](https://pubs.rsc.org/pubs.rsc.org#cit3) and ChemAxon [4](https://pubs.rsc.org/pubs.rsc.org#cit4) provide a variety of functions, including the calculation of molecular properties and descriptors. On the other hand, programming libraries such as Chemistry Development KIT (CDK), [5](https://pubs.rsc.org/pubs.rsc.org#cit5) RDKit, [6](https://pubs.rsc.org/pubs.rsc.org#cit6) and OpenBabel [7](https://pubs.rsc.org/pubs.rsc.org#cit7) give access to a wide range of chemoinformatics functions, with RDKit being a de facto standard for chemoinformatics applications in most areas of research. Other software kits such as PaDEL, [8](https://pubs.rsc.org/pubs.rsc.org#cit8) ISIDA (In Silico Design and Data Analysis) platform, [9](https://pubs.rsc.org/pubs.rsc.org#cit9) GUIDEMOL, [10](https://pubs.rsc.org/pubs.rsc.org#cit10) etc., implement GUI or command line interfaces (CLI) for the calculation of specific types of descriptors. Python libraries CGRtools [11](https://pubs.rsc.org/pubs.rsc.org#cit11) and Chython [12](https://pubs.rsc.org/pubs.rsc.org#cit12) provide an open-access code for managing chemical data, including the calculation of descriptors (e.g., Chython implements its own Morgan-like and linear fingerprints). Recently reported packages, MolPipeline [13](https://pubs.rsc.org/pubs.rsc.org#cit13) and Scikit-Mol, [14](https://pubs.rsc.org/pubs.rsc.org#cit14) provide an array of functions that facilitates integrating chemical information into ML modeling through automatic SMILES-to-descriptor calculations that include important curation steps.\n\nOnce the descriptors are calculated, a ML algorithm needs to be trained, and many solutions are available for this task. Statistical software such as WEKA, [15](https://pubs.rsc.org/pubs.rsc.org#cit15) XLSTAT, Statistica, [16](https://pubs.rsc.org/pubs.rsc.org#cit16) etc., give access to a wide array of ML models that can be applied to precomputed descriptors. More specialized chemoinformatics software, like MOE, combines the calculation of descriptors and the building of models in one package. The commercial KNIME Analytics Platform [17](https://pubs.rsc.org/pubs.rsc.org#cit17) is an open-source platform with workflow-driven cheminformatics capabilities, implementing the most commonly used descriptor types and ML algorithms, and providing bindings for external chemoinformatics and molecular modeling tools and libraries. QSAR-Co [18](https://pubs.rsc.org/pubs.rsc.org#cit18) is an open source tool written in Java that is capable of robust data analysis and the development of classification models, including multi-task ones. However, models often require optimization of parameters, which can be complicated with the above tools. Often, researchers create in-house scripts tailored to the third-party tools they have access to. [19](https://pubs.rsc.org/pubs.rsc.org#cit19) Some commercial solutions exist for this problem, too; for example, Schr\u00f6dinger provides a platform with access to both calculation of descriptors and modeling (CANVAS), as well as tools for the automatization of model optimization and building (AutoQSAR, [20](https://pubs.rsc.org/pubs.rsc.org#cit20) which has recently evolved into DeepAutoQSAR). Auto-Sklearn has been introduced recently [21,22](https://pubs.rsc.org/pubs.rsc.org#cit21) as an ML automation (AutoML) platform, implementing a Bayesian optimization algorithm for data set preparation, feature calculation and preprocessing, and model hyperparameter optimization.\n\nThe alternative that gives the most freedom for customization of descriptors and models is writing custom scripts using the abundance of tools available to researchers these days. Specifically, the Python programming language has an extraordinary level of community support for ML-related tasks, with open-source libraries like scikit-learn [23](https://pubs.rsc.org/pubs.rsc.org#cit23) for ML algorithms, pandas [24](https://pubs.rsc.org/pubs.rsc.org#cit24) for data processing, as well as RDKit, OpenBabel, or Chython for chemoinformatics-related tasks. Scikit-learn has limited capabilities for model parameters optimization using grid search, and other libraries such as Optuna [25](https://pubs.rsc.org/pubs.rsc.org#cit25) provide an expanded selection of optimization algorithms. However, there is still an issue of compatibility between application programming interfaces (API) of these libraries, especially chemical ones, as their outputs often cannot directly serve as inputs for ML algorithms. Still, some recently reported tools, such as ROBERT, [26](https://pubs.rsc.org/pubs.rsc...",
      "url": "https://pubs.rsc.org/en/content/articlehtml/2025/dd/d4dd00399c"
    },
    {
      "title": "Inter-Pol: An Interpretable Machine Learning Framework for Solvent Polarity Prediction",
      "text": "Inter-Pol: An Interpretable Machine Learning Framework for Solvent Polarity Prediction | Journal of Solution Chemistry\n[Skip to main content](#main)\nAdvertisement\n[![Springer Nature Link](https://link.springer.com/oscar-static/images/darwin/header/img/logo-springer-nature-link-3149409f62.svg)](https://link.springer.com)\n[Log in](https://idp.springer.com/auth/personal/springernature?redirect_uri=https://link.springer.com/article/10.1007/s10953-025-01508-6?)\n# Inter-Pol: An Interpretable Machine Learning Framework for Solvent Polarity Prediction\n* Published:15 October 2025\n* (2025)\n* [Cite this article](#citeas)\n[![](https://media.springernature.com/w72/springer-static/cover-hires/journal/10953?as=webp)Journal of Solution Chemistry](https://link.springer.com/journal/10953)[Aims and scope](https://link.springer.com/journal/10953/aims-and-scope)[Submit manuscript](https://submission.nature.com/new-submission/10953/3)\n* [Sadettin Y. Ugurlu](#auth-Sadettin_Y_-Ugurlu-Aff1-Aff2)[ORCID:orcid.org/0000-0001-9589-0269](https://orcid.org/0000-0001-9589-0269)[1](#Aff1),[2](#Aff2)\n* 71Accesses\n* [Explore all metrics](https://link.springer.com/article/10.1007/s10953-025-01508-6/metrics)\n## Abstract\nThe growing emphasis on sustainable solvents in modern organic synthesis demands a deeper understanding of structure\u2013property relationships to guide reaction outcomes. While solvent polarity is a critical parameter, it cannot be fully captured using conventional physical constants. The empirical*E*T(30) parameter is a reliable benchmark, but its experimental determination is labor-intensive. Although deep learning models have been proposed for prediction, they often sacrifice interpretability. To address this, Inter-Pol, an interpretable machine learning framework, has been developed. Inter-Pol integrates 1618 features from RDKit, Mordred, PyBioMed, and CDK, followed by rigorous feature selection, which eliminates 1191 fingerprint features from Morgan, Avalon, and MACCS. After feature selection, Inter-Pol employs a rule-based RuleFit model within an interpretable framework. The model generates human-readable rules, such as \u201cLogP &gt; threshold, then high*E*T(30), such as 42,\u201d that link molecular descriptors to polarity outcomes, enhancing both transparency and usability in solvent selection. These rules not only explain how and why the model produces its predictions but also provide actionable guidance for*E*T(30) optimization. For example, removing hydrogen bond donor groups can result in higher LogP values, reflecting increased polarity, which in turn contributes to higher ET(30) values, as guided by the rules extracted from Inter-Pol. Thus, the interpretable rules derived from Inter-Pol serve not only as predictive components but also as a practical tool for rational solvent design and experimental planning. Across both the 2022 and 2023 benchmarks used in the state-of-the-art paper, the Inter-Pol framework consistently delivers competitive predictive performance\u2013achieving test set\\\\(\\\\text{R}^2\\\\)values of 0.965 and 0.929, respectively\u2013surpassing the 2022 Neural Network benchmark (\\\\(\\\\text{R}^2 = 0.88\\\\)) and approaching the 2023 Neural Network performance (\\\\(\\\\text{R}^2 = 0.952\\\\)), while offering enhanced interpretability through its transparent, rule-based architecture. These results confirm Inter-Pol\u2019s effectiveness in balancing interpretability and accuracy, offering a robust framework for solvent selection in cheminformatics and synthesis.\nThis is a preview of subscription content,[log in via an institution](https://wayf.springernature.com/?redirect_uri&#x3D;https://link.springer.com/article/10.1007/s10953-025-01508-6?error=cookies_not_supported&code=4f145d1f-8abb-4691-98de-d14e4f76eb6f)to check access.\n## Access this article\n[Log in via an institution](https://wayf.springernature.com/?redirect_uri&#x3D;https://link.springer.com/article/10.1007/s10953-025-01508-6?error=cookies_not_supported&code=4f145d1f-8abb-4691-98de-d14e4f76eb6f)\n## Subscribe and save\nSpringer+\nfrom $39.99 /Month\n* Starting from 10 chapters or articles per month\n* Access and download chapters and articles from more than 300k books and 2,500 journals\n* Cancel anytime[View plans](https://link.springer.com/product/springer-plus)\n## Buy Now\nBuy article PDF USD 39.95\nPrice excludes VAT (USA)\nTax calculation will be finalised during checkout.\nInstant access to the full article PDF.\n[Institutional subscriptions](https://www.springernature.com/gp/librarians/licensing/agc/journals)\n**Fig. 1**\n![](https://media.springernature.com/m312/springer-static/image/art%3A10.1007%2Fs10953-025-01508-6/MediaObjects/10953_2025_1508_Fig1_HTML.png)\n**Fig. 2**\n![](https://media.springernature.com/m312/springer-static/image/art%3A10.1007%2Fs10953-025-01508-6/MediaObjects/10953_2025_1508_Fig2_HTML.png)\n**Fig. 3**\n![](https://media.springernature.com/m312/springer-static/image/art%3A10.1007%2Fs10953-025-01508-6/MediaObjects/10953_2025_1508_Fig3_HTML.png)\n**Fig. 4**\n![](https://media.springernature.com/m312/springer-static/image/art%3A10.1007%2Fs10953-025-01508-6/MediaObjects/10953_2025_1508_Fig4_HTML.png)\n**Fig. 5**\n![](https://media.springernature.com/m312/springer-static/image/art%3A10.1007%2Fs10953-025-01508-6/MediaObjects/10953_2025_1508_Fig5_HTML.png)\n**Fig. 6**\n![](https://media.springernature.com/m312/springer-static/image/art%3A10.1007%2Fs10953-025-01508-6/MediaObjects/10953_2025_1508_Fig6_HTML.png)\n**Fig. 7**\n![](https://media.springernature.com/m312/springer-static/image/art%3A10.1007%2Fs10953-025-01508-6/MediaObjects/10953_2025_1508_Fig7_HTML.png)\n**Fig. 8**\n![](https://media.springernature.com/m312/springer-static/image/art%3A10.1007%2Fs10953-025-01508-6/MediaObjects/10953_2025_1508_Fig8_HTML.png)\n**Fig. 9**\n![](https://media.springernature.com/m312/springer-static/image/art%3A10.1007%2Fs10953-025-01508-6/MediaObjects/10953_2025_1508_Fig9_HTML.png)\n**Fig. 10**\n![](https://media.springernature.com/m312/springer-static/image/art%3A10.1007%2Fs10953-025-01508-6/MediaObjects/10953_2025_1508_Fig10_HTML.png)\n**Fig. 11**\n![](https://media.springernature.com/m312/springer-static/image/art%3A10.1007%2Fs10953-025-01508-6/MediaObjects/10953_2025_1508_Fig11_HTML.png)\n**Fig. 12**\n![](https://media.springernature.com/m312/springer-static/image/art%3A10.1007%2Fs10953-025-01508-6/MediaObjects/10953_2025_1508_Fig12_HTML.png)\n### Similar content being viewed by others\n![](https://media.springernature.com/w215h120/springer-static/image/art%3Aplaceholder%2Fimages/placeholder-figure-springernature.png)\n### [A Machine Learning Study of Polymer-Solvent Interactions](https://link.springer.com/10.1007/s10118-022-2716-2?fromPaywallRec=true)\nArticle20 May 2022\n![](https://media.springernature.com/w215h120/springer-static/image/art%3A10.1038%2Fs41598-025-12758-1/MediaObjects/41598_2025_12758_Fig1_HTML.png)\n### [Data-driven frameworks to robustly predict solubility parameter of diverse polymers](https://link.springer.com/10.1038/s41598-025-12758-1?fromPaywallRec=true)\nArticleOpen access25 August 2025\n![](https://media.springernature.com/w215h120/springer-static/image/art%3Aplaceholder%2Fimages/placeholder-figure-springernature.png)\n### [Machine Learning-assisted Prediction of Polymer Glass Transition Temperature: A Structural Feature Approach](https://link.springer.com/10.1007/s10118-025-3361-3?fromPaywallRec=true)\nArticle01 July 2025\n### Explore related subjects\nDiscover the latest articles, books and news in related subjects, suggested using machine learning.\n* [Apicobasal Polarity](https://link.springer.com/subjects/apicobasal-polarity)\n* [Cheminformatics](https://link.springer.com/subjects/cheminformatics)\n* [Machine Learning](https://link.springer.com/subjects/machine-learning)\n* [Plant polarity](https://link.springer.com/subjects/plant-polarity)\n* [Polarization](https://link.springer.com/subjects/polarization)\n* [Structure Prediction](https://link.springer.com/subjects/structure-prediction)\n## Data Availability\nThe materials can...",
      "url": "https://link.springer.com/article/10.1007/s10953-025-01508-6"
    },
    {
      "title": "rdkit.ML.Descriptors.CompoundDescriptors module \u2014 The RDKit 2025.03.6 documentation",
      "text": "rdkit.ML.Descriptors.CompoundDescriptors module \u2014 The RDKit 2025.03.6 documentation https://rdkit.org/docs/source/rdkit.ML.Descriptors.CompoundDescriptors.html\nrdkit.ML.Descriptors.CompoundDescriptors module \u2014 The RDKit 2025.03.6 documentation\nNone\n2025-03-01T00:00:00Z\n# rdkit.ML.Descriptors.CompoundDescriptors module [](rdkit.org/docs/sourc...)\n\ndescriptor calculator for compounds defined by a composition alone\n(only the composition is required)\n\n_class_ rdkit.ML.Descriptors.CompoundDescriptors.CompoundDescriptorCalculator( _simpleList_, _compoundList=None_, _dbName=None_, _dbTable='atomic_data'_, _dbUser='sysdba'_, _dbPassword='masterkey'_) [](rdkit.org/docs/sourc...)\n\nBases: [`DescriptorCalculator`](https://rdkit.org/docs/source/rdkit.ML.Descriptors.Descriptors.html#rdkit.ML.Descriptors.Descriptors.DescriptorCalculator)\n\nused for calculating descriptors\n\nThis is the central point for descriptor calculation\n\n**Notes**\n\n- There are two kinds of descriptors this cares about:\n\n\n> 1. _Simple Descriptors_ can be calculated solely using atomic descriptor\n> values and the composition of the compound. The full list of possible\n> simple descriptors is determined by the types of _Calculator Methods_\n> (see below) and the contents of an atomic database.\n\n> Simple Descriptors can be marked as _nonZeroDescriptors_. These are used\n> to winnow out atom types where particular atomic descriptors are zero\n> (usually indicating that the value is unknown)\n\n> Simple Descriptors are maintained locally in the_simpleList_\n\n> 2. _Compound Descriptors_ may rely upon more complicated computation schemes\n> and descriptors for the compound as a whole (e.g. structural variables, etc.).\n> The full list of compound descriptors is limitless. They are calculated using\n> the_ML.Descriptors.Parser_ module.\n\n> Compound Descriptors are maintained locally in the_compoundList_\n\n- This class has a some special methods which are labelled as _Calculator Method_\nThese are used internally to take atomic descriptors and reduce them to a single\nsimple descriptor value for a composition. They are primarily intended for internal use.\n\n- a _composition vector_ is a list of 2-tuples: \u2018[(atom1name,atom1Num),\u2026]\u2019\nwhere atom1Num is the contribution of the atom to the stoichiometry of the\ncompound. No assumption is made about the stoichiometries (i.e. they don\u2019t\nhave to be either integral or all sum to one).\n\n\nConstructor\n\n**Arguments**\n\n> - simpleList: list of simple descriptors to be calculated\n\n> (see below for format)\n\n> - compoundList: list of compound descriptors to be calculated\n\n> (see below for format)\n\n> - dbName: name of the atomic database to be used\n\n> - dbTable: name the table in_dbName_ which has atomic data\n\n> - dbUser: user name for DB access\n\n> - dbPassword: password for DB access\n\n**Note**\n\n> - format of simpleList:\n\n> a list of 2-tuples containing:\n\n\n> > 1. name of the atomic descriptor\n\n> > 2. a list of operations on that descriptor (e.g. NonZero, Max, etc.)\n> > These must correspond to the _Calculator Method_ names above.\n\n> - format of compoundList:\n\n> a list of 2-tuples containing:\n\n\n> > 1. name of the descriptor to be calculated\n\n> > 2. list of selected atomic descriptor names (define $1, $2, etc.)\n\n> > 3. list of selected compound descriptor names (define $a, $b, etc.)\n\n> > 4. text formula defining the calculation (see_Parser_)\n\nBuildAtomDict() [\u00b6]\n\nbuilds the local atomic dict\n\nWe don\u2019t want to keep around all descriptor values for all atoms, so this\nmethod takes care of only pulling out the descriptors in which we are\ninterested.\n\n**Notes**\n\n> - this uses_chemutils.GetAtomicData_ to actually pull the data\n\nCalcCompoundDescriptorsForComposition( _compos=''_, _composList=None_, _propDict={}_) [\u00b6]\n\ncalculates all simple descriptors for a given composition\n\n**Arguments**\n\n> - compos: a string representation of the composition\n\n> - composList: a _composVect_\n\n> - propDict: a dictionary containing the properties of the composition\n> as a whole (e.g. structural variables, etc.)\n\n\n> The client must provide either_compos_ or_composList_. If both are\n> provided,_composList_ takes priority.\n\n**Returns**\n\nthe list of descriptor values\n\n**Notes**\n\n> - when_compos_ is provided, this uses_chemutils.SplitComposition_\n> to split the composition into its individual pieces\n\nCalcDescriptors( _composVect_, _propDict_) [\u00b6]\n\ncalculates all descriptors for a given composition\n\n**Arguments**\n\n> - compos: a string representation of the composition\n\n> - propDict: a dictionary containing the properties of the composition\n> as a whole (e.g. structural variables, etc.). These are used to\n> generate Compound Descriptors\n\n**Returns**\n\nthe list of all descriptor values\n\n**Notes**\n\n> - this uses_chemutils.SplitComposition_\n> to split the composition into its individual pieces\n\nCalcDescriptorsForComposition( _composVect_, _propDict_) [\u00b6]\n\ncalculates all descriptors for a given composition\n\n**Arguments**\n\n> - compos: a string representation of the composition\n\n> - propDict: a dictionary containing the properties of the composition\n> as a whole (e.g. structural variables, etc.). These are used to\n> generate Compound Descriptors\n\n**Returns**\n\nthe list of all descriptor values\n\n**Notes**\n\n> - this uses_chemutils.SplitComposition_\n> to split the composition into its individual pieces\n\nCalcSimpleDescriptorsForComposition( _compos=''_, _composList=None_) [\u00b6]\n\ncalculates all simple descriptors for a given composition\n\n**Arguments**\n\n> - compos: a string representation of the composition\n\n> - composList: a _composVect_\n\n\n> The client must provide either_compos_ or_composList_. If both are\n> provided,_composList_ takes priority.\n\n**Returns**\n\nthe list of descriptor values\n\n**Notes**\n\n> - when_compos_ is provided, this uses_chemutils.SplitComposition_\n> to split the composition into its individual pieces\n\n> - if problems are encountered because of either an unknown descriptor or\n> atom type, a_KeyError_ will be raised.\n\nDEV( _desc_, _compos_) [](rdkit.org/docs/sourc...)\n\n_Calculator Method_\n\naverage deviation of the descriptor values across the composition\n\n**Arguments**\n\n> - desc: the name of the descriptor\n\n> - compos: the composition vector\n\n**Returns**\n\n> a float\n\nGetDescriptorNames() [\u00b6]\n\nreturns a list of the names of the descriptors this calculator generates\n\nMAX( _desc_, _compos_) [](rdkit.org/docs/sourc...)\n\n_Calculator Method_\n\nmaximum of the descriptor values across the composition\n\n**Arguments**\n\n> - desc: the name of the descriptor\n\n> - compos: the composition vector\n\n**Returns**\n\n> a float\n\nMEAN( _desc_, _compos_) [\u00b6]\n\n_Calculator Method_\n\naverages the descriptor values across the composition\n\n**Arguments**\n\n> - desc: the name of the descriptor\n\n> - compos: the composition vector\n\n**Returns**\n\n> a float\n\nMIN( _desc_, _compos_) [](rdkit.org/docs/sourc...)\n\n_Calculator Method_\n\nminimum of the descriptor values across the composition\n\n**Arguments**\n\n> - desc: the name of the descriptor\n\n> - compos: the composition vector\n\n**Returns**\n\n> a float\n\nProcessCompoundList() [\u00b6]\n\nAdds entries from the_compoundList_ to the list of_requiredDescriptors_\n\nEach compound descriptor is surveyed. Any atomic descriptors it requires\nare added to the list of_requiredDescriptors_ to be pulled from the database.\n\nProcessSimpleList() [\u00b6]\n\nHandles the list of simple descriptors\n\nThis constructs the list of_nonZeroDescriptors_ and_requiredDescriptors_.\n\nThere\u2019s some other magic going on that I can\u2019t decipher at the moment.\n\nSUM( _desc_, _compos_) [](rdkit.org/docs/sourc...)\n\n_Calculator Method_\n\nsums the descriptor values across the composition\n\n**Arguments**\n\n> - desc: the name of the descriptor\n\n> - compos: the composition vector\n\n**Returns**\n\n> a float\n\nrdkit.ML.Descriptors.CompoundDescriptors.GetAllDescriptorNames( _db_, _tbl1_, _tbl2_, _user='sysdba'_, _password='masterkey'_) [](rdkit.org/docs/sourc...)\n\ngets possible descriptor names from a database\n\n**Arguments**\n\n> - db: the name of the database to use\n\n> - tbl1: the name o...",
      "url": "https://rdkit.org/docs/source/rdkit.ML.Descriptors.CompoundDescriptors.html"
    },
    {
      "title": "200 RDkit Features for ML: A Full Guide | Medium",
      "text": "[Sitemap](https://medium.com/sitemap/sitemap.xml)\n\n[Open in app](https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2Fe43c619bec46&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderUser&%7Estage=mobileNavBar&source=post_page---top_nav_layout_nav-----------------------------------------)\n\nSign up\n\n[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2F%40hamidhadipour74%2Funlocking-molecular-insights-a-comprehensive-guide-to-extracting-200-rdkit-features-for-machine-e43c619bec46&source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\n\n[Medium Logo](https://medium.com/?source=post_page---top_nav_layout_nav-----------------------------------------)\n\n[Write](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---top_nav_layout_nav-----------------------new_post_topnav------------------)\n\n[Search](https://medium.com/search?source=post_page---top_nav_layout_nav-----------------------------------------)\n\nSign up\n\n[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2F%40hamidhadipour74%2Funlocking-molecular-insights-a-comprehensive-guide-to-extracting-200-rdkit-features-for-machine-e43c619bec46&source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\n\n# Unlocking Molecular Insights: A Comprehensive Guide to Extracting 200 RDkit Features for Machine Learning (Part 1)\n\n[Hamid Hadipour](https://medium.com/@hamidhadipour74?source=post_page---byline--e43c619bec46---------------------------------------)\n\n3 min read\n\n\u00b7\n\nSep 17, 2024\n\n--\n\n1\n\nListen\n\nShare\n\nPress enter or click to view image in full size\n\nMolecule Features. This image was created with the assistance of DALL\u00b7E.\n\nWhen using machine learning and deep learning models for molecular activity prediction, such as classifying molecules based on properties like toxicity or biological activity, we must represent molecules with numerical features. This is because computers cannot interpret molecular structures directly.\n\nThere are several methods to extract molecular features, including Atom-Bond descriptors, graph-based representations, 3D features, and Morgan Fingerprints. However, one of the most comprehensive approaches for capturing the physicochemical properties of small molecules is through a set of 200 RDKit features. These features provide a broad range of molecular descriptors, covering structural, physicochemical, and electronic properties. For example, they include molecular weight, hydrogen bond donors and acceptors, logP values, and topological polar surface area, among others.\n\nNumerous published studies have utilized this specific set of features in their molecular analyses. Notable examples include the works of [Wong et al., 2023](https://www.nature.com/articles/s41586-023-06887-8#citeas), [Hadipour et al., 2021](https://link.springer.com/article/10.1186/s12859-022-04667-1), and [Yang et al., 2019](https://pubs.acs.org/doi/full/10.1021/acs.jcim.9b00237). These papers underscore the relevance and applicability of these features in advancing the field of molecular research.\n\nIn this work, we use a base repository ( [link](https://github.com/bp-kelley/descriptastorus/tree/master)) that extracts not only the 200 RDKit features but also Morgan Fingerprints and additional descriptors. To access the full code, including all the details required to extract these RDKit features, you can visit our GitHub repository [here](https://github.com/HamidHadipour/RDkit_features).\n\n[**GitHub - HamidHadipour/RDkit\\_features: Extract 200 RDkit featuers for machine learning tasks** \\\n\\\n**Extract 200 RDkit featuers for machine learning tasks - HamidHadipour/RDkit\\_features**\\\n\\\ngithub.com](https://github.com/HamidHadipour/RDkit_features?source=post_page-----e43c619bec46---------------------------------------)\n\nBefore proceeding, you will need to install a few essential tools, with RDKit and Descriptastorus being the most important.\n\n```\npip install rdkit-pypipip install git+https://github.com/bp-kelley/descriptastorus\n```\n\n## Setting Up the Stage with Essential Libraries\n\nThe journey begins by importing the necessary Python libraries:\n\n```\nimport pandas as pdfrom descriptastorus.descriptors.DescriptorGenerator import MakeGeneratorfrom sklearn.preprocessing import MinMaxScaler, StandardScaler\n```\n\n`pandas` is crucial for data manipulation, `MakeGenerator` allows us to generate molecular descriptors using RDKit, and `MinMaxScaler` and `StandardScaler` are used for normalizing the data.\n\n## Initializing the RDKit 2D Feature Generator\n\nThe next step involves setting up the RDKit 2D feature generator, which will be responsible for extracting molecular features from the SMILES strings:\n\n```\ngenerator = MakeGenerator((\"RDKit2D\",))\n```\n\nThis line of code creates a descriptor generator that can interpret the molecular structure from SMILES strings and convert them into a form that\u2019s analyzable by data scientists.\n\n## Function to Extract Features from SMILES\n\nThe function `extract_features` processes each SMILES string, handling potential errors like invalid formats gracefully:\n\n```\ndef extract_features(smiles):    try:        data = generator.process(smiles)        if data[0]:  # Check if the SMILES was valid and processed            return data[1:]        else:            return None  # Return None if SMILES could not be processed    except:        return None\n```\n\nThis function tries to extract features for a list of SMILES altogether using the RDKit generator and checks if the SMILES strings were processed correctly. If there\u2019s an issue, it returns `None`.\n\n## Handling Missing Data\n\nHandling imperfections in the dataset, such as missing values, Nans, and infinite numbers, is crucial for maintaining data integrity:\n\n```\ndef handle_missing_values(features_df, fill_nan):    if features_df.isnull().any().any() or np.isinf(features_df).any().any():  # Check for NaNs or Inf        print(\"There are missing or infinite values in the data.\")        features_df.replace([np.inf, -np.inf], np.nan, inplace=True)  # Replace inf with NaN        if fill_nan:            print(\"Filling missing values with the median of each column...\")            features_df = features_df.fillna(features_df.median())  # Using median to avoid influence of outliers        else:            print(\"Leaving the missing values as they are.\")    else:        print(\"There are no missing values in the data.\")    return features_df\n```\n\nBased on user input, this function checks for non-float numbers and either fills them with the column mean or leaves them as is.\n\n## Normalizing the Features\n\nTo ensure the features are on a comparable scale, normalization is applied as specified by the user:\n\n```\ndef normalize_features(features_df, method):    if method == 'CDF':        return features_df.rank(method='average', pct=True)    elif method == 'minmax':        scaler = MinMaxScaler()        return pd.DataFrame(scaler.fit_transform(features_df), columns=features_df.columns)    elif method == 'standardscaler':        scaler = StandardScaler()        return pd.DataFrame(scaler.fit_transform(features_df), columns=features_df.columns)    return features_df\n```\n\nThose are all of the necessary functions that should be discussed. If you want to have access to a full implementation that includes all the codes together, please check out the Google Colab notebook provided here:\n\n[**Google Colab** \\\n\\\n**Edit description**\\\n\\\ncolab.research.google.com](https://colab.research.google.com/drive/1kfeesfUem4vii3Mh-6H6Cobmy5RKI_uV?usp=sharing&source=post_page-----e43c619bec46---------------------------------------)\n\nHopefully, this article gives you a solid starting point for extracting molecular features. You can check our next article to learn how to train a machine learning model with those features.\n\nPlease email me your questions and comments and follow me on [LinkedIn](https://www.l...",
      "url": "https://medium.com/@hamidhadipour74/unlocking-molecular-insights-a-comprehensive-guide-to-extracting-200-rdkit-features-for-machine-e43c619bec46"
    },
    {
      "title": "Search code, repositories, users, issues, pull requests...",
      "text": "GitHub - basf/MolPipeline: A Python package for processing molecules with RDKit in scikit-learn\n[Skip to content](#start-of-content)\n## Navigation Menu\nToggle navigation\n[](https://github.com/)\n[Sign in](https://github.com/login?return_to=https://github.com/basf/molpipeline)\nAppearance settings\nSearch or jump to...\n# Search code, repositories, users, issues, pull requests...\n</option></form>\nSearch\nClear\n[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)\n# Provide feedback\n</option></form>\nWe read every piece of feedback, and take your input very seriously.\nInclude my email address so I can be contacted\nCancelSubmit feedback\n# Saved searches\n## Use saved searches to filter your results more quickly\n</option></form>\nName\nQuery\nTo see all available qualifiers, see our[documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).\nCancelCreate saved search\n[Sign in](https://github.com/login?return_to=https://github.com/basf/molpipeline)\n[Sign up](https://github.com/signup?ref_cta=Sign+up&amp;ref_loc=header+logged+out&amp;ref_page=/%3Cuser-name%3E/%3Crepo-name%3E&amp;source=header-repo&amp;source_repo=basf/MolPipeline)\nAppearance settings\nResetting focus\nYou signed in with another tab or window.[Reload]()to refresh your session.You signed out in another tab or window.[Reload]()to refresh your session.You switched accounts on another tab or window.[Reload]()to refresh your session.Dismiss alert\n{{ message }}\n[basf](https://github.com/basf)/**[MolPipeline](https://github.com/basf/MolPipeline)**Public\n* [Notifications](https://github.com/login?return_to=/basf/MolPipeline)You must be signed in to change notification settings\n* [Fork13](https://github.com/login?return_to=/basf/MolPipeline)\n* [Star210](https://github.com/login?return_to=/basf/MolPipeline)\nA Python package for processing molecules with RDKit in scikit-learn\n### License\n[MIT license](https://github.com/basf/MolPipeline/blob/main/LICENSE)\n[210stars](https://github.com/basf/MolPipeline/stargazers)[13forks](https://github.com/basf/MolPipeline/forks)[Branches](https://github.com/basf/MolPipeline/branches)[Tags](https://github.com/basf/MolPipeline/tags)[Activity](https://github.com/basf/MolPipeline/activity)\n[Star](https://github.com/login?return_to=/basf/MolPipeline)\n[Notifications](https://github.com/login?return_to=/basf/MolPipeline)You must be signed in to change notification settings\n# basf/MolPipeline\nmain\n[Branches](https://github.com/basf/MolPipeline/branches)[Tags](https://github.com/basf/MolPipeline/tags)\n[](https://github.com/basf/MolPipeline/branches)[](https://github.com/basf/MolPipeline/tags)\nGo to file\nCode\nOpen more actions menu\n## Folders and files\n|Name|Name|\nLast commit message\n|\nLast commit date\n|\n## Latest commit\n## History\n[1,088 Commits](https://github.com/basf/MolPipeline/commits/main/)\n[](https://github.com/basf/MolPipeline/commits/main/)\n|\n[.github](https://github.com/basf/MolPipeline/tree/main/.github)\n|\n[.github](https://github.com/basf/MolPipeline/tree/main/.github)\n|\n|\n|\n[molpipeline](https://github.com/basf/MolPipeline/tree/main/molpipeline)\n|\n[molpipeline](https://github.com/basf/MolPipeline/tree/main/molpipeline)\n|\n|\n|\n[notebooks](https://github.com/basf/MolPipeline/tree/main/notebooks)\n|\n[notebooks](https://github.com/basf/MolPipeline/tree/main/notebooks)\n|\n|\n|\n[test\\_extras](https://github.com/basf/MolPipeline/tree/main/test_extras)\n|\n[test\\_extras](https://github.com/basf/MolPipeline/tree/main/test_extras)\n|\n|\n|\n[tests](https://github.com/basf/MolPipeline/tree/main/tests)\n|\n[tests](https://github.com/basf/MolPipeline/tree/main/tests)\n|\n|\n|\n[.gitignore](https://github.com/basf/MolPipeline/blob/main/.gitignore)\n|\n[.gitignore](https://github.com/basf/MolPipeline/blob/main/.gitignore)\n|\n|\n|\n[.pre-commit-config.yaml](https://github.com/basf/MolPipeline/blob/main/.pre-commit-config.yaml)\n|\n[.pre-commit-config.yaml](https://github.com/basf/MolPipeline/blob/main/.pre-commit-config.yaml)\n|\n|\n|\n[.python-version](https://github.com/basf/MolPipeline/blob/main/.python-version)\n|\n[.python-version](https://github.com/basf/MolPipeline/blob/main/.python-version)\n|\n|\n|\n[DEVELOPMENT.md](https://github.com/basf/MolPipeline/blob/main/DEVELOPMENT.md)\n|\n[DEVELOPMENT.md](https://github.com/basf/MolPipeline/blob/main/DEVELOPMENT.md)\n|\n|\n|\n[LICENSE](https://github.com/basf/MolPipeline/blob/main/LICENSE)\n|\n[LICENSE](https://github.com/basf/MolPipeline/blob/main/LICENSE)\n|\n|\n|\n[README.md](https://github.com/basf/MolPipeline/blob/main/README.md)\n|\n[README.md](https://github.com/basf/MolPipeline/blob/main/README.md)\n|\n|\n|\n[pyproject.toml](https://github.com/basf/MolPipeline/blob/main/pyproject.toml)\n|\n[pyproject.toml](https://github.com/basf/MolPipeline/blob/main/pyproject.toml)\n|\n|\n|\n[ruff.toml](https://github.com/basf/MolPipeline/blob/main/ruff.toml)\n|\n[ruff.toml](https://github.com/basf/MolPipeline/blob/main/ruff.toml)\n|\n|\n|\n[uv.lock](https://github.com/basf/MolPipeline/blob/main/uv.lock)\n|\n[uv.lock](https://github.com/basf/MolPipeline/blob/main/uv.lock)\n|\n|\n|\nView all files\n|\n## Repository files navigation\n# MolPipeline\n[](#molpipeline)\nMolPipeline is a Python package for processing molecules with RDKit in scikit-learn.\n[![](https://github.com/basf/MolPipeline/raw/main/.github/molpipeline.png)](https://github.com/basf/MolPipeline/blob/main/.github/molpipeline.png)\n## Background\n[](#background)\nThe[scikit-learn](https://scikit-learn.org/)package provides a large variety of machine\nlearning algorithms and data processing tools, among which is the`Pipeline`class, allowing users to\nprepend custom data processing steps to the machine learning model.`MolPipeline`extends this concept to the field of cheminformatics by\nwrapping standard[RDKit](https://www.rdkit.org/)functionality, such as reading and writing SMILES strings\nor calculating molecular descriptors from a molecule-object.\nMolPipeline aims to provide:\n* Automated end-to-end processing from molecule data sets to deployable machine learning models.\n* Scalable parallel processing and low memory usage through instance-based processing.\n* Standard pipeline building blocks for flexibly building custom pipelines for various\ncheminformatics tasks.\n* Consistent error handling for tracking, logging, and replacing failed instances (e.g., a\nSMILES string that could not be parsed correctly).\n* Integrated and self-contained pipeline serialization for easy deployment and tracking\nin version control.\n## Publications\n[](#publications)\n[Sieg J, Feldmann CW, Hemmerich J, Stork C, Sandfort F, Eiden P, and Mathea M, MolPipeline: A python package for processing\nmolecules with RDKit in scikit-learn, J. Chem. Inf. Model., doi:10.1021/acs.jcim.4c00863, 2024](https://doi.org/10.1021/acs.jcim.4c00863)\nFurther links:[arXiv](https://chemrxiv.org/engage/chemrxiv/article-details/661fec7f418a5379b00ae036)\n[Feldmann CW, Sieg J, and Mathea M, Analysis of uncertainty of neural\nfingerprint-based models, 2024](https://doi.org/10.1039/D4FD00095A)\nFurther links:[repository](https://github.com/basf/neural-fingerprint-uncertainty)\n# Table of Contents\n[](#table-of-contents)\n* [MolPipeline](#molpipeline)\n* [Background](#background)\n* [Publications](#publications)\n* [Table of Contents](#table-of-contents)\n* [Installation](#installation)\n* [Documentation](#documentation)\n* [Quick start](#quick-start)\n* [Model building](#model-building)\n* [Feature calculation](#feature-calculation)\n* [Clustering](#clustering)\n* [Explainability](#explainability)\n* [License](#license)\n## Installation\n[](#installation)\n```\n`pip install molpipeline`\n```\n## Documentation\n[](#documentation)\nThe[notebooks](https://github.com/basf/MolPipeline/blob/main/notebooks)folder contains many basic and advanced examples of how to use Molpipeline.\nA nice introduction to the basic usage is in the[01\\_getting\\_started\\_with\\_molpipeline notebook](https://github.com/basf/MolPipeline/blob/main/notebooks/...",
      "url": "https://github.com/basf/molpipeline"
    }
  ]
}